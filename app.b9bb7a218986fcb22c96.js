/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(158);
	
	var _App = __webpack_require__(159);
	
	var _App2 = _interopRequireDefault(_App);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	(0, _reactDom.render)(_react2.default.createElement(_App2.default, null), document.getElementById('content'));

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(2);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var ReactDOM = __webpack_require__(3);
	var ReactDOMServer = __webpack_require__(148);
	var ReactIsomorphic = __webpack_require__(152);
	
	var assign = __webpack_require__(39);
	var deprecated = __webpack_require__(157);
	
	// `version` will be added here by ReactIsomorphic.
	var React = {};
	
	assign(React, ReactIsomorphic);
	
	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
	
	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});
	
	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
	
	module.exports = React;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactDOMTextComponent = __webpack_require__(6);
	var ReactDefaultInjection = __webpack_require__(71);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactMount = __webpack_require__(28);
	var ReactPerf = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(50);
	var ReactUpdates = __webpack_require__(54);
	var ReactVersion = __webpack_require__(146);
	
	var findDOMNode = __webpack_require__(91);
	var renderSubtreeIntoContainer = __webpack_require__(147);
	var warning = __webpack_require__(25);
	
	ReactDefaultInjection.inject();
	
	var render = ReactPerf.measure('React', 'render', ReactMount.render);
	
	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(9);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,
	
	    // shams
	    Object.create, Object.freeze];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(7);
	var DOMPropertyOperations = __webpack_require__(22);
	var ReactComponentBrowserEnvironment = __webpack_require__(26);
	var ReactMount = __webpack_require__(28);
	
	var assign = __webpack_require__(39);
	var escapeTextContentForBrowser = __webpack_require__(21);
	var setTextContent = __webpack_require__(20);
	var validateDOMNesting = __webpack_require__(70);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (props) {
	  // This constructor and its argument is currently used by mocks.
	};
	
	assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function (text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;
	
	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement('span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },
	
	  unmountComponent: function () {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var Danger = __webpack_require__(8);
	var ReactMultiChildUpdateTypes = __webpack_require__(16);
	var ReactPerf = __webpack_require__(18);
	
	var setInnerHTML = __webpack_require__(19);
	var setTextContent = __webpack_require__(20);
	var invariant = __webpack_require__(13);
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.
	
	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
	
	  parentNode.insertBefore(childNode, beforeChild);
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
	
	  updateTextContent: setTextContent,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function (updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;
	
	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;
	
	        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
	
	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;
	
	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }
	
	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }
	
	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createNodesFromMarkup = __webpack_require__(10);
	var emptyFunction = __webpack_require__(15);
	var getMarkupWrap = __webpack_require__(14);
	var invariant = __webpack_require__(13);
	
	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';
	
	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}
	
	var Danger = {
	
	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function (markupList) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];
	
	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];
	
	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }
	
	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );
	
	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
	
	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);
	
	          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
	
	          resultList[resultIndex] = renderNode;
	
	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (process.env.NODE_ENV !== 'production') {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }
	
	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
	
	    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
	
	    return resultList;
	  },
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
	
	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 9 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createArrayFromMixed = __webpack_require__(11);
	var getMarkupWrap = __webpack_require__(14);
	var invariant = __webpack_require__(13);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */
	
	'use strict';
	
	var toArray = __webpack_require__(12);
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return(
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	module.exports = toArray;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 15 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(17);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function (obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function (object, objectName, methodNames) {
	    if (process.env.NODE_ENV !== 'production') {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function (objName, fnName, func) {
	    if (process.env.NODE_ENV !== 'production') {
	      var measuredFunc = null;
	      var wrapper = function () {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function (measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function (node, html) {
	  node.innerHTML = html;
	};
	
	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function (node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var escapeTextContentForBrowser = __webpack_require__(21);
	var setInnerHTML = __webpack_require__(19);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 21 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	var ReactPerf = __webpack_require__(18);
	
	var quoteAttributeValueForBrowser = __webpack_require__(24);
	var warning = __webpack_require__(25);
	
	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};
	
	  var warnUnknownProperty = function (name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }
	
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	
	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function (nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(21);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(15);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(27);
	var ReactMount = __webpack_require__(28);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
	
	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function (rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(7);
	var DOMPropertyOperations = __webpack_require__(22);
	var ReactMount = __webpack_require__(28);
	var ReactPerf = __webpack_require__(18);
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function (id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
	
	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },
	
	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};
	
	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});
	
	module.exports = ReactDOMIDOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactDOMFeatureFlags = __webpack_require__(41);
	var ReactElement = __webpack_require__(42);
	var ReactEmptyComponentRegistry = __webpack_require__(44);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactInstanceMap = __webpack_require__(47);
	var ReactMarkupChecksum = __webpack_require__(48);
	var ReactPerf = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(50);
	var ReactUpdateQueue = __webpack_require__(53);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var emptyObject = __webpack_require__(58);
	var containsNode = __webpack_require__(59);
	var instantiateReactComponent = __webpack_require__(62);
	var invariant = __webpack_require__(13);
	var setInnerHTML = __webpack_require__(19);
	var shouldUpdateReactComponent = __webpack_require__(67);
	var validateDOMNesting = __webpack_require__(70);
	var warning = __webpack_require__(25);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
	
	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};
	
	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}
	
	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}
	
	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
	
	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }
	
	  return id;
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}
	
	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
	
	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}
	
	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}
	
	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
	
	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}
	
	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	
	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);
	
	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function () {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }
	
	    return prevComponent;
	  },
	
	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function (nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },
	
	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
	
	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var prevComponent = instancesByReactRootID[getReactRootID(container)];
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function (container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }
	
	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (process.env.NODE_ENV !== 'production') {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },
	
	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function (id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];
	
	    if (process.env.NODE_ENV !== 'production') {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        process.env.NODE_ENV !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }
	
	    return container;
	  },
	
	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function (id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },
	
	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function (node) {
	    return findFirstReactDOMImpl(node);
	  },
	
	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function (ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;
	
	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw on the next line; give an early warning
	      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }
	
	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;
	
	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;
	
	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.
	
	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }
	
	        child = child.nextSibling;
	      }
	
	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;
	
	        return targetChild;
	      }
	    }
	
	    firstChildren.length = 0;
	
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },
	
	  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },
	
	  ownerDocumentContextKey: ownerDocumentContextKey,
	
	  /**
	   * React ID utilities.
	   */
	
	  getReactRootID: getReactRootID,
	
	  getID: getID,
	
	  setID: setID,
	
	  getNode: getNode,
	
	  getNodeFromInstance: getNodeFromInstance,
	
	  isValid: isValid,
	
	  purgeID: purgeID
	};
	
	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginRegistry = __webpack_require__(32);
	var ReactEventEmitterMixin = __webpack_require__(37);
	var ReactPerf = __webpack_require__(18);
	var ViewportMetrics = __webpack_require__(38);
	
	var assign = __webpack_require__(39);
	var isEventSupported = __webpack_require__(40);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },
	
	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginHub.registrationNameModules,
	
	  putListener: EventPluginHub.putListener,
	
	  getListener: EventPluginHub.getListener,
	
	  deleteListener: EventPluginHub.deleteListener,
	
	  deleteAllListeners: EventPluginHub.deleteAllListeners
	
	});
	
	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(17);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var EventPluginRegistry = __webpack_require__(32);
	var EventPluginUtils = __webpack_require__(33);
	var ReactErrorUtils = __webpack_require__(34);
	
	var accumulateInto = __webpack_require__(35);
	var forEachAccumulated = __webpack_require__(36);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;
	
	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,
	
	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function (InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	    },
	
	    getInstanceHandle: function () {
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginRegistry.registrationNameModules,
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function (id, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;
	
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function (id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }
	
	      delete listenerBank[registrationName][id];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var ReactErrorUtils = __webpack_require__(34);
	
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function (InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getNode: function (id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function (node) {
	    return injection.Mount.getID(node);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);
	
	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }
	
	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }
	
	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 36 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	var forEachAccumulated = function (arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};
	
	module.exports = forEachAccumulated;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(31);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 38 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 39 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
	
	'use strict';
	
	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }
	
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = assign;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = (eventName in document);
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 41 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	
	var assign = __webpack_require__(39);
	var canDefineProperty = __webpack_require__(43);
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }
	
	  return element;
	};
	
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
	
	  if (process.env.NODE_ENV !== 'production') {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }
	
	  return newElement;
	};
	
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */
	
	'use strict';
	
	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	var nullComponentIDsRegistry = {};
	
	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}
	
	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}
	
	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}
	
	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};
	
	module.exports = ReactEmptyComponentRegistry;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactRootIndex = __webpack_require__(46);
	
	var invariant = __webpack_require__(13);
	
	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;
	
	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;
	
	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}
	
	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}
	
	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}
	
	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}
	
	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}
	
	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}
	
	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}
	
	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {
	
	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function () {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },
	
	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function (rootID, name) {
	    return rootID + name;
	  },
	
	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function (id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },
	
	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },
	
	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },
	
	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },
	
	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function (targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },
	
	  getFirstCommonAncestorID: getFirstCommonAncestorID,
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,
	
	  isAncestorIDOf: isAncestorIDOf,
	
	  SEPARATOR: SEPARATOR
	
	};
	
	module.exports = ReactInstanceHandles;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function (_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};
	
	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};
	
	module.exports = ReactRootIndex;

/***/ },
/* 47 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(49);
	
	var TAG_END = /\/?>/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 49 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(51);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }
	
	};
	
	module.exports = ReactReconciler;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(52);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return(
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactElement = __webpack_require__(42);
	var ReactInstanceMap = __webpack_require__(47);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },
	
	  enqueueSetPropsInternal: function (internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },
	
	  enqueueReplacePropsInternal: function (internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  enqueueElementInternal: function (internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(55);
	var PooledClass = __webpack_require__(56);
	var ReactPerf = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(50);
	var Transaction = __webpack_require__(57);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	
	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}
	
	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isTextNode = __webpack_require__(60);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;
	
	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;
	
	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isNode = __webpack_require__(61);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 61 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCompositeComponent = __webpack_require__(63);
	var ReactEmptyComponent = __webpack_require__(68);
	var ReactNativeComponent = __webpack_require__(69);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function () {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }
	
	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(64);
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactElement = __webpack_require__(42);
	var ReactInstanceMap = __webpack_require__(47);
	var ReactPerf = __webpack_require__(18);
	var ReactPropTypeLocations = __webpack_require__(65);
	var ReactPropTypeLocationNames = __webpack_require__(66);
	var ReactReconciler = __webpack_require__(50);
	var ReactUpdateQueue = __webpack_require__(53);
	
	var assign = __webpack_require__(39);
	var emptyObject = __webpack_require__(58);
	var invariant = __webpack_require__(13);
	var shouldUpdateReactComponent = __webpack_require__(67);
	var warning = __webpack_require__(25);
	
	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;
	
	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedComponent = null;
	
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;
	
	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    // Initialize the public class
	    var inst;
	    var renderedElement;
	
	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = ('prototype' in Component);
	
	    if (canInstantiate) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }
	
	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    this._renderedComponent = this._instantiateReactComponent(renderedElement);
	
	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }
	
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function () {
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }
	
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function (newProps) {
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },
	
	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function (propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);
	
	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }
	
	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	
	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;
	
	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.
	
	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	
	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }
	
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);
	
	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },
	
	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(17);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 67 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	var ReactEmptyComponentRegistry = __webpack_require__(44);
	var ReactReconciler = __webpack_require__(50);
	
	var assign = __webpack_require__(39);
	
	var placeholderElement;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function (component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};
	
	var ReactEmptyComponent = function (instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function (element) {},
	  mountComponent: function (rootID, transaction, context) {
	    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function () {},
	  unmountComponent: function (rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */
	
	'use strict';
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	
	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}
	
	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};
	
	module.exports = ReactNativeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var assign = __webpack_require__(39);
	var emptyFunction = __webpack_require__(15);
	var warning = __webpack_require__(25);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    parentTag: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.parentTag = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };
	
	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(72);
	var ChangeEventPlugin = __webpack_require__(80);
	var ClientReactRootIndex = __webpack_require__(83);
	var DefaultEventPluginOrder = __webpack_require__(84);
	var EnterLeaveEventPlugin = __webpack_require__(85);
	var ExecutionEnvironment = __webpack_require__(9);
	var HTMLDOMPropertyConfig = __webpack_require__(89);
	var ReactBrowserComponentMixin = __webpack_require__(90);
	var ReactComponentBrowserEnvironment = __webpack_require__(26);
	var ReactDefaultBatchingStrategy = __webpack_require__(92);
	var ReactDOMComponent = __webpack_require__(93);
	var ReactDOMTextComponent = __webpack_require__(6);
	var ReactEventListener = __webpack_require__(118);
	var ReactInjection = __webpack_require__(121);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactMount = __webpack_require__(28);
	var ReactReconcileTransaction = __webpack_require__(125);
	var SelectEventPlugin = __webpack_require__(130);
	var ServerReactRootIndex = __webpack_require__(131);
	var SimpleEventPlugin = __webpack_require__(132);
	var SVGDOMPropertyConfig = __webpack_require__(141);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	
	  if (process.env.NODE_ENV !== 'production') {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = __webpack_require__(142);
	      ReactDefaultPerf.start();
	    }
	  }
	}
	
	module.exports = {
	  inject: inject
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPropagators = __webpack_require__(73);
	var ExecutionEnvironment = __webpack_require__(9);
	var FallbackCompositionState = __webpack_require__(74);
	var SyntheticCompositionEvent = __webpack_require__(76);
	var SyntheticInputEvent = __webpack_require__(78);
	
	var keyOf = __webpack_require__(79);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(31);
	
	var warning = __webpack_require__(25);
	
	var accumulateInto = __webpack_require__(35);
	var forEachAccumulated = __webpack_require__(36);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	
	var assign = __webpack_require__(39);
	var getTextContentAccessor = __webpack_require__(75);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(77);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	
	var assign = __webpack_require__(39);
	var emptyFunction = __webpack_require__(15);
	var warning = __webpack_require__(25);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}
	
	assign(SyntheticEvent.prototype, {
	
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(77);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";
	
	var keyOf = function (oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(31);
	var EventPropagators = __webpack_require__(73);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactUpdates = __webpack_require__(54);
	var SyntheticEvent = __webpack_require__(77);
	
	var getEventTarget = __webpack_require__(81);
	var isEventSupported = __webpack_require__(40);
	var isTextInputElement = __webpack_require__(82);
	var keyOf = __webpack_require__(79);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}
	
	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}
	
	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}
	
	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	
	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }
	
	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 81 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 82 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var nextReactRootIndex = 0;
	
	var ClientReactRootIndex = {
	  createReactRootIndex: function () {
	    return nextReactRootIndex++;
	  }
	};
	
	module.exports = ClientReactRootIndex;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(79);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPropagators = __webpack_require__(73);
	var SyntheticMouseEvent = __webpack_require__(86);
	
	var ReactMount = __webpack_require__(28);
	var keyOf = __webpack_require__(79);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var extractedEvents = [null, null];
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
	
	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;
	
	    return extractedEvents;
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(87);
	var ViewportMetrics = __webpack_require__(38);
	
	var getEventModifierState = __webpack_require__(88);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(77);
	
	var getEventTarget = __webpack_require__(81);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,
	
	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */
	
	'use strict';
	
	var ReactInstanceMap = __webpack_require__(47);
	
	var findDOMNode = __webpack_require__(91);
	var warning = __webpack_require__(25);
	
	var didWarnKey = '_getDOMNodeDidWarn';
	
	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function () {
	    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};
	
	module.exports = ReactBrowserComponentMixin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactInstanceMap = __webpack_require__(47);
	var ReactMount = __webpack_require__(28);
	
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var ReactUpdates = __webpack_require__(54);
	var Transaction = __webpack_require__(57);
	
	var assign = __webpack_require__(39);
	var emptyFunction = __webpack_require__(15);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var AutoFocusUtils = __webpack_require__(94);
	var CSSPropertyOperations = __webpack_require__(96);
	var DOMProperty = __webpack_require__(23);
	var DOMPropertyOperations = __webpack_require__(22);
	var EventConstants = __webpack_require__(30);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactComponentBrowserEnvironment = __webpack_require__(26);
	var ReactDOMButton = __webpack_require__(104);
	var ReactDOMInput = __webpack_require__(105);
	var ReactDOMOption = __webpack_require__(109);
	var ReactDOMSelect = __webpack_require__(112);
	var ReactDOMTextarea = __webpack_require__(113);
	var ReactMount = __webpack_require__(28);
	var ReactMultiChild = __webpack_require__(114);
	var ReactPerf = __webpack_require__(18);
	var ReactUpdateQueue = __webpack_require__(53);
	
	var assign = __webpack_require__(39);
	var canDefineProperty = __webpack_require__(43);
	var escapeTextContentForBrowser = __webpack_require__(21);
	var invariant = __webpack_require__(13);
	var isEventSupported = __webpack_require__(40);
	var keyOf = __webpack_require__(79);
	var setInnerHTML = __webpack_require__(19);
	var setTextContent = __webpack_require__(20);
	var shallowEqual = __webpack_require__(117);
	var validateDOMNesting = __webpack_require__(70);
	var warning = __webpack_require__(25);
	
	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	
	var ELEMENT_NODE_TYPE = 1;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	var legacyPropsDescriptor;
	if (process.env.NODE_ENV !== 'production') {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function () {
	        var component = this._reactInternalComponent;
	        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}
	
	function legacyGetDOMNode() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}
	
	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}
	
	function legacySetStateEtc() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}
	
	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (process.env.NODE_ENV !== 'production') {
	    if (voidElementTags[component._tag]) {
	      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}
	
	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
	
	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}
	
	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = ({}).hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (process.env.NODE_ENV !== 'production') {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  construct: function (element) {
	    this._currentElement = element;
	  },
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._rootNodeID = rootID;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }
	
	    assertValidProps(this, props);
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement(this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }
	
	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function () {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }
	
	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },
	
	  getPublicInstance: function () {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);
	
	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }
	
	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }
	
	};
	
	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});
	
	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(28);
	
	var findDOMNode = __webpack_require__(91);
	var focusNode = __webpack_require__(95);
	
	var Mixin = {
	  componentDidMount: function () {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};
	
	var AutoFocusUtils = {
	  Mixin: Mixin,
	
	  focusDOMComponent: function () {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(97);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactPerf = __webpack_require__(18);
	
	var camelizeStyleName = __webpack_require__(98);
	var dangerousStyleValue = __webpack_require__(100);
	var hyphenateStyleName = __webpack_require__(101);
	var memoizeStringOnly = __webpack_require__(103);
	var warning = __webpack_require__(25);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };
	
	  var warnBadVendoredStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function (name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function (node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 97 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(99);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 99 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	"use strict";
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(97);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(102);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 102 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	'use strict';
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function (inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }
	
	    return nativeProps;
	  }
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(27);
	var LinkedValueUtils = __webpack_require__(106);
	var ReactMount = __webpack_require__(28);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	
	var instancesByReactID = {};
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function (inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  mountReadyWrapper: function (inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },
	
	  unmountWrapper: function (inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactPropTypes = __webpack_require__(107);
	var ReactPropTypeLocations = __webpack_require__(65);
	
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	var ReactPropTypeLocationNames = __webpack_require__(66);
	
	var emptyFunction = __webpack_require__(15);
	var getIteratorFn = __webpack_require__(108);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;

/***/ },
/* 108 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/* global Symbol */
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(110);
	var ReactDOMSelect = __webpack_require__(112);
	
	var assign = __webpack_require__(39);
	var warning = __webpack_require__(25);
	
	var valueContextKey = ReactDOMSelect.valueContextKey;
	
	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }
	
	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];
	
	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  getNativeProps: function (inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = '';
	
	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });
	
	    if (content) {
	      nativeProps.children = content;
	    }
	
	    return nativeProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	var ReactElement = __webpack_require__(42);
	
	var emptyFunction = __webpack_require__(15);
	var traverseAllChildren = __webpack_require__(111);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactElement = __webpack_require__(42);
	var ReactInstanceHandles = __webpack_require__(45);
	
	var getIteratorFn = __webpack_require__(108);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};
	
	var userProvidedKeyEscapeRegex = /[=.:]/g;
	
	var didWarnAboutMaps = false;
	
	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}
	
	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(106);
	var ReactMount = __webpack_require__(28);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var warning = __webpack_require__(25);
	
	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,
	
	  getNativeProps: function (inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },
	
	  processChildContext: function (inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(106);
	var ReactDOMIDOperations = __webpack_require__(27);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function (inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }
	
	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);
	
	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(64);
	var ReactMultiChildUpdateTypes = __webpack_require__(16);
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactReconciler = __webpack_require__(50);
	var ReactChildReconciler = __webpack_require__(115);
	
	var flattenChildren = __webpack_require__(116);
	
	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;
	
	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];
	
	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];
	
	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}
	
	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function () {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },
	
	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function (textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },
	
	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function (markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(50);
	
	var instantiateReactComponent = __webpack_require__(62);
	var shouldUpdateReactComponent = __webpack_require__(67);
	var traverseAllChildren = __webpack_require__(111);
	var warning = __webpack_require__(25);
	
	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */
	
	'use strict';
	
	var traverseAllChildren = __webpack_require__(111);
	var warning = __webpack_require__(25);
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventListener = __webpack_require__(119);
	var ExecutionEnvironment = __webpack_require__(9);
	var PooledClass = __webpack_require__(56);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactMount = __webpack_require__(28);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var getEventTarget = __webpack_require__(81);
	var getUnboundedScrollPosition = __webpack_require__(120);
	
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }
	
	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}
	
	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);
	
	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
	
	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(15);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function () {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function () {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 120 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	var EventPluginHub = __webpack_require__(31);
	var ReactComponentEnvironment = __webpack_require__(64);
	var ReactClass = __webpack_require__(122);
	var ReactEmptyComponent = __webpack_require__(68);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactNativeComponent = __webpack_require__(69);
	var ReactPerf = __webpack_require__(18);
	var ReactRootIndex = __webpack_require__(46);
	var ReactUpdates = __webpack_require__(54);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var ReactComponent = __webpack_require__(123);
	var ReactElement = __webpack_require__(42);
	var ReactPropTypeLocations = __webpack_require__(65);
	var ReactPropTypeLocationNames = __webpack_require__(66);
	var ReactNoopUpdateQueue = __webpack_require__(124);
	
	var assign = __webpack_require__(39);
	var emptyObject = __webpack_require__(58);
	var invariant = __webpack_require__(13);
	var keyMirror = __webpack_require__(17);
	var keyOf = __webpack_require__(79);
	var warning = __webpack_require__(25);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}
	
	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	
	  var proto = Constructor.prototype;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    validateMethodOverride(proto, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = (name in RESERVED_SPEC_KEYS);
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
	
	    var isInherited = (name in Constructor);
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function (partialProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function (newProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};
	
	var ReactClassComponent = function () {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var ReactNoopUpdateQueue = __webpack_require__(124);
	
	var canDefineProperty = __webpack_require__(43);
	var emptyObject = __webpack_require__(58);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(25);
	
	function warnTDZ(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }
	
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(55);
	var PooledClass = __webpack_require__(56);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactDOMFeatureFlags = __webpack_require__(41);
	var ReactInputSelection = __webpack_require__(126);
	var Transaction = __webpack_require__(57);
	
	var assign = __webpack_require__(39);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(127);
	
	var containsNode = __webpack_require__(59);
	var focusNode = __webpack_require__(95);
	var getActiveElement = __webpack_require__(129);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var getNodeForCharacterOffset = __webpack_require__(128);
	var getTextContentAccessor = __webpack_require__(75);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 128 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 129 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPropagators = __webpack_require__(73);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactInputSelection = __webpack_require__(126);
	var SyntheticEvent = __webpack_require__(77);
	
	var getActiveElement = __webpack_require__(129);
	var isTextInputElement = __webpack_require__(82);
	var keyOf = __webpack_require__(79);
	var shallowEqual = __webpack_require__(117);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 131 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
	
	var ServerReactRootIndex = {
	  createReactRootIndex: function () {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};
	
	module.exports = ServerReactRootIndex;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventListener = __webpack_require__(119);
	var EventPropagators = __webpack_require__(73);
	var ReactMount = __webpack_require__(28);
	var SyntheticClipboardEvent = __webpack_require__(133);
	var SyntheticEvent = __webpack_require__(77);
	var SyntheticFocusEvent = __webpack_require__(134);
	var SyntheticKeyboardEvent = __webpack_require__(135);
	var SyntheticMouseEvent = __webpack_require__(86);
	var SyntheticDragEvent = __webpack_require__(138);
	var SyntheticTouchEvent = __webpack_require__(139);
	var SyntheticUIEvent = __webpack_require__(87);
	var SyntheticWheelEvent = __webpack_require__(140);
	
	var emptyFunction = __webpack_require__(15);
	var getEventCharCode = __webpack_require__(136);
	var invariant = __webpack_require__(13);
	var keyOf = __webpack_require__(79);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(77);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(87);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(87);
	
	var getEventCharCode = __webpack_require__(136);
	var getEventKey = __webpack_require__(137);
	var getEventModifierState = __webpack_require__(88);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(136);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(86);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(87);
	
	var getEventModifierState = __webpack_require__(88);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(86);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	var ReactDefaultPerfAnalysis = __webpack_require__(143);
	var ReactMount = __webpack_require__(28);
	var ReactPerf = __webpack_require__(18);
	
	var performanceNow = __webpack_require__(144);
	
	function roundFloat(val) {
	  return Math.floor(val * 100) / 100;
	}
	
	function addValue(obj, key, val) {
	  obj[key] = (obj[key] || 0) + val;
	}
	
	var ReactDefaultPerf = {
	  _allMeasurements: [], // last item in the list is the current one
	  _mountStack: [0],
	  _injected: false,
	
	  start: function () {
	    if (!ReactDefaultPerf._injected) {
	      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
	    }
	
	    ReactDefaultPerf._allMeasurements.length = 0;
	    ReactPerf.enableMeasure = true;
	  },
	
	  stop: function () {
	    ReactPerf.enableMeasure = false;
	  },
	
	  getLastMeasurements: function () {
	    return ReactDefaultPerf._allMeasurements;
	  },
	
	  printExclusive: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Component class name': item.componentName,
	        'Total inclusive time (ms)': roundFloat(item.inclusive),
	        'Exclusive mount time (ms)': roundFloat(item.exclusive),
	        'Exclusive render time (ms)': roundFloat(item.render),
	        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
	        'Render time per instance (ms)': roundFloat(item.render / item.count),
	        'Instances': item.count
	      };
	    }));
	    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
	    // number.
	  },
	
	  printInclusive: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Inclusive time (ms)': roundFloat(item.time),
	        'Instances': item.count
	      };
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  getMeasurementsSummaryMap: function (measurements) {
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
	    return summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Wasted time (ms)': item.time,
	        'Instances': item.count
	      };
	    });
	  },
	
	  printWasted: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  printDOM: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
	    console.table(summary.map(function (item) {
	      var result = {};
	      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
	      result.type = item.type;
	      result.args = JSON.stringify(item.args);
	      return result;
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  _recordWrite: function (id, fnName, totalTime, args) {
	    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
	    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
	    writes[id] = writes[id] || [];
	    writes[id].push({
	      type: fnName,
	      time: totalTime,
	      args: args
	    });
	  },
	
	  measure: function (moduleName, fnName, func) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      var totalTime;
	      var rv;
	      var start;
	
	      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
	        // A "measurement" is a set of metrics recorded for each flush. We want
	        // to group the metrics for a given flush together so we can look at the
	        // components that rendered and the DOM operations that actually
	        // happened to determine the amount of "wasted work" performed.
	        ReactDefaultPerf._allMeasurements.push({
	          exclusive: {},
	          inclusive: {},
	          render: {},
	          counts: {},
	          writes: {},
	          displayNames: {},
	          totalTime: 0,
	          created: {}
	        });
	        start = performanceNow();
	        rv = func.apply(this, args);
	        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
	        return rv;
	      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (fnName === '_mountImageIntoNode') {
	          var mountID = ReactMount.getID(args[1]);
	          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
	        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
	          // special format
	          args[0].forEach(function (update) {
	            var writeArgs = {};
	            if (update.fromIndex !== null) {
	              writeArgs.fromIndex = update.fromIndex;
	            }
	            if (update.toIndex !== null) {
	              writeArgs.toIndex = update.toIndex;
	            }
	            if (update.textContent !== null) {
	              writeArgs.textContent = update.textContent;
	            }
	            if (update.markupIndex !== null) {
	              writeArgs.markup = args[1][update.markupIndex];
	            }
	            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
	          });
	        } else {
	          // basic format
	          var id = args[0];
	          if (typeof id === 'object') {
	            id = ReactMount.getID(args[0]);
	          }
	          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
	        }
	        return rv;
	      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
	      fnName === '_renderValidatedComponent')) {
	
	        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
	          return func.apply(this, args);
	        }
	
	        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
	        var isRender = fnName === '_renderValidatedComponent';
	        var isMount = fnName === 'mountComponent';
	
	        var mountStack = ReactDefaultPerf._mountStack;
	        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
	
	        if (isRender) {
	          addValue(entry.counts, rootNodeID, 1);
	        } else if (isMount) {
	          entry.created[rootNodeID] = true;
	          mountStack.push(0);
	        }
	
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (isRender) {
	          addValue(entry.render, rootNodeID, totalTime);
	        } else if (isMount) {
	          var subMountTime = mountStack.pop();
	          mountStack[mountStack.length - 1] += totalTime;
	          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        } else {
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        }
	
	        entry.displayNames[rootNodeID] = {
	          current: this.getName(),
	          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
	        };
	
	        return rv;
	      } else {
	        return func.apply(this, args);
	      }
	    };
	  }
	};
	
	module.exports = ReactDefaultPerf;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerfAnalysis
	 */
	
	'use strict';
	
	var assign = __webpack_require__(39);
	
	// Don't try to save users less than 1.2ms (a number I made up)
	var DONT_CARE_THRESHOLD = 1.2;
	var DOM_OPERATION_TYPES = {
	  '_mountImageIntoNode': 'set innerHTML',
	  INSERT_MARKUP: 'set innerHTML',
	  MOVE_EXISTING: 'move',
	  REMOVE_NODE: 'remove',
	  SET_MARKUP: 'set innerHTML',
	  TEXT_CONTENT: 'set textContent',
	  'setValueForProperty': 'update attribute',
	  'setValueForAttribute': 'update attribute',
	  'deleteValueForProperty': 'remove attribute',
	  'setValueForStyles': 'update styles',
	  'replaceNodeWithMarkup': 'replace',
	  'updateTextContent': 'set textContent'
	};
	
	function getTotalTime(measurements) {
	  // TODO: return number of DOM ops? could be misleading.
	  // TODO: measure dropped frames after reconcile?
	  // TODO: log total time of each reconcile and the top-level component
	  // class that triggered it.
	  var totalTime = 0;
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    totalTime += measurement.totalTime;
	  }
	  return totalTime;
	}
	
	function getDOMSummary(measurements) {
	  var items = [];
	  measurements.forEach(function (measurement) {
	    Object.keys(measurement.writes).forEach(function (id) {
	      measurement.writes[id].forEach(function (write) {
	        items.push({
	          id: id,
	          type: DOM_OPERATION_TYPES[write.type] || write.type,
	          args: write.args
	        });
	      });
	    });
	  });
	  return items;
	}
	
	function getExclusiveSummary(measurements) {
	  var candidates = {};
	  var displayName;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	    for (var id in allIDs) {
	      displayName = measurement.displayNames[id].current;
	
	      candidates[displayName] = candidates[displayName] || {
	        componentName: displayName,
	        inclusive: 0,
	        exclusive: 0,
	        render: 0,
	        count: 0
	      };
	      if (measurement.render[id]) {
	        candidates[displayName].render += measurement.render[id];
	      }
	      if (measurement.exclusive[id]) {
	        candidates[displayName].exclusive += measurement.exclusive[id];
	      }
	      if (measurement.inclusive[id]) {
	        candidates[displayName].inclusive += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[displayName].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (displayName in candidates) {
	    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[displayName]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.exclusive - a.exclusive;
	  });
	
	  return arr;
	}
	
	function getInclusiveSummary(measurements, onlyClean) {
	  var candidates = {};
	  var inclusiveKey;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	    var cleanComponents;
	
	    if (onlyClean) {
	      cleanComponents = getUnchangedComponents(measurement);
	    }
	
	    for (var id in allIDs) {
	      if (onlyClean && !cleanComponents[id]) {
	        continue;
	      }
	
	      var displayName = measurement.displayNames[id];
	
	      // Inclusive time is not useful for many components without knowing where
	      // they are instantiated. So we aggregate inclusive time with both the
	      // owner and current displayName as the key.
	      inclusiveKey = displayName.owner + ' > ' + displayName.current;
	
	      candidates[inclusiveKey] = candidates[inclusiveKey] || {
	        componentName: inclusiveKey,
	        time: 0,
	        count: 0
	      };
	
	      if (measurement.inclusive[id]) {
	        candidates[inclusiveKey].time += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[inclusiveKey].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (inclusiveKey in candidates) {
	    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[inclusiveKey]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.time - a.time;
	  });
	
	  return arr;
	}
	
	function getUnchangedComponents(measurement) {
	  // For a given reconcile, look at which components did not actually
	  // render anything to the DOM and return a mapping of their ID to
	  // the amount of time it took to render the entire subtree.
	  var cleanComponents = {};
	  var dirtyLeafIDs = Object.keys(measurement.writes);
	  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	  for (var id in allIDs) {
	    var isDirty = false;
	    // For each component that rendered, see if a component that triggered
	    // a DOM op is in its subtree.
	    for (var i = 0; i < dirtyLeafIDs.length; i++) {
	      if (dirtyLeafIDs[i].indexOf(id) === 0) {
	        isDirty = true;
	        break;
	      }
	    }
	    // check if component newly created
	    if (measurement.created[id]) {
	      isDirty = true;
	    }
	    if (!isDirty && measurement.counts[id] > 0) {
	      cleanComponents[id] = true;
	    }
	  }
	  return cleanComponents;
	}
	
	var ReactDefaultPerfAnalysis = {
	  getExclusiveSummary: getExclusiveSummary,
	  getInclusiveSummary: getInclusiveSummary,
	  getDOMSummary: getDOMSummary,
	  getTotalTime: getTotalTime
	};
	
	module.exports = ReactDefaultPerfAnalysis;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performanceNow
	 * @typechecks
	 */
	
	'use strict';
	
	var performance = __webpack_require__(145);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function () {
	    return performance.now();
	  };
	} else {
	  performanceNow = function () {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performance
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 146 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '0.14.7';

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(28);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */
	
	'use strict';
	
	var ReactDefaultInjection = __webpack_require__(71);
	var ReactServerRendering = __webpack_require__(149);
	var ReactVersion = __webpack_require__(146);
	
	ReactDefaultInjection.inject();
	
	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};
	
	module.exports = ReactDOMServer;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';
	
	var ReactDefaultBatchingStrategy = __webpack_require__(92);
	var ReactElement = __webpack_require__(42);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactMarkupChecksum = __webpack_require__(48);
	var ReactServerBatchingStrategy = __webpack_require__(150);
	var ReactServerRenderingTransaction = __webpack_require__(151);
	var ReactUpdates = __webpack_require__(54);
	
	var emptyObject = __webpack_require__(58);
	var instantiateReactComponent = __webpack_require__(62);
	var invariant = __webpack_require__(13);
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 150 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function (callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};
	
	module.exports = ReactServerBatchingStrategy;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	var CallbackQueue = __webpack_require__(55);
	var Transaction = __webpack_require__(57);
	
	var assign = __webpack_require__(39);
	var emptyFunction = __webpack_require__(15);
	
	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  close: emptyFunction
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(110);
	var ReactComponent = __webpack_require__(123);
	var ReactClass = __webpack_require__(122);
	var ReactDOMFactories = __webpack_require__(153);
	var ReactElement = __webpack_require__(42);
	var ReactElementValidator = __webpack_require__(154);
	var ReactPropTypes = __webpack_require__(107);
	var ReactVersion = __webpack_require__(146);
	
	var assign = __webpack_require__(39);
	var onlyChild = __webpack_require__(156);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	var ReactElementValidator = __webpack_require__(154);
	
	var mapObject = __webpack_require__(155);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (process.env.NODE_ENV !== 'production') {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',
	
	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'
	
	}, createDOMFactory);
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	var ReactPropTypeLocations = __webpack_require__(65);
	var ReactPropTypeLocationNames = __webpack_require__(66);
	var ReactCurrentOwner = __webpack_require__(5);
	
	var canDefineProperty = __webpack_require__(43);
	var getIteratorFn = __webpack_require__(108);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	var loggedTypeFailures = {};
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}
	
	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	
	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;
	
	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  return addenda;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum();
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}
	
	module.exports = mapObject;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */
	
	'use strict';
	
	var assign = __webpack_require__(39);
	var warning = __webpack_require__(25);
	
	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (process.env.NODE_ENV !== 'production') {
	    var newFn = function () {
	      process.env.NODE_ENV !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }
	
	  return fn;
	}
	
	module.exports = deprecated;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(3);


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Subschema = __webpack_require__(160);
	
	var _Subschema2 = _interopRequireDefault(_Subschema);
	
	var _hellojs = __webpack_require__(411);
	
	var _hellojs2 = _interopRequireDefault(_hellojs);
	
	var _Login = __webpack_require__(414);
	
	var _Login2 = _interopRequireDefault(_Login);
	
	var _Login3 = __webpack_require__(416);
	
	var _Login4 = _interopRequireDefault(_Login3);
	
	var _GithubProcessor = __webpack_require__(420);
	
	var _GithubProcessor2 = _interopRequireDefault(_GithubProcessor);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	_Subschema.loader.addType({ Login: _Login2.default });
	_Subschema.loader.addStyle({ Login: _Login4.default });
	_Subschema.loader.addProcessor({ GithubProcessor: _GithubProcessor2.default });
	
	var valueManager = (0, _Subschema.ValueManager)();
	valueManager.addListener('login', function (v) {
	    console.log('login', v);
	});
	
	var schema = {
	    "schema": {
	        "login": {
	            "type": "Login",
	            "template": false
	        },
	        "organizations": {
	            "type": "Autocomplete",
	            "processor": "GithubProcessor",
	            "url": "/user/orgs"
	        },
	        "repositories": {
	            "type": "Autocomplete",
	            "processor": "GithubProcessor",
	            "url": "/user/repos"
	        }
	    },
	    "fieldsets": [{
	        "fields": "login"
	    }, {
	        "legend": "Github Info",
	        fields: ["organizations", "repositories"]
	    }]
	};
	
	var App = function (_Component) {
	    _inherits(App, _Component);
	
	    function App() {
	        _classCallCheck(this, App);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(App).apply(this, arguments));
	    }
	
	    _createClass(App, [{
	        key: "render",
	        value: function render() {
	            return _react2.default.createElement(
	                "div",
	                null,
	                _react2.default.createElement(
	                    "p",
	                    null,
	                    "Subschema Github Integration"
	                ),
	                _react2.default.createElement(_Subschema.Form, { schema: schema, loader: _Subschema.loader, valueManager: valueManager })
	            );
	        }
	    }]);
	
	    return App;
	}(_react.Component);

	exports.default = App;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.injector = exports.loader = exports.ReactCSSReplaceTransition = exports.resolvers = exports.DefaultLoader = exports.styles = exports.processors = exports.types = exports.templates = exports.transitions = exports.warning = exports.validators = exports.tutils = exports.listenUtil = exports.eventable = exports.decorators = exports.css = exports.ValueManager = exports.Template = exports.PropTypes = exports.Dom = exports.NewChildContext = exports.Form = exports.FieldSet = exports.Field = exports.Conditional = exports.loaderFactory = undefined;
	exports.newSubschemaContext = newSubschemaContext;
	
	var _ReactCSSReplaceTransition2 = __webpack_require__(161);
	
	var _ReactCSSReplaceTransition3 = _interopRequireDefault(_ReactCSSReplaceTransition2);
	
	var _decorators2 = __webpack_require__(166);
	
	var _DefaultLoader2 = __webpack_require__(250);
	
	var _DefaultLoader3 = _interopRequireDefault(_DefaultLoader2);
	
	var _templates2 = __webpack_require__(260);
	
	var _templates = _interopRequireWildcard(_templates2);
	
	var _types2 = __webpack_require__(300);
	
	var _types = _interopRequireWildcard(_types2);
	
	var _processors2 = __webpack_require__(327);
	
	var _processors = _interopRequireWildcard(_processors2);
	
	var _styles2 = __webpack_require__(332);
	
	var _styles = _interopRequireWildcard(_styles2);
	
	var _resolvers2 = __webpack_require__(365);
	
	var _resolvers = _interopRequireWildcard(_resolvers2);
	
	var _transition = __webpack_require__(359);
	
	var _provideFactory = __webpack_require__(404);
	
	var _provideFactory2 = _interopRequireDefault(_provideFactory);
	
	var _cachedInjector2 = __webpack_require__(405);
	
	var _cachedInjector3 = _interopRequireDefault(_cachedInjector2);
	
	var _subschemaInjection = __webpack_require__(256);
	
	var _index = __webpack_require__(407);
	
	var _index2 = _interopRequireDefault(_index);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var loaderFactory = exports.loaderFactory = _index.loaderFactory;
	var Conditional = exports.Conditional = _index.Conditional;
	var Field = exports.Field = _index.Field;
	var FieldSet = exports.FieldSet = _index.FieldSet;
	var Form = exports.Form = _index.Form;
	var NewChildContext = exports.NewChildContext = _index.NewChildContext;
	var Dom = exports.Dom = _index.Dom;
	var PropTypes = exports.PropTypes = _index.PropTypes;
	var Template = exports.Template = _index.Template;
	var ValueManager = exports.ValueManager = _index.ValueManager;
	var css = exports.css = _index.css;
	var decorators = exports.decorators = _index.decorators;
	var eventable = exports.eventable = _index.eventable;
	var listenUtil = exports.listenUtil = _index.listenUtil;
	var tutils = exports.tutils = _index.tutils;
	var validators = exports.validators = _index.validators;
	var warning = exports.warning = _index.warning;
	var transitions = exports.transitions = _transition.transitions;
	var templates = exports.templates = _templates;
	var types = exports.types = _types;
	var processors = exports.processors = _processors;
	var styles = exports.styles = _styles;
	var DefaultLoader = exports.DefaultLoader = _DefaultLoader3.default;
	var resolvers = exports.resolvers = _resolvers;
	var ReactCSSReplaceTransition = exports.ReactCSSReplaceTransition = _ReactCSSReplaceTransition3.default;
	
	_index2.default.types = _types;
	_index2.default.templates = _templates;
	_index2.default.processors = _processors;
	_index2.default.styles = _styles;
	_index2.default.resolvers = _resolvers;
	_index2.default.DefaultLoader = _DefaultLoader3.default;
	
	var _initSubchemaContext = newSubschemaContext();
	var loader = exports.loader = _initSubchemaContext.loader;
	var injector = exports.injector = _index2.default.injector = _initSubchemaContext.injector;
	exports.default = _initSubchemaContext;
	
	/**
	 * Allows for a new Subschema instance to be created. Mostly for testing,
	 * but for other stuff, may be useful.
	 *
	 * @param defaultLoaders
	 * @param defaultResolvers
	 * @param defaultPropTypes
	 */
	
	function newSubschemaContext() {
	    var defaultLoaders = arguments.length <= 0 || arguments[0] === undefined ? [_DefaultLoader3.default] : arguments[0];
	    var defaultResolvers = arguments.length <= 1 || arguments[1] === undefined ? _resolvers : arguments[1];
	    var defaultPropTypes = arguments.length <= 2 || arguments[2] === undefined ? _index.PropTypes : arguments[2];
	    var defaultInjectorFactory = arguments.length <= 3 || arguments[3] === undefined ? _subschemaInjection.injectorFactory : arguments[3];
	    var defaultSubschema = arguments.length <= 4 || arguments[4] === undefined ? _index2.default : arguments[4];
	
	    return (0, _index.newSubschemaContext)(defaultLoaders, defaultResolvers, defaultPropTypes, defaultInjectorFactory, defaultSubschema);
	}

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2; /**
	                     * Adapted from ReactCSSTransitionGroup.js by Facebook
	                     * Borrowed, with much thanks  from - http://marnusw.github.io/react-css-transition-replace/
	                     *
	                     * @providesModule ReactCSSTransitionReplace
	                     */
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(162);
	
	var _ReactCSSTransitionGroupChild = __webpack_require__(163);
	
	var _ReactCSSTransitionGroupChild2 = _interopRequireDefault(_ReactCSSTransitionGroupChild);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var reactCSSTransitionGroupChild = _react2.default.createFactory(_ReactCSSTransitionGroupChild2.default);
	
	var TICK = 17;
	
	function createTransitionTimeoutPropValidator(transitionType) {
	    var timeoutPropName = 'transition' + transitionType + 'Timeout';
	    var enabledPropName = 'transition' + transitionType;
	
	    return function (props) {
	        // If the transition is enabled
	        if (props[enabledPropName]) {
	            // If no timeout duration is provided
	            if (!props[timeoutPropName]) {
	                return new Error(timeoutPropName + ' wasn\'t supplied to ReactCSSTransitionReplace: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.');
	
	                // If the duration isn't a number
	            } else if (typeof props[timeoutPropName] !== 'number') {
	                    return new Error(timeoutPropName + ' must be a number (in milliseconds)');
	                }
	        }
	    };
	}
	
	var ReactCSSTransitionReplace = (_temp2 = _class = function (_React$Component) {
	    _inherits(ReactCSSTransitionReplace, _React$Component);
	
	    function ReactCSSTransitionReplace() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, ReactCSSTransitionReplace);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(ReactCSSTransitionReplace)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.state = {
	            currentChild: _this.props.children ? _react.Children.only(_this.props.children) : null,
	            nextChild: null,
	            height: null
	        }, _this._handleDoneAppearing = function () {
	            _this.isTransitioning = false;
	        }, _this._handleDoneEntering = function () {
	            _this.isTransitioning = false;
	            _this.setState({
	                currentChild: _this.state.nextChild,
	                nextChild: null,
	                height: null
	            });
	        }, _this._handleDoneLeaving = function () {
	            if (_this.isTransitioning) {
	                var state = { currentChild: null };
	
	                if (!_this.state.nextChild) {
	                    _this.isTransitioning = false;
	                    state.height = null;
	                }
	
	                _this.setState(state);
	            }
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(ReactCSSTransitionReplace, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (this.props.transitionAppear && this.state.currentChild) {
	                this.appearCurrent();
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            if (this.timeout) {
	                clearTimeout(this.timeout);
	            }
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            var _this2 = this;
	
	            // Setting false indicates that the child has changed, but it is a removal so there is no next child.
	            var nextChild = nextProps.children ? _react.Children.only(nextProps.children) : false;
	            var currentChild = this.state.currentChild;
	
	            if (currentChild && nextChild && nextChild.key === currentChild.key) {
	                // Nothing changed, but we are re-rendering so update the currentChild.
	                return this.setState({
	                    currentChild: nextChild
	                });
	            }
	
	            // Set the next child to start the transition, and set the current height.
	            this.setState({
	                nextChild: nextChild,
	                height: this.state.currentChild ? (0, _reactDom.findDOMNode)(this.refs.curr).offsetHeight : 0
	            });
	
	            // Enqueue setting the next height to trigger the height transition.
	            this.timeout = setTimeout(function () {
	                _this2.setState({ height: _this2.state.nextChild ? (0, _reactDom.findDOMNode)(_this2.refs.next).offsetHeight : 0 });
	                _this2.timeout = null;
	            }, TICK);
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (!this.isTransitioning) {
	                if (this.state.nextChild) {
	                    this.enterNext();
	                }
	                if (this.state.currentChild && (this.state.nextChild || this.state.nextChild === false)) {
	                    this.leaveCurrent();
	                }
	            }
	        }
	    }, {
	        key: 'appearCurrent',
	        value: function appearCurrent() {
	            this.refs.curr.componentWillAppear(this._handleDoneAppearing);
	            this.isTransitioning = true;
	        }
	    }, {
	        key: 'enterNext',
	        value: function enterNext() {
	            this.refs.next.componentWillEnter(this._handleDoneEntering);
	            this.isTransitioning = true;
	        }
	    }, {
	        key: 'leaveCurrent',
	        value: function leaveCurrent() {
	            this.refs.curr.componentWillLeave(this._handleDoneLeaving);
	            this.isTransitioning = true;
	        }
	
	        // When the leave transition time-out expires the animation classes are removed, so the
	        // element must be removed from the DOM if the enter transition is still in progress.
	
	    }, {
	        key: '_wrapChild',
	        value: function _wrapChild(child, moreProps) {
	            // We need to provide this childFactory so that
	            // ReactCSSTransitionReplaceChild can receive updates to name,
	            // enter, and leave while it is leaving.
	            return reactCSSTransitionGroupChild(_extends({}, moreProps, {
	                name: this.props.transitionName,
	                appear: this.props.transitionAppear,
	                enter: this.props.transitionEnter,
	                leave: this.props.transitionLeave,
	                appearTimeout: this.props.transitionAppearTimeout,
	                enterTimeout: this.props.transitionEnterTimeout,
	                leaveTimeout: this.props.transitionLeaveTimeout
	            }), child);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _state = this.state;
	            var currentChild = _state.currentChild;
	            var nextChild = _state.nextChild;
	            var height = _state.height;
	
	            var childrenToRender = [];
	
	            var _props = this.props;
	            var overflowHidden = _props.overflowHidden;
	
	            var containerProps = _objectWithoutProperties(_props, ['overflowHidden']);
	
	            if (currentChild) {
	                childrenToRender.push(this._wrapChild(currentChild, {
	                    ref: 'curr', key: 'curr'
	                }));
	            }
	
	            if (height !== null) {
	                var transitionHeightClass = containerProps.transitionHeightClass;
	                var style = containerProps.style;
	                var className = containerProps.className;
	
	                containerProps.className = (className || '') + ' ' + transitionHeightClass;
	                containerProps.style = _extends({}, style, {
	                    position: 'relative',
	                    display: 'block',
	                    height: height
	                });
	
	                if (overflowHidden) {
	                    containerProps.style.overflow = 'hidden';
	                }
	            }
	
	            if (nextChild) {
	                childrenToRender.push((0, _react.createElement)('span', {
	                    style: {
	                        position: 'absolute',
	                        top: 0,
	                        left: 0,
	                        right: 0,
	                        bottom: 0
	                    },
	                    key: 'next'
	                }, this._wrapChild(nextChild, { ref: 'next' })));
	            }
	
	            return (0, _react.createElement)(this.props.component, containerProps, childrenToRender);
	        }
	    }]);
	
	    return ReactCSSTransitionReplace;
	}(_react2.default.Component), _class.propTypes = {
	    transitionName: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.shape({
	        enter: _react.PropTypes.string,
	        enterActive: _react.PropTypes.string,
	        leave: _react.PropTypes.string,
	        leaveActive: _react.PropTypes.string,
	        appear: _react.PropTypes.string,
	        appearActive: _react.PropTypes.string
	    })]),
	    transitionAppearTimeout: createTransitionTimeoutPropValidator('Appear'),
	    transitionEnterTimeout: createTransitionTimeoutPropValidator('Enter'),
	    transitionLeaveTimeout: createTransitionTimeoutPropValidator('Leave'),
	    transitionHeightClass: _react.PropTypes.string,
	    overflowHidden: _react.PropTypes.bool
	
	}, _class.defaultProps = {
	    transitionAppear: false,
	    transitionEnter: true,
	    transitionLeave: true,
	    overflowHidden: true,
	    component: 'span',
	    style: {}
	}, _temp2);
	exports.default = ReactCSSTransitionReplace;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(3);


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * @providesModule ReactCSSTransitionGroupChild
	 */
	
	'use strict';
	
	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(3);
	
	var CSSCore = __webpack_require__(164);
	var ReactTransitionEvents = __webpack_require__(165);
	
	var onlyChild = __webpack_require__(156);
	
	// We don't remove the element from the DOM until we receive an animationend or
	// transitionend event. If the user screws up and forgets to add an animation
	// their node will be stuck in the DOM forever, so we detect if an animation
	// does not start and if it doesn't, we just call the end listener immediately.
	var TICK = 17;
	
	var ReactCSSTransitionGroupChild = React.createClass({
	  displayName: 'ReactCSSTransitionGroupChild',
	
	  propTypes: {
	    name: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.shape({
	      enter: React.PropTypes.string,
	      leave: React.PropTypes.string,
	      active: React.PropTypes.string
	    }), React.PropTypes.shape({
	      enter: React.PropTypes.string,
	      enterActive: React.PropTypes.string,
	      leave: React.PropTypes.string,
	      leaveActive: React.PropTypes.string,
	      appear: React.PropTypes.string,
	      appearActive: React.PropTypes.string
	    })]).isRequired,
	
	    // Once we require timeouts to be specified, we can remove the
	    // boolean flags (appear etc.) and just accept a number
	    // or a bool for the timeout flags (appearTimeout etc.)
	    appear: React.PropTypes.bool,
	    enter: React.PropTypes.bool,
	    leave: React.PropTypes.bool,
	    appearTimeout: React.PropTypes.number,
	    enterTimeout: React.PropTypes.number,
	    leaveTimeout: React.PropTypes.number
	  },
	
	  transition: function (animationType, finishCallback, userSpecifiedDelay) {
	    var node = ReactDOM.findDOMNode(this);
	
	    if (!node) {
	      if (finishCallback) {
	        finishCallback();
	      }
	      return;
	    }
	
	    var className = this.props.name[animationType] || this.props.name + '-' + animationType;
	    var activeClassName = this.props.name[animationType + 'Active'] || className + '-active';
	    var timeout = null;
	
	    var endListener = function (e) {
	      if (e && e.target !== node) {
	        return;
	      }
	
	      clearTimeout(timeout);
	
	      CSSCore.removeClass(node, className);
	      CSSCore.removeClass(node, activeClassName);
	
	      ReactTransitionEvents.removeEndEventListener(node, endListener);
	
	      // Usually this optional callback is used for informing an owner of
	      // a leave animation and telling it to remove the child.
	      if (finishCallback) {
	        finishCallback();
	      }
	    };
	
	    CSSCore.addClass(node, className);
	
	    // Need to do this to actually trigger a transition.
	    this.queueClass(activeClassName);
	
	    // If the user specified a timeout delay.
	    if (userSpecifiedDelay) {
	      // Clean-up the animation after the specified delay
	      timeout = setTimeout(endListener, userSpecifiedDelay);
	      this.transitionTimeouts.push(timeout);
	    } else {
	      // DEPRECATED: this listener will be removed in a future version of react
	      ReactTransitionEvents.addEndEventListener(node, endListener);
	    }
	  },
	
	  queueClass: function (className) {
	    this.classNameQueue.push(className);
	
	    if (!this.timeout) {
	      this.timeout = setTimeout(this.flushClassNameQueue, TICK);
	    }
	  },
	
	  flushClassNameQueue: function () {
	    if (this.isMounted()) {
	      this.classNameQueue.forEach(CSSCore.addClass.bind(CSSCore, ReactDOM.findDOMNode(this)));
	    }
	    this.classNameQueue.length = 0;
	    this.timeout = null;
	  },
	
	  componentWillMount: function () {
	    this.classNameQueue = [];
	    this.transitionTimeouts = [];
	  },
	
	  componentWillUnmount: function () {
	    if (this.timeout) {
	      clearTimeout(this.timeout);
	    }
	    this.transitionTimeouts.forEach(function (timeout) {
	      clearTimeout(timeout);
	    });
	  },
	
	  componentWillAppear: function (done) {
	    if (this.props.appear) {
	      this.transition('appear', done, this.props.appearTimeout);
	    } else {
	      done();
	    }
	  },
	
	  componentWillEnter: function (done) {
	    if (this.props.enter) {
	      this.transition('enter', done, this.props.enterTimeout);
	    } else {
	      done();
	    }
	  },
	
	  componentWillLeave: function (done) {
	    if (this.props.leave) {
	      this.transition('leave', done, this.props.leaveTimeout);
	    } else {
	      done();
	    }
	  },
	
	  render: function () {
	    return onlyChild(this.props.children);
	  }
	});
	
	module.exports = ReactCSSTransitionGroupChild;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSCore
	 * @typechecks
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * The CSSCore module specifies the API (and implements most of the methods)
	 * that should be used when dealing with the display of elements (via their
	 * CSS classes and visibility on screen. It is an API focused on mutating the
	 * display and not reading it as no logical state should be encoded in the
	 * display of elements.
	 */
	
	var CSSCore = {
	
	  /**
	   * Adds the class passed in to the element if it doesn't already have it.
	   *
	   * @param {DOMElement} element the element to set the class on
	   * @param {string} className the CSS className
	   * @return {DOMElement} the element passed in
	   */
	  addClass: function (element, className) {
	    !!/\s/.test(className) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'CSSCore.addClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;
	
	    if (className) {
	      if (element.classList) {
	        element.classList.add(className);
	      } else if (!CSSCore.hasClass(element, className)) {
	        element.className = element.className + ' ' + className;
	      }
	    }
	    return element;
	  },
	
	  /**
	   * Removes the class passed in from the element
	   *
	   * @param {DOMElement} element the element to set the class on
	   * @param {string} className the CSS className
	   * @return {DOMElement} the element passed in
	   */
	  removeClass: function (element, className) {
	    !!/\s/.test(className) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'CSSCore.removeClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;
	
	    if (className) {
	      if (element.classList) {
	        element.classList.remove(className);
	      } else if (CSSCore.hasClass(element, className)) {
	        element.className = element.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ') // multiple spaces to one
	        .replace(/^\s*|\s*$/g, ''); // trim the ends
	      }
	    }
	    return element;
	  },
	
	  /**
	   * Helper to add or remove a class from an element based on a condition.
	   *
	   * @param {DOMElement} element the element to set the class on
	   * @param {string} className the CSS className
	   * @param {*} bool condition to whether to add or remove the class
	   * @return {DOMElement} the element passed in
	   */
	  conditionClass: function (element, className, bool) {
	    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);
	  },
	
	  /**
	   * Tests whether the element has the class specified.
	   *
	   * @param {DOMNode|DOMWindow} element the element to set the class on
	   * @param {string} className the CSS className
	   * @return {boolean} true if the element has the class, false if not
	   */
	  hasClass: function (element, className) {
	    !!/\s/.test(className) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'CSS.hasClass takes only a single class name.') : invariant(false) : undefined;
	    if (element.classList) {
	      return !!className && element.classList.contains(className);
	    }
	    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
	  }
	
	};
	
	module.exports = CSSCore;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactTransitionEvents
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	/**
	 * EVENT_NAME_MAP is used to determine which event fired when a
	 * transition/animation ends, based on the style property used to
	 * define that event.
	 */
	var EVENT_NAME_MAP = {
	  transitionend: {
	    'transition': 'transitionend',
	    'WebkitTransition': 'webkitTransitionEnd',
	    'MozTransition': 'mozTransitionEnd',
	    'OTransition': 'oTransitionEnd',
	    'msTransition': 'MSTransitionEnd'
	  },
	
	  animationend: {
	    'animation': 'animationend',
	    'WebkitAnimation': 'webkitAnimationEnd',
	    'MozAnimation': 'mozAnimationEnd',
	    'OAnimation': 'oAnimationEnd',
	    'msAnimation': 'MSAnimationEnd'
	  }
	};
	
	var endEvents = [];
	
	function detectEvents() {
	  var testEl = document.createElement('div');
	  var style = testEl.style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are useable, and if not remove them
	  // from the map
	  if (!('AnimationEvent' in window)) {
	    delete EVENT_NAME_MAP.animationend.animation;
	  }
	
	  if (!('TransitionEvent' in window)) {
	    delete EVENT_NAME_MAP.transitionend.transition;
	  }
	
	  for (var baseEventName in EVENT_NAME_MAP) {
	    var baseEvents = EVENT_NAME_MAP[baseEventName];
	    for (var styleName in baseEvents) {
	      if (styleName in style) {
	        endEvents.push(baseEvents[styleName]);
	        break;
	      }
	    }
	  }
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  detectEvents();
	}
	
	// We use the raw {add|remove}EventListener() call because EventListener
	// does not know how to remove event listeners and we really should
	// clean up. Also, these events are not triggered in older browsers
	// so we should be A-OK here.
	
	function addEventListener(node, eventName, eventListener) {
	  node.addEventListener(eventName, eventListener, false);
	}
	
	function removeEventListener(node, eventName, eventListener) {
	  node.removeEventListener(eventName, eventListener, false);
	}
	
	var ReactTransitionEvents = {
	  addEndEventListener: function (node, eventListener) {
	    if (endEvents.length === 0) {
	      // If CSS transitions are not supported, trigger an "end animation"
	      // event immediately.
	      window.setTimeout(eventListener, 0);
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      addEventListener(node, endEvent, eventListener);
	    });
	  },
	
	  removeEndEventListener: function (node, eventListener) {
	    if (endEvents.length === 0) {
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      removeEventListener(node, endEvent, eventListener);
	    });
	  }
	};
	
	module.exports = ReactTransitionEvents;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.lifecycle = exports.decorator = undefined;
	
	var _decorator2 = __webpack_require__(167);
	
	var _decorator3 = _interopRequireDefault(_decorator2);
	
	var _lifecycle2 = __webpack_require__(249);
	
	var _lifecycle3 = _interopRequireDefault(_lifecycle2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var decorator = exports.decorator = _decorator3.default;
	var lifecycle = exports.lifecycle = _lifecycle3.default;
	
	exports.default = {
	    decorator: _decorator3.default,
	    lifecycle: _lifecycle3.default
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function isDescriptor(obj) {
	    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') return false;
	    var keys = Object.keys(obj);
	    if (keys.indexOf('enumerable') === -1) return false;
	    if (keys.indexOf('configurable') === -1) return false;
	    if (keys.indexOf('writable') === -1) return false;
	    return true;
	}
	function emptyClassConfig() {
	    return function emptyClass$return(Target) {
	        return Target;
	    };
	}
	function emptyPropertyConfig() {
	    return function emptyProp$return(target, name, descriptor) {
	        return descriptor;
	    };
	}
	/**
	 * Check if Method decorator.
	 * Returns true if it is a property decorator.
	 * issues warning if it is a property decorator used on a class.
	 */
	function isProperty(config, args) {
	    //3 arguments
	    if (args == null || args.length != 3 || args[0] == null || args[1] == null || args[2] == null) {
	        return false;
	    }
	
	    //First argument is an object with a function constructor.
	    //TODO find better isntance detection.
	    if (!(_typeof(args[0]) === 'object' && typeof args[0].constructor === 'function')) {
	        return false;
	    }
	
	    //Second argument is a string
	    if (!(typeof args[1] === 'string')) {
	        return false;
	    }
	
	    //Third argument is the descriptors argument.
	    if (!isDescriptor(args[2])) {
	        return false;
	        //return Object.hasOwnPropty(args[2], 'value');
	    }
	    if (config == null) {
	        decorator.warning.apply(decorator, [false, 'decorator [%s]#[%s] was used on a method, but the decorator does not support this'].concat(_toConsumableArray(args)));
	        return false;
	    }
	    return true;
	}
	
	/**
	 * Check if Class decorator
	 * Returns true if it is a class decorator.
	 * Issues warning if it is a class decorator used on a property and return true.
	 * return false otherwise.
	 *
	 * //BUG-
	 * If someone uses a function as the only parameter to a property descriptor, this will fail.
	 * as we can not determine if this is being invoked
	 * Example
	 * var a = function(){}
	 * @decorator(a);
	 * class Stuff {
	 * 
	 * }
	 *
	 *
	 */
	function isClass(config, args) {
	
	    if (args != null && args.length === 1 && typeof args[0] === 'function') {
	        if (config == null) {
	            decorator.warning.apply(decorator, [false, 'decorator [%s] was used on a class, but the decorator does not support this'].concat(_toConsumableArray(args)));
	            return false;
	        }
	        return true;
	    }
	    return false;
	}
	/**
	 * Check if the decorator is a property or a class decorator and invoke accordingly
	 */
	function decorator$config$config(propertyConfig, classConfig) {
	    var decoratorArgs = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
	
	    for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
	        args[_key - 3] = arguments[_key];
	    }
	
	    if (isProperty(propertyConfig, args)) {
	
	        return propertyConfig.apply(undefined, _toConsumableArray(decoratorArgs)).apply(undefined, args);
	    }
	    if (isClass(classConfig, args)) {
	
	        return classConfig.apply(undefined, _toConsumableArray(decoratorArgs)).apply(undefined, args);
	    }
	    return false;
	}
	
	/**
	 * config returns a function that is the decorator.
	 * This should normalize decorator access.
	 * The first argument to the decorator is 'method' if it is a method decorator, or 'class' if it is
	 * a class decorator.
	 *
	 * It also numeralizes invoked, vs uninvoked decorators
	 * @decorator
	 * class Stuf {
	 * }
	 * or
	 * @decorator()
	 * class Stuf {
	 * }
	 *
	 * can be handled without any other checks.
	 *
	 * Note this follows the @decorators() protocol.   So the method decorated, should always return
	 * a method.   Regardless of typical usage.
	 *
	 * You can also specify different functions for class decoration or property decoration.
	 *
	 */
	function decorator() {
	    var propertyConfig = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var classConfig = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	    var decorator$config = function decorator$config() {
	        if (decorator$config.noDecorate || decorator.noDecorate) {
	            propertyConfig = emptyPropertyConfig;
	            classConfig = emptyClassConfig;
	        }
	
	        for (var _len2 = arguments.length, decoratorArgs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            decoratorArgs[_key2] = arguments[_key2];
	        }
	
	        return decorator$config$config.apply(undefined, [propertyConfig, classConfig, _tutils.FREEZE_ARR].concat(decoratorArgs)) || decorator$config$config.bind(null, propertyConfig, classConfig, decoratorArgs);
	    };
	    return decorator$config;
	}
	decorator.property = decorator.bind(null);
	decorator.clazz = decorator.bind(null, null);
	decorator.warning = _warning2.default;
	
	//Disable decoration - useful for testing.
	decorator.noDecorate = false;
	
	exports.default = decorator;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _noop = __webpack_require__(169);
	
	var _noop2 = _interopRequireDefault(_noop);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var warning = _noop2.default;
	
	if (process.env.NODE_ENV !== 'production') {
	    warning = function warning(check, format) {
	        if (format === undefined) {
	            throw new Error('`subschema: warning(condition, format, ...args)` requires a warning message argument');
	        }
	        if (check) {
	            return;
	        }
	
	        var args = arguments,
	            i = 2,
	            message = 'Subschema Warning: ' + format.replace(/%s/g, function () {
	            return args[i++];
	        });
	
	        if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== void 0) {
	            console.error(message);
	        }
	
	        try {
	            //trigger debugger;
	            throw new Error(message);
	        } catch (x) {}
	    };
	}
	
	exports.default = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 169 */
/***/ function(module, exports) {

	/**
	 * A no-operation function that returns `undefined` regardless of the
	 * arguments it receives.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.noop(object) === undefined;
	 * // => true
	 */
	function noop() {
	  // No operation performed.
	}
	
	module.exports = noop;


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.inherits = exports.nextFunc = exports.applyFuncs = exports.titlelize = exports.uppercase = exports.emptyCheck = exports.nullCheck = exports.debounce = exports.clone = exports.xtend = exports.toArray = exports.path = exports.result = exports.returnFirst = exports.resolveKey = exports.slice = exports.push = exports.flatten = exports.FREEZE_ARR = exports.FREEZE_OBJ = exports.isObject = exports.values = exports.each = exports.noop = exports.unique = exports.find = exports.isNumber = exports.isArray = exports.isBoolean = exports.isDate = exports.isRegExp = exports.isString = exports.isFunction = exports.extend = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extend = __webpack_require__(171);
	
	var _extend2 = _interopRequireDefault(_extend);
	
	var _isFunction = __webpack_require__(177);
	
	var _isFunction2 = _interopRequireDefault(_isFunction);
	
	var _isString = __webpack_require__(196);
	
	var _isString2 = _interopRequireDefault(_isString);
	
	var _isRegExp = __webpack_require__(197);
	
	var _isRegExp2 = _interopRequireDefault(_isRegExp);
	
	var _isDate = __webpack_require__(198);
	
	var _isDate2 = _interopRequireDefault(_isDate);
	
	var _isBoolean = __webpack_require__(199);
	
	var _isBoolean2 = _interopRequireDefault(_isBoolean);
	
	var _isArray = __webpack_require__(186);
	
	var _isArray2 = _interopRequireDefault(_isArray);
	
	var _isNumber = __webpack_require__(200);
	
	var _isNumber2 = _interopRequireDefault(_isNumber);
	
	var _isObject = __webpack_require__(178);
	
	var _isObject2 = _interopRequireDefault(_isObject);
	
	var _find = __webpack_require__(201);
	
	var _find2 = _interopRequireDefault(_find);
	
	var _unique = __webpack_require__(233);
	
	var _unique2 = _interopRequireDefault(_unique);
	
	var _noop = __webpack_require__(169);
	
	var _noop2 = _interopRequireDefault(_noop);
	
	var _each = __webpack_require__(243);
	
	var _each2 = _interopRequireDefault(_each);
	
	var _values = __webpack_require__(247);
	
	var _values2 = _interopRequireDefault(_values);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FREEZE_OBJ = Object.freeze({});
	var FREEZE_ARR = Object.freeze([]);
	var flatten = Function.apply.bind(Array.prototype.concat, []);
	var push = Function.apply.bind(Array.prototype.push);
	var slice = Function.call.bind(Array.prototype.slice);
	
	function returnFirst(value) {
	    return value;
	}
	
	function resolveKey(path, key) {
	    if (!key) {
	        return path;
	    }
	    if (key[0] != '.') {
	        return key;
	    }
	    var parts = path ? path.split('.') : [];
	    key = key.substring(1);
	    while (key[0] === '.') {
	        key = key.substring(1);
	        parts.pop();
	    }
	    if (key) {
	        parts.push(key);
	    }
	    return parts.length === 0 ? null : parts.join('.');
	}
	
	function result(scope, key) {
	    if (!key) {
	        return null;
	    }
	    if (typeof key === 'string') {
	        return result(scope, scope[key]);
	    }
	    if (typeof key === 'function') {
	        return key.call(scope);
	    }
	    return key;
	}
	
	function path() {
	    var args = slice(arguments),
	        l = args.length,
	        i = 0,
	        j = 0,
	        p;
	    var ret = '';
	    for (; i < l; i++) {
	        p = args[i];
	        if (p == null || p === '') continue;
	        ret += j++ === 0 ? p : "." + p;
	    }
	    return ret;
	}
	
	function toArray(v) {
	    if ((0, _isArray2.default)(v)) {
	        return v;
	    }
	    if ((0, _isString2.default)(v)) {
	        return v.split(/\,\s*/);
	    }
	    if (v == null) {
	        return [];
	    }
	    return [v];
	}
	
	function xtend(dest, args) {
	    dest = dest || {};
	    for (var i = 1, l = arguments.length; i < l; i++) {
	        var arg = arguments[1];
	        if (arg == null) continue;
	        for (var j in arg) {
	            dest[j] = args[j];
	        }
	    }
	    return dest;
	}
	
	function clone(t) {
	    if (t == null) return t;
	    var tt = typeof t === 'undefined' ? 'undefined' : _typeof(t);
	    if (tt == 'boolean' || tt === 'number' || tt === 'string' || tt === 'function' || tt === 'symbol') {
	        return t;
	    }
	    if ((0, _isArray2.default)(t)) {
	        return t.concat();
	    }
	    if (t instanceof Date) {
	        return new Date(t.getTime());
	    }
	    return (0, _extend2.default)({}, t);
	}
	
	function debounce(fn, to) {
	    var ti;
	
	    return function f() {
	        clearTimeout(ti);
	        var args = Array.prototype.slice.call(arguments),
	            self = this;
	        ti = setTimeout(function () {
	            fn.apply(self, args);
	        }, to);
	    };
	}
	
	function nullCheck(v) {
	    return v != null;
	}
	
	function emptyCheck(v) {
	    return v != null && v.length > 0;
	}
	
	function uppercase(v) {
	    return v.toUpperCase();
	}
	
	function titlelize(value) {
	    return ((value || '') + '').replace(/([A-Z])/g, ' $1').replace(/^./, uppercase);
	}
	
	function applyFuncs(f1, f2) {
	    if (f1 && !f2) return f1;
	    if (!f1 && f2) return f2;
	    return function applyFuncs$bothFuncs() {
	        f1.call.apply(f1, [this].concat(Array.prototype.slice.call(arguments)));
	        f2.call.apply(f2, [this].concat(Array.prototype.slice.call(arguments)));
	    };
	}
	
	function inherits(Clazz) {
	    var Proto = this;
	    do {
	        if (Proto === Clazz) {
	            return true;
	        }
	        Proto = Object.getPrototypeOf(Proto);
	    } while (Proto !== Object && Proto != null);
	    return false;
	}
	/**
	 * When f1 and f2 are defined-
	 *
	 * Calls f1 and f2 if f1 and f2 are defined and f1 does not return false.
	 * If f1 returns false, f2 is not called.
	 *
	 * If f2 is not defined f1 is returned.
	 * if f1 is not defined f2 is returned.
	 *
	 * @param f1
	 * @param f2
	 * @returns {function}
	 */
	function nextFunc(f1, f2) {
	    if (f1 && !f2) return f1;
	    if (f2 && !f1) return f2;
	    return function nextFunc$wrapper() {
	        if (f1.call.apply(f1, [this].concat(Array.prototype.slice.call(arguments))) !== false) {
	            return f2.call.apply(f2, [this].concat(Array.prototype.slice.call(arguments)));
	        }
	    };
	}
	
	//re-exports
	exports.extend = _extend2.default;
	exports.isFunction = _isFunction2.default;
	exports.isString = _isString2.default;
	exports.isRegExp = _isRegExp2.default;
	exports.isDate = _isDate2.default;
	exports.isBoolean = _isBoolean2.default;
	exports.isArray = _isArray2.default;
	exports.isNumber = _isNumber2.default;
	exports.find = _find2.default;
	exports.unique = _unique2.default;
	exports.noop = _noop2.default;
	exports.each = _each2.default;
	exports.values = _values2.default;
	exports.isObject = _isObject2.default;
	exports.FREEZE_OBJ = FREEZE_OBJ;
	exports.FREEZE_ARR = FREEZE_ARR;
	exports.flatten = flatten;
	exports.push = push;
	exports.slice = slice;
	exports.resolveKey = resolveKey;
	exports.returnFirst = returnFirst;
	exports.result = result;
	exports.path = path;
	exports.toArray = toArray;
	exports.xtend = xtend;
	exports.clone = clone;
	exports.debounce = debounce;
	exports.nullCheck = nullCheck;
	exports.emptyCheck = emptyCheck;
	exports.uppercase = uppercase;
	exports.titlelize = titlelize;
	exports.applyFuncs = applyFuncs;
	exports.nextFunc = nextFunc;
	exports.inherits = inherits;
	exports.default = {
	    extend: _extend2.default,
	    isFunction: _isFunction2.default,
	    isString: _isString2.default,
	    isRegExp: _isRegExp2.default,
	    isDate: _isDate2.default,
	    isBoolean: _isBoolean2.default,
	    isArray: _isArray2.default,
	    isNumber: _isNumber2.default,
	    find: _find2.default,
	    unique: _unique2.default,
	    noop: _noop2.default,
	    each: _each2.default,
	    values: _values2.default,
	    isObject: _isObject2.default,
	    FREEZE_OBJ: FREEZE_OBJ,
	    FREEZE_ARR: FREEZE_ARR,
	    flatten: flatten,
	    push: push,
	    resolveKey: resolveKey,
	    slice: slice,
	    inherits: inherits,
	    returnFirst: returnFirst,
	    result: result,
	    path: path,
	    toArray: toArray,
	    xtend: xtend,
	    clone: clone,
	    debounce: debounce,
	    nullCheck: nullCheck,
	    emptyCheck: emptyCheck,
	    uppercase: uppercase,
	    titlelize: titlelize,
	    applyFuncs: applyFuncs,
	    nextFunc: nextFunc
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(172);


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var assignWith = __webpack_require__(173),
	    baseAssign = __webpack_require__(189),
	    createAssigner = __webpack_require__(191);
	
	/**
	 * Assigns own enumerable properties of source object(s) to the destination
	 * object. Subsequent sources overwrite property assignments of previous sources.
	 * If `customizer` is provided it's invoked to produce the assigned values.
	 * The `customizer` is bound to `thisArg` and invoked with five arguments:
	 * (objectValue, sourceValue, key, object, source).
	 *
	 * **Note:** This method mutates `object` and is based on
	 * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
	 *
	 * @static
	 * @memberOf _
	 * @alias extend
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {*} [thisArg] The `this` binding of `customizer`.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	 * // => { 'user': 'fred', 'age': 40 }
	 *
	 * // using a customizer callback
	 * var defaults = _.partialRight(_.assign, function(value, other) {
	 *   return _.isUndefined(value) ? other : value;
	 * });
	 *
	 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	 * // => { 'user': 'barney', 'age': 36 }
	 */
	var assign = createAssigner(function(object, source, customizer) {
	  return customizer
	    ? assignWith(object, source, customizer)
	    : baseAssign(object, source);
	});
	
	module.exports = assign;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(174);
	
	/**
	 * A specialized version of `_.assign` for customizing assigned values without
	 * support for argument juggling, multiple sources, and `this` binding `customizer`
	 * functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {Function} customizer The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 */
	function assignWith(object, source, customizer) {
	  var index = -1,
	      props = keys(source),
	      length = props.length;
	
	  while (++index < length) {
	    var key = props[index],
	        value = object[key],
	        result = customizer(value, source[key], key, object, source);
	
	    if ((result === result ? (result !== value) : (value === value)) ||
	        (value === undefined && !(key in object))) {
	      object[key] = result;
	    }
	  }
	  return object;
	}
	
	module.exports = assignWith;


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(175),
	    isArrayLike = __webpack_require__(180),
	    isObject = __webpack_require__(178),
	    shimKeys = __webpack_require__(184);
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeKeys = getNative(Object, 'keys');
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	var keys = !nativeKeys ? shimKeys : function(object) {
	  var Ctor = object == null ? undefined : object.constructor;
	  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	      (typeof object != 'function' && isArrayLike(object))) {
	    return shimKeys(object);
	  }
	  return isObject(object) ? nativeKeys(object) : [];
	};
	
	module.exports = keys;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var isNative = __webpack_require__(176);
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}
	
	module.exports = getNative;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(177),
	    isObjectLike = __webpack_require__(179);
	
	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}
	
	module.exports = isNative;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(178);
	
	/** `Object#toString` result references. */
	var funcTag = '[object Function]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 which returns 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}
	
	module.exports = isFunction;


/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ },
/* 179 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var getLength = __webpack_require__(181),
	    isLength = __webpack_require__(183);
	
	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}
	
	module.exports = isArrayLike;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(182);
	
	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');
	
	module.exports = getLength;


/***/ },
/* 182 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	module.exports = baseProperty;


/***/ },
/* 183 */
/***/ function(module, exports) {

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	module.exports = isLength;


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var isArguments = __webpack_require__(185),
	    isArray = __webpack_require__(186),
	    isIndex = __webpack_require__(187),
	    isLength = __webpack_require__(183),
	    keysIn = __webpack_require__(188);
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * A fallback implementation of `Object.keys` which creates an array of the
	 * own enumerable property names of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function shimKeys(object) {
	  var props = keysIn(object),
	      propsLength = props.length,
	      length = propsLength && object.length;
	
	  var allowIndexes = !!length && isLength(length) &&
	    (isArray(object) || isArguments(object));
	
	  var index = -1,
	      result = [];
	
	  while (++index < propsLength) {
	    var key = props[index];
	    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = shimKeys;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(180),
	    isObjectLike = __webpack_require__(179);
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Native method references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/**
	 * Checks if `value` is classified as an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  return isObjectLike(value) && isArrayLike(value) &&
	    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	}
	
	module.exports = isArguments;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(175),
	    isLength = __webpack_require__(183),
	    isObjectLike = __webpack_require__(179);
	
	/** `Object#toString` result references. */
	var arrayTag = '[object Array]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};
	
	module.exports = isArray;


/***/ },
/* 187 */
/***/ function(module, exports) {

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;
	
	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}
	
	module.exports = isIndex;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var isArguments = __webpack_require__(185),
	    isArray = __webpack_require__(186),
	    isIndex = __webpack_require__(187),
	    isLength = __webpack_require__(183),
	    isObject = __webpack_require__(178);
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  if (object == null) {
	    return [];
	  }
	  if (!isObject(object)) {
	    object = Object(object);
	  }
	  var length = object.length;
	  length = (length && isLength(length) &&
	    (isArray(object) || isArguments(object)) && length) || 0;
	
	  var Ctor = object.constructor,
	      index = -1,
	      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	      result = Array(length),
	      skipIndexes = length > 0;
	
	  while (++index < length) {
	    result[index] = (index + '');
	  }
	  for (var key in object) {
	    if (!(skipIndexes && isIndex(key, length)) &&
	        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = keysIn;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var baseCopy = __webpack_require__(190),
	    keys = __webpack_require__(174);
	
	/**
	 * The base implementation of `_.assign` without support for argument juggling,
	 * multiple sources, and `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return source == null
	    ? object
	    : baseCopy(source, keys(source), object);
	}
	
	module.exports = baseAssign;


/***/ },
/* 190 */
/***/ function(module, exports) {

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property names to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @returns {Object} Returns `object`.
	 */
	function baseCopy(source, props, object) {
	  object || (object = {});
	
	  var index = -1,
	      length = props.length;
	
	  while (++index < length) {
	    var key = props[index];
	    object[key] = source[key];
	  }
	  return object;
	}
	
	module.exports = baseCopy;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var bindCallback = __webpack_require__(192),
	    isIterateeCall = __webpack_require__(194),
	    restParam = __webpack_require__(195);
	
	/**
	 * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return restParam(function(object, sources) {
	    var index = -1,
	        length = object == null ? 0 : sources.length,
	        customizer = length > 2 ? sources[length - 2] : undefined,
	        guard = length > 2 ? sources[2] : undefined,
	        thisArg = length > 1 ? sources[length - 1] : undefined;
	
	    if (typeof customizer == 'function') {
	      customizer = bindCallback(customizer, thisArg, 5);
	      length -= 2;
	    } else {
	      customizer = typeof thisArg == 'function' ? thisArg : undefined;
	      length -= (customizer ? 1 : 0);
	    }
	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, customizer);
	      }
	    }
	    return object;
	  });
	}
	
	module.exports = createAssigner;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(193);
	
	/**
	 * A specialized version of `baseCallback` which only supports `this` binding
	 * and specifying the number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {Function} func The function to bind.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function bindCallback(func, thisArg, argCount) {
	  if (typeof func != 'function') {
	    return identity;
	  }
	  if (thisArg === undefined) {
	    return func;
	  }
	  switch (argCount) {
	    case 1: return function(value) {
	      return func.call(thisArg, value);
	    };
	    case 3: return function(value, index, collection) {
	      return func.call(thisArg, value, index, collection);
	    };
	    case 4: return function(accumulator, value, index, collection) {
	      return func.call(thisArg, accumulator, value, index, collection);
	    };
	    case 5: return function(value, other, key, object, source) {
	      return func.call(thisArg, value, other, key, object, source);
	    };
	  }
	  return function() {
	    return func.apply(thisArg, arguments);
	  };
	}
	
	module.exports = bindCallback;


/***/ },
/* 193 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument provided to it.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.identity(object) === object;
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	module.exports = identity;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(180),
	    isIndex = __webpack_require__(187),
	    isObject = __webpack_require__(178);
	
	/**
	 * Checks if the provided arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	      ? (isArrayLike(object) && isIndex(index, object.length))
	      : (type == 'string' && index in object)) {
	    var other = object[index];
	    return value === value ? (value === other) : (other !== other);
	  }
	  return false;
	}
	
	module.exports = isIterateeCall;


/***/ },
/* 195 */
/***/ function(module, exports) {

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * Creates a function that invokes `func` with the `this` binding of the
	 * created function and arguments from `start` and beyond provided as an array.
	 *
	 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).
	 *
	 * @static
	 * @memberOf _
	 * @category Function
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var say = _.restParam(function(what, names) {
	 *   return what + ' ' + _.initial(names).join(', ') +
	 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	 * });
	 *
	 * say('hello', 'fred', 'barney', 'pebbles');
	 * // => 'hello fred, barney, & pebbles'
	 */
	function restParam(func, start) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        rest = Array(length);
	
	    while (++index < length) {
	      rest[index] = args[start + index];
	    }
	    switch (start) {
	      case 0: return func.call(this, rest);
	      case 1: return func.call(this, args[0], rest);
	      case 2: return func.call(this, args[0], args[1], rest);
	    }
	    var otherArgs = Array(start + 1);
	    index = -1;
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = rest;
	    return func.apply(this, otherArgs);
	  };
	}
	
	module.exports = restParam;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(179);
	
	/** `Object#toString` result references. */
	var stringTag = '[object String]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
	}
	
	module.exports = isString;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(178);
	
	/** `Object#toString` result references. */
	var regexpTag = '[object RegExp]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `RegExp` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isRegExp(/abc/);
	 * // => true
	 *
	 * _.isRegExp('/abc/');
	 * // => false
	 */
	function isRegExp(value) {
	  return isObject(value) && objToString.call(value) == regexpTag;
	}
	
	module.exports = isRegExp;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(179);
	
	/** `Object#toString` result references. */
	var dateTag = '[object Date]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `Date` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isDate(new Date);
	 * // => true
	 *
	 * _.isDate('Mon April 23 2012');
	 * // => false
	 */
	function isDate(value) {
	  return isObjectLike(value) && objToString.call(value) == dateTag;
	}
	
	module.exports = isDate;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(179);
	
	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a boolean primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isBoolean(false);
	 * // => true
	 *
	 * _.isBoolean(null);
	 * // => false
	 */
	function isBoolean(value) {
	  return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
	}
	
	module.exports = isBoolean;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(179);
	
	/** `Object#toString` result references. */
	var numberTag = '[object Number]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `Number` primitive or object.
	 *
	 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	 * as numbers, use the `_.isFinite` method.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isNumber(8.4);
	 * // => true
	 *
	 * _.isNumber(NaN);
	 * // => true
	 *
	 * _.isNumber('8.4');
	 * // => false
	 */
	function isNumber(value) {
	  return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
	}
	
	module.exports = isNumber;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(202),
	    createFind = __webpack_require__(208);
	
	/**
	 * Iterates over elements of `collection`, returning the first element
	 * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	 * invoked with three arguments: (value, index|key, collection).
	 *
	 * If a property name is provided for `predicate` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `predicate` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * @static
	 * @memberOf _
	 * @alias detect
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to search.
	 * @param {Function|Object|string} [predicate=_.identity] The function invoked
	 *  per iteration.
	 * @param {*} [thisArg] The `this` binding of `predicate`.
	 * @returns {*} Returns the matched element, else `undefined`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'age': 36, 'active': true },
	 *   { 'user': 'fred',    'age': 40, 'active': false },
	 *   { 'user': 'pebbles', 'age': 1,  'active': true }
	 * ];
	 *
	 * _.result(_.find(users, function(chr) {
	 *   return chr.age < 40;
	 * }), 'user');
	 * // => 'barney'
	 *
	 * // using the `_.matches` callback shorthand
	 * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
	 * // => 'pebbles'
	 *
	 * // using the `_.matchesProperty` callback shorthand
	 * _.result(_.find(users, 'active', false), 'user');
	 * // => 'fred'
	 *
	 * // using the `_.property` callback shorthand
	 * _.result(_.find(users, 'active'), 'user');
	 * // => 'barney'
	 */
	var find = createFind(baseEach);
	
	module.exports = find;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(203),
	    createBaseEach = __webpack_require__(207);
	
	/**
	 * The base implementation of `_.forEach` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object|string} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);
	
	module.exports = baseEach;


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(204),
	    keys = __webpack_require__(174);
	
	/**
	 * The base implementation of `_.forOwn` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return baseFor(object, iteratee, keys);
	}
	
	module.exports = baseForOwn;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(205);
	
	/**
	 * The base implementation of `baseForIn` and `baseForOwn` which iterates
	 * over `object` properties returned by `keysFunc` invoking `iteratee` for
	 * each property. Iteratee functions may exit iteration early by explicitly
	 * returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	module.exports = baseFor;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var toObject = __webpack_require__(206);
	
	/**
	 * Creates a base function for `_.forIn` or `_.forInRight`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var iterable = toObject(object),
	        props = keysFunc(object),
	        length = props.length,
	        index = fromRight ? length : -1;
	
	    while ((fromRight ? index-- : ++index < length)) {
	      var key = props[index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	module.exports = createBaseFor;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(178);
	
	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}
	
	module.exports = toObject;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var getLength = __webpack_require__(181),
	    isLength = __webpack_require__(183),
	    toObject = __webpack_require__(206);
	
	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    var length = collection ? getLength(collection) : 0;
	    if (!isLength(length)) {
	      return eachFunc(collection, iteratee);
	    }
	    var index = fromRight ? length : -1,
	        iterable = toObject(collection);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}
	
	module.exports = createBaseEach;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var baseCallback = __webpack_require__(209),
	    baseFind = __webpack_require__(231),
	    baseFindIndex = __webpack_require__(232),
	    isArray = __webpack_require__(186);
	
	/**
	 * Creates a `_.find` or `_.findLast` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new find function.
	 */
	function createFind(eachFunc, fromRight) {
	  return function(collection, predicate, thisArg) {
	    predicate = baseCallback(predicate, thisArg, 3);
	    if (isArray(collection)) {
	      var index = baseFindIndex(collection, predicate, fromRight);
	      return index > -1 ? collection[index] : undefined;
	    }
	    return baseFind(collection, predicate, eachFunc);
	  };
	}
	
	module.exports = createFind;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(210),
	    baseMatchesProperty = __webpack_require__(222),
	    bindCallback = __webpack_require__(192),
	    identity = __webpack_require__(193),
	    property = __webpack_require__(229);
	
	/**
	 * The base implementation of `_.callback` which supports specifying the
	 * number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {*} [func=_.identity] The value to convert to a callback.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function baseCallback(func, thisArg, argCount) {
	  var type = typeof func;
	  if (type == 'function') {
	    return thisArg === undefined
	      ? func
	      : bindCallback(func, thisArg, argCount);
	  }
	  if (func == null) {
	    return identity;
	  }
	  if (type == 'object') {
	    return baseMatches(func);
	  }
	  return thisArg === undefined
	    ? property(func)
	    : baseMatchesProperty(func, thisArg);
	}
	
	module.exports = baseCallback;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(211),
	    getMatchData = __webpack_require__(219),
	    toObject = __webpack_require__(206);
	
	/**
	 * The base implementation of `_.matches` which does not clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    var key = matchData[0][0],
	        value = matchData[0][1];
	
	    return function(object) {
	      if (object == null) {
	        return false;
	      }
	      return object[key] === value && (value !== undefined || (key in toObject(object)));
	    };
	  }
	  return function(object) {
	    return baseIsMatch(object, matchData);
	  };
	}
	
	module.exports = baseMatches;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(212),
	    toObject = __webpack_require__(206);
	
	/**
	 * The base implementation of `_.isMatch` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Array} matchData The propery names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;
	
	  if (object == null) {
	    return !length;
	  }
	  object = toObject(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];
	
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	
	module.exports = baseIsMatch;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(213),
	    isObject = __webpack_require__(178),
	    isObjectLike = __webpack_require__(179);
	
	/**
	 * The base implementation of `_.isEqual` without support for `this` binding
	 * `customizer` functions.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	}
	
	module.exports = baseIsEqual;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var equalArrays = __webpack_require__(214),
	    equalByTag = __webpack_require__(216),
	    equalObjects = __webpack_require__(217),
	    isArray = __webpack_require__(186),
	    isTypedArray = __webpack_require__(218);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;
	
	  if (!objIsArr) {
	    objTag = objToString.call(object);
	    if (objTag == argsTag) {
	      objTag = objectTag;
	    } else if (objTag != objectTag) {
	      objIsArr = isTypedArray(object);
	    }
	  }
	  if (!othIsArr) {
	    othTag = objToString.call(other);
	    if (othTag == argsTag) {
	      othTag = objectTag;
	    } else if (othTag != objectTag) {
	      othIsArr = isTypedArray(other);
	    }
	  }
	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;
	
	  if (isSameTag && !(objIsArr || objIsObj)) {
	    return equalByTag(object, other, objTag);
	  }
	  if (!isLoose) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	    if (objIsWrapped || othIsWrapped) {
	      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  // For more information on detecting circular references see https://es5.github.io/#JO.
	  stackA || (stackA = []);
	  stackB || (stackB = []);
	
	  var length = stackA.length;
	  while (length--) {
	    if (stackA[length] == object) {
	      return stackB[length] == other;
	    }
	  }
	  // Add `object` and `other` to the stack of traversed objects.
	  stackA.push(object);
	  stackB.push(other);
	
	  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
	
	  stackA.pop();
	  stackB.pop();
	
	  return result;
	}
	
	module.exports = baseIsEqualDeep;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var arraySome = __webpack_require__(215);
	
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing arrays.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var index = -1,
	      arrLength = array.length,
	      othLength = other.length;
	
	  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	    return false;
	  }
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index],
	        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
	
	    if (result !== undefined) {
	      if (result) {
	        continue;
	      }
	      return false;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (isLoose) {
	      if (!arraySome(other, function(othValue) {
	            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	          })) {
	        return false;
	      }
	    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	      return false;
	    }
	  }
	  return true;
	}
	
	module.exports = equalArrays;


/***/ },
/* 215 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array.length;
	
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	module.exports = arraySome;


/***/ },
/* 216 */
/***/ function(module, exports) {

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    stringTag = '[object String]';
	
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag) {
	  switch (tag) {
	    case boolTag:
	    case dateTag:
	      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	      return +object == +other;
	
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	
	    case numberTag:
	      // Treat `NaN` vs. `NaN` as equal.
	      return (object != +object)
	        ? other != +other
	        : object == +other;
	
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings primitives and string
	      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	      return object == (other + '');
	  }
	  return false;
	}
	
	module.exports = equalByTag;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(174);
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;
	
	  if (objLength != othLength && !isLoose) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  var skipCtor = isLoose;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key],
	        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;
	
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	      return false;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (!skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;
	
	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      return false;
	    }
	  }
	  return true;
	}
	
	module.exports = equalObjects;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var isLength = __webpack_require__(183),
	    isObjectLike = __webpack_require__(179);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	function isTypedArray(value) {
	  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
	}
	
	module.exports = isTypedArray;


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(220),
	    pairs = __webpack_require__(221);
	
	/**
	 * Gets the propery names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = pairs(object),
	      length = result.length;
	
	  while (length--) {
	    result[length][2] = isStrictComparable(result[length][1]);
	  }
	  return result;
	}
	
	module.exports = getMatchData;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(178);
	
	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}
	
	module.exports = isStrictComparable;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(174),
	    toObject = __webpack_require__(206);
	
	/**
	 * Creates a two dimensional array of the key-value pairs for `object`,
	 * e.g. `[[key1, value1], [key2, value2]]`.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the new array of key-value pairs.
	 * @example
	 *
	 * _.pairs({ 'barney': 36, 'fred': 40 });
	 * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	 */
	function pairs(object) {
	  object = toObject(object);
	
	  var index = -1,
	      props = keys(object),
	      length = props.length,
	      result = Array(length);
	
	  while (++index < length) {
	    var key = props[index];
	    result[index] = [key, object[key]];
	  }
	  return result;
	}
	
	module.exports = pairs;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(223),
	    baseIsEqual = __webpack_require__(212),
	    baseSlice = __webpack_require__(224),
	    isArray = __webpack_require__(186),
	    isKey = __webpack_require__(225),
	    isStrictComparable = __webpack_require__(220),
	    last = __webpack_require__(226),
	    toObject = __webpack_require__(206),
	    toPath = __webpack_require__(227);
	
	/**
	 * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to compare.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  var isArr = isArray(path),
	      isCommon = isKey(path) && isStrictComparable(srcValue),
	      pathKey = (path + '');
	
	  path = toPath(path);
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    var key = pathKey;
	    object = toObject(object);
	    if ((isArr || !isCommon) && !(key in object)) {
	      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	      if (object == null) {
	        return false;
	      }
	      key = last(path);
	      object = toObject(object);
	    }
	    return object[key] === srcValue
	      ? (srcValue !== undefined || (key in object))
	      : baseIsEqual(srcValue, object[key], undefined, true);
	  };
	}
	
	module.exports = baseMatchesProperty;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	var toObject = __webpack_require__(206);
	
	/**
	 * The base implementation of `get` without support for string paths
	 * and default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path of the property to get.
	 * @param {string} [pathKey] The key representation of path.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path, pathKey) {
	  if (object == null) {
	    return;
	  }
	  if (pathKey !== undefined && pathKey in toObject(object)) {
	    path = [pathKey];
	  }
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[path[index++]];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	module.exports = baseGet;


/***/ },
/* 224 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;
	
	  start = start == null ? 0 : (+start || 0);
	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = (end === undefined || end > length) ? length : (+end || 0);
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;
	
	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}
	
	module.exports = baseSlice;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(186),
	    toObject = __webpack_require__(206);
	
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;
	
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  var type = typeof value;
	  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	    return true;
	  }
	  if (isArray(value)) {
	    return false;
	  }
	  var result = !reIsDeepProp.test(value);
	  return result || (object != null && value in toObject(object));
	}
	
	module.exports = isKey;


/***/ },
/* 226 */
/***/ function(module, exports) {

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array ? array.length : 0;
	  return length ? array[length - 1] : undefined;
	}
	
	module.exports = last;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(228),
	    isArray = __webpack_require__(186);
	
	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/**
	 * Converts `value` to property path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Array} Returns the property path array.
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return value;
	  }
	  var result = [];
	  baseToString(value).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	}
	
	module.exports = toPath;


/***/ },
/* 228 */
/***/ function(module, exports) {

	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` or `undefined` values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  return value == null ? '' : (value + '');
	}
	
	module.exports = baseToString;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(182),
	    basePropertyDeep = __webpack_require__(230),
	    isKey = __webpack_require__(225);
	
	/**
	 * Creates a function that returns the property value at `path` on a
	 * given object.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': { 'c': 2 } } },
	 *   { 'a': { 'b': { 'c': 1 } } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b.c'));
	 * // => [2, 1]
	 *
	 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	}
	
	module.exports = property;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(223),
	    toPath = __webpack_require__(227);
	
	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function basePropertyDeep(path) {
	  var pathKey = (path + '');
	  path = toPath(path);
	  return function(object) {
	    return baseGet(object, path, pathKey);
	  };
	}
	
	module.exports = basePropertyDeep;


/***/ },
/* 231 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
	 * without support for callback shorthands and `this` binding, which iterates
	 * over `collection` using the provided `eachFunc`.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to search.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {Function} eachFunc The function to iterate over `collection`.
	 * @param {boolean} [retKey] Specify returning the key of the found element
	 *  instead of the element itself.
	 * @returns {*} Returns the found element or its key, else `undefined`.
	 */
	function baseFind(collection, predicate, eachFunc, retKey) {
	  var result;
	  eachFunc(collection, function(value, key, collection) {
	    if (predicate(value, key, collection)) {
	      result = retKey ? key : value;
	      return false;
	    }
	  });
	  return result;
	}
	
	module.exports = baseFind;


/***/ },
/* 232 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for callback shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromRight) {
	  var length = array.length,
	      index = fromRight ? length : -1;
	
	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	module.exports = baseFindIndex;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(234);


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	var baseCallback = __webpack_require__(209),
	    baseUniq = __webpack_require__(235),
	    isIterateeCall = __webpack_require__(194),
	    sortedUniq = __webpack_require__(242);
	
	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurence of each element
	 * is kept. Providing `true` for `isSorted` performs a faster search algorithm
	 * for sorted arrays. If an iteratee function is provided it's invoked for
	 * each element in the array to generate the criterion by which uniqueness
	 * is computed. The `iteratee` is bound to `thisArg` and invoked with three
	 * arguments: (value, index, array).
	 *
	 * If a property name is provided for `iteratee` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `iteratee` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * @static
	 * @memberOf _
	 * @alias unique
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {boolean} [isSorted] Specify the array is sorted.
	 * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array} Returns the new duplicate-value-free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 *
	 * // using `isSorted`
	 * _.uniq([1, 1, 2], true);
	 * // => [1, 2]
	 *
	 * // using an iteratee function
	 * _.uniq([1, 2.5, 1.5, 2], function(n) {
	 *   return this.floor(n);
	 * }, Math);
	 * // => [1, 2.5]
	 *
	 * // using the `_.property` callback shorthand
	 * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	 * // => [{ 'x': 1 }, { 'x': 2 }]
	 */
	function uniq(array, isSorted, iteratee, thisArg) {
	  var length = array ? array.length : 0;
	  if (!length) {
	    return [];
	  }
	  if (isSorted != null && typeof isSorted != 'boolean') {
	    thisArg = iteratee;
	    iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
	    isSorted = false;
	  }
	  iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);
	  return (isSorted)
	    ? sortedUniq(array, iteratee)
	    : baseUniq(array, iteratee);
	}
	
	module.exports = uniq;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(236),
	    cacheIndexOf = __webpack_require__(238),
	    createCache = __webpack_require__(239);
	
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	
	/**
	 * The base implementation of `_.uniq` without support for callback shorthands
	 * and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The function invoked per iteration.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee) {
	  var index = -1,
	      indexOf = baseIndexOf,
	      length = array.length,
	      isCommon = true,
	      isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
	      seen = isLarge ? createCache() : null,
	      result = [];
	
	  if (seen) {
	    indexOf = cacheIndexOf;
	    isCommon = false;
	  } else {
	    isLarge = false;
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value, index, array) : value;
	
	    if (isCommon && value === value) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (indexOf(seen, computed, 0) < 0) {
	      if (iteratee || isLarge) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}
	
	module.exports = baseUniq;


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	var indexOfNaN = __webpack_require__(237);
	
	/**
	 * The base implementation of `_.indexOf` without support for binary searches.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  if (value !== value) {
	    return indexOfNaN(array, fromIndex);
	  }
	  var index = fromIndex - 1,
	      length = array.length;
	
	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	module.exports = baseIndexOf;


/***/ },
/* 237 */
/***/ function(module, exports) {

	/**
	 * Gets the index at which the first occurrence of `NaN` is found in `array`.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	 */
	function indexOfNaN(array, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 0 : -1);
	
	  while ((fromRight ? index-- : ++index < length)) {
	    var other = array[index];
	    if (other !== other) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	module.exports = indexOfNaN;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(178);
	
	/**
	 * Checks if `value` is in `cache` mimicking the return signature of
	 * `_.indexOf` by returning `0` if the value is found, else `-1`.
	 *
	 * @private
	 * @param {Object} cache The cache to search.
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `0` if `value` is found, else `-1`.
	 */
	function cacheIndexOf(cache, value) {
	  var data = cache.data,
	      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
	
	  return result ? 0 : -1;
	}
	
	module.exports = cacheIndexOf;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var SetCache = __webpack_require__(240),
	    getNative = __webpack_require__(175);
	
	/** Native method references. */
	var Set = getNative(global, 'Set');
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeCreate = getNative(Object, 'create');
	
	/**
	 * Creates a `Set` cache object to optimize linear searches of large arrays.
	 *
	 * @private
	 * @param {Array} [values] The values to cache.
	 * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	 */
	function createCache(values) {
	  return (nativeCreate && Set) ? new SetCache(values) : null;
	}
	
	module.exports = createCache;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var cachePush = __webpack_require__(241),
	    getNative = __webpack_require__(175);
	
	/** Native method references. */
	var Set = getNative(global, 'Set');
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeCreate = getNative(Object, 'create');
	
	/**
	 *
	 * Creates a cache object to store unique values.
	 *
	 * @private
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var length = values ? values.length : 0;
	
	  this.data = { 'hash': nativeCreate(null), 'set': new Set };
	  while (length--) {
	    this.push(values[length]);
	  }
	}
	
	// Add functions to the `Set` cache.
	SetCache.prototype.push = cachePush;
	
	module.exports = SetCache;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(178);
	
	/**
	 * Adds `value` to the cache.
	 *
	 * @private
	 * @name push
	 * @memberOf SetCache
	 * @param {*} value The value to cache.
	 */
	function cachePush(value) {
	  var data = this.data;
	  if (typeof value == 'string' || isObject(value)) {
	    data.set.add(value);
	  } else {
	    data.hash[value] = true;
	  }
	}
	
	module.exports = cachePush;


/***/ },
/* 242 */
/***/ function(module, exports) {

	/**
	 * An implementation of `_.uniq` optimized for sorted arrays without support
	 * for callback shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The function invoked per iteration.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function sortedUniq(array, iteratee) {
	  var seen,
	      index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];
	
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value, index, array) : value;
	
	    if (!index || seen !== computed) {
	      seen = computed;
	      result[++resIndex] = value;
	    }
	  }
	  return result;
	}
	
	module.exports = sortedUniq;


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(244);


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	var arrayEach = __webpack_require__(245),
	    baseEach = __webpack_require__(202),
	    createForEach = __webpack_require__(246);
	
	/**
	 * Iterates over elements of `collection` invoking `iteratee` for each element.
	 * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	 * (value, index|key, collection). Iteratee functions may exit iteration early
	 * by explicitly returning `false`.
	 *
	 * **Note:** As with other "Collections" methods, objects with a "length" property
	 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	 * may be used for object iteration.
	 *
	 * @static
	 * @memberOf _
	 * @alias each
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array|Object|string} Returns `collection`.
	 * @example
	 *
	 * _([1, 2]).forEach(function(n) {
	 *   console.log(n);
	 * }).value();
	 * // => logs each value from left to right and returns the array
	 *
	 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
	 *   console.log(n, key);
	 * });
	 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	 */
	var forEach = createForEach(arrayEach, baseEach);
	
	module.exports = forEach;


/***/ },
/* 245 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.forEach` for arrays without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array.length;
	
	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}
	
	module.exports = arrayEach;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	var bindCallback = __webpack_require__(192),
	    isArray = __webpack_require__(186);
	
	/**
	 * Creates a function for `_.forEach` or `_.forEachRight`.
	 *
	 * @private
	 * @param {Function} arrayFunc The function to iterate over an array.
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @returns {Function} Returns the new each function.
	 */
	function createForEach(arrayFunc, eachFunc) {
	  return function(collection, iteratee, thisArg) {
	    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	      ? arrayFunc(collection, iteratee)
	      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
	  };
	}
	
	module.exports = createForEach;


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	var baseValues = __webpack_require__(248),
	    keys = __webpack_require__(174);
	
	/**
	 * Creates an array of the own enumerable property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return baseValues(object, keys(object));
	}
	
	module.exports = values;


/***/ },
/* 248 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  var index = -1,
	      length = props.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = object[props[index]];
	  }
	  return result;
	}
	
	module.exports = baseValues;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _tutils = __webpack_require__(170);
	
	var _decorator = __webpack_require__(167);
	
	var _decorator2 = _interopRequireDefault(_decorator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Add a function to the lifecycle. By Default its componentWillMount;
	 * it has 2 optional parameters
	 *
	 * componentWillMount
	 *
	 * Your function will get invoked before, the down streams component.
	 *
	 * This allows for nice names, and methods that can be invoked without worry
	 * of subclasses being called.
	 *
	 *  @lifecycle("componentWillMount")
	 *  yourFunc(){
	 *
	 *  }
	 */
	/**
	 * @param stage [strgin=componentWillMount] - The lifecycle method to partake in .
	 * @param before [boolean=true] - Run yours before the original or if false after.
	 * */
	function lifecycle() {
	    var stage = arguments.length <= 0 || arguments[0] === undefined ? "componentWillMount" : arguments[0];
	    var before = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    before = before == null ? true : before;
	    return before ? lifecycle$config$before : lifecycle$config$after;
	
	    function lifecycle$config$before(Target, name, descriptor) {
	        Target[stage] = (0, _tutils.applyFuncs)(descriptor.value, Target[stage]);
	    }
	
	    function lifecycle$config$after(Target, name, descriptor) {
	        Target[stage] = (0, _tutils.applyFuncs)(Target[stage], descriptor.value);
	    }
	}
	
	exports.default = (0, _decorator2.default)(lifecycle);

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _loaderFactory = __webpack_require__(251);
	
	var _loaderFactory2 = _interopRequireDefault(_loaderFactory);
	
	var _templates = __webpack_require__(260);
	
	var _templates2 = _interopRequireDefault(_templates);
	
	var _types = __webpack_require__(300);
	
	var _types2 = _interopRequireDefault(_types);
	
	var _processors = __webpack_require__(327);
	
	var _processors2 = _interopRequireDefault(_processors);
	
	var _validators = __webpack_require__(331);
	
	var _validators2 = _interopRequireDefault(_validators);
	
	var _styles = __webpack_require__(332);
	
	var _styles2 = _interopRequireDefault(_styles);
	
	var _transition = __webpack_require__(359);
	
	var _transition2 = _interopRequireDefault(_transition);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var loader = (0, _loaderFactory2.default)();
	
	loader.addTemplate(_templates2.default);
	loader.addProcessor(_processors2.default);
	loader.addType(Object.keys(_types2.default).reduce(function (ret, key) {
	    if (/^(index|.*Mixin)$/.test(key)) {
	        return ret;
	    }
	    ret[key] = _types2.default[key];
	    return ret;
	}, {}));
	loader.addStyle(_styles2.default);
	loader.addValidator(_validators2.default);
	loader.addTransition(_transition2.default.transitions);
	
	exports.default = loader;

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = loaderFactory;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var concat = Function.apply.bind(Array.prototype.concat, []);
	
	function loaderFactory() {
	    var loaders = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	
	    var types = { load: load, list: list, add: add },
	        api = {
	        addLoader: function addLoader(loader) {
	            if ((0, _tutils.isArray)(loader)) {
	                return loader.map(function (v) {
	                    return this.addLoader(v);
	                }, this);
	            }
	            Object.keys(loader).forEach(function (key) {
	                if (!(key in this)) {
	                    var parts = /^(load|list)(.*)/.exec(key);
	                    if (parts && parts.length > 2 && parts[1] in types) {
	                        this[key] = types[parts[1]](parts[2]);
	                    } else {
	                        console.log('do not understand ' + key);
	                    }
	                }
	            }, this);
	
	            loaders.unshift(loader);
	            return loader;
	        },
	        removeLoader: function removeLoader(loader) {
	            var idx = loaders.indexOf(loader);
	            if (0 > idx) {
	                return;
	            }
	            var ret = loaders.splice(idx, 1)[0];
	            if (ret && ret && ret.removeLoader) {
	                ret.removeLoader();
	            }
	            return ret;
	        },
	        clearLoaders: function clearLoaders() {
	            var ret = loaders.concat();
	            loaders.length = 0;
	            return ret;
	        }
	    };
	
	    function list(method) {
	        var type = 'list' + method + 's';
	        return function loader$list() {
	            return concat(loaders.filter(function (v) {
	                return typeof v[type] === 'function';
	            }).map(function (v) {
	                return v[type]();
	            }));
	        };
	    }
	
	    function load(method) {
	        method = 'load' + method;
	        return function load$load(load) {
	            var i = 0,
	                l = loaders.length,
	                ret = null,
	                scope;
	            for (; i < l; i++) {
	                var ret = loaders[i][method] && loaders[i][method].apply(this, arguments);
	                if (ret != null) {
	                    return ret;
	                }
	            }
	        };
	    }
	
	    function add(type) {
	        var listKey = 'list' + type + 's',
	            loadKey = 'load' + type,
	            lcType = type.toLowerCase();
	        return function loader$add(key, value) {
	            var map,
	                _api = {};
	            if ((0, _tutils.isString)(key)) {
	                map = {};
	                map[key] = value;
	            } else {
	                map = key;
	            }
	            _api[listKey] = function () {
	                return Object.keys(map).map(function (name) {
	                    var ret = { name: name };
	                    ret[lcType] = map[name];
	                    return ret;
	                });
	            };
	            _api[loadKey] = function (name) {
	                return map[name];
	            };
	            api.addLoader(_api);
	            return _api;
	        };
	    }
	    function loaderType(name) {
	        var addF = arguments.length <= 1 || arguments[1] === undefined ? add : arguments[1];
	        var loadF = arguments.length <= 2 || arguments[2] === undefined ? load : arguments[2];
	        var listF = arguments.length <= 3 || arguments[3] === undefined ? list : arguments[3];
	
	        if (addF) {
	            this['add' + name] = addF(name);
	        }
	        if (loadF) {
	            this['load' + name] = loadF(name);
	        }
	        if (listF) {
	            this['list' + name + 's'] = listF(name);
	        }
	        return this;
	    }
	    ['Operator', 'Template', 'Processor', 'Type', 'Schema', 'Validator', 'Style', 'Transition'].forEach(function (v) {
	        return loaderType.call(api, v);
	    });
	    return api;
	}

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _extend = __webpack_require__(171);
	
	var _extend2 = _interopRequireDefault(_extend);
	
	var _find = __webpack_require__(201);
	
	var _find2 = _interopRequireDefault(_find);
	
	var _map = __webpack_require__(253);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _index = __webpack_require__(256);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//we'll re-export these for convenience in the babel6 world.
	var string = _react.PropTypes.string;
	var bool = _react.PropTypes.bool;
	var number = _react.PropTypes.number;
	var object = _react.PropTypes.object;
	var func = _react.PropTypes.func;
	var any = _react.PropTypes.any;
	var node = _react.PropTypes.node;
	var shape = _react.PropTypes.shape;
	var arrayOf = _react.PropTypes.arrayOf;
	var instanceOf = _react.PropTypes.instanceOf;
	var oneOf = _react.PropTypes.oneOf;
	var oneOfType = _react.PropTypes.oneOfType;
	
	
	function customPropType(type, name) {
	    function customPropType$return() {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return type.apply(api, args);
	    }
	
	    customPropType$return.isRequired = function customPropType$return$isRequired() {
	        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            args[_key2] = arguments[_key2];
	        }
	
	        return type.isRequired.apply(type, args);
	    };
	    if (name) customPropType$return.propTypeName = name;
	
	    return customPropType$return;
	}
	
	function propTypeToName(propType) {
	    var keys = Object.keys(api),
	        l = keys.length;
	    for (var i = 0; i < l; i++) {
	        var key = keys[i],
	            f = api[key];
	        if (f.isRequired === propType) {
	            return '*' + key;
	        }
	        if (f === propType) {
	            return key;
	        }
	    }
	}
	
	function propTypesToNames(props) {
	    var ret = {};
	    (0, _map2.default)(props, function (v, k) {
	        ret[k] = propTypeToName(v);
	    });
	    return ret;
	}
	
	var conditional = oneOfType([string, shape({
	    operator: oneOfType([string, func])
	})]);
	
	var domType = customPropType(node, 'domType');
	
	var fields = customPropType(arrayOf(string), 'fields');
	
	var title = customPropType(oneOfType([string, bool]), 'title');
	
	var injector = _index.PropTypes.injector;
	
	var blurValidate = customPropType(func, 'blurValidate');
	
	var changeValidate = customPropType(func, 'changeValidate');
	
	var validate = customPropType(func, 'validate');
	
	var value = customPropType(any, 'value');
	
	var message = customPropType(any, 'message');
	
	var error = customPropType(any, 'error');
	
	var errors = customPropType(any, 'errors');
	
	var promise = shape({ then: func });
	
	var id = customPropType(string, 'id');
	
	var htmlFor = customPropType(id, 'htmlFor');
	
	var fieldAttrs = customPropType(object, 'fieldAttrs');
	
	var cssClass = customPropType(string, 'cssClass');
	
	var style = customPropType(object, 'style');
	
	var typeClass = customPropType(cssClass, 'typeClass');
	
	var templateClass = customPropType(cssClass, 'templateClass');
	
	var injectedClass = customPropType(any, "injectedClass");
	
	var event = customPropType(func, 'event');
	
	var validator = customPropType(func, 'validator');
	
	var path = customPropType(string, 'path');
	
	var placeholder = customPropType(string, 'placeholder');
	
	var arrayString = oneOfType([string, arrayOf(string)]);
	
	var listener = customPropType(any, 'listener');
	
	/**
	 * A valueEvent does not expect target.value
	 */
	var valueEvent = customPropType(func, 'valueEvent');
	
	/**
	 * A targetEvent expects the first arg to have target.value
	 */
	var targetEvent = customPropType(func, 'targetEvent');
	
	/**
	 * A errorEvent expects the first arg to be an error.
	 */
	var errorEvent = customPropType(func, 'errorEvent');
	
	/**
	 * Signify this is a blur Event Listener.
	 */
	var blurEvent = customPropType(func, 'blurEvent');
	
	/**
	 * Signify this is a onValid Event listener.
	 */
	var validEvent = customPropType(func, 'validEvent');
	
	var dataType = customPropType(string, 'dataType');
	
	var type = oneOfType([string, func]);
	
	var typeDescription = oneOfType([string, shape({
	    type: string.isRequired
	})]);
	
	var _transitionTypes = oneOf(['appear', 'enter', 'leave']);
	var transition = oneOfType([_react.PropTypes.string, shape({
	    transition: _react.PropTypes.string,
	    on: _transitionTypes
	})]);
	
	/**
	 * Signify this property can take an expression.  This
	 * allows properties to be tied to the valueManager.  So
	 * it will evaluate the property against the valueManager.
	 *
	 * It will add a listener for each of the corresponding
	 * matching strings.
	 *
	 */
	var expression = customPropType(string, 'expression');
	
	var loader = shape({
	    loadTemplate: func,
	    loadType: func,
	    loadSchema: func,
	    loadValidator: func,
	    loadProcessor: func,
	    loadOperator: func
	});
	
	var valueManager = shape({
	    addListener: func,
	
	    addErrorListener: func,
	
	    addValidateListener: func,
	
	    addSubmitListener: func,
	
	    addStateListener: func
	});
	
	var contentShape = {
	    className: cssClass,
	    type: string,
	    children: bool
	};
	
	var pContentShape = shape(contentShape);
	
	var contentType = oneOfType([pContentShape, string, bool, func, number, arrayOf(oneOfType([string, string, bool, number, func, pContentShape]))]);
	
	contentShape.content = contentType;
	
	var content = contentType;
	
	var template = oneOfType([string, bool, shape({
	    template: oneOfType([string, bool, func]),
	    content: content,
	    className: cssClass
	}), func]);
	
	var button = oneOfType([string, shape({
	    onClick: event,
	    buttonClass: cssClass,
	    action: string,
	    name: string,
	    value: string,
	    iconClass: cssClass
	})]);
	
	var buttons = oneOfType([button, arrayOf(button), shape({
	    buttonsClass: cssClass,
	    onButtonClick: event,
	    buttons: oneOfType(arrayString, arrayOf(button)),
	    buttonTemplate: template,
	    buttonsTemplate: template
	})]);
	
	var fieldset = shape({
	    fields: arrayString,
	    legend: content,
	    className: cssClass,
	    buttons: buttons,
	    template: template
	});
	
	var literal = oneOfType([string, bool, number, instanceOf(Date)]);
	
	var options = oneOfType([arrayString, arrayOf(shape({
	    label: string,
	    val: literal
	}))]);
	
	var optionsGroup = oneOfType([arrayString, arrayOf(shape({
	    options: options,
	    group: string,
	    label: string,
	    labelHTML: string,
	    val: literal
	}))]);
	
	var schema = oneOfType([string, shape({
	    fields: arrayString,
	    fieldsets: oneOfType([arrayString, fieldset, arrayOf(fieldset)]),
	    schema: object
	})]);
	
	var array = arrayOf(any);
	
	var validators = oneOfType([arrayString, arrayOf(validators)]);
	
	var operator = oneOfType([string, func, instanceOf(RegExp)]);
	
	var events = {
	    onValidate: event,
	    onFocus: event,
	    onBlur: event,
	    onValid: event,
	    onChange: oneOfType(targetEvent, valueEvent)
	};
	
	var field = customPropType(any, 'field');
	
	var mixin = {
	    events: events,
	    field: (0, _extend2.default)({
	        title: content,
	        help: content,
	        name: string,
	        placeholder: placeholder,
	        dataType: dataType,
	        editorClass: cssClass,
	        fieldClass: cssClass,
	        field: {}
	    }, events)
	};
	
	var contextTypes = Object.freeze({
	    valueManager: valueManager,
	    loader: loader,
	    injector: injector
	});
	
	var processor = oneOfType([string, shape({
	    fetch: func,
	    value: func,
	    format: func
	})]);
	
	var injectClass = oneOfType([func, shape({
	    injectClass: func,
	    propTypes: object,
	    injectProps: object,
	    strict: bool
	})]);
	
	var api = {
	    conditional: conditional,
	    transition: transition,
	    injectClass: injectClass,
	    blurValidate: blurValidate,
	    changeValidate: changeValidate,
	    promise: promise,
	    id: id,
	    injectedClass: injectedClass,
	    fieldAttrs: fieldAttrs,
	    cssClass: cssClass,
	    error: error,
	    errors: errors,
	    event: event,
	    htmlFor: htmlFor,
	    validator: validator,
	    path: path,
	    placeholder: placeholder,
	    arrayString: arrayString,
	    listener: listener,
	    valueEvent: valueEvent,
	    targetEvent: targetEvent,
	    blurEvent: blurEvent,
	    validEvent: validEvent,
	    dataType: dataType,
	    type: type,
	    domType: domType,
	    typeDescription: typeDescription,
	    expression: expression,
	    loader: loader,
	    valueManager: valueManager,
	    content: content,
	    template: template,
	    button: button,
	    buttons: buttons,
	    fields: fields,
	    fieldset: fieldset,
	    literal: literal,
	    options: options,
	    optionsGroup: optionsGroup,
	    schema: schema,
	    value: value,
	    validate: validate,
	    validators: validators,
	    operator: operator,
	    events: events,
	    field: field,
	    mixin: mixin,
	    style: style,
	    contextTypes: contextTypes,
	    processor: processor,
	    typeClass: typeClass,
	    string: string, bool: bool, number: number, object: object, func: func, any: any, node: node, shape: shape, arrayOf: arrayOf, instanceOf: instanceOf, oneOfType: oneOfType, oneOf: oneOf
	
	};
	
	exports.default = {
	    propTypesToNames: propTypesToNames,
	    propTypeToName: propTypeToName,
	    customPropType: customPropType,
	    conditional: conditional,
	    blurValidate: blurValidate,
	    changeValidate: changeValidate,
	    promise: promise,
	    id: id,
	    fieldAttrs: fieldAttrs,
	    cssClass: cssClass,
	    error: error,
	    errors: errors,
	    event: event,
	    valueEvent: valueEvent,
	    targetEvent: targetEvent,
	    errorEvent: errorEvent,
	    validator: validator,
	    path: path,
	    placeholder: placeholder,
	    arrayString: arrayString,
	    listener: listener,
	    blurEvent: blurEvent,
	    validEvent: validEvent,
	    dataType: dataType,
	    domType: domType,
	    type: type,
	    typeDescription: typeDescription,
	    expression: expression,
	    loader: loader,
	    valueManager: valueManager,
	    content: content,
	    template: template,
	    button: button,
	    buttons: buttons,
	    fields: fields,
	    fieldset: fieldset,
	    injectedClass: injectedClass,
	    injector: injector,
	    literal: literal,
	    htmlFor: htmlFor,
	    options: options,
	    optionsGroup: optionsGroup,
	    schema: schema,
	    validators: validators,
	    operator: operator,
	    events: events,
	    field: field,
	    mixin: mixin,
	    contextTypes: contextTypes,
	    processor: processor,
	    value: value,
	    validate: validate,
	    array: array,
	    title: title,
	    injectClass: injectClass,
	    typeClass: typeClass,
	    style: style,
	    transition: transition,
	    string: string, bool: bool, number: number, object: object, func: func, any: any, node: node, shape: shape, arrayOf: arrayOf, instanceOf: instanceOf, oneOfType: oneOfType, oneOf: oneOf
	};

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(254),
	    baseCallback = __webpack_require__(209),
	    baseMap = __webpack_require__(255),
	    isArray = __webpack_require__(186);
	
	/**
	 * Creates an array of values by running each element in `collection` through
	 * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * If a property name is provided for `iteratee` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `iteratee` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
	 * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
	 * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
	 * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
	 * `sum`, `uniq`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @alias collect
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	 *  per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function timesThree(n) {
	 *   return n * 3;
	 * }
	 *
	 * _.map([1, 2], timesThree);
	 * // => [3, 6]
	 *
	 * _.map({ 'a': 1, 'b': 2 }, timesThree);
	 * // => [3, 6] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // using the `_.property` callback shorthand
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee, thisArg) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  iteratee = baseCallback(iteratee, thisArg, 3);
	  return func(collection, iteratee);
	}
	
	module.exports = map;


/***/ },
/* 254 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	
	module.exports = arrayMap;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(202),
	    isArrayLike = __webpack_require__(180);
	
	/**
	 * The base implementation of `_.map` without support for callback shorthands
	 * and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];
	
	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}
	
	module.exports = baseMap;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.PropTypes = exports.injectorFactory = exports.util = undefined;
	
	var _react = __webpack_require__(1);
	
	var _injector = __webpack_require__(257);
	
	var _injector2 = _interopRequireDefault(_injector);
	
	var _injectorFactory = __webpack_require__(258);
	
	var _injectorFactory2 = _interopRequireDefault(_injectorFactory);
	
	var _util = __webpack_require__(259);
	
	var _util2 = _interopRequireDefault(_util);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var util = exports.util = _util2.default;
	
	var injectorFactory = exports.injectorFactory = _injectorFactory2.default;
	
	var PropTypes = exports.PropTypes = {
	    injector: _react.PropTypes.shape({
	        inject: _react.PropTypes.func.isRequired
	    })
	};
	
	exports.default = _injector2.default;

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _injectorFactory = __webpack_require__(258);
	
	var _injectorFactory2 = _interopRequireDefault(_injectorFactory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _injectorFactory2.default)();

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.BaseInjectComponent = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = injector;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _util = __webpack_require__(259);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BaseInjectComponent = exports.BaseInjectComponent = function (_Component) {
	    _inherits(BaseInjectComponent, _Component);
	
	    function BaseInjectComponent() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, BaseInjectComponent);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(BaseInjectComponent)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.state = {}, _this.injected = {}, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    return BaseInjectComponent;
	}(_react.Component);
	
	function hasAnyKeys(obj) {
	    if (!obj) return false;
	    return Object.keys(obj).length > 0;
	}
	function isIterable(obj) {
	    // checks for null and undefined
	    if (obj == null) {
	        return false;
	    }
	    return obj[Symbol.iterator] !== void 0;
	}
	function injector() {
	    var resolvers = arguments.length <= 0 || arguments[0] === undefined ? new Map() : arguments[0];
	
	    if (!(resolvers instanceof Map)) {
	        if (isIterable(resolvers)) {
	            resolvers = new Map(resolvers);
	        } else {
	            throw new Error('resolvers must be iterable');
	        }
	    }
	    function resolveProp(propType) {
	        if (propType == null) return propType;
	        var resolved = resolvers.get(propType);
	        return resolved;
	    }
	
	    var Injector = {
	        resolver: function resolver(propType, resolve) {
	            if (propType == null || resolve == null) {
	                throw new Error('must define both a propType and a resolver');
	            }
	            if (propType.isRequired) {
	                resolvers.set(propType.isRequired, resolve);
	            }
	            resolvers.set(propType, resolve);
	        },
	
	        unmount: _util.unmount,
	        listener: _util.listener,
	        property: _util.prop,
	        extendPrototype: _util.extendPrototype,
	        resolveKey: _util.resolveKey,
	        createWrapperClass: function createWrapperClass(Clazz, copyPropTypeKeys, strictProps) {
	            var defaultProps = Clazz.defaultProps;
	            var propTypes = Clazz.propTypes;
	
	            var render = strictProps !== false ? function render() {
	                var props = (0, _util.onlyKeys)(copyPropTypeKeys, this.injected, this.props);
	                return _react2.default.createElement(
	                    Clazz,
	                    _extends({}, props, this.injected),
	                    this.props.children
	                );
	            } : function loosePropsRender() {
	                return _react2.default.createElement(
	                    Clazz,
	                    _extends({}, this.props, this.injected),
	                    this.props.children
	                );
	            };
	            var name = Clazz.name;
	            var displayName = Clazz.displayName;
	            //BaseInjectComponent is just a marker class.
	
	            var InjectedClass = function (_BaseInjectComponent) {
	                _inherits(InjectedClass, _BaseInjectComponent);
	
	                function InjectedClass() {
	                    var _Object$getPrototypeO2;
	
	                    var _temp2, _this2, _ret2;
	
	                    _classCallCheck(this, InjectedClass);
	
	                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	                        args[_key2] = arguments[_key2];
	                    }
	
	                    return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, (_Object$getPrototypeO2 = Object.getPrototypeOf(InjectedClass)).call.apply(_Object$getPrototypeO2, [this].concat(args))), _this2), _this2.render = render, _temp2), _possibleConstructorReturn(_this2, _ret2);
	                }
	
	                return InjectedClass;
	            }(BaseInjectComponent);
	
	            InjectedClass.defaultProps = {};
	            InjectedClass.contextTypes = {};
	            InjectedClass.displayName = (displayName || name) + '$Wrapper';
	
	            return InjectedClass;
	        },
	
	        /**
	         * Injects properties based propType.
	         *
	         * @param Clazz - class to wrap.
	         * @param extraPropTypes - extra prop types if the component does not have the propType than it will use this propType, otherwise the
	         * the class'es default propType will be used.
	         * @param extraProps - If a component has a defaultProp than it will use that otherwise it will use this.
	         * @param strictProps - If false than it will pass all props on to component, otherwise it just passes defined props.
	         * @returns {*}
	         */
	
	        inject: function inject(Clazz, extraPropTypes, extraProps, strictProps) {
	            var _this3 = this;
	
	            var hasExtra = hasAnyKeys(extraPropTypes) || hasAnyKeys(extraProps);
	
	            var defaultProps = Clazz.defaultProps;
	            var propTypes = Clazz.propTypes;
	
	
	            var propTypeKeys = (0, _util.uniqueKeys)(propTypes, defaultProps, extraPropTypes);
	
	            var _propTypeKeys = _toArray(propTypeKeys);
	
	            var copyPropTypeKeys = _propTypeKeys;
	
	
	            var start = hasExtra ? this.createWrapperClass(Clazz, copyPropTypeKeys, strictProps) : null;
	
	            var injected = propTypeKeys.reduce(function (injectedClass, key) {
	
	                var resolver = resolveProp((0, _util.keyIn)(key, propTypes, extraPropTypes));
	                //resolver is null, nothing to do just return.
	                if (resolver == null) {
	                    return injectedClass;
	                }
	                //injectedClass may be null if it didn't have any extras.  So we will create if it is.
	                injectedClass = injectedClass || _this3.createWrapperClass(Clazz, copyPropTypeKeys, strictProps);
	
	                //Add default props to this thing.
	                injectedClass.defaultProps[key] = (0, _util.keyIn)(key, defaultProps, extraProps);
	
	                //Resolver could return a different class.
	                var nextClass = resolver.call(Injector, injectedClass, key, propTypeKeys, Clazz);
	
	                //If a different class was null, return the original class.
	                return nextClass == null ? injectedClass : nextClass;
	            }, start);
	            return injected || Clazz;
	        }
	    };
	    return Injector;
	}

/***/ },
/* 259 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	function applyNice(f1, f2) {
	    if (f1 === f2 || !f2) return f1;
	    if (!f1) return f2;
	    return function applyNice$return() {
	        f1.call.apply(f1, [this].concat(Array.prototype.slice.call(arguments)));
	        f2.call.apply(f2, [this].concat(Array.prototype.slice.call(arguments)));
	    };
	}
	
	function extendPrototype(property, fn) {
	    this.prototype[property] = applyNice(fn, this.prototype[property]);
	    return this;
	}
	
	function execArg(v) {
	    v && v();
	}
	
	var push = Function.apply.bind(Array.prototype.push);
	
	function keyIn(key) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	    }
	
	    for (var i = 0; i < args.length; i++) {
	        if (args[i] == null) continue;
	        if (key in args[i]) return args[i][key];
	    }
	    return;
	}
	function onlyKeys(keys) {
	    var ret = {};
	    var length = keys.length;
	
	    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	    }
	
	    var argLength = args.length;
	    KEYS: for (var i = 0; i < length; i++) {
	        var key = keys[i];
	        ARGS: for (var j = 0; j < argLength; j++) {
	            var arg = args[j];
	            if (arg == null) continue ARGS;
	            if (key in arg) {
	                ret[key] = arg[key];
	                continue KEYS;
	            }
	        }
	    }
	
	    return ret;
	}
	function uniqueKeys() {
	    var keys = [];
	
	    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	    }
	
	    for (var i = 0, l = args.length; i < l; i++) {
	        if (args[i] == null) continue;
	        var k = Object.keys(args[i]),
	            jl = k.length;
	        for (var j = 0; j < jl; j++) {
	            if (keys.indexOf(k[j]) === -1) {
	                keys.push(k[j]);
	            }
	        }
	    }
	    return keys;
	}
	function resolveKey(path, key) {
	    if (!key) {
	        return path;
	    }
	    if (key[0] != '.') {
	        return key;
	    }
	    var parts = path ? path.split('.') : [];
	    key = key.substring(1);
	    while (key[0] === '.') {
	        key = key.substring(1);
	        parts.pop();
	    }
	    if (key) {
	        parts.push(key);
	    }
	    return parts.length === 0 ? null : parts.join('.');
	}
	function extend(name, fn) {
	    var fn2 = this.prototype[name];
	    this.prototype[name] = applyNice(fn, fn2);
	}
	function didMount() {
	    this.mounted = true;
	}
	
	function listener(key, fn) {
	    function listener$listen(props, context) {
	
	        if (!this._listeners) {
	            this._listeners = {};
	        } else if (this._listeners[key]) {
	            this._listeners[key]();
	        }
	        this._listeners[key] = fn.call(this, props[key], key, props, context);
	    }
	
	    extend.call(this, 'componentDidMount', didMount);
	
	    extend.call(this, 'componentWillMount', function listener$willMount() {
	        this.mounted = false;
	        listener$listen.call(this, this.props, this.context);
	    });
	
	    extend.call(this, 'componentWillReceiveProps', listener$listen);
	
	    unmount.call(this, function () {
	        this.mounted = false;
	        this._listeners && this._listeners[key] && this._listeners[key]();
	    });
	}
	function prop(key, fn) {
	    //this is class scope.
	    extend.call(this, 'componentWillMount', function util$prop$willMount() {
	        //this is instance scope.
	        this.injected[key] = fn.call(this, this.props[key], key, this.props, this.context);
	    });
	
	    extend.call(this, 'componentWillReceiveProps', function util$prop$receiveProps(props, context) {
	        if (props[key] !== this.props[key]) {
	            this.injected[key] = fn.call(this, props[key], key, props, context);
	        }
	    });
	
	    return this;
	}
	function extendStatic(name, value) {
	    this[name] = value;
	}
	function removeListeners(listeners) {
	    if (listeners) {
	        listeners.forEach(execArg);
	        listeners.length = 0;
	    }
	    return listeners;
	}
	function clearListeners() {
	    if (this.listeners) {
	        return removeListeners(this.listeners);
	    }
	}
	function unmount(fn) {
	    this.prototype.componentWillUnmount = applyNice(fn, this.prototype.componentWillUnmount);
	}
	
	exports.applyNice = applyNice;
	exports.listener = listener;
	exports.extend = extend;
	exports.prop = prop;
	exports.unmount = unmount;
	exports.extendStatic = extendStatic;
	exports.extendPrototype = extendPrototype;
	exports.onlyKeys = onlyKeys;
	exports.keyIn = keyIn;
	exports.uniqueKeys = uniqueKeys;
	exports.resolveKey = resolveKey;
	exports.execArg = execArg;
	exports.push = push;
	exports.removeListeners = removeListeners;
	exports.clearListeners = clearListeners;

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var context = __webpack_require__(261),
	    api = {}; //make sure you have your directory and regex test set correctly!
	context.keys().forEach(function (key) {
	    var k = key.replace(/^\.\/(.*)\.js(x)?$/, '$1');
	    api[k] = context(key).default;
	});
	module.exports = api;

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./AutocompleteItemTemplate.jsx": 262,
		"./ButtonTemplate.jsx": 263,
		"./ButtonsTemplate.jsx": 264,
		"./CheckboxTemplate.jsx": 265,
		"./CheckboxesGroupTemplate.jsx": 266,
		"./CheckboxesTemplate.jsx": 267,
		"./CollectionCreateTemplate.jsx": 268,
		"./ContentItemTemplate.jsx": 274,
		"./EditorTemplate.jsx": 276,
		"./FieldSetTemplate.jsx": 277,
		"./FormTemplate.jsx": 278,
		"./ListItemTemplate.jsx": 279,
		"./ModalTemplate.jsx": 280,
		"./ObjectTemplate.jsx": 292,
		"./RadioItemTemplate.jsx": 293,
		"./WizardProgressTemplate.jsx": 294,
		"./WizardTemplate.jsx": 295
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 261;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AutocompleteItemTemplate = (_temp = _class = function (_Component) {
	    _inherits(AutocompleteItemTemplate, _Component);
	
	    function AutocompleteItemTemplate() {
	        _classCallCheck(this, AutocompleteItemTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(AutocompleteItemTemplate).apply(this, arguments));
	    }
	
	    _createClass(AutocompleteItemTemplate, [{
	        key: 'handleClick',
	        value: function handleClick(e) {
	            e && e.preventDefault();
	            this.props.onSelect(this.props.data);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var data = _props.data;
	            var focus = _props.focus;
	            var itemClass = _props.itemClass;
	            var focusedClass = _props.focusedClass;
	            var value = _props.value;
	            var processor = _props.processor;
	
	            var __html = processor.format(data, value, true);
	            return __html == null ? null : _react2.default.createElement('li', { ref: 'item', className: itemClass + '  ' + (focus ? focusedClass : ''), onClick: this.handleClick.bind(this),
	                dangerouslySetInnerHTML: { __html: __html } });
	        }
	    }]);
	
	    return AutocompleteItemTemplate;
	}(_react.Component), _class.defaultProps = {
	    data: null,
	    value: null,
	    focus: false,
	    processor: null
	}, _class.propTypes = {
	    onSelect: _PropTypes2.default.event,
	    style: _PropTypes2.default.style
	}, _temp);
	exports.default = AutocompleteItemTemplate;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Button = (_temp2 = _class = function (_Component) {
	    _inherits(Button, _Component);
	
	    function Button() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Button);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Button)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.handleClick = function (e) {
	            var _this$props = _this.props;
	            var value = _this$props.value;
	            var action = _this$props.action;
	            var label = _this$props.label;
	
	            _this.props.onClick(e, value || action || label, _this);
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(Button, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var buttonClass = _props.buttonClass;
	            var className = _props.className;
	            var title = _props.title;
	            var iconClass = _props.iconClass;
	            var onClick = _props.onClick;
	            var label = _props.label;
	
	            var props = _objectWithoutProperties(_props, ['buttonClass', 'className', 'title', 'iconClass', 'onClick', 'label']);
	
	            return _react2.default.createElement(
	                'button',
	                _extends({ className: className || buttonClass }, props, { onClick: this.handleClick.bind(this) }),
	                iconClass ? _react2.default.createElement('i', { className: iconClass }) : null,
	                label
	            );
	        }
	    }]);
	
	    return Button;
	}(_react.Component), _class.defaultProps = {
	    action: 'Submit',
	    label: 'Submit',
	    buttonClass: 'btn',
	    iconClass: null,
	    disabled: false
	}, _class.propTypes = {
	    onClick: _react.PropTypes.func,
	    disabled: _react.PropTypes.bool,
	    title: _react.PropTypes.string,
	    buttonClass: _react.PropTypes.string,
	    iconClass: _react.PropTypes.string,
	    action: _react.PropTypes.string,
	    label: _react.PropTypes.string,
	    className: _react.PropTypes.string
	}, _temp2);
	exports.default = Button;

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _tutils = __webpack_require__(170);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ButtonsTemplate = (_temp = _class = function (_Component) {
	    _inherits(ButtonsTemplate, _Component);
	
	    function ButtonsTemplate() {
	        _classCallCheck(this, ButtonsTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(ButtonsTemplate).apply(this, arguments));
	    }
	
	    _createClass(ButtonsTemplate, [{
	        key: 'makeButtons',
	        value: function makeButtons(buttons) {
	            var _this2 = this;
	
	            var onClick = this.props.onButtonClick || this.props.onClick,
	                buttonTemplate = this.props.buttonTemplate;
	            return buttons.map(function (b) {
	                onClick = b.onClick || onClick;
	                var btn = (0, _tutils.isString)(b) ? {
	                    action: b,
	                    label: b,
	                    onClick: onClick
	                } : (0, _tutils.extend)({}, b, { onClick: onClick, template: buttonTemplate });
	                if (_this2.props.buttonClass) {
	                    btn.buttonClass = (btn.buttonClass || '') + ' ' + (_this2.props.buttonClass || '');
	                }
	                if (btn.primary) {
	                    btn.buttonClass = btn.buttonClass + ' ' + _this2.props.primaryClass;
	                }
	                return btn;
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var buttons = _props.buttons;
	            var buttonTemplate = _props.buttonTemplate;
	            var buttonsClass = _props.buttonsClass;
	            var buttonContainerClass = _props.buttonContainerClass;
	
	            if (buttons.buttons) {
	                buttonsClass = buttons.buttonsClass || buttonsClass;
	                buttons = buttons.buttons;
	            }
	            var ButtonTemplate = buttonTemplate;
	            return _react2.default.createElement(
	                'div',
	                { className: buttonContainerClass },
	                _react2.default.createElement(
	                    'div',
	                    { className: buttonsClass },
	                    this.makeButtons(buttons).map(function (b, i) {
	                        return _react2.default.createElement(ButtonTemplate, _extends({ key: "btn-" + i }, b));
	                    })
	                )
	            );
	        }
	    }]);
	
	    return ButtonsTemplate;
	}(_react.Component), _class.defaultProps = {
	    buttonTemplate: 'ButtonTemplate',
	    buttons: [{
	        action: 'submit',
	        label: 'Submit',
	        template: 'Button',
	        primary: true
	    }],
	    onButtonClick: function onButtonClick(event, action, btn, value) {}
	}, _class.propTypes = {
	    buttonTemplate: _PropTypes2.default.template,
	    buttonClass: _PropTypes2.default.cssClass,
	    style: _PropTypes2.default.style
	}, _temp);
	exports.default = ButtonsTemplate;

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CheckboxTemplate = (_temp = _class = function (_Component) {
	    _inherits(CheckboxTemplate, _Component);
	
	    function CheckboxTemplate() {
	        _classCallCheck(this, CheckboxTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(CheckboxTemplate).apply(this, arguments));
	    }
	
	    _createClass(CheckboxTemplate, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var children = _props.children;
	            var checkboxClass = _props.checkboxClass;
	            var checked = _props.checked;
	            var checkedClass = _props.checkedClass;
	            var uncheckedClass = _props.uncheckedClass;
	            var label = _props.label;
	
	            return _react2.default.createElement(
	                'div',
	                { className: checkboxClass + ' ' + (checked ? checkedClass : uncheckedClass) + ' ' },
	                _react2.default.createElement(
	                    'label',
	                    null,
	                    children,
	                    label
	                )
	            );
	        }
	    }]);
	
	    return CheckboxTemplate;
	}(_react.Component), _class.propTypes = {
	    label: _PropTypes2.default.node,
	    style: _PropTypes2.default.style,
	    checked: _PropTypes2.default.bool
	}, _class.defaultProps = {
	    style: "CheckboxTemplate",
	    checkedClass: "",
	    uncheckedClass: "",
	    checkboxClass: ""
	}, _temp);
	exports.default = CheckboxTemplate;

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CheckboxesGroupTemplate = (_temp = _class = function (_Component) {
	    _inherits(CheckboxesGroupTemplate, _Component);
	
	    function CheckboxesGroupTemplate() {
	        _classCallCheck(this, CheckboxesGroupTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(CheckboxesGroupTemplate).apply(this, arguments));
	    }
	
	    _createClass(CheckboxesGroupTemplate, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'fieldset',
	                { className: this.props.groupClass },
	                _react2.default.createElement(
	                    'legend',
	                    null,
	                    this.props.legend
	                ),
	                this.props.children
	            );
	        }
	    }]);
	
	    return CheckboxesGroupTemplate;
	}(_react.Component), _class.propTypes = {
	    legend: _PropTypes2.default.node,
	    style: _PropTypes2.default.style
	}, _temp);
	exports.default = CheckboxesGroupTemplate;

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(265);

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Content = __webpack_require__(269);
	
	var _Content2 = _interopRequireDefault(_Content);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CollectionCreateTemplate = (_temp = _class = function (_Component) {
	    _inherits(CollectionCreateTemplate, _Component);
	
	    function CollectionCreateTemplate() {
	        _classCallCheck(this, CollectionCreateTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(CollectionCreateTemplate).apply(this, arguments));
	    }
	
	    _createClass(CollectionCreateTemplate, [{
	        key: 'renderInline',
	        value: function renderInline() {
	            return _react2.default.createElement(
	                'div',
	                { className: this.props.inlineClass },
	                this.props.children
	            );
	        }
	    }, {
	        key: 'renderPanel',
	        value: function renderPanel() {
	            var _props = this.props;
	            var title = _props.title;
	            var panelClass = _props.panelClass;
	            var editText = _props.editText;
	            var createText = _props.createText;
	            var panelTitleClass = _props.panelTitleClass;
	            var panelHeadingClass = _props.panelHeadingClass;
	            var panelBodyClass = _props.panelBodyClass;
	            var groupClass = _props.groupClass;
	            var create = _props.create;
	
	            if (title === false) {
	                title = '';
	            } else if (title == null) {
	                title = create ? createText : editText;
	            } else if (typeof title === 'string') {
	                title = {
	                    type: 'h3',
	                    content: create ? createText + ' ' + title : editText + ' ' + title,
	                    className: panelTitleClass
	                };
	            }
	            return _react2.default.createElement(
	                'div',
	                { className: panelClass },
	                _react2.default.createElement(_Content2.default, { content: title, type: 'div', className: panelHeadingClass }),
	                _react2.default.createElement(
	                    'div',
	                    { className: this.props.panelBodyClass },
	                    _react2.default.createElement(
	                        'div',
	                        { className: this.props.groupClass },
	                        this.props.children
	                    )
	                )
	            );
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return this.props.inline ? this.renderInline() : this.renderPanel();
	        }
	    }]);
	
	    return CollectionCreateTemplate;
	}(_react.Component), _class.propTypes = {
	    title: _PropTypes2.default.node,
	    style: _PropTypes2.default.style,
	    inline: _PropTypes2.default.bool,
	    create: _PropTypes2.default.bool,
	    editText: _PropTypes2.default.string,
	    createText: _PropTypes2.default.string
	}, _class.defaultProps = {
	    create: true,
	    editText: 'Edit ',
	    createText: 'Create '
	}, _temp);
	exports.default = CollectionCreateTemplate;
	;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _map = __webpack_require__(253);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _tutils = __webpack_require__(170);
	
	var _defaults = __webpack_require__(270);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _ContentWrapper = __webpack_require__(273);
	
	var _ContentWrapper2 = _interopRequireDefault(_ContentWrapper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Content = (_temp = _class = function (_Component) {
	    _inherits(Content, _Component);
	
	    function Content() {
	        _classCallCheck(this, Content);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Content).apply(this, arguments));
	    }
	
	    _createClass(Content, [{
	        key: 'renderChildren',
	
	
	        //Expose for react-native subschema.
	        value: function renderChildren(props, children) {
	            if (children && props.children) {
	                return children;
	            }
	        }
	    }, {
	        key: 'renderChild',
	        value: function renderChild(content, props, prefix, children) {
	            var _this2 = this;
	
	            if (content == null || content === false) {
	                return null;
	            }
	            if ((0, _tutils.isString)(content)) {
	                var ContentWrapper = this.props.contentWrapper;
	                return _react2.default.createElement(ContentWrapper, _extends({}, props, { key: 'content-' + prefix, content: content }));
	            }
	            var Content = this.props.injected;
	
	            if ((0, _tutils.isArray)(content)) {
	                //TODO - check if we need to flatten this.
	                return content.map(function (c, key) {
	                    //prevent children from being wrapped.
	                    if (c.children === true) {
	                        return children;
	                    }
	                    if (c.content) {
	                        if (typeof c.content !== 'string') {
	                            return _react2.default.createElement(
	                                Content,
	                                _extends({}, c, { key: 'content-' + prefix + '-' + key }),
	                                _this2.renderChildren(c, children)
	                            );
	                        } else {
	                            return _this2.renderChild(c.content, props, prefix + '-s-' + key, children);
	                        }
	                    }
	                    return _this2.renderChild(c, {}, prefix + '-a-' + key, children);
	                });
	            }
	
	            if (content.content) {
	                return _react2.default.createElement(
	                    Content,
	                    _extends({}, content.content, { key: 'content-content' }),
	                    this.renderChildren(content.content, children)
	                );
	            }
	
	            return _react2.default.createElement(
	                Content,
	                _extends({}, props, { key: 'content-ft-' + prefix, content: content }),
	                this.renderChildren(content, children)
	            );
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var type = _props.type;
	            var content = _props.content;
	            var children = _props.children;
	            var field = _props.field;
	            var context = _props.context;
	
	            var props = _objectWithoutProperties(_props, ['type', 'content', 'children', 'field', 'context']);
	
	            if (field && field.content) {
	                content = field.content;
	            }
	            if (content == null || content === false) {
	                return null;
	            }
	            /**
	             * a field could be described like
	             *
	             * {
	             *   type:'Content',
	             *   content:'Hello {name}'
	             * }
	             * and content type would be Content so... there.
	             */
	            if (type === Content.displayName) {
	                //The real type when type == 'Content' not a great solution and will break if someone renames content.
	                // if they do they will need to change the display name;
	                props.type = type = Content.defaultProps.type;
	            }
	            /**
	             * This is the case
	             * {
	             *   type:'Content',
	             *   content:{
	             *     className:'stuff',
	             *     type:'div',
	             *     content:[{//array or object of content}]
	             *   }
	             * }
	             *
	             */
	            if (content.content) {
	                var _content = content;
	
	                var rest = _objectWithoutProperties(_content, []);
	
	                delete rest.content;
	                children = this.renderChild(content.content, rest, 'dom', children);
	            } else
	
	                /**
	                 * Case where content is a string.
	                 * {
	                 *   content:'hello world'.
	                 * }
	                 */
	                if ((0, _tutils.isString)(content)) {
	                    props.type = type;
	                    return this.renderChild(content, props, 'str-c');
	
	                    /**
	                     * Case where content is an array maybe mixed.
	                     *
	                     * {
	                     *   content:[{
	                     *      content:'What',
	                     *      className:'stuff'
	                     *   },
	                     *   'Hello',
	                     *   ['more', {content:'stuff'}],
	                     *   {
	                     *    children:true
	                     *   }
	                      *  ]
	                     * }
	                     *
	                     */
	                } else if ((0, _tutils.isArray)(content)) {
	                        props.type = type;
	                        children = this.renderChild(content, props, 'arr', children);
	                    } else if (content.content === false) {
	                        props = (0, _defaults2.default)(content, props);
	                        type = props.type;
	                    }
	
	            if (Content.Types[type]) {
	                return _react2.default.createElement(type, props, children);
	            }
	
	            var Ctype = this.context.loader.loadType(type);
	
	            return _react2.default.createElement(
	                Ctype,
	                props,
	                children
	            );
	        }
	    }]);
	
	    return Content;
	}(_react.Component), _class.isContainer = true, _class.contextTypes = {
	    loader: _PropTypes2.default.loader
	}, _class.propTypes = {
	    content: _PropTypes2.default.any,
	    contentWrapper: _PropTypes2.default.injectClass,
	    value: _PropTypes2.default.any,
	    onChange: _PropTypes2.default.any,
	    title: _PropTypes2.default.any,
	    className: _PropTypes2.default.cssClass,
	    id: _PropTypes2.default.any,
	    name: _PropTypes2.default.any,
	    injected: _PropTypes2.default.injectedClass
	
	}, _class.defaultProps = {
	    type: 'span',
	    content: '',
	    contentWrapper: _ContentWrapper2.default
	}, _class.Types = _react.DOM || {}, _temp);
	exports.default = Content;

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var assign = __webpack_require__(172),
	    assignDefaults = __webpack_require__(271),
	    createDefaults = __webpack_require__(272);
	
	/**
	 * Assigns own enumerable properties of source object(s) to the destination
	 * object for all destination properties that resolve to `undefined`. Once a
	 * property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	 * // => { 'user': 'barney', 'age': 36 }
	 */
	var defaults = createDefaults(assign, assignDefaults);
	
	module.exports = defaults;


/***/ },
/* 271 */
/***/ function(module, exports) {

	/**
	 * Used by `_.defaults` to customize its `_.assign` use.
	 *
	 * @private
	 * @param {*} objectValue The destination object property value.
	 * @param {*} sourceValue The source object property value.
	 * @returns {*} Returns the value to assign to the destination object.
	 */
	function assignDefaults(objectValue, sourceValue) {
	  return objectValue === undefined ? sourceValue : objectValue;
	}
	
	module.exports = assignDefaults;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	var restParam = __webpack_require__(195);
	
	/**
	 * Creates a `_.defaults` or `_.defaultsDeep` function.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @param {Function} customizer The function to customize assigned values.
	 * @returns {Function} Returns the new defaults function.
	 */
	function createDefaults(assigner, customizer) {
	  return restParam(function(args) {
	    var object = args[0];
	    if (object == null) {
	      return object;
	    }
	    args.push(customizer);
	    return assigner.apply(undefined, args);
	  });
	}
	
	module.exports = createDefaults;


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ContentWrapper = (_temp = _class = function (_Component) {
	    _inherits(ContentWrapper, _Component);
	
	    function ContentWrapper() {
	        _classCallCheck(this, ContentWrapper);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(ContentWrapper).apply(this, arguments));
	    }
	
	    _createClass(ContentWrapper, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var type = _props.type;
	            var content = _props.content;
	            var children = _props.children;
	            var context = _props.context;
	
	            var props = _objectWithoutProperties(_props, ['type', 'content', 'children', 'context']);
	
	            props.dangerouslySetInnerHTML = { __html: content };
	            var Type = type;
	            if (typeof type == 'string') {
	                return _react2.default.createElement(type, props);
	            }
	            return _react2.default.createElement(Type, props);
	        }
	    }]);
	
	    return ContentWrapper;
	}(_react.Component), _class.defaultProps = {
	    type: 'span',
	    content: ''
	}, _class.propTypes = {
	    content: _PropTypes2.default.expression,
	    type: _PropTypes2.default.domType,
	    value: _PropTypes2.default.any,
	    onChange: _PropTypes2.default.any,
	    title: _PropTypes2.default.any,
	    className: _PropTypes2.default.cssClass,
	    id: _PropTypes2.default.any,
	    name: _PropTypes2.default.any
	}, _temp);
	exports.default = ContentWrapper;

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _get2 = __webpack_require__(275);
	
	var _get3 = _interopRequireDefault(_get2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ContentItemTemplate = (_temp2 = _class = function (_Component) {
	    _inherits(ContentItemTemplate, _Component);
	
	    function ContentItemTemplate() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, ContentItemTemplate);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(ContentItemTemplate)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.handleClick = function (e) {
	            e && e.preventDefault();
	            _this.props.onClick(_this.props.pos, _this.props.value.value, _this.props.pid);
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	    //(pos, val, pid)
	
	
	    _createClass(ContentItemTemplate, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var value = _props.value;
	            var showKey = _props.showKey;
	            var children = _props.children;
	            var itemInnerClass = _props.itemInnerClass;
	            var itemClass = _props.itemClass;
	            var clickableClass = _props.clickableClass;
	            var labelKey = _props.labelKey;
	
	            var key = value.key || '';
	            var _label = labelKey ? (0, _get3.default)(value.value, labelKey, '') : value.value;
	            return _react2.default.createElement(
	                'span',
	                { onClick: this.handleClick, className: this.props.onClick ? clickableClass : '' },
	                showKey ? _react2.default.createElement(
	                    'h4',
	                    { className: itemClass },
	                    key
	                ) : null,
	                _react2.default.createElement(
	                    'span',
	                    { className: itemInnerClass },
	                    _label
	                ),
	                children
	            );
	        }
	    }]);
	
	    return ContentItemTemplate;
	}(_react.Component), _class.propTypes = {
	    onClick: _PropTypes2.default.func,
	    pid: _PropTypes2.default.any,
	    pos: _PropTypes2.default.number,
	    showKey: _PropTypes2.default.bool,
	    labelKey: _PropTypes2.default.string,
	    itemInnerClass: _PropTypes2.default.string,
	    clickableClass: _PropTypes2.default.string,
	    value: function value(props, propName, componentName) {
	        var value = props[propName];
	        var labelKey = props.labelKey;
	        if ('value' in props) {
	            if (labelKey) {
	                return _PropTypes2.default.node(props.value, labelKey, componentName);
	            } else return _PropTypes2.default.node(value, 'value', componentName);
	        }
	        if (props.showKey) {
	            return _PropTypes2.default.node(props, 'key', componentName);
	        }
	    }
	}, _class.defaultProps = {
	    clickableClass: 'clickable'
	}, _temp2);
	exports.default = ContentItemTemplate;

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(223),
	    toPath = __webpack_require__(227);
	
	/**
	 * Gets the property value at `path` of `object`. If the resolved value is
	 * `undefined` the `defaultValue` is used in its place.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, toPath(path), (path + ''));
	  return result === undefined ? defaultValue : result;
	}
	
	module.exports = get;


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _Content = __webpack_require__(269);
	
	var _Content2 = _interopRequireDefault(_Content);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var EditorTemplate = (_temp = _class = function (_Component) {
	    _inherits(EditorTemplate, _Component);
	
	    function EditorTemplate() {
	        _classCallCheck(this, EditorTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(EditorTemplate).apply(this, arguments));
	    }
	
	    _createClass(EditorTemplate, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var Content = _props.Content;
	            var name = _props.name;
	            var htmlFor = _props.htmlFor;
	            var title = _props.title;
	            var help = _props.help;
	            var labelClass = _props.labelClass;
	            var hasTitleClass = _props.hasTitleClass;
	            var noTitleClass = _props.noTitleClass;
	            var errorClass = _props.errorClass;
	            var helpClass = _props.helpClass;
	            var error = _props.error;
	            var hasErrorClass = _props.hasErrorClass;
	            var errorClassName = _props.errorClassName;
	            var message = _props.message;
	            var fieldClass = _props.fieldClass;
	            var children = _props.children;
	
	            if (hasErrorClass) {
	                errorClassName = hasErrorClass;
	            }
	            return _react2.default.createElement(
	                'div',
	                { className: fieldClass + " " + (error != null ? errorClassName || '' : '') },
	                _react2.default.createElement(Content, { content: title, type: 'label', className: labelClass, htmlFor: htmlFor }),
	                _react2.default.createElement(
	                    'div',
	                    { className: title ? hasTitleClass : noTitleClass },
	                    children,
	                    _react2.default.createElement(Content, { content: error || help, key: 'error-block', type: 'p', className: error ? errorClass : helpClass })
	                )
	            );
	        }
	    }]);
	
	    return EditorTemplate;
	}(_react.Component), _class.propTypes = {
	    error: _PropTypes2.default.error,
	    title: _PropTypes2.default.title,
	    name: _PropTypes2.default.string,
	    help: _PropTypes2.default.content,
	    style: _PropTypes2.default.style,
	    htmlFor: _PropTypes2.default.htmlFor,
	    Content: _PropTypes2.default.injectClass
	}, _class.defaultProps = {
	    Content: _Content2.default
	}, _temp);
	exports.default = EditorTemplate;
	;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var FieldSetTemplate = (_temp = _class = function (_Component) {
	    _inherits(FieldSetTemplate, _Component);
	
	    function FieldSetTemplate() {
	        _classCallCheck(this, FieldSetTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(FieldSetTemplate).apply(this, arguments));
	    }
	
	    _createClass(FieldSetTemplate, [{
	        key: 'render',
	        value: function render() {
	            var _props$field$props = _extends({}, this.props.field, this.props);
	
	            var legend = _props$field$props.legend;
	            var content = _props$field$props.content;
	            var legendClass = _props$field$props.legendClass;
	            var buttons = _props$field$props.buttons;
	            var className = _props$field$props.className;
	
	            var rest = _objectWithoutProperties(_props$field$props, ['legend', 'content', 'legendClass', 'buttons', 'className']);
	
	            return legend ? _react2.default.createElement(
	                'fieldset',
	                { className: className },
	                _react2.default.createElement(
	                    'legend',
	                    { className: legendClass },
	                    legend
	                ),
	                content,
	                this.props.children,
	                buttons
	            ) : _react2.default.createElement(
	                'div',
	                { className: className },
	                content,
	                this.props.children,
	                buttons
	            );
	        }
	    }]);
	
	    return FieldSetTemplate;
	}(_react.Component), _class.propTypes = {
	    buttons: _PropTypes2.default.node,
	    legend: _PropTypes2.default.node,
	    className: _PropTypes2.default.cssClass,
	    field: _PropTypes2.default.any,
	    content: _PropTypes2.default.node
	}, _class.defaultProps = {
	    field: _tutils.FREEZE_OBJ
	}, _temp);
	exports.default = FieldSetTemplate;

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var FormTemplate = (_temp = _class = function (_Component) {
	    _inherits(FormTemplate, _Component);
	
	    function FormTemplate() {
	        _classCallCheck(this, FormTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(FormTemplate).apply(this, arguments));
	    }
	
	    _createClass(FormTemplate, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var children = _props.children;
	            var name = _props.name;
	            var fieldAttrs = _props.fieldAttrs;
	            var enctype = _props.enctype;
	            var formClass = _props.formClass;
	            var className = _props.className;
	            var action = _props.action;
	            var method = _props.method;
	            var onSubmit = _props.onSubmit;
	
	            var props = _objectWithoutProperties(_props, ['children', 'name', 'fieldAttrs', 'enctype', 'formClass', 'className', 'action', 'method', 'onSubmit']);
	
	            return _react2.default.createElement(
	                'form',
	                _extends({ name: name, action: action, enctype: enctype, method: method, onSubmit: onSubmit,
	                    className: className || formClass }, fieldAttrs),
	                children
	            );
	        }
	    }]);
	
	    return FormTemplate;
	}(_react.Component), _class.propTypes = {
	    style: _PropTypes2.default.style,
	    onSubmit: _PropTypes2.default.event,
	    accept: _PropTypes2.default.string,
	    acceptCharset: _PropTypes2.default.string,
	    action: _PropTypes2.default.string,
	    autocapitalize: _PropTypes2.default.oneOf(['on', 'off', 'words', 'sentences', 'charecters', 'none']),
	    autocomplete: _PropTypes2.default.oneOf(['on', 'off']),
	    enctype: _PropTypes2.default.oneOf(['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain']),
	    method: _PropTypes2.default.oneOf(['get', 'post']),
	    name: _PropTypes2.default.string,
	    novalidate: _PropTypes2.default.bool,
	    target: _PropTypes2.default.string,
	    fieldAttrs: _PropTypes2.default.any
	}, _class.defaultProps = {
	    className: ''
	}, _temp);
	exports.default = FormTemplate;

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _tutils = __webpack_require__(170);
	
	var _ButtonsTemplate = __webpack_require__(264);
	
	var _ButtonsTemplate2 = _interopRequireDefault(_ButtonsTemplate);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ListItemTemplate = (_temp2 = _class = function (_Component) {
	    _inherits(ListItemTemplate, _Component);
	
	    function ListItemTemplate() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, ListItemTemplate);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(ListItemTemplate)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.handleMoveUp = function (e) {
	            e.preventDefault();
	            _this.props.onMoveUp(_this.props.pos, _this.props.value, _this.props.pid);
	        }, _this.handleMoveDown = function (e) {
	            e.preventDefault();
	            _this.props.onMoveDown(_this.props.pos, _this.props.value, _this.props.pid);
	        }, _this.handleDelete = function (e) {
	            e.preventDefault();
	            _this.props.onDelete(_this.props.pos, _this.props.value, _this.props.pid);
	        }, _this.handleEdit = function (e) {
	            e.preventDefault();
	            var val = _this.props.value;
	
	            _this.props.onEdit(_this.props.pos, val.value, _this.props.pid);
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(ListItemTemplate, [{
	        key: 'buttons',
	        value: function buttons(pos, last, canReorder, canDelete) {
	            var buttons = [];
	            var buttonClass = this.props.buttonClass;
	            if (canReorder) {
	                if (pos > 0) {
	                    buttons.push({
	                        onClick: this.handleMoveUp,
	                        title: 'Move Up',
	                        action: 'up',
	                        label: '',
	                        iconClass: this.props.moveUpClass,
	                        buttonClass: buttonClass
	                    });
	                }
	                if (!last) {
	                    buttons.push({
	                        onClick: this.handleMoveDown,
	                        title: 'Move Down',
	                        action: 'down',
	                        iconClass: this.props.moveDownClass,
	                        buttonClass: buttonClass,
	                        label: ''
	                    });
	                }
	            }
	            if (canDelete) {
	                buttons.push({
	                    onClick: this.handleDelete,
	                    title: 'Delete',
	                    action: 'delete',
	                    iconClass: this.props.deleteClass,
	                    buttonClass: buttonClass,
	                    label: ''
	                });
	            }
	            return buttons;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var pos = _props.pos;
	            var Buttons = _props.Buttons;
	            var value = _props.value;
	            var errors = _props.errors;
	            var path = _props.path;
	            var ctrlButtonsClass = _props.ctrlButtonsClass;
	            var listGroupItemClass = _props.listGroupItemClass;
	            var helpClass = _props.helpClass;
	            var onValidate = _props.onValidate;
	            var type = _props.type;
	            var name = _props.name;
	            var hasErrorClass = _props.hasErrorClass;
	            var canReorder = _props.canReorder;
	            var canDelete = _props.canDelete;
	            var last = _props.last;
	            var onValueChange = _props.onValueChange;
	
	            var error = errors && errors[0] && errors[0].message;
	            return _react2.default.createElement(
	                'li',
	                { className: listGroupItemClass + ' ' + (error ? hasErrorClass : '') },
	                error ? _react2.default.createElement(
	                    'p',
	                    { ref: 'error', key: 'error', className: helpClass },
	                    error
	                ) : null,
	                _react2.default.createElement(Buttons, { key: 'buttons', buttons: this.buttons(pos, last, canReorder, canDelete), ref: 'buttons',
	                    buttonsClass: ctrlButtonsClass, buttonContainerClass: ' ' }),
	                this.props.children
	            );
	        }
	    }]);
	
	    return ListItemTemplate;
	}(_react.Component), _class.propTypes = {
	    style: _PropTypes2.default.style,
	    Buttons: _PropTypes2.default.injectClass
	}, _class.defaultProps = {
	    type: 'Text',
	    onMoveUp: _tutils.noop,
	    onMoveDown: _tutils.noop,
	    onDelete: _tutils.noop,
	    onValidate: _tutils.noop,
	    onValueChange: _tutils.noop,
	    onEdit: _tutils.noop,
	    canAdd: false,
	    canReorder: false,
	    canEdit: false,
	    canDelete: false,
	    last: false,
	    errors: null,
	    pos: 0,
	    style: "ListItemTemplate",
	    Buttons: _ButtonsTemplate2.default
	}, _temp2);
	exports.default = ListItemTemplate;

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ButtonsTemplate = __webpack_require__(264);
	
	var _ButtonsTemplate2 = _interopRequireDefault(_ButtonsTemplate);
	
	var _ValueManager = __webpack_require__(281);
	
	var _ValueManager2 = _interopRequireDefault(_ValueManager);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _NewChildContext = __webpack_require__(283);
	
	var _NewChildContext2 = _interopRequireDefault(_NewChildContext);
	
	var _cloneDeep = __webpack_require__(284);
	
	var _cloneDeep2 = _interopRequireDefault(_cloneDeep);
	
	var _RenderContent = __webpack_require__(291);
	
	var _RenderContent2 = _interopRequireDefault(_RenderContent);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ModalTemplate = (_temp = _class = function (_Component) {
	    _inherits(ModalTemplate, _Component);
	
	    _createClass(ModalTemplate, [{
	        key: 'handleCancel',
	        value: function handleCancel() {
	            this.props.onChange(this.value);
	            this.props.dismiss();
	        }
	    }]);
	
	    function ModalTemplate(props) {
	        var _Object$getPrototypeO;
	
	        _classCallCheck(this, ModalTemplate);
	
	        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            rest[_key - 1] = arguments[_key];
	        }
	
	        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(ModalTemplate)).call.apply(_Object$getPrototypeO, [this, props].concat(rest)));
	
	        _this.handleClose = function (e) {
	            e && e.preventDefault();
	            _this.props.dismiss();
	        };
	
	        _this.handleBtnClose = function (e, action) {
	            switch (action) {
	                case 'submit':
	                    {
	                        _this.props.dismiss();
	                        break;
	                    }
	                case 'close':
	                case 'cancel':
	                    _this.props.onChange(_this.value);
	                    _this.handleClose(e);
	                    break;
	            }
	        };
	
	        _this.value = (0, _cloneDeep2.default)(props.value);
	        return _this;
	    }
	
	    _createClass(ModalTemplate, [{
	        key: 'renderButtons',
	        value: function renderButtons(buttons) {
	            if (!buttons) {
	                return null;
	            }
	            var ButtonsTemplate = this.props.buttonsTemplate;
	            if (!buttons.buttons) {
	                buttons = {
	                    buttons: buttons
	                };
	            }
	            return _react2.default.createElement(ButtonsTemplate, _extends({ onButtonClick: this.handleBtnClose }, buttons));
	        }
	    }, {
	        key: 'renderFooter',
	        value: function renderFooter(buttons) {
	            if (!buttons) return null;
	            return _react2.default.createElement(
	                'div',
	                { className: this.props.footerClass },
	                this.renderButtons(buttons)
	            );
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var title = _props.title;
	            var buttons = _props.buttons;
	            var path = _props.path;
	            var value = _props.value;
	            var bodyClass = _props.bodyClass;
	            var headerClass = _props.headerClass;
	            var closeClass = _props.closeClass;
	            var contentClass = _props.contentClass;
	            var backdropClass = _props.backdropClass;
	            var dialogClass = _props.dialogClass;
	            var namespaceClass = _props.namespaceClass;
	            var overlayClass = _props.overlayClass;
	            var children = _props.children;
	
	            var rest = _objectWithoutProperties(_props, ['title', 'buttons', 'path', 'value', 'bodyClass', 'headerClass', 'closeClass', 'contentClass', 'backdropClass', 'dialogClass', 'namespaceClass', 'overlayClass', 'children']);
	
	            return _react2.default.createElement(
	                'div',
	                { className: namespaceClass + ' ' + overlayClass, style: { display: 'block' } },
	                _react2.default.createElement('div', { className: backdropClass }),
	                _react2.default.createElement(
	                    'div',
	                    { className: dialogClass, role: 'document', style: { zIndex: 2000 } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: contentClass },
	                        _react2.default.createElement(
	                            'div',
	                            { className: headerClass },
	                            _react2.default.createElement(
	                                'button',
	                                { onClick: this.handleClose, className: closeClass, name: this.props.dismiss,
	                                    value: value,
	                                    'aria-label': 'Close' },
	                                _react2.default.createElement(
	                                    'span',
	                                    { 'aria-hidden': 'true' },
	                                    ''
	                                )
	                            ),
	                            _react2.default.createElement(_RenderContent2.default, { type: 'h4', content: title })
	                        ),
	                        _react2.default.createElement(
	                            'div',
	                            { className: bodyClass },
	                            children
	                        ),
	                        this.renderFooter(buttons)
	                    )
	                )
	            );
	        }
	    }]);
	
	    return ModalTemplate;
	}(_react.Component), _class.propTypes = {
	    style: _PropTypes2.default.style,
	    title: _PropTypes2.default.content,
	    buttons: _PropTypes2.default.buttons,
	    path: _PropTypes2.default.path,
	    value: _PropTypes2.default.value,
	    onChange: _PropTypes2.default.valueEvent,
	    ModalTemplate: _PropTypes2.default.injectClass,
	    dismiss: _PropTypes2.default.valueEvent,
	    buttonsTemplate: _PropTypes2.default.template
	
	}, _class.defaultProps = {
	    buttonsTemplate: 'ButtonsTemplate',
	    onCancel: function onCancel() {},
	
	    buttons: {
	        buttonsClass: 'pull-right btn-group',
	        buttons: [{
	            label: "Cancel",
	            action: 'cancel',
	            className: 'btn'
	        }, {
	            label: "Save",
	            action: 'submit',
	            className: 'btn btn-primary'
	        }]
	    }
	}, _temp);
	exports.default = ModalTemplate;

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = ValueManager;
	
	var _tutils = __webpack_require__(170);
	
	var _eventable = __webpack_require__(282);
	
	var _eventable2 = _interopRequireDefault(_eventable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function reduceKeys(arr, v, b, c) {
	    if (canDescend(v)) {
	        (0, _tutils.push)(arr, Object.keys(v));
	    }
	    return arr;
	}
	function canDescend(obj) {
	    if (obj == null || (0, _tutils.isNumber)(obj) || (0, _tutils.isBoolean)(obj) || (0, _tutils.isString)(obj) || (0, _tutils.isDate)(obj) || (0, _tutils.isArray)(obj)) {
	        return false;
	    }
	    return true;
	}
	function copy(obj) {
	    return obj == null ? null : (0, _tutils.isArray)(obj) ? obj.slice(0) : (0, _tutils.extend)({}, obj);
	}
	
	function _keys() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	    }
	
	    return (0, _tutils.unique)(args.reduce(reduceKeys, []));
	}
	/**
	 * Value manager listens and changes values on the objects.
	 * It can be passed a property to any subschema type, or form.
	 *
	 * @param value
	 * @param errors
	 * @returns {ValueManager}
	 * @constructor
	 */
	function ValueManager(value, errors) {
	    if (!(this instanceof ValueManager)) {
	        return new ValueManager(value, errors);
	    }
	    this.listeners = [];
	    this.errorListeners = [];
	    this.validateListeners = [];
	    this.stateListeners = [];
	    this.setValue(value || {});
	    this.setErrors(errors);
	    this.oldValue = (0, _tutils.extend)({}, this.value);
	
	    var self = this;
	
	    /**
	     * Adds a value listener
	     * @param {String} [path] - Path to listen to, null or no value will listen to all changes.
	     * @param {ValueManagerListener} listener - The listener to execute.
	     * @param {Object} [scope] - The scope to execute the listener in.
	     * @param {boolean|Function}  init - true or a function will execute when the listener is added.
	     * */
	    this.addListener = (0, _eventable2.default)(this.listeners, function (prop) {
	        return self.path(prop, self.value);
	    }, function (prop) {
	        return self.path(prop, self.oldValue);
	    });
	    /**
	     * Adds an error  listener
	     * @param {String} [path] - Path to listen to, null or no value will listen to all changes.
	     * @param {ValueManagerListener} listener - The listener to execute.
	     * @param {Object} [scope] - The scope to execute the listener in.
	     * @param {boolean|Function}  init - true or a function will execute when the listener is added.
	     * */
	    this.addErrorListener = (0, _eventable2.default)(this.errorListeners, function (prop) {
	        return self.errorsFor(prop);
	    }, _tutils.noop);
	
	    /**
	     * Adds a validate  listener
	     * @param {String} [path] - Path to listen to, null or no value will listen to all changes.
	     * @param {ValueManagerListener} listener - The listener to execute.
	     * @param {Object} [scope] - The scope to execute the listener in.
	     * @param {boolean|Function}  init - true or a function will execute when the listener is added.
	     * */
	
	    this.addValidateListener = (0, _eventable2.default)(this.validateListeners, _tutils.noop, _tutils.noop);
	
	    this.submitListeners = [];
	    /**
	     * adds a submit listener.
	     * @param {String} [path] -  path to listen to.
	     * @param {Function} [ValueManagerListener] - the listener to look for.
	     * @param {Listener} [listener] - the listener returned from eventable();
	     */
	    this.addSubmitListener = (0, _eventable2.default)(this.submitListeners);
	
	    /**
	     * adds a submit listener.
	     * @param {String} [path] -  path to listen to.
	     * @param {Function} [ValueManagerListener] - the listener to look for.
	     * @param {Listener} [listener] - the listener returned from eventable();
	     */
	    this.addStateListener = (0, _eventable2.default)(this.stateListeners);
	}
	
	function remove(v) {
	    v && v.remove && v.remove();
	}
	var listenersTypes = ['listeners', 'errorListeners', 'validateListeners', 'stateListeners', 'submitListeners'];
	function _removeAll(v) {
	    var listeners = this[v];
	    if (listeners) {
	        listeners.forEach(remove);
	        listeners.length = 0;
	    }
	}
	ValueManager.prototype = {
	    removeListener: function removeListener() {
	        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            args[_key2] = arguments[_key2];
	        }
	
	        args.forEach(remove);
	    },
	
	    /**
	     * Removes all listeners, both error and value.
	     */
	    removeAll: function removeAll() {
	        listenersTypes.forEach(_removeAll, this);
	    },
	
	    /**
	     * When onSubmit is called this is fired
	     */
	    onSubmit: function onSubmit(e, value, errors, path) {
	        var parts = path && path.split('.') || [],
	            i = 0,
	            l = parts.length,
	            pp = null;
	        do {
	            if (this.submitListeners.some(function (v) {
	                if (v.path == null || v.path === pp) {
	                    return v.listener.call(v.scope, e, value, errors, path) === false;
	                }
	            }, this) === true) {
	                return false;
	            }
	            pp = (0, _tutils.path)(pp, parts[i]);
	        } while (i++ < l);
	        return true;
	    },
	
	    /**
	     * Triggers the value change on all listeneners.
	     */
	    onValueChange: function onValueChange(path, value, oldValue) {
	        var _this = this;
	
	        var parts = path && path.split('.') || [],
	            i = 0,
	            l = parts.length,
	            pp = null;
	        do {
	            if (this.listeners.some(function (v) {
	                if (v.path === pp) {
	                    return v.listener.call(v.scope, _this.path(pp, _this.value), _this.path(pp, _this.oldValue), path) === false;
	                }
	            }, this) === true) {
	                return false;
	            }
	            pp = (0, _tutils.path)(pp, parts[i]);
	        } while (i++ < l);
	        return true;
	    },
	
	    /**
	     * Returns the path of an object
	     * @param {String} - a dot deliminted string.
	     * @param {Object} [object] - defaults to the current value.
	     */
	    path: function path(p, obj) {
	        if (arguments.length < 2) {
	            obj = this.value;
	        }
	        if (!p) return obj;
	
	        var parts = p.split('.');
	
	        for (var i = 0, l = parts.length; i < l; i++) {
	            var key = parts[i];
	            if (obj == null || !(key in obj)) {
	                return null;
	            }
	            obj = obj[key];
	        }
	        return obj;
	    },
	
	    /**
	     * Updates the value at a given path. This will trigger the value listeners.
	     * @param {String} path - Path to update
	     * @param {*} value - Value to update.argument.
	     */
	    update: function update(path, value) {
	        var parts = path.split('.'),
	            obj = this.value || (this.value = {}),
	            oobj = this.oldValue,
	            last = parts[parts.length - 1];
	
	        for (var i = 0, l = parts.length - 1; i < l; i++) {
	            var key = parts[i];
	
	            if (key in obj) {
	                //We won't build the oobj tree, we may need to in the case of multiple changes to the object.  The question becomes
	                // are old values the original values or the last change.
	                oobj = oobj && oobj[key];
	
	                //We copy it so that when oldValues and value share a nested object, they do not conflict, but we only need to do it when
	                // they are referencing the same instance, note we are parts -1 levels up, so really only arrays and objects.
	                if (obj[key] == null) {
	                    if (/^\d+?$/.test(key)) {
	                        obj = obj[key] = [];
	                    } else {
	                        obj = obj[key] = {};
	                    }
	                } else {
	                    obj = obj[key] = oobj === obj[key] ? copy(obj[key]) : obj[key];
	                }
	            } else {
	
	                //So the object tree isn't reached yet, we will create an array or object. if the key
	                // is an integer we will guess its an array, this will probably be correct 99% of the time, and
	                // horrible wrong 1%, se la vie.
	                if (/^\d+?$/.test(parts[i + 1])) {
	                    obj = obj[key] = [];
	                } else {
	                    obj = obj[key] = {};
	                }
	            }
	        }
	        if (value === void 0) {
	            delete obj[last];
	        } else {
	            obj[last] = value;
	        }
	        //We will build a path for the new value, but not for the oldvalue.   This
	        // might break whean a value changes multiple times.
	        return this.onValueChange(path, value, oobj && oobj[last]) !== false;
	    },
	
	    /**
	     * Returns the current value.
	     */
	    getValue: function getValue() {
	        return this.value;
	    },
	
	    /**
	     * @param {Object} value - The new value for the params.  Will trigger
	     * changes on all listeners.
	     */
	    setValue: function setValue(value) {
	        this.oldValue = (0, _tutils.extend)({}, this.value);
	        this.value = (0, _tutils.extend)({}, value);
	        if (this._setValue(value, this.oldValue) !== false) {}
	    },
	    _setValue: function _setValue(value, oldValue, path) {
	        if (canDescend(value) || canDescend(oldValue)) {
	            _keys(value, oldValue).forEach(function (key) {
	                this._setValue(value && value[key], oldValue && oldValue[key], (0, _tutils.path)(path, key));
	            }, this);
	        } else {
	            return this.onValueChange(path, value, oldValue);
	        }
	    },
	
	    /**
	     * Triggers error handlers.
	     * @param {String} path - path to trigger the error.
	     * @param {Object[]} errors - Errors to set.
	     * @param {String} errors.name - Name of the error.
	     * @param {String} errors.message - Message of the error.
	     */
	    onError: function onError(path, errors, value) {
	        errors = errors && errors[0] ? errors : null;
	        var oErrors = this.errors || {},
	            listeners = this.errorListeners;
	
	        return listeners.some(function (v) {
	            if (path == null || v.path == null || v.path === path || path.indexOf(v.path + '.') === 0) {
	                return v.listener.call(v.scope, errors, oErrors[path], path, value) === false;
	            }
	        }, this);
	    },
	
	    /**
	     * Sets the current errors and triggers the error listeners.
	     *
	     * @param {Object} errors - object containing errors. The key is the full qualified path to the value in error
	     *
	     */
	    setErrors: function setErrors(errors) {
	        var keys = _keys(errors, this.errors);
	        this.errors = (0, _tutils.extend)({}, errors);
	        return keys.some(function (key) {
	            return this.onError(key, this.errors[key]);
	        }, this) !== true;
	    },
	    getErrors: function getErrors() {
	        var ret = {};
	        Object.keys(this.errors).filter(function (v) {
	            return this[v] != null;
	        }, this.errors).forEach(function (v) {
	            ret[v] = this[v];
	        }, this.errors);
	        return ret;
	    },
	    updateErrors: function updateErrors(path, errors, value) {
	        errors = (0, _tutils.isArray)(errors) ? errors : [errors];
	        errors = errors && errors[0] ? errors : null;
	        this.errors[path] = errors;
	        this.onError(path, errors, value);
	    },
	    errorsFor: function errorsFor(path) {
	        var pathe = path + '.',
	            keys = Object.keys(this.errors).filter(function (key) {
	            return this[key] != null && (path == null || key === path || key.indexOf(pathe) === 0);
	        }, this.errors),
	            errors = [];
	
	        if (keys.length < 2) {
	            return this.errors[keys[0]];
	        }
	        keys.forEach(function (key) {
	            (0, _tutils.push)(errors, this[key]);
	        }, this.errors);
	        return errors;
	    },
	
	    /**
	     * Trigger the validators.
	     *
	     */
	    validate: function validate(path, value) {
	        var pp = path && path + '.';
	        this.validateListeners.forEach(function ValueManager$validate$forEach(v) {
	            if (path == null || v.path === path || pp.indexOf(path) === 0) v.listener.call(v.scope, path, value);
	        });
	    },
	
	    /**
	     * Trigger Validators And Callback with Errors for paths.
	     */
	    validatePaths: function validatePaths(paths, callback) {
	        var _this2 = this;
	
	        var errors = null;
	        paths.forEach(function (path) {
	            //validate does not return the error, it just triggers the error handler,
	            // so we add a listener for that path, trigger it and remove the listener.
	            //  so that we can get the listener.  We should probably change validate
	            // to return the error (or a promise) but not today.
	            _this2.addErrorListener(path, function (e) {
	                if (e) {
	                    (errors == null ? errors = {} : errors)[path] = e;
	                }
	            }).once();
	            _this2.validate(path);
	        }, this);
	
	        if (callback) {
	            callback(errors);
	        }
	        return errors;
	    },
	
	    /**
	     * Pretty much the same as update, except that it does not, store
	     * the values.  It just fires, listeners.
	     */
	    updateState: function updateState(path, value) {
	        return this.onChangeState(path, value) !== false;
	    },
	    onChangeState: function onChangeState(path, value) {
	        var parts = path && path.split('.') || [],
	            i = 0,
	            l = parts.length,
	            pp = null;
	        do {
	            if (this.stateListeners.some(function (v) {
	                if (v.path === pp) {
	                    return v.listener.call(v.scope, value, path) === false;
	                }
	            }, this) === true) {
	                return false;
	            }
	            pp = (0, _tutils.path)(pp, parts[i]);
	        } while (i++ < l);
	        return true;
	    },
	    copy: function copy() {
	        return new ValueManager(this.getValue(), this.getErrors());
	    }
	};

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = eventable;
	
	var _tutils = __webpack_require__(170);
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * This callback is displayed as a global member.
	 * It will call them in order of most distant to least distance path.
	 * In the event of two paths being the same distance, it will call the last
	 * added first.
	 *
	 * @callback ValueManagerListener
	 * @param {*} newValue - The new value to be updated
	 * @param {*} oldValue - The previous value updated.
	 * @param {String} path - The path to value updated
	 */
	function eventable(listeners) {
	    var find = arguments.length <= 1 || arguments[1] === undefined ? _tutils.returnFirst : arguments[1];
	    var findOld = arguments.length <= 2 || arguments[2] === undefined ? _tutils.returnFirst : arguments[2];
	
	    listeners = listeners || [];
	
	    //Remove if called more than once don't do anything.
	    function remove() {
	        var idx = listeners.indexOf(this);
	        if (idx > -1) {
	            listeners.splice(idx, 1);
	        }
	        return this;
	    }
	
	    function once() {
	        var rem = this.remove,
	            listener = this.listener,
	            self = this;
	
	        this.listener = function () {
	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                args[_key] = arguments[_key];
	            }
	
	            var ret = listener.apply.apply(listener, [self].concat(args));
	            rem();
	            return ret;
	        };
	        return this;
	    }
	
	    /**
	     * @param path {string}
	     * @param listener {function}
	     * @param scope {object}
	     * @param init {boolean|function}
	     */
	    return function eventable$addListener(path, listener, scope, init) {
	        if (listener == null) {
	            (0, _warning2.default)(listener, 'trying to add a null listener %s', path);
	            return;
	        }
	        var obj = { path: path, listener: listener, scope: scope, once: once };
	        obj.remove = remove.bind(obj);
	        init = init === true ? obj.listener : (0, _tutils.isFunction)(init) ? init : null;
	        if (init) {
	            init.call(obj.scope, find(path), findOld(path), path);
	        }
	        if (listeners.length === 0) {
	            listeners.push(obj);
	        } else {
	            var plength = path ? path.split('.').length : 0;
	            for (var i = 0, l = listeners.length; i < l; i++) {
	
	                var lp = listeners[i].path,
	                    cllength = lp ? lp.split('.').length : 0;
	
	                if (plength >= cllength || i + 1 === l) {
	                    listeners.splice(i, 0, obj);
	                    break;
	                }
	            }
	        }
	        return obj;
	    };
	}

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _ValueManager = __webpack_require__(281);
	
	var _ValueManager2 = _interopRequireDefault(_ValueManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NewChildContext = (_temp = _class = function (_Component) {
	    _inherits(NewChildContext, _Component);
	
	    function NewChildContext(props, context) {
	        var _Object$getPrototypeO;
	
	        _classCallCheck(this, NewChildContext);
	
	        for (var _len = arguments.length, rest = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	            rest[_key - 2] = arguments[_key];
	        }
	
	        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(NewChildContext)).call.apply(_Object$getPrototypeO, [this, props, context].concat(rest)));
	
	        _this.handleSubmit = function (e) {
	            //t(e, vm.getErrors(), vm.getValue(), this.props.path)
	            var value = _this.valueManager.path(_this.props.path),
	                errors = _this.valueManager.getErrors();
	
	            if (_this.props.onSubmit) {
	                if (_this.props.onSubmit(e, errors, value, _this.props.path) !== false) {
	                    _this.props.valueManager.update(_this.props.path, value);
	                }
	            } else {
	                _this.props.valueManager.update(_this.props.path, value);
	            }
	            return false;
	        };
	
	        var parentValueManager = _this.props.valueManager;
	        _this.valueManager = (0, _ValueManager2.default)(parentValueManager.getValue(), parentValueManager.getErrors());
	        return _this;
	    }
	
	    _createClass(NewChildContext, [{
	        key: 'getChildContext',
	        value: function getChildContext() {
	            return {
	                valueManager: this.valueManager,
	                parentValueManager: this.props.valueManager,
	                loader: this.props.loader
	            };
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.cloneElement(this.props.children, { onSubmit: this.handleSubmit });
	        }
	    }]);
	
	    return NewChildContext;
	}(_react.Component), _class.displayName = "NewChildContext", _class.propTypes = {
	    valueManager: _PropTypes2.default.valueManager,
	    loader: _PropTypes2.default.loader,
	    path: _PropTypes2.default.string.isRequired
	}, _class.childContextTypes = {
	    valueManager: _PropTypes2.default.valueManager,
	    loader: _PropTypes2.default.loader,
	    parentValueManager: _PropTypes2.default.valueManager
	}, _temp);
	exports.default = NewChildContext;

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var baseClone = __webpack_require__(285),
	    bindCallback = __webpack_require__(192);
	
	/**
	 * Creates a deep clone of `value`. If `customizer` is provided it's invoked
	 * to produce the cloned values. If `customizer` returns `undefined` cloning
	 * is handled by the method instead. The `customizer` is bound to `thisArg`
	 * and invoked with up to three argument; (value [, index|key, object]).
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	 * The enumerable properties of `arguments` objects and objects created by
	 * constructors other than `Object` are cloned to plain `Object` objects. An
	 * empty object is returned for uncloneable values such as functions, DOM nodes,
	 * Maps, Sets, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to deep clone.
	 * @param {Function} [customizer] The function to customize cloning values.
	 * @param {*} [thisArg] The `this` binding of `customizer`.
	 * @returns {*} Returns the deep cloned value.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * var deep = _.cloneDeep(users);
	 * deep[0] === users[0];
	 * // => false
	 *
	 * // using a customizer callback
	 * var el = _.cloneDeep(document.body, function(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(true);
	 *   }
	 * });
	 *
	 * el === document.body
	 * // => false
	 * el.nodeName
	 * // => BODY
	 * el.childNodes.length;
	 * // => 20
	 */
	function cloneDeep(value, customizer, thisArg) {
	  return typeof customizer == 'function'
	    ? baseClone(value, true, bindCallback(customizer, thisArg, 3))
	    : baseClone(value, true);
	}
	
	module.exports = cloneDeep;


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var arrayCopy = __webpack_require__(286),
	    arrayEach = __webpack_require__(245),
	    baseAssign = __webpack_require__(189),
	    baseForOwn = __webpack_require__(203),
	    initCloneArray = __webpack_require__(287),
	    initCloneByTag = __webpack_require__(288),
	    initCloneObject = __webpack_require__(290),
	    isArray = __webpack_require__(186),
	    isObject = __webpack_require__(178);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	cloneableTags[dateTag] = cloneableTags[float32Tag] =
	cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[stringTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[mapTag] = cloneableTags[setTag] =
	cloneableTags[weakMapTag] = false;
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * The base implementation of `_.clone` without support for argument juggling
	 * and `this` binding `customizer` functions.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @param {Function} [customizer] The function to customize cloning values.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The object `value` belongs to.
	 * @param {Array} [stackA=[]] Tracks traversed source objects.
	 * @param {Array} [stackB=[]] Associates clones with source counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	  var result;
	  if (customizer) {
	    result = object ? customizer(value, key, object) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return arrayCopy(value, result);
	    }
	  } else {
	    var tag = objToString.call(value),
	        isFunc = tag == funcTag;
	
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = initCloneObject(isFunc ? {} : value);
	      if (!isDeep) {
	        return baseAssign(result, value);
	      }
	    } else {
	      return cloneableTags[tag]
	        ? initCloneByTag(value, tag, isDeep)
	        : (object ? value : {});
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stackA || (stackA = []);
	  stackB || (stackB = []);
	
	  var length = stackA.length;
	  while (length--) {
	    if (stackA[length] == value) {
	      return stackB[length];
	    }
	  }
	  // Add the source value to the stack of traversed objects and associate it with its clone.
	  stackA.push(value);
	  stackB.push(result);
	
	  // Recursively populate clone (susceptible to call stack limits).
	  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	  });
	  return result;
	}
	
	module.exports = baseClone;


/***/ },
/* 286 */
/***/ function(module, exports) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function arrayCopy(source, array) {
	  var index = -1,
	      length = source.length;
	
	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}
	
	module.exports = arrayCopy;


/***/ },
/* 287 */
/***/ function(module, exports) {

	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);
	
	  // Add array properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}
	
	module.exports = initCloneArray;


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	var bufferClone = __webpack_require__(289);
	
	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    stringTag = '[object String]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;
	
	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag:
	      return bufferClone(object);
	
	    case boolTag:
	    case dateTag:
	      return new Ctor(+object);
	
	    case float32Tag: case float64Tag:
	    case int8Tag: case int16Tag: case int32Tag:
	    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	      var buffer = object.buffer;
	      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
	
	    case numberTag:
	    case stringTag:
	      return new Ctor(object);
	
	    case regexpTag:
	      var result = new Ctor(object.source, reFlags.exec(object));
	      result.lastIndex = object.lastIndex;
	  }
	  return result;
	}
	
	module.exports = initCloneByTag;


/***/ },
/* 289 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Native method references. */
	var ArrayBuffer = global.ArrayBuffer,
	    Uint8Array = global.Uint8Array;
	
	/**
	 * Creates a clone of the given array buffer.
	 *
	 * @private
	 * @param {ArrayBuffer} buffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function bufferClone(buffer) {
	  var result = new ArrayBuffer(buffer.byteLength),
	      view = new Uint8Array(result);
	
	  view.set(new Uint8Array(buffer));
	  return result;
	}
	
	module.exports = bufferClone;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 290 */
/***/ function(module, exports) {

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  var Ctor = object.constructor;
	  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	    Ctor = Object;
	  }
	  return new Ctor;
	}
	
	module.exports = initCloneObject;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * This is to be used to render properties with type content.
	 * Just a convient wrapper so that things go well.
	 *
	 * @param props
	 * @returns {*}
	 * @constructor
	 */
	
	function RenderContent(props) {
	    if (props == null) {
	        return props;
	    }
	
	    var content = props.content;
	
	    var oprops = _objectWithoutProperties(props, ['content']);
	
	    if (content === false) {
	        return null;
	    }
	
	    var Content = content.Content;
	
	    var rest = _objectWithoutProperties(content, ['Content']);
	
	    return _react2.default.createElement(Content, _extends({ content: rest }, oprops));
	}
	RenderContent.displayName = 'RenderContent';
	exports.default = RenderContent;

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = ObjectTemplate;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function ObjectTemplate(props) {
	    var children = props.children;
	    var className = props.className;
	    var fieldAttrs = props.fieldAttrs;
	
	    var rest = _objectWithoutProperties(props, ['children', 'className', 'fieldAttrs']);
	
	    return _react2.default.createElement(
	        'div',
	        _extends({ className: className }, fieldAttrs),
	        children
	    );
	}

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Content = __webpack_require__(269);
	
	var _Content2 = _interopRequireDefault(_Content);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var RadioItemTemplate = (_temp = _class = function (_Component) {
	    _inherits(RadioItemTemplate, _Component);
	
	    function RadioItemTemplate() {
	        _classCallCheck(this, RadioItemTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(RadioItemTemplate).apply(this, arguments));
	    }
	
	    _createClass(RadioItemTemplate, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var Content = _props.Content;
	            var label = _props.label;
	            var namespaceClass = _props.namespaceClass;
	            var labelHTML = _props.labelHTML;
	            var children = _props.children;
	            var checked = _props.checked;
	            var checkedClass = _props.checkedClass;
	            var uncheckedClass = _props.uncheckedClass;
	            var id = _props.id;
	
	            label = labelHTML ? labelHTML : label;
	            checkedClass = checkedClass || '';
	            label = typeof label === 'string' ? [{ children: true }, label] : label;
	            return _react2.default.createElement(
	                'div',
	                { className: namespaceClass + ' ' + (checked ? checkedClass : uncheckedClass) },
	                _react2.default.createElement(
	                    Content,
	                    { type: 'label', content: label },
	                    children
	                )
	            );
	        }
	    }]);
	
	    return RadioItemTemplate;
	}(_react.Component), _class.propTypes = {
	    label: _PropTypes2.default.any,
	    labelHTML: _PropTypes2.default.any,
	    checked: _PropTypes2.default.bool,
	    checkedClass: _PropTypes2.default.string,
	    id: _PropTypes2.default.id,
	    Content: _PropTypes2.default.injectClass,
	    style: _PropTypes2.default.style
	}, _class.defaultProps = {
	    Content: _Content2.default,
	    namespaceClass: "radio",
	    checkedClass: "",
	    uncheckedClass: ""
	}, _temp);
	exports.default = RadioItemTemplate;

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var WizardProgressTemplate = (_temp = _class = function (_Component) {
	    _inherits(WizardProgressTemplate, _Component);
	
	    function WizardProgressTemplate() {
	        _classCallCheck(this, WizardProgressTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(WizardProgressTemplate).apply(this, arguments));
	    }
	
	    _createClass(WizardProgressTemplate, [{
	        key: 'getStyle',
	        value: function getStyle(i) {
	            var _props = this.props;
	            var length = _props.fieldsets.length;
	            var index = _props.index;
	            var doneClass = _props.doneClass;
	            var doingClass = _props.doingClass;
	            var todoClass = _props.todoClass;
	
	            if (i < index || index == length) {
	                return doneClass;
	            }
	
	            if (i === index) {
	                return doingClass;
	            }
	
	            return todoClass;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            return _react2.default.createElement(
	                'ol',
	                { className: this.props.namespaceClass },
	                this.props.fieldsets.map(function (s, i) {
	                    return _react2.default.createElement(
	                        'li',
	                        { value: i, key: 'li' + i,
	                            className: _this2.getStyle(i),
	                            onClick: _this2.props.onClick },
	                        _react2.default.createElement(
	                            'em',
	                            null,
	                            i + 1
	                        ),
	                        _react2.default.createElement(
	                            'span',
	                            null,
	                            s.legend
	                        )
	                    );
	                })
	            );
	        }
	    }]);
	
	    return WizardProgressTemplate;
	}(_react.Component), _class.propTypes = {
	    style: _PropTypes2.default.style
	}, _class.defaultProps = {
	    index: 0,
	    fieldsets: [],
	    onClick: function onClick(e) {}
	}, _temp);
	exports.default = WizardProgressTemplate;

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Object = __webpack_require__(296);
	
	var _Object2 = _interopRequireDefault(_Object);
	
	var _WizardMixin2 = __webpack_require__(299);
	
	var _WizardMixin3 = _interopRequireDefault(_WizardMixin2);
	
	var _ButtonsTemplate = __webpack_require__(264);
	
	var _ButtonsTemplate2 = _interopRequireDefault(_ButtonsTemplate);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _defaults = __webpack_require__(270);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function donner(done) {
	    done();
	}
	
	var WizardTemplate = (_temp = _class = function (_WizardMixin) {
	    _inherits(WizardTemplate, _WizardMixin);
	
	    function WizardTemplate() {
	        _classCallCheck(this, WizardTemplate);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(WizardTemplate).apply(this, arguments));
	    }
	
	    _createClass(WizardTemplate, [{
	        key: 'setNavState',
	        value: function setNavState(next) {
	            var len = this.props.schema.fieldsets.length,
	                compState = this.state.compState;
	            next = Math.max(Math.min(len - 1, next), 0);
	            if (this.props.onNavChange(next, compState, this.props.schema.fieldsets[next]) !== false) {
	                this.setState({
	                    compState: next,
	                    disabled: false,
	                    prevState: next === compState ? this.state.prevState : compState
	                });
	            }
	        }
	    }, {
	        key: 'renderProgress',
	        value: function renderProgress(fieldsets) {
	            var Template = this.props.wizardProgressTemplate;
	            return Template ? _react2.default.createElement(Template, { fieldsets: fieldsets, index: this.state.done ? fieldsets.length : this.state.compState,
	                onClick: this.handleOnClick }) : null;
	        }
	    }, {
	        key: 'makeTransition',
	        value: function makeTransition(compState) {
	            if (compState < this.state.prevState) {
	                return this.props.transitionForward;
	            } else {
	                return this.props.transitionBackward;
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var className = _props.className;
	            var Template = _props.Template;
	            var template = _props.template;
	            var fieldsets = _props.fieldsets;
	            var fields = _props.fields;
	            var onButtonClick = _props.onButtonClick;
	            var transitionLeaveTimeout = _props.transitionLeaveTimeout;
	            var transitionEnterTimeout = _props.transitionEnterTimeout;
	            var carouselHeightClass = _props.carouselHeightClass;
	            var children = _props.children;
	            var schema = _props.schema;
	
	            var rest = _objectWithoutProperties(_props, ['className', 'Template', 'template', 'fieldsets', 'fields', 'onButtonClick', 'transitionLeaveTimeout', 'transitionEnterTimeout', 'carouselHeightClass', 'children', 'schema']);
	
	            var _props$schema = this.props.schema;
	            fieldsets = _props$schema.fieldsets;
	            schema = _props$schema.schema;
	            var compState = this.state.compState;
	            var current = fieldsets[compState];
	
	            var _makeTransition = this.makeTransition(compState);
	
	            var Transition = _makeTransition.Transition;
	
	            var transition = _objectWithoutProperties(_makeTransition, ['Transition']);
	
	            var buttons = current.buttons ? current.buttons : this.createButtons(compState);
	            var currentSchema = { schema: schema, fieldsets: [_extends({ buttons: buttons }, current, { legend: false })], Template: Template };
	            return _react2.default.createElement(
	                'div',
	                { className: this.props.namespaceClass + ' ' + (this.state.animating ? this.props.animatingClass : ''),
	                    onKeyDown: this.handleKeyDown },
	                this.renderProgress(fieldsets),
	                _react2.default.createElement(
	                    Transition,
	                    _extends({ key: 'wizard-transition' }, transition),
	                    _react2.default.createElement(_Object2.default, _extends({}, rest, {
	                        className: 'clearfix state-' + compState,
	                        key: "form-" + compState,
	                        schema: currentSchema,
	                        onButtonClick: this.handleBtn.bind(this)
	                    }))
	                )
	            );
	        }
	    }]);
	
	    return WizardTemplate;
	}(_WizardMixin3.default), _class.defaultProps = (0, _defaults2.default)({
	    wizardProgressTemplate: 'WizardProgressTemplate',
	    Template: 'ObjectTemplate',
	    onNext: donner,
	    onPrevious: donner,
	    onDone: donner,
	    buttons: {
	        'previous': {
	            label: 'Previous',
	            action: 'previous'
	        },
	        'next': {
	            label: 'Next',
	            action: 'next',
	            primary: true
	        },
	        'last': {
	            label: 'Done',
	            action: 'submit',
	            primary: true
	        }
	    },
	    onAction: function onAction(pos, action, wizard) {},
	    onNavChange: function onNavChange(current, previous, wizard) {},
	
	    transitionForward: "slideRight",
	    transitionBackward: "slideLeft",
	    namespaceClass: 'wizard'
	}, _WizardMixin3.default.defaultProps), _class.propTypes = _extends({}, _WizardMixin3.default.propTypes, {
	    wizardProgressTemplate: _PropTypes2.default.template,
	    Template: _PropTypes2.default.template,
	    transitionForward: _PropTypes2.default.transition,
	    transitionBackward: _PropTypes2.default.transition,
	    style: _PropTypes2.default.style
	}), _temp);
	exports.default = WizardTemplate;

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	var _map = __webpack_require__(253);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _Field = __webpack_require__(297);
	
	var _Field2 = _interopRequireDefault(_Field);
	
	var _FieldSet = __webpack_require__(298);
	
	var _FieldSet2 = _interopRequireDefault(_FieldSet);
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ObjectType = (_temp2 = _class = function (_Component) {
	    _inherits(ObjectType, _Component);
	
	    function ObjectType() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, ObjectType);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(ObjectType)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.handleButtonClick = function (e, action) {
	            for (var _len2 = arguments.length, rest = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	                rest[_key2 - 2] = arguments[_key2];
	            }
	
	            var _this$props;
	
	            if ((_this$props = _this.props).onButtonClick.apply(_this$props, [e, action].concat(rest)) !== false) {
	                if (action === 'submit') {
	                    var _this$props2;
	
	                    (_this$props2 = _this.props).onSubmit.apply(_this$props2, [e].concat(rest));
	                }
	            }
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(ObjectType, [{
	        key: 'addEditor',
	        value: function addEditor(f, field, fields, Field) {
	
	            if (field == null) {
	                (0, _warning2.default)(true, 'No field found for %s probably a key in fields does not match in schema', f);
	                return null;
	            }
	
	            f = typeof f === 'string' ? f : f.name || f;
	
	            return _react2.default.createElement(Field, { key: 'key-' + f, path: (0, _tutils.path)(this.props.path, f), conditional: field.conditional, transition: field.transition, field: field, fields: fields });
	        }
	    }, {
	        key: 'makeFieldset',
	        value: function makeFieldset(f, i, schema, FieldSet, Field) {
	            return _react2.default.createElement(
	                FieldSet,
	                _extends({ key: 'fieldset-' + i }, f, { field: f,
	                    onSubmit: this.handleSubmit,
	                    onButtonClick: this.handleButtonClick }),
	                f.fields ? this.makeFields(f.fields, schema, Field) : this.makeFieldsets(f.fieldsets, schema, FieldSet, Field)
	            );
	        }
	    }, {
	        key: 'makeFields',
	        value: function makeFields(fields, schema, Field) {
	            var _this2 = this;
	
	            var fieldMap = {};
	            var mappedfields = fields.map(function (field) {
	                var _field$split = field.split('.', 2);
	
	                var _field$split2 = _slicedToArray(_field$split, 2);
	
	                var f = _field$split2[0];
	                var rest = _field$split2[1];
	
	                if (rest) {
	                    (fieldMap[f] || (fieldMap[f] = [])).push(rest);
	                }
	                return f;
	            });
	
	            return (0, _tutils.unique)(mappedfields).map(function (f, i) {
	                return _this2.addEditor(f, schema[f] || f, fieldMap[f], Field);
	            });
	        }
	    }, {
	        key: 'makeFieldsets',
	        value: function makeFieldsets(fieldsets, schema, FieldSet, Field) {
	            var _this3 = this;
	
	            if (fieldsets == null) {
	                return null;
	            }
	            return fieldsets.map(function (f, i) {
	                return _this3.makeFieldset(f, i, schema, FieldSet, Field);
	            });
	        }
	    }, {
	        key: 'renderSchema',
	        value: function renderSchema(schema, FieldSet, Field) {
	            return this.makeFieldsets(schema.fieldsets, schema.schema, FieldSet, Field);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            //capture the things that should not fall through.
	            var _props = this.props;
	            var schema = _props.schema;
	            var subSchema = _props.subSchema;
	            var onButtonClick = _props.onButtonClick;
	            var submitButton = _props.submitButton;
	            var conditional = _props.conditional;
	            var FieldSet = _props.FieldSet;
	            var Field = _props.Field;
	            var children = _props.children;
	            var objectTemplate = _props.objectTemplate;
	            var template = _props.template;
	
	            var props = _objectWithoutProperties(_props, ['schema', 'subSchema', 'onButtonClick', 'submitButton', 'conditional', 'FieldSet', 'Field', 'children', 'objectTemplate', 'template']);
	
	            var ObjectTemplate = objectTemplate;
	
	            var _ref = schema || subSchema;
	
	            var Template = _ref.Template;
	
	            var rschema = _objectWithoutProperties(_ref, ['Template']);
	
	            return _react2.default.createElement(
	                Template,
	                _extends({ schema: rschema, onButtonClick: this.handleButtonClick }, props),
	                rschema != null ? this.renderSchema(rschema, FieldSet, Field) : null,
	                children
	            );
	        }
	    }]);
	
	    return ObjectType;
	}(_react.Component), _class.template = false, _class.inputClassName = ' ', _class.propTypes = {
	    objectTemplate: _PropTypes2.default.oneOfType([_PropTypes2.default.string, _PropTypes2.default.func]),
	    schema: _PropTypes2.default.schema,
	    subSchema: _PropTypes2.default.schema,
	    onButtonClick: _PropTypes2.default.event,
	    onSubmit: _PropTypes2.default.event,
	    buttons: _PropTypes2.default.buttons,
	    path: _PropTypes2.default.path,
	    fieldsets: _PropTypes2.default.fieldset,
	    fields: _PropTypes2.default.fields,
	    FieldSet: _PropTypes2.default.injectClass,
	    Field: _PropTypes2.default.injectClass
	
	}, _class.defaultProps = {
	    onButtonClick: _tutils.noop,
	    onSubmit: _tutils.noop,
	    fallbackTemplate: 'ObjectTemplate',
	    FieldSet: _FieldSet2.default,
	    Field: _Field2.default,
	    subSchema: {}
	}, _class.contextTypes = _PropTypes2.default.contextTypes, _temp2);
	exports.default = ObjectType;

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Field = (_temp = _class = function (_Component) {
	    _inherits(Field, _Component);
	
	    function Field() {
	        _classCallCheck(this, Field);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Field).apply(this, arguments));
	    }
	
	    _createClass(Field, [{
	        key: 'renderField',
	        value: function renderField(field, propPath) {
	            var Template = field.Template;
	            var Type = field.Type;
	            var path = field.path;
	
	            var rest = _objectWithoutProperties(field, ['Template', 'Type', 'path']);
	
	            var validators = field.validators || _tutils.FREEZE_ARR;
	            var cpath = propPath || path;
	            var FieldTemplate = Template;
	            return FieldTemplate ? _react2.default.createElement(
	                FieldTemplate,
	                _extends({ path: cpath }, rest),
	                _react2.default.createElement(Type, _extends({ path: cpath, onBlur: validators }, rest))
	            ) : _react2.default.createElement(Type, _extends({ path: cpath }, rest));
	        }
	    }, {
	        key: 'renderConditional',
	        value: function renderConditional(conditional) {
	            var _props = this.props;
	            var field = _props.field;
	            var path = _props.path;
	
	
	            if (!conditional) {
	                return this.renderField(field, path);
	            }
	
	            var Conditional = conditional.Conditional;
	
	            var rest = _objectWithoutProperties(conditional, ['Conditional']);
	
	            return _react2.default.createElement(
	                Conditional,
	                _extends({ path: path }, rest, {
	                    field: field }),
	                this.renderField(field, conditional.path || path)
	            );
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            if (this.props.transition) {
	                var _props$transition = this.props.transition;
	                var Transition = _props$transition.Transition;
	
	                var transition = _objectWithoutProperties(_props$transition, ['Transition']);
	
	                return _react2.default.createElement(
	                    Transition,
	                    transition,
	                    this.renderConditional(this.props.conditional)
	                );
	            }
	            return this.renderConditional(this.props.conditional);
	        }
	    }]);
	
	    return Field;
	}(_react.Component), _class.displayName = "Field", _class.propTypes = {
	    path: _PropTypes2.default.path.isRequired,
	    field: _PropTypes2.default.field,
	    transition: _PropTypes2.default.transition,
	    conditional: _PropTypes2.default.conditional
	}, _temp);
	exports.default = Field;

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _RenderContent = __webpack_require__(291);
	
	var _RenderContent2 = _interopRequireDefault(_RenderContent);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Manages the the fieldset.  It  uses FieldSetTemplate or similar, but now
	 * it renders the buttons, so the Template does not have to handle that.
	 *
	 */
	var FieldSet = (_temp = _class = function (_Component) {
	    _inherits(FieldSet, _Component);
	
	    function FieldSet() {
	        _classCallCheck(this, FieldSet);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(FieldSet).apply(this, arguments));
	    }
	
	    _createClass(FieldSet, [{
	        key: 'renderButtons',
	        value: function renderButtons(buttons) {
	            if (!buttons) {
	                return null;
	            }
	            var ButtonsTemplate = this.props.buttonsTemplate;
	            if (!buttons.buttons) {
	                buttons = {
	                    buttons: buttons
	                };
	            }
	            return _react2.default.createElement(ButtonsTemplate, _extends({ key: 'buttons', onButtonClick: this.props.onButtonClick,
	                onClick: this.props.onClick }, buttons));
	        }
	    }, {
	        key: 'renderFieldSet',
	        value: function renderFieldSet(key) {
	            var _props = this.props;
	            var template = _props.template;
	            var children = _props.children;
	            var buttons = _props.buttons;
	            var content = _props.content;
	            var field = _props.field;
	
	            var rest = _objectWithoutProperties(_props, ['template', 'children', 'buttons', 'content', 'field']);
	
	            var FieldSetTemplate = template;
	            return _react2.default.createElement(
	                FieldSetTemplate,
	                _extends({ key: key }, rest, field, { buttons: this.renderButtons(buttons), content: _react2.default.createElement(_RenderContent2.default, { content: content, key: 'content-' + key }) }),
	                children
	            );
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            if (this.props.transition) {
	                var _props$transition = this.props.transition;
	                var Transition = _props$transition.Transition;
	
	                var transition = _objectWithoutProperties(_props$transition, ['Transition']);
	
	                return _react2.default.createElement(
	                    Transition,
	                    transition,
	                    this.renderFieldSet('transition')
	                );
	            }
	            if (this.props.conditional) {
	                var _props$conditional = this.props.conditional;
	                var Conditional = _props$conditional.Conditional;
	
	                var conditional = _objectWithoutProperties(_props$conditional, ['Conditional']);
	
	                return _react2.default.createElement(
	                    Conditional,
	                    conditional,
	                    this.renderFieldSet('conditional')
	                );
	            }
	            return this.renderFieldSet();
	        }
	    }]);
	
	    return FieldSet;
	}(_react.Component), _class.displayName = "FieldSet", _class.propTypes = {
	    fieldsets: _PropTypes2.default.arrayOf(_PropTypes2.default.shape({
	        field: _PropTypes2.default.field,
	        fieldsets: _PropTypes2.default.arrayOf(_PropTypes2.default.shape({
	            field: _PropTypes2.default.field
	        }))
	    })),
	    conditional: _PropTypes2.default.conditional,
	    buttons: _PropTypes2.default.any,
	    onButtonClick: _PropTypes2.default.event,
	    onSubmit: _PropTypes2.default.event,
	    onCancel: _PropTypes2.default.event,
	    field: _PropTypes2.default.any,
	    legend: _PropTypes2.default.any,
	    template: _PropTypes2.default.template,
	    transition: _PropTypes2.default.transition,
	    buttonsTemplate: _PropTypes2.default.template,
	    content: _PropTypes2.default.content
	}, _class.defaultProps = {
	    template: 'FieldSetTemplate',
	    buttonsTemplate: 'ButtonsTemplate'
	}, _temp);
	exports.default = FieldSet;

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Object = __webpack_require__(296);
	
	var _Object2 = _interopRequireDefault(_Object);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _Field = __webpack_require__(297);
	
	var _Field2 = _interopRequireDefault(_Field);
	
	var _FieldSet = __webpack_require__(298);
	
	var _FieldSet2 = _interopRequireDefault(_FieldSet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function donner(d) {
	    d && d();
	}
	var WizardMixin = (_temp2 = _class = function (_Component) {
	    _inherits(WizardMixin, _Component);
	
	    function WizardMixin() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, WizardMixin);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(WizardMixin)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.state = { compState: 0, prevState: 0, maxState: 0, done: false }, _this.handleOnClick = function (evt) {
	            var steps = _this.props.schema.fieldsets.length,
	                value = evt.target.value;
	            if (value < steps && value <= _this.state.maxState) {
	                _this.setNavState(value, true);
	            }
	        }, _this.handleKeyDown = function (e) {
	            if (e.which === 13) {
	                if (_this.state.compState < _this.props.schema.fieldsets.length - 1) {
	                    return _this.handleBtn(e, 'next');
	                } else {
	                    return _this.handleBtn(e, 'submit');
	                }
	            }
	        }, _this.handleValidate = function () {}, _this.handleEnter = function () {
	            _this.setState({ animating: true });
	        }, _this.handleLeave = function (done) {
	            _this.setState({ animating: false });
	            done();
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(WizardMixin, [{
	        key: 'handleSubmit',
	        value: function handleSubmit(e) {
	            //    e && e.preventDefault();
	            this._validate(function (errors) {
	                if (errors) {
	
	                    this.setState({ disabled: false, done: false });
	                    return;
	                }
	
	                this.setState({ done: true });
	                this.props.onSubmit(e);
	                return;
	            }.bind(this));
	        }
	    }, {
	        key: 'next',
	        value: function next() {
	            var compState = this.state.compState,
	                nextState = compState + 1,
	                current = this.props.schema.fieldsets[compState];
	            this.setState({ disabled: true });
	            this._validate(function (e) {
	                var _this2 = this;
	
	                if (e) {
	                    this.setState({ disabled: false, done: false });
	                    return;
	                }
	                if (this.props.onNext(function (resp) {
	                    return _this2.go(nextState, resp);
	                }, nextState, current) === false) {
	                    this.setState({ disabled: false, done: false, maxState: Math.max(nextState, this.state.maxState) });
	                    return;
	                }
	            }.bind(this));
	        }
	    }, {
	        key: 'previous',
	        value: function previous() {
	            var _this3 = this;
	
	            var compState = this.state.compState,
	                nextState = compState - 1,
	                current = this.props.schema.fieldsets[compState];
	
	            this.setState({ disabled: true });
	            if (this.props.onPrevious(function (resp) {
	                return _this3.go(nextState, resp);
	            }, nextState, current) === false) {
	                this.setState({ disabled: false, done: false });
	                return;
	            }
	        }
	    }, {
	        key: 'go',
	        value: function go(pos, resp) {
	            if (resp === false) {
	                this.setState({ disabled: false, done: false });
	                return;
	            }
	            this.setNavState(resp == null ? pos : resp);
	        }
	    }, {
	        key: '_validate',
	        value: function _validate(done) {
	            this.context.valueManager.validatePaths(this.props.schema.fieldsets[this.state.compState].fields, done);
	        }
	    }, {
	        key: 'createButtons',
	        value: function createButtons(state) {
	            var buttons = this.props.schema.fieldsets[state].buttons;
	
	            var rest = {};
	            if (buttons) {
	                if (buttons.buttons) {
	                    var _buttons = buttons;
	                    buttons = _buttons.buttons;
	                    rest = _objectWithoutProperties(_buttons, ['buttons']);
	                }
	                if (!Array.isArray(buttons)) {
	                    buttons = [buttons];
	                }
	            } else {
	                buttons = [];
	                var _props$buttons = this.props.buttons;
	                var next = _props$buttons.next;
	                var previous = _props$buttons.previous;
	                var last = _props$buttons.last;
	
	                var restBtns = _objectWithoutProperties(_props$buttons, ['next', 'previous', 'last']);
	
	                rest = restBtns;
	                var isFirst = state == 0,
	                    isLast = state + 1 === this.props.schema.fieldsets.length;
	
	                if (isLast) {
	                    if (!isFirst) {
	                        buttons.push(_extends({ buttonClass: this.props.previousClass }, previous));
	                    }
	                    buttons.push(_extends({ buttonClass: this.props.lastClass, primary: true }, last));
	                } else if (isFirst) {
	                    buttons.push(_extends({ buttonClass: this.props.nextClass, primary: true }, next));
	                } else {
	                    buttons.push(_extends({ buttonClass: this.props.previousClass }, previous), _extends({ buttonClass: this.props.nextClass, primary: true }, next));
	                }
	            }
	
	            buttons.forEach(function (b) {
	                if (b.action === 'next' || b.action === 'submit') {
	                    b.disabled = this.disabled;
	                }
	            }, this.state);
	            return _extends({}, rest, {
	                buttons: buttons
	            });
	        }
	    }, {
	        key: 'handleBtn',
	        value: function handleBtn(e, action, btn) {
	            e && e.preventDefault();
	            switch (action) {
	
	                case 'previous':
	                    {
	                        this.previous();
	                        break;
	                    }
	                case 'next':
	                    {
	                        this.next();
	                        break;
	                    }
	                case 'submit':
	                    {
	                        this.handleSubmit(e);
	                        break;
	                    }
	                default:
	                    {
	                        this.props.onAction(this.state.compState, action, this);
	                    }
	            }
	        }
	    }]);
	
	    return WizardMixin;
	}(_react.Component), _class.contextTypes = {
	    valueManager: _PropTypes2.default.valueManager
	}, _class.defaultProps = {
	    buttonsTemplate: 'ButtonsTemplate',
	    Field: _Field2.default,
	    FieldSet: _FieldSet2.default
	}, _class.propTypes = {
	    schema: _PropTypes2.default.any,
	    buttonsTemplate: _PropTypes2.default.template,
	    onSubmit: _PropTypes2.default.event,
	    FieldSet: _PropTypes2.default.injectClass,
	    Field: _PropTypes2.default.injectClass
	}, _temp2);
	exports.default = WizardMixin;

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var context = __webpack_require__(301),
	    api = {}; //make sure you have your directory and regex test set correctly!
	context.keys().forEach(function (key) {
	    var k = key.replace(/^\.\/(.*)\.js(x)?$/, '$1');
	    api[k] = context(key).default;
	});
	module.exports = api;

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./Autocomplete.jsx": 302,
		"./Checkbox.jsx": 304,
		"./Checkboxes.jsx": 305,
		"./CollectionMixin.jsx": 306,
		"./Content.jsx": 269,
		"./ContentWrapper.jsx": 273,
		"./Date.jsx": 307,
		"./Hidden.jsx": 308,
		"./LazyType.jsx": 309,
		"./List.jsx": 310,
		"./Mixed.jsx": 315,
		"./Number.jsx": 316,
		"./Object.jsx": 296,
		"./Password.jsx": 317,
		"./Radio.jsx": 318,
		"./Restricted.jsx": 319,
		"./RestrictedMixin.js": 320,
		"./Select.jsx": 321,
		"./SubstituteMixin.js": 322,
		"./Text.jsx": 325,
		"./TextArea.jsx": 326,
		"./index.js": 300
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 301;


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _desc, _value, _class, _class2, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _tutils = __webpack_require__(170);
	
	var _Dom = __webpack_require__(303);
	
	var _Dom2 = _interopRequireDefault(_Dom);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _lifecycle = __webpack_require__(249);
	
	var _lifecycle2 = _interopRequireDefault(_lifecycle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
	    var desc = {};
	    Object['ke' + 'ys'](descriptor).forEach(function (key) {
	        desc[key] = descriptor[key];
	    });
	    desc.enumerable = !!desc.enumerable;
	    desc.configurable = !!desc.configurable;
	
	    if ('value' in desc || desc.initializer) {
	        desc.writable = true;
	    }
	
	    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
	        return decorator(target, property, desc) || desc;
	    }, desc);
	
	    if (context && desc.initializer !== void 0) {
	        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
	        desc.initializer = undefined;
	    }
	
	    if (desc.initializer === void 0) {
	        Object['define' + 'Property'](target, property, desc);
	        desc = null;
	    }
	
	    return desc;
	}
	
	var Autocomplete = (_dec = (0, _lifecycle2.default)("componentWillUnmount"), (_class = (_temp2 = _class2 = function (_Component) {
	    _inherits(Autocomplete, _Component);
	
	    function Autocomplete() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this2, _ret;
	
	        _classCallCheck(this, Autocomplete);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Autocomplete)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this2), _this2.state = { suggestions: [], showing: false, focus: -1 }, _this2.hide = function (selectValue) {
	            var _this2$state = _this2.state;
	            var selected = _this2$state.selected;
	            var input = _this2$state.input;
	            var suggestions = _this2$state.suggestions;
	            var focus = _this2$state.focus;var i = 0;var l;var options;var found = false;
	            suggestions = suggestions || [];
	            if (selectValue) {
	
	                var p = _this2.getProcessor();
	                if (selectValue && focus > -1) {
	
	                    selected = suggestions[focus];
	                } else if (input == null || input.trim() === '') {
	                    selected = null;
	                    input = null;
	                } else if (!selected || input !== selected.label) {
	                    if (suggestions.length === 1) {
	                        selected = suggestions[0];
	                        input = selected.label;
	                    } else {
	                        selected = null;
	                        options = suggestions;
	                        l = options.length;
	                        for (; i < l; i++) {
	                            var opt = options[i];
	                            if (opt.label === input) {
	                                selected = opt;
	                                input = opt.label;
	                                found = true;
	                                break;
	                            }
	                        }
	                        if (!found) {
	                            input = null;
	                        }
	                    }
	                }
	                if (selected !== _this2.state.selected) {
	                    _this2.onSelect(selected);
	                } else {
	                    _this2.props.onValidate(selected && selected.val, _this2.props.value, _this2.props.name, _this2.props.path);
	                    _this2.setState({ suggestions: [], selected: selected, input: input, showing: false, focus: -1 });
	                }
	            } else {
	                _this2.setState({ showing: false, focus: -1, suggestions: [] }, _this2.un);
	            }
	            //        this.props.onBlur();
	        }, _this2.bindDocument = function () {
	            if (_this2._bound) {
	                return;
	            }
	            _this2.unbindDocument();
	            _this2._bound = true;
	            _this2._onDocumentClickListener = _Dom2.default.listen(_this2, 'click', _this2.handleDocumentClick);
	
	            _this2._onDocumentKeyupListener = _Dom2.default.listen(_this2, 'keyup', _this2.handleDocumentKeyUp);
	
	            _this2._onDocumentKeydownListener = _Dom2.default.listen(_this2, 'keypress', _this2.handleDocumentEnter);
	        }, _this2.handleDocumentEnter = function (e) {
	
	            if (e.keyCode === 13 && _this2.state.suggestions && _this2.state.suggestions.length) {
	                e.preventDefault();
	                e.stopPropagation();
	                _this2.hide(true);
	            }
	        }, _this2.handleDocumentKeyUp = function (e) {
	
	            if (e.keyCode === 27) {
	                _this2.hide(false);
	            }
	        }, _this2.handleDocumentClick = function (e) {
	            // If the click originated from within this component
	            // don't do anything.
	            if (_Dom2.default.isNodeInRoot(e.target, _this2)) {
	                return;
	            }
	
	            _this2.hide(false);
	        }, _this2.handleSuggestionClick = function (o) {
	            _this2.onSelect(o);
	        }, _this2.onSelect = function (o) {
	            if (_this2.props.onSelect(o) === false) {
	                return;
	            }
	            var p = _this2.processor();
	            var value = p.value(o);
	            if (_this2.props.onChange(value) !== false) {
	                var input = p.format(o);
	                _this2.setState({
	                    suggestions: [],
	                    showing: false,
	                    focus: -1,
	                    selected: o,
	                    value: value,
	                    input: input
	                });
	            }
	        }, _this2._handleDispatch = function (input) {
	            _this2.setState({
	                input: input,
	                selected: null
	            });
	
	            if (_this2._fetch && _this2._fetch.cancel) {
	                _this2._fetch.cancel();
	            }
	            var _this = _this2;
	            _this2._fetch = _this2.processor().fetch(_this2.props.url, input, _this2, function (err, suggestions) {
	                if (err) {
	                    return;
	                }
	                if (_this.props.autoSelectSingle && suggestions && suggestions.length === 1) {
	                    _this.onSelect(suggestions[0]);
	                } else {
	                    _this.props.onInputChange(input);
	                    _this.setState({
	                        suggestions: suggestions || [],
	                        showing: true,
	                        input: input
	                    });
	                }
	            });
	        }, _this2.handleKeyUp = function (e) {
	            if (_this2.props.onKeyUp) {
	                _this2.props.onKeyUp.call(_this2, e);
	            }
	            var focus = _this2.state.focus,
	                s = _this2.state.suggestions;
	            if (s && s.length) {
	                var update = false;
	                switch (e.key || e.keyCode) {
	                    case 'Up':
	                    case 38:
	                    case 'ArrowUp':
	                        {
	                            focus = Math.max(-1, focus - 1);
	                            update = true;
	                            break;
	                        }
	                    case 40:
	                    case 'Down':
	                    case 'ArrowDown':
	                        {
	                            focus = Math.min(s.length, focus + 1);
	                            update = true;
	                            break;
	                        }
	                    case 'Enter':
	                        {
	                            if (e) {
	                                e.preventDefault();
	                                e.stopPropagation();
	                            }
	                            if (s.length) {
	                                _this2.handleSuggestionClick(s[Math.max(_this2.state.focus, 0)]);
	                                _this2.setState({ suggestions: [], showing: false, focus: -1 });
	
	                                return;
	                            }
	                            _this2.hide();
	                            break;
	                        }
	                }
	                if (update) {
	                    //e.preventDefault();
	                    _this2.setState({ focus: focus });
	                }
	            }
	        }, _this2.handleChange = function (e) {
	            _this2._handleDispatch(e.target.value);
	        }, _this2.handlePaste = function (event) {
	            var items = event.clipboardData && event.clipboardData.items;
	            items && items[0] && items[0].getAsString(function (input) {
	
	                _this2.setState({ input: input, suggestions: [], showing: false });
	            });
	        }, _this2.handleBlur = function (event) {
	            var suggestions = _this2.state.suggestions || [];
	            if (suggestions.length === 1 && !_this2.state.selected) {
	                _this2.handleSuggestionClick(suggestions[Math.max(0, _this2.state.focus)]);
	            }
	            _this2.props.onValidate(event);
	            _this2.props.onBlur(event);
	        }, _temp), _possibleConstructorReturn(_this2, _ret);
	    }
	
	    _createClass(Autocomplete, [{
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            this._processProps(this.props);
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(props, context) {
	            this._processProps(props);
	        }
	    }, {
	        key: 'componentWillUpdate',
	        value: function componentWillUpdate(nextProps, nextState) {
	            if (nextState && nextState.suggestions && nextState.suggestions.length) {
	                this.bindDocument();
	            } else {
	                this.unbindDocument();
	            }
	        }
	    }, {
	        key: 'setValue',
	        value: function setValue(v) {
	            var p = this.processor();
	            var value = p.value(v);
	            var input = p.format(v);
	            this.setState({
	                value: value,
	                selected: v,
	                input: input,
	                showing: false,
	                suggestions: []
	            });
	        }
	
	        /** In the event that the value does not have the meta data for displaying
	         * We will try to fetch the object and format it.
	         * @param props
	         * @private
	         */
	
	    }, {
	        key: '_processProps',
	        value: function _processProps(props) {
	            var _this3 = this;
	
	            var value = props.value;
	            if (value && value !== this.state.value) {
	                //see if we can get the formatted value from the value, may not work.
	                var input = props.processor.format(value);
	                if (input == null) {
	                    //It didn't format to a value, go fetch it so we can display it.
	                    props.processor.fetch(props.url, value, this, function (e, o) {
	                        if (o && o.length === 1) {
	                            _this3.setValue(o[0]);
	                        } else {
	                            _this3.setState({
	                                suggestions: o,
	                                showing: true
	                            });
	                        }
	                    });
	                } else {
	                    this.setState({ input: input, value: value });
	                }
	            }
	        }
	
	        /**
	         * Hide could be called when a user has not selected a value.
	         *
	         * If their is a selected value and input equals its label select it.
	         * So if there is only 1 selection select it.
	         * If
	         */
	
	    }, {
	        key: 'unbindDocument',
	        value: function unbindDocument() {
	            this._bound = false;
	            if (this._onDocumentClickListener) {
	                this._onDocumentClickListener.remove();
	            }
	
	            if (this._onDocumentKeyupListener) {
	                this._onDocumentKeyupListener.remove();
	            }
	            if (this._onDocumentKeydownListener) {
	                this._onDocumentKeydownListener.remove();
	            }
	        }
	    }, {
	        key: 'processor',
	        value: function processor() {
	            return this.props.processor;
	        }
	    }, {
	        key: 'renderSuggestions',
	        value: function renderSuggestions() {
	            var suggestions = this.state.suggestions || [];
	            if (this.state.showing === false || suggestions.length === 0) {
	
	                return null;
	            }
	            var _state = this.state;
	            var focus = _state.focus;
	            var input = _state.input;
	
	            var processor = this.processor();
	            var handleSuggestionClick = this.handleSuggestionClick;
	            var CompleteItem = this.props.itemTemplate;
	            return _react2.default.createElement(
	                'ul',
	                { className: this.props.listGroupClass },
	                suggestions.map(function (item, i) {
	                    return _react2.default.createElement(CompleteItem, {
	                        key: item.val,
	                        focus: focus === i,
	                        value: input,
	                        ref: "item_" + i,
	                        processor: processor,
	                        onSelect: handleSuggestionClick,
	                        data: item });
	                })
	            );
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var suggestions = this.state.suggestions || [];
	            var _props = this.props;
	            var foundClass = _props.foundClass;
	            var namespaceClass = _props.namespaceClass;
	            var inputType = _props.inputType;
	            var id = _props.id;
	            var input = _props.input;
	            var notFoundClass = _props.notFoundClass;
	            // props.onChange = this::this.handleChange;
	
	            var inputProps = {
	                onPaste: this.handlePaste.bind(this),
	                onKeyDown: this.handleKeyUp.bind(this),
	                onBlur: this.handleBlur.bind(this),
	                onChange: this.handleChange.bind(this),
	                value: this.state.input,
	                id: id
	            };
	            var Input = inputType;
	            return _react2.default.createElement(
	                'div',
	                { className: namespaceClass + ' ' + (suggestions.length > 0 ? foundClass : notFoundClass) },
	                _react2.default.createElement(Input, _extends({}, inputProps, { ref: 'input' })),
	                this.renderSuggestions()
	            );
	        }
	    }]);
	
	    return Autocomplete;
	}(_react.Component), _class2.propTypes = {
	    inputType: _PropTypes2.default.type,
	    onChange: _PropTypes2.default.valueEvent,
	    onSelect: _PropTypes2.default.event,
	    minLength: _PropTypes2.default.number,
	    autoSelectSingle: _PropTypes2.default.bool,
	    useshowing: _PropTypes2.default.bool,
	    maxInputLength: _PropTypes2.default.number,
	    itemTemplate: _PropTypes2.default.template,
	    processor: _PropTypes2.default.processor,
	    showing: _PropTypes2.default.content,
	    foundClass: _PropTypes2.default.cssClass,
	    notFoundClass: _PropTypes2.default.cssClass,
	    options: _PropTypes2.default.options,
	    onInputChange: _PropTypes2.default.event,
	    style: _PropTypes2.default.style,
	    url: _PropTypes2.default.expression
	
	}, _class2.defaultProps = {
	    country: 'US',
	    locale: 'en_US',
	    useshowing: true,
	    minLength: 1,
	    maxInputLength: 200,
	    itemTemplate: "AutocompleteItemTemplate",
	    inputType: {
	        type: 'Text',
	        propTypes: { value: _PropTypes2.default.any },
	        defaultProps: { value: '' }
	    },
	    processor: 'OptionsProcessor',
	    showing: 'Searching...',
	    input: 'input',
	    inputValue: 'input'
	}, _temp2), (_applyDecoratedDescriptor(_class.prototype, 'unbindDocument', [_dec], Object.getOwnPropertyDescriptor(_class.prototype, 'unbindDocument'), _class.prototype)), _class));
	exports.default = Autocomplete;

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var EventListener = __webpack_require__(119);
	var ReactDOM = __webpack_require__(162);
	
	module.exports = {
	    EventListener: EventListener,
	    ownerDocument: ownerDocument,
	    isNodeInRoot: isNodeInRoot,
	    listen: listen
	
	};
	/**
	 * listen
	 */
	function listen(node, event, func) {
	    return EventListener.listen(ownerDocument(node), event, func);
	}
	/**
	 * Get elements owner document
	 *
	 * @param {ReactComponent|HTMLElement} componentOrElement
	 * @returns {HTMLElement}
	 */
	function ownerDocument(componentOrElement) {
	    var elem = ReactDOM.findDOMNode(componentOrElement);
	    return elem && elem.ownerDocument || document;
	}
	/**
	 * Checks whether a node is within
	 * a root nodes tree
	 *
	 * @param {DOMElement} node
	 * @param {DOMElement} root
	 * @returns {boolean}
	 */
	function isNodeInRoot(node, root) {
	    node = ReactDOM.findDOMNode(node), root = ReactDOM.findDOMNode(root);
	    return _isNodeInRoot(node, root);
	}
	function _isNodeInRoot(node, root) {
	    while (node) {
	        if (node === root) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	
	    return false;
	}

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Checkbox = (_temp = _class = function (_Component) {
	    _inherits(Checkbox, _Component);
	
	    function Checkbox() {
	        _classCallCheck(this, Checkbox);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Checkbox).apply(this, arguments));
	    }
	
	    _createClass(Checkbox, [{
	        key: 'handleChange',
	        value: function handleChange(e) {
	            var value = this.props.value;
	            //Blur does not get called on checkbox, so we do check on change anyways.
	
	            var val = e.target.checked ? value == null || value === false ? true : value : value == null || value == true ? false : null;
	            this.props.onChange(val);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var onChange = _props.onChange;
	            var value = _props.value;
	            var className = _props.className;
	            var checkedClass = _props.checkedClass;
	
	            var props = _objectWithoutProperties(_props, ['onChange', 'value', 'className', 'checkedClass']);
	
	            var checked = typeof value === 'boolean' ? value : value == null ? this.props.checked : true;
	            return _react2.default.createElement('input', _extends({}, props, { value: value, className: className + ' ' + (checked ? checkedClass : ''),
	                checked: checked, onChange: this.handleChange.bind(this) }));
	        }
	    }]);
	
	    return Checkbox;
	}(_react.Component), _class.inputClassName = ' ', _class.propTypes = {
	    onChange: _PropTypes2.default.valueEvent,
	    checkedClass: _PropTypes2.default.cssClass,
	    onBlur: _PropTypes2.default.changeValidate
	}, _class.defaultProps = {
	    type: 'checkbox',
	    checkedClass: ''
	}, _temp);
	exports.default = Checkbox;

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Checkboxes = (_temp = _class = function (_Component) {
	    _inherits(Checkboxes, _Component);
	
	    function Checkboxes() {
	        _classCallCheck(this, Checkboxes);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Checkboxes).apply(this, arguments));
	    }
	
	    _createClass(Checkboxes, [{
	        key: 'handleCheckChange',
	        value: function handleCheckChange(e) {
	            if (this.props.dataType === 'radio') {
	                this.props.onChange(e.target.checked ? e.target.value : null);
	                this.props.onBlur();
	                return;
	            }
	            var newValues = this.props.value.concat();
	            var idx = newValues.indexOf(e.target.value);
	
	            if (e.target.checked) {
	                if (idx < 0) newValues.push(e.target.value);
	            } else {
	                if (idx > -1) newValues.splice(idx, 1);
	            }
	
	            this.props.onChange(newValues);
	            this.props.onBlur();
	        }
	        //override added input Class Names.
	
	    }, {
	        key: '_createCheckbox',
	        value: function _createCheckbox(option, index, group) {
	
	            var CheckboxTemplate = this.props.itemTemplate;
	            var id = (0, _tutils.path)(this.props.path, group, index);
	            var val = option.val;
	            var labelHTML = option.labelHTML;
	            var label = option.label;
	
	            val = val == null ? label || labelHTML : val;
	            label = labelHTML || label;
	            var value = this.props.value;
	            var labelContent = label ? _react2.default.createElement('span', { dangerouslySetInnerHTML: { __html: label } }) : val;
	            var opts = {
	                onChange: this.handleCheckChange.bind(this),
	                name: group,
	                checked: value ? !! ~value.indexOf(val) : false,
	                id: id,
	                value: val
	            };
	            return _react2.default.createElement(
	                CheckboxTemplate,
	                _extends({ key: 'checkbox-' + index + '-' + group, label: labelContent, type: 'checkbox' }, opts),
	                _react2.default.createElement('input', _extends({ type: this.props.type }, opts))
	            );
	        }
	    }, {
	        key: '_createGroup',
	        value: function _createGroup(option, index, group) {
	            var _props = this.props;
	            var Checkboxes = _props.Checkboxes;
	            var groupTemplate = _props.groupTemplate;
	            var name = _props.name;
	            var value = _props.value;
	
	            var rest = _objectWithoutProperties(_props, ['Checkboxes', 'groupTemplate', 'name', 'value']);
	
	            var GroupTemplate = groupTemplate;
	            return _react2.default.createElement(
	                GroupTemplate,
	                { key: 'checkbox-group-' + index + '-' + option.group, legend: option.legend || option.group },
	                this.makeOptions(option.options, group + '-' + index)
	            );
	        }
	
	        /**
	         * Create the checkbox list HTML
	         * @param {Array}   Options as a simple array e.g. ['option1', 'option2']
	         *                      or as an array of objects e.g. [{val: 543, label: 'Title for object 543'}]
	         * @return {String} HTML
	         */
	
	    }, {
	        key: 'makeOptions',
	        value: function makeOptions(array, group) {
	            var _this2 = this;
	
	            return array.map(function (option, index) {
	                return option.group ? _this2._createGroup(option, index, group) : _this2._createCheckbox(option, index, group);
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	
	            return _react2.default.createElement(
	                'div',
	                { className: this.props.className },
	                this.makeOptions(this.props.options, this.props.path)
	            );
	        }
	    }]);
	
	    return Checkboxes;
	}(_react.Component), _class.inputClassName = ' ', _class.propTypes = {
	    onChange: _PropTypes2.default.valueEvent,
	    options: _PropTypes2.default.options,
	    item: _PropTypes2.default.type,
	    name: _PropTypes2.default.string,
	    itemTemplate: _PropTypes2.default.template,
	    groupTemplate: _PropTypes2.default.template,
	    path: _PropTypes2.default.path,
	    dataType: _PropTypes2.default.dataType,
	    onBlur: _PropTypes2.default.changeValidate
	}, _class.defaultProps = {
	    options: _tutils.FREEZE_ARR,
	    item: 'Text',
	    itemTemplate: 'CheckboxesTemplate',
	    groupTemplate: 'CheckboxesGroupTemplate',
	    //make the value an array regardless of input
	    value: {
	        processor: 'ArrayProcessor'
	    },
	    dataType: "checkbox"
	}, _temp);
	exports.default = Checkboxes;

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ValueManager = __webpack_require__(281);
	
	var _ValueManager2 = _interopRequireDefault(_ValueManager);
	
	var _tutils = __webpack_require__(170);
	
	var _Object = __webpack_require__(296);
	
	var _Object2 = _interopRequireDefault(_Object);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _map = __webpack_require__(253);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _defaults = __webpack_require__(270);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function makeEditPid(path, pid) {
	    return '@' + path.replace(/\./g, '@') + (pid != null ? '@' + pid : '');
	}
	function wrapFunc(value, key) {
	    return { value: value, key: '' + key };
	}
	function remove(obj, key) {
	    if (!obj) return;
	    if (Array.isArray(obj)) {
	        obj.splice(key, 1);
	    } else {
	        delete obj[key];
	    }
	    return obj;
	}
	
	var CollectionMixin = (_temp2 = _class = function (_Component) {
	    _inherits(CollectionMixin, _Component);
	
	    function CollectionMixin() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, CollectionMixin);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(CollectionMixin)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.state = {
	            showAdd: _this.props.showAdd,
	            wrapped: _this.wrapValues(_this.props.value)
	        }, _this.handleMoveUp = function (pos, val) {
	            var values = _this.state.wrapped,
	                oval = values && values.concat();
	            values.splice(Math.max(pos - 1, 0), 0, values.splice(pos, 1)[0]);
	            _this.changeValue(values, oval);
	        }, _this.handleMoveDown = function (pos, val) {
	            var values = _this.state.wrapped,
	                oval = values && values.concat();
	            values.splice(Math.min(pos + 1, values.length), 0, values.splice(pos, 1)[0]);
	            _this.changeValue(values, oval);
	        }, _this.handleDelete = function (pos, val, pid) {
	            var values = _this.state.wrapped,
	                oval = values && values.concat();
	            values.splice(pos, 1);
	            _this.changeValue(values, oval);
	        }, _this.changeValue = function (newValue, oldValue) {
	            if (_this.props.onChange(_this.unwrap(newValue)) !== false) {
	
	                _this.setState({
	                    wrapped: newValue,
	                    showAdd: _this.props.showAdd,
	                    showEdit: false
	                });
	            }
	        }, _this.handleEdit = function (pos, val, pid) {
	            _this.context.valueManager.update(makeEditPid(_this.props.path, pid), {
	                value: (0, _tutils.clone)(val),
	                key: pid
	            });
	            _this.setState({
	                showAdd: false,
	                showEdit: true,
	                editPid: pid
	            });
	        }, _this.handleCancelAdd = function (e) {
	            e && e.preventDefault();
	            _this.setState({ showAdd: _this.props.showAdd, showEdit: false });
	        }, _this.handleBtnClick = function (e, action) {
	            e && e.preventDefault();
	
	            if (action == 'submit') {
	                _this.handleSubmit(e);
	            } else {
	                _this.context.valueManager.update(makeEditPid(_this.props.path, _this.state.editPid));
	                _this.setState({
	                    showAdd: _this.props.showAdd,
	                    showEdit: false,
	                    editPid: null
	                });
	            }
	        }, _this.handleSubmit = function (e) {
	            e && e.preventDefault();
	            var valueManager = _this.context.valueManager;
	
	            var origKey = makeEditPid(_this.props.path, _this.state.editPid);
	            var origValue = valueManager.path(origKey) || {};
	            var key = origValue.key;
	            var value = origValue.value;
	
	            var errors = valueManager.getErrors();
	
	            if (errors == null || Object.keys(errors).length === 0) {
	                var currentPath = (0, _tutils.path)(_this.props.path, key);
	                var clonedValue = _this.props.value == null ? _this.createDefValue() : (0, _tutils.clone)(_this.props.value);
	                if (!_this.props.onSubmit || _this.props.onSubmit(e, errors, value, currentPath) !== false) {
	                    if (key) {
	                        clonedValue[key] = value;
	                        //if the key changed, remove the original.
	                        if (origKey !== makeEditPid(currentPath)) {
	                            remove(clonedValue, _this.state.editPid);
	                        }
	                    } else {
	                        clonedValue.unshift(value);
	                    }
	                    valueManager.update(origKey);
	
	                    _this.props.onChange(clonedValue);
	                }
	
	                //return false;
	            } else {
	                    return false;
	                }
	
	            _this.setState({
	                showAdd: _this.props.showAdd,
	                showEdit: false,
	                editPid: null
	            });
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(CollectionMixin, [{
	        key: 'wrapValues',
	        value: function wrapValues(values) {
	            return (0, _map2.default)(values, wrapFunc);
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(props) {
	            if (props.value !== this.props.value) {
	                this.setValue(props.value);
	            }
	            var showAdd = props.showAdd;
	
	            if (showAdd !== this.props.showAdd) {
	                this.setState({ showAdd: showAdd });
	            }
	        }
	    }, {
	        key: 'getValue',
	        value: function getValue() {
	            return this.unwrap(this.state.wrapped);
	        }
	    }, {
	        key: 'setValue',
	        value: function setValue(value) {
	            this.setState({ wrapped: this.wrapValues(value) });
	        }
	    }, {
	        key: 'setErrors',
	        value: function setErrors(errors) {
	            this.setState({ errors: errors });
	        }
	    }, {
	        key: 'handleAddBtn',
	        value: function handleAddBtn(e) {
	            e && e.preventDefault();
	            var key = this.createPid();
	            this.context.valueManager.update(makeEditPid(this.props.path, key), {
	                key: key
	            });
	            this.setState({ showAdd: true, editPid: key });
	        }
	    }, {
	        key: 'renderAddEditTemplate',
	        value: function renderAddEditTemplate(edit, create) {
	            if (!(edit || create)) {
	                return null;
	            }
	            var childPath = (0, _tutils.path)(this.props.path, this.state.editPid);
	            var _props = this.props;
	            var ObjectType = _props.ObjectType;
	            var createTemplate = _props.createTemplate;
	
	            var CreateTemplate = createTemplate;
	            return _react2.default.createElement(
	                CreateTemplate,
	                { inline: edit ? this.props.inline : false,
	                    create: edit ? false : create,
	                    title: this.props.title, key: 'addEditTemplate' },
	                _react2.default.createElement(ObjectType, { key: 'addEdit',
	                    onButtonClick: this.handleBtnClick,
	                    schema: this.createItemSchema(childPath),
	                    path: makeEditPid(this.props.path, this.state.editPid)
	                })
	            );
	        }
	    }, {
	        key: 'renderAddBtn',
	        value: function renderAddBtn() {
	            if (!this.props.canAdd) {
	                return null;
	            }
	            var btn = (0, _defaults2.default)({}, this.props.addButton, CollectionMixin.defaultProps.addButton);
	            var ButtonTemplate = this.props.buttonTemplate;
	            return _react2.default.createElement(ButtonTemplate, _extends({ key: 'addBtn' }, btn, { onClick: this.handleAddBtn.bind(this),
	                iconClass: this.props.iconAddClass }));
	        }
	    }, {
	        key: 'renderAdd',
	        value: function renderAdd() {
	            if (!(this.props.canAdd || this.props.canEdit)) {
	                return null;
	            }
	            var _state = this.state;
	            var showAdd = _state.showAdd;
	            var showEdit = _state.showEdit;
	
	            if (this.props.inline) {
	                if (showAdd) {
	                    return this.renderAddEditTemplate(false, true);
	                } else {
	                    return this.renderAddBtn();
	                }
	            } else if (!(showAdd || showEdit)) {
	                return this.renderAddBtn();
	            }
	            return this.renderAddEditTemplate(showEdit, showAdd);
	        }
	    }, {
	        key: 'createItemSchema',
	        value: function createItemSchema() {
	            return {
	                schema: this.getTemplateItem(),
	                fieldsets: [{
	                    fields: ['key', 'value'],
	                    buttons: this.props.buttons
	                }]
	
	            };
	        }
	    }, {
	        key: 'renderRowEach',
	        value: function renderRowEach(data, rowId) {
	            return this.renderRow(data, null, rowId);
	        }
	    }, {
	        key: 'renderRow',
	        value: function renderRow(v, sectionId, i) {
	            var _React$createElement;
	
	            var ItemTemplate = this.props.itemTemplate,
	                ContentItemTemplate = this.props.contentTemplate;
	
	            return _react2.default.createElement(
	                ItemTemplate,
	                { key: this.props.path + '.' + i, pos: i, path: (0, _tutils.path)(this.props.path, v.key),
	                    onMoveUp: this.handleMoveUp,
	                    onMoveDown: this.handleMoveDown,
	                    onDelete: this.handleDelete,
	                    onEdit: this.handleEdit,
	                    canReorder: this.props.canReorder,
	                    canDelete: this.props.canDelete,
	                    canEdit: this.props.canEdit,
	                    field: v,
	                    pid: v.key,
	                    value: v, errors: this.props.errors, last: i + 1 === this.state.wrapped.length },
	                this.props.inline && this.state.editPid === v.key ? this.renderAddEditTemplate(v, false) : _react2.default.createElement(ContentItemTemplate, (_React$createElement = { value: v,
	                    labelKey: this.props.labelKey,
	                    pos: i,
	                    pid: v.key
	                }, _defineProperty(_React$createElement, 'value', v), _defineProperty(_React$createElement, 'showKey', this.props.showKey), _defineProperty(_React$createElement, 'onClick', this.props.canEdit ? this.handleEdit : null), _React$createElement))
	            );
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props2 = this.props;
	            var name = _props2.name;
	            var itemType = _props2.itemType;
	            var errors = _props2.errors;
	            var className = _props2.className;
	            var listContainerClassName = _props2.listContainerClassName;
	            var canReorder = _props2.canReorder;
	            var canDelete = _props2.canDelete;
	            var itemTemplate = _props2.itemTemplate;
	            var canEdit = _props2.canEdit;
	            var canAdd = _props2.canAdd;var values = this.state.wrapped || _tutils.FREEZE_ARR;var length = values.length;
	            return _react2.default.createElement(
	                'div',
	                { className: className },
	                this.renderAdd(),
	                _react2.default.createElement(
	                    'ul',
	                    { className: listContainerClassName },
	                    values.map(this.renderRowEach, this)
	                )
	            );
	        }
	    }]);
	
	    return CollectionMixin;
	}(_react.Component), _class.inputClassName = 'list-editor', _class.contextTypes = { valueManager: _PropTypes2.default.valueManager }, _class.propTypes = {
	    onChange: _PropTypes2.default.valueEvent,
	    path: _PropTypes2.default.path,
	    showAdd: _PropTypes2.default.bool,
	    canEdit: _PropTypes2.default.bool,
	    canReorder: _PropTypes2.default.bool,
	    canDelete: _PropTypes2.default.bool,
	    canAdd: _PropTypes2.default.bool,
	    showKey: _PropTypes2.default.bool,
	    inline: _PropTypes2.default.bool,
	    labelKey: _PropTypes2.default.string,
	    itemType: _PropTypes2.default.typeDescription,
	    createTemplate: _PropTypes2.default.template,
	    buttonTemplate: _PropTypes2.default.template,
	    itemTemplate: _PropTypes2.default.template,
	    contentTemplate: _PropTypes2.default.template,
	    buttons: _PropTypes2.default.buttons,
	    addButton: _PropTypes2.default.button,
	    listContainerClassName: _PropTypes2.default.cssClass,
	    ObjectType: _PropTypes2.default.injectClass,
	    value: _PropTypes2.default.value,
	    title: _PropTypes2.default.title
	}, _class.defaultProps = {
	    createTemplate: 'CollectionCreateTemplate',
	    buttonTemplate: 'ButtonTemplate',
	    itemTemplate: 'ListItemTemplate',
	    contentTemplate: "ContentItemTemplate",
	    showKey: false,
	    showAdd: false,
	    itemType: {
	        type: 'Text'
	    },
	    addButton: {
	        "label": "Add",
	        "className": "btn btn-default btn-add"
	    },
	    buttons: {
	        buttonsClass: 'btn-group pull-right',
	        buttons: [{ label: 'Cancel', action: 'cancel', buttonClass: 'btn btn-default' }, { label: 'Save', type: 'submit', action: 'submit', buttonClass: 'btn-primary btn' }]
	    },
	    ObjectType: _Object2.default
	}, _temp2);
	exports.default = CollectionMixin;

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var DateInput = (_temp2 = _class = function (_Component) {
	    _inherits(DateInput, _Component);
	
	    function DateInput() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, DateInput);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(DateInput)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.handleDateChange = function (e) {
	            var value = e.target.value;
	            _this.props.onChange(new Date(value).getTime());
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(DateInput, [{
	        key: 'asInputValue',
	        value: function asInputValue(value) {
	            if (value == null) {
	                return '';
	            }
	            return new Date(value).toISOString().substring(0, 10);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var value = _props.value;
	            var onChange = _props.onChange;
	
	            var props = _objectWithoutProperties(_props, ['value', 'onChange']);
	
	            return _react2.default.createElement('input', _extends({}, props, { onChange: this.handleDateChange, value: this.asInputValue(value) }));
	        }
	    }]);
	
	    return DateInput;
	}(_react.Component), _class.propTypes = {
	    onChange: _PropTypes2.default.valueEvent
	}, _class.defaultProps = {
	    type: "date"
	}, _temp2);
	exports.default = DateInput;

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Hidden does need a template, and does not care about errors.
	 * but we will
	 */
	var Hidden = (_temp = _class = function (_Component) {
	    _inherits(Hidden, _Component);
	
	    function Hidden() {
	        _classCallCheck(this, Hidden);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Hidden).apply(this, arguments));
	    }
	
	    _createClass(Hidden, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var value = _props.value;
	            var asJSON = _props.asJSON;
	
	            var props = _objectWithoutProperties(_props, ['value', 'asJSON']);
	
	            return _react2.default.createElement('input', _extends({}, props, { value: asJSON ? JSON.stringify(value) : value }));
	        }
	        //only unnormal is asJSON, which will set the value to json rather than a string
	        // so that it can be used to hold hidden state of complex structures.
	
	    }]);
	
	    return Hidden;
	}(_react.Component), _class.noTemplate = true, _class.propTypes = {
	    asJSON: _PropTypes2.default.bool
	}, _class.template = false, _class.defaultProps = {
	    type: "hidden",
	    asJSON: false
	}, _temp);
	exports.default = Hidden;

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LazyType = (_temp = _class = function (_Component) {
	    _inherits(LazyType, _Component);
	
	    function LazyType(props) {
	        _classCallCheck(this, LazyType);
	
	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LazyType).call(this, props));
	
	        _this.onResolve = function (resolved) {
	            _this.setState({ resolved: resolved, loaded: true });
	        };
	
	        _this.state = { loaded: false };
	        return _this;
	    }
	
	    _createClass(LazyType, [{
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            var promise = this.props.promise;
	            promise && promise.then(this.onResolve);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            if (this.state.loaded) {
	                var Type = this.state.resolved;
	                var _props = this.props;
	                var promise = _props.promise;
	
	                var props = _objectWithoutProperties(_props, ['promise']);
	
	                return _react2.default.createElement(Type, _extends({ key: 'resolved' }, props));
	            }
	            return _react2.default.createElement('span', { className: 'lazy-loading-type', key: 'unresolved' });
	        }
	    }]);
	
	    return LazyType;
	}(_react.Component), _class.propTypes = {
	    promise: _PropTypes2.default.promise
	}, _temp);
	exports.default = LazyType;

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _tutils = __webpack_require__(170);
	
	var _CollectionMixin2 = __webpack_require__(306);
	
	var _CollectionMixin3 = _interopRequireDefault(_CollectionMixin2);
	
	var _reactAddonsCssTransitionGroup = __webpack_require__(311);
	
	var _reactAddonsCssTransitionGroup2 = _interopRequireDefault(_reactAddonsCssTransitionGroup);
	
	var _get2 = __webpack_require__(275);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _map = __webpack_require__(253);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _defaults = __webpack_require__(270);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ListInput = (_temp = _class = function (_CollectionMixin) {
	    _inherits(ListInput, _CollectionMixin);
	
	    function ListInput() {
	        _classCallCheck(this, ListInput);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(ListInput).apply(this, arguments));
	    }
	
	    _createClass(ListInput, [{
	        key: 'unwrap',
	        value: function unwrap(value) {
	            return (0, _map2.default)(value, 'value');
	        }
	    }, {
	        key: 'createDefValue',
	        value: function createDefValue() {
	            return [];
	        }
	    }, {
	        key: 'createPid',
	        value: function createPid() {
	            return this.state.wrapped.length || 0;
	        }
	    }, {
	        key: 'getTemplateItem',
	        value: function getTemplateItem() {
	            var value = (0, _tutils.isString)(this.props.itemType) ? {
	                type: this.props.itemType
	            } : this.props.itemType || {};
	            value.title = false;
	            return {
	                value: value,
	                key: { title: false, template: false, type: 'Hidden' }
	            };
	        }
	    }]);
	
	    return ListInput;
	}(_CollectionMixin3.default), _class.inputClassName = _CollectionMixin3.default.inputClassName, _temp);
	exports.default = ListInput;

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(312);

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * @providesModule ReactCSSTransitionGroup
	 */
	
	'use strict';
	
	var React = __webpack_require__(2);
	
	var assign = __webpack_require__(39);
	
	var ReactTransitionGroup = __webpack_require__(313);
	var ReactCSSTransitionGroupChild = __webpack_require__(163);
	
	function createTransitionTimeoutPropValidator(transitionType) {
	  var timeoutPropName = 'transition' + transitionType + 'Timeout';
	  var enabledPropName = 'transition' + transitionType;
	
	  return function (props) {
	    // If the transition is enabled
	    if (props[enabledPropName]) {
	      // If no timeout duration is provided
	      if (props[timeoutPropName] == null) {
	        return new Error(timeoutPropName + ' wasn\'t supplied to ReactCSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.');
	
	        // If the duration isn't a number
	      } else if (typeof props[timeoutPropName] !== 'number') {
	          return new Error(timeoutPropName + ' must be a number (in milliseconds)');
	        }
	    }
	  };
	}
	
	var ReactCSSTransitionGroup = React.createClass({
	  displayName: 'ReactCSSTransitionGroup',
	
	  propTypes: {
	    transitionName: ReactCSSTransitionGroupChild.propTypes.name,
	
	    transitionAppear: React.PropTypes.bool,
	    transitionEnter: React.PropTypes.bool,
	    transitionLeave: React.PropTypes.bool,
	    transitionAppearTimeout: createTransitionTimeoutPropValidator('Appear'),
	    transitionEnterTimeout: createTransitionTimeoutPropValidator('Enter'),
	    transitionLeaveTimeout: createTransitionTimeoutPropValidator('Leave')
	  },
	
	  getDefaultProps: function () {
	    return {
	      transitionAppear: false,
	      transitionEnter: true,
	      transitionLeave: true
	    };
	  },
	
	  _wrapChild: function (child) {
	    // We need to provide this childFactory so that
	    // ReactCSSTransitionGroupChild can receive updates to name, enter, and
	    // leave while it is leaving.
	    return React.createElement(ReactCSSTransitionGroupChild, {
	      name: this.props.transitionName,
	      appear: this.props.transitionAppear,
	      enter: this.props.transitionEnter,
	      leave: this.props.transitionLeave,
	      appearTimeout: this.props.transitionAppearTimeout,
	      enterTimeout: this.props.transitionEnterTimeout,
	      leaveTimeout: this.props.transitionLeaveTimeout
	    }, child);
	  },
	
	  render: function () {
	    return React.createElement(ReactTransitionGroup, assign({}, this.props, { childFactory: this._wrapChild }));
	  }
	});
	
	module.exports = ReactCSSTransitionGroup;

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactTransitionGroup
	 */
	
	'use strict';
	
	var React = __webpack_require__(2);
	var ReactTransitionChildMapping = __webpack_require__(314);
	
	var assign = __webpack_require__(39);
	var emptyFunction = __webpack_require__(15);
	
	var ReactTransitionGroup = React.createClass({
	  displayName: 'ReactTransitionGroup',
	
	  propTypes: {
	    component: React.PropTypes.any,
	    childFactory: React.PropTypes.func
	  },
	
	  getDefaultProps: function () {
	    return {
	      component: 'span',
	      childFactory: emptyFunction.thatReturnsArgument
	    };
	  },
	
	  getInitialState: function () {
	    return {
	      children: ReactTransitionChildMapping.getChildMapping(this.props.children)
	    };
	  },
	
	  componentWillMount: function () {
	    this.currentlyTransitioningKeys = {};
	    this.keysToEnter = [];
	    this.keysToLeave = [];
	  },
	
	  componentDidMount: function () {
	    var initialChildMapping = this.state.children;
	    for (var key in initialChildMapping) {
	      if (initialChildMapping[key]) {
	        this.performAppear(key);
	      }
	    }
	  },
	
	  componentWillReceiveProps: function (nextProps) {
	    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(nextProps.children);
	    var prevChildMapping = this.state.children;
	
	    this.setState({
	      children: ReactTransitionChildMapping.mergeChildMappings(prevChildMapping, nextChildMapping)
	    });
	
	    var key;
	
	    for (key in nextChildMapping) {
	      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
	      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
	        this.keysToEnter.push(key);
	      }
	    }
	
	    for (key in prevChildMapping) {
	      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
	      if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
	        this.keysToLeave.push(key);
	      }
	    }
	
	    // If we want to someday check for reordering, we could do it here.
	  },
	
	  componentDidUpdate: function () {
	    var keysToEnter = this.keysToEnter;
	    this.keysToEnter = [];
	    keysToEnter.forEach(this.performEnter);
	
	    var keysToLeave = this.keysToLeave;
	    this.keysToLeave = [];
	    keysToLeave.forEach(this.performLeave);
	  },
	
	  performAppear: function (key) {
	    this.currentlyTransitioningKeys[key] = true;
	
	    var component = this.refs[key];
	
	    if (component.componentWillAppear) {
	      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
	    } else {
	      this._handleDoneAppearing(key);
	    }
	  },
	
	  _handleDoneAppearing: function (key) {
	    var component = this.refs[key];
	    if (component.componentDidAppear) {
	      component.componentDidAppear();
	    }
	
	    delete this.currentlyTransitioningKeys[key];
	
	    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);
	
	    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
	      // This was removed before it had fully appeared. Remove it.
	      this.performLeave(key);
	    }
	  },
	
	  performEnter: function (key) {
	    this.currentlyTransitioningKeys[key] = true;
	
	    var component = this.refs[key];
	
	    if (component.componentWillEnter) {
	      component.componentWillEnter(this._handleDoneEntering.bind(this, key));
	    } else {
	      this._handleDoneEntering(key);
	    }
	  },
	
	  _handleDoneEntering: function (key) {
	    var component = this.refs[key];
	    if (component.componentDidEnter) {
	      component.componentDidEnter();
	    }
	
	    delete this.currentlyTransitioningKeys[key];
	
	    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);
	
	    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
	      // This was removed before it had fully entered. Remove it.
	      this.performLeave(key);
	    }
	  },
	
	  performLeave: function (key) {
	    this.currentlyTransitioningKeys[key] = true;
	
	    var component = this.refs[key];
	    if (component.componentWillLeave) {
	      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
	    } else {
	      // Note that this is somewhat dangerous b/c it calls setState()
	      // again, effectively mutating the component before all the work
	      // is done.
	      this._handleDoneLeaving(key);
	    }
	  },
	
	  _handleDoneLeaving: function (key) {
	    var component = this.refs[key];
	
	    if (component.componentDidLeave) {
	      component.componentDidLeave();
	    }
	
	    delete this.currentlyTransitioningKeys[key];
	
	    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);
	
	    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
	      // This entered again before it fully left. Add it again.
	      this.performEnter(key);
	    } else {
	      this.setState(function (state) {
	        var newChildren = assign({}, state.children);
	        delete newChildren[key];
	        return { children: newChildren };
	      });
	    }
	  },
	
	  render: function () {
	    // TODO: we could get rid of the need for the wrapper node
	    // by cloning a single child
	    var childrenToRender = [];
	    for (var key in this.state.children) {
	      var child = this.state.children[key];
	      if (child) {
	        // You may need to apply reactive updates to a child as it is leaving.
	        // The normal React way to do it won't work since the child will have
	        // already been removed. In case you need this behavior you can provide
	        // a childFactory function to wrap every child, even the ones that are
	        // leaving.
	        childrenToRender.push(React.cloneElement(this.props.childFactory(child), { ref: key, key: key }));
	      }
	    }
	    return React.createElement(this.props.component, this.props, childrenToRender);
	  }
	});
	
	module.exports = ReactTransitionGroup;

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactTransitionChildMapping
	 */
	
	'use strict';
	
	var flattenChildren = __webpack_require__(116);
	
	var ReactTransitionChildMapping = {
	  /**
	   * Given `this.props.children`, return an object mapping key to child. Just
	   * simple syntactic sugar around flattenChildren().
	   *
	   * @param {*} children `this.props.children`
	   * @return {object} Mapping of key to child
	   */
	  getChildMapping: function (children) {
	    if (!children) {
	      return children;
	    }
	    return flattenChildren(children);
	  },
	
	  /**
	   * When you're adding or removing children some may be added or removed in the
	   * same render pass. We want to show *both* since we want to simultaneously
	   * animate elements in and out. This function takes a previous set of keys
	   * and a new set of keys and merges them with its best guess of the correct
	   * ordering. In the future we may expose some of the utilities in
	   * ReactMultiChild to make this easy, but for now React itself does not
	   * directly have this concept of the union of prevChildren and nextChildren
	   * so we implement it here.
	   *
	   * @param {object} prev prev children as returned from
	   * `ReactTransitionChildMapping.getChildMapping()`.
	   * @param {object} next next children as returned from
	   * `ReactTransitionChildMapping.getChildMapping()`.
	   * @return {object} a key set that contains all keys in `prev` and all keys
	   * in `next` in a reasonable order.
	   */
	  mergeChildMappings: function (prev, next) {
	    prev = prev || {};
	    next = next || {};
	
	    function getValueForKey(key) {
	      if (next.hasOwnProperty(key)) {
	        return next[key];
	      } else {
	        return prev[key];
	      }
	    }
	
	    // For each key of `next`, the list of keys to insert before that key in
	    // the combined list
	    var nextKeysPending = {};
	
	    var pendingKeys = [];
	    for (var prevKey in prev) {
	      if (next.hasOwnProperty(prevKey)) {
	        if (pendingKeys.length) {
	          nextKeysPending[prevKey] = pendingKeys;
	          pendingKeys = [];
	        }
	      } else {
	        pendingKeys.push(prevKey);
	      }
	    }
	
	    var i;
	    var childMapping = {};
	    for (var nextKey in next) {
	      if (nextKeysPending.hasOwnProperty(nextKey)) {
	        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
	          var pendingNextKey = nextKeysPending[nextKey][i];
	          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
	        }
	      }
	      childMapping[nextKey] = getValueForKey(nextKey);
	    }
	
	    // Finally, add the keys which didn't appear before any key in `next`
	    for (i = 0; i < pendingKeys.length; i++) {
	      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
	    }
	
	    return childMapping;
	  }
	};
	
	module.exports = ReactTransitionChildMapping;

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _CollectionMixin2 = __webpack_require__(306);
	
	var _CollectionMixin3 = _interopRequireDefault(_CollectionMixin2);
	
	var _tutils = __webpack_require__(170);
	
	var _get2 = __webpack_require__(275);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _defaults = __webpack_require__(270);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MixedInput = (_temp2 = _class = function (_CollectionMixin) {
	    _inherits(MixedInput, _CollectionMixin);
	
	    function MixedInput() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, MixedInput);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(MixedInput)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.uniqueCheck = function (value) {
	            var values = _this.getValue();
	            if (_this.state.editPid == value) {
	                return null;
	            }
	            if (value in values) {
	
	                return {
	                    message: 'Keys must be unique'
	                };
	            }
	            return null;
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(MixedInput, [{
	        key: 'unwrap',
	        value: function unwrap(value) {
	            var ret = {};
	            if (value == null) {
	                return ret;
	            }
	            value.forEach(function (v) {
	                ret[v.key] = v.value;
	            });
	            return ret;
	        }
	    }, {
	        key: 'createPid',
	        value: function createPid() {
	            return '' + this.props.newKeyPrefix + this.state.wrapped.length;
	        }
	    }, {
	        key: 'createDefValue',
	        value: function createDefValue() {
	            return {};
	        }
	    }, {
	        key: 'getTemplateItem',
	        value: function getTemplateItem() {
	            var _props = this.props;
	            var keyType = _props.keyType;
	            var valueType = _props.valueType;
	            var itemType = _props.itemType;
	
	
	            keyType = keyType ? (0, _tutils.isString)(keyType) ? { type: keyType } : keyType : { type: 'Text' };
	
	            var schema = {
	                key: (0, _tutils.isString)(keyType) ? { keyType: keyType } : keyType,
	                value: valueType || itemType
	            };
	
	            (keyType.validators || (keyType.validators = [])).unshift('required', this.uniqueCheck);
	
	            return schema;
	        }
	    }]);
	
	    return MixedInput;
	}(_CollectionMixin3.default), _class.propTypes = (0, _defaults2.default)({
	    labelKey: _PropTypes2.default.string,
	    keyType: _PropTypes2.default.typeDescription,
	    valueType: _PropTypes2.default.typeDescription,
	    value: _PropTypes2.default.value
	}, _CollectionMixin3.default.propTypes), _class.defaultProps = (0, _defaults2.default)({
	    newKeyPrefix: 'new_key',
	    showKey: true,
	    valueType: { type: 'Text' },
	    keyType: { type: 'Text' }
	}, _CollectionMixin3.default.defaultProps), _temp2);
	exports.default = MixedInput;

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var noRe = /^(-|\+)?([0-9]*\.)?$/,
	    numRe = /^(\-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/;
	
	var NumberInput = (_temp = _class = function (_Component) {
	    _inherits(NumberInput, _Component);
	
	    function NumberInput(props) {
	        var _Object$getPrototypeO;
	
	        _classCallCheck(this, NumberInput);
	
	        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            rest[_key - 1] = arguments[_key];
	        }
	
	        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(NumberInput)).call.apply(_Object$getPrototypeO, [this, props].concat(rest)));
	
	        _this.handleDateChange = function (e) {
	
	            var value = e.target.value;
	            //Not a valid number but valid to become a number
	            if (value === '') {
	                _this.props.onChange(null);
	            } else if (noRe.test(value)) {
	                if (/\.$/.test(value)) {
	                    _this.props.onChange(parseFloat(value));
	                    _this.setValue(value);
	                } else {
	                    _this.setValue(value);
	                }
	            } else
	                //check if real actual numbers.
	                if (numRe.test(value)) {
	                    _this.props.onChange(parseFloat(value));
	                } else {
	                    _this.forceUpdate();
	                    return false;
	                }
	        };
	
	        var state = _this.state || (_this.state = {});
	        state.value = props.value;
	
	        return _this;
	    }
	
	    _createClass(NumberInput, [{
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(newProps) {
	            if (newProps.value !== this.props.value) {
	                this.setState({ value: newProps.value });
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var onChange = _props.onChange;
	            var value = _props.value;
	
	            var props = _objectWithoutProperties(_props, ['onChange', 'value']);
	
	            return _react2.default.createElement('input', _extends({}, props, { value: this.state.value, onChange: this.handleDateChange }));
	        }
	    }]);
	
	    return NumberInput;
	}(_react.Component), _class.propTypes = {
	    onChange: _PropTypes2.default.valueEvent
	}, _temp);
	exports.default = NumberInput;

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Password = (_temp = _class = function (_Component) {
	    _inherits(Password, _Component);
	
	    function Password() {
	        _classCallCheck(this, Password);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Password).apply(this, arguments));
	    }
	
	    _createClass(Password, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('input', this.props);
	        }
	    }]);
	
	    return Password;
	}(_react.Component), _class.defaultProps = {
	    type: 'password'
	}, _temp);
	exports.default = Password;

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _tutils = __webpack_require__(170);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function compare(val, val2) {
	    if (val == null && val2 == null) {
	        return true;
	    }
	    if (val == null || val2 == null) return false;
	    return '' + val === '' + val2;
	}
	
	var RadioInput = (_temp = _class = function (_Component) {
	    _inherits(RadioInput, _Component);
	
	    function RadioInput() {
	        _classCallCheck(this, RadioInput);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(RadioInput).apply(this, arguments));
	    }
	
	    _createClass(RadioInput, [{
	        key: 'handleCheckChange',
	        value: function handleCheckChange(e) {
	            //Make a radio behave like a checkbox when there is only 1.
	            if (this.props.forceSelection === false || this.props.options && this.props.options.length === 1) {
	                this.props.onChange(compare(e.target.value, this.props.value) ? null : e.target.value);
	            } else {
	                this.props.onChange(e.target.value);
	            }
	        }
	    }, {
	        key: 'makeOptions',
	        value: function makeOptions(options) {
	            var _this2 = this;
	
	            options = options || [];
	            var onChange = this.handleCheckChange.bind(this);
	            var value = this.props.value;
	            var path = this.props.path;
	            return options.map(function (option, index) {
	                var val = option.val;
	                var label = option.label;
	                var labelHTML = option.labelHTML;
	
	                var path = (0, _tutils.path)(path, index);
	                return {
	                    val: val,
	                    path: path,
	                    label: label,
	                    onChange: onChange,
	                    checkedClass: _this2.props.checkedClass,
	                    checked: compare(value, val)
	                };
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var name = _props.name;
	            var itemTemplate = _props.itemTemplate;
	            var className = _props.className;
	            var checkedClass = _props.checkedClass;
	            var value = _props.value;
	            var options = _props.options;
	            var field = _props.field;
	
	            var options = this.makeOptions(options);
	            var RadioItemTemplate = itemTemplate;
	            return _react2.default.createElement(
	                'div',
	                { className: className },
	                options.map(function (option, index) {
	                    var id = options.id || name + '.' + index;
	                    return _react2.default.createElement(
	                        RadioItemTemplate,
	                        _extends({ id: id, checkedClass: checkedClass }, option, { key: option.path }),
	                        _react2.default.createElement('input', _extends({ id: id, type: 'radio',
	                            name: name }, option, { value: option.val }))
	                    );
	                }, this)
	            );
	        }
	    }]);
	
	    return RadioInput;
	}(_react.Component), _class.inputClassName = '  ', _class.defaultProps = {
	    itemTemplate: 'RadioItemTemplate',
	    options: [],
	    forceSelection: false
	}, _class.propTypes = {
	    onChange: _PropTypes2.default.valueEvent,
	    itemTemplate: _PropTypes2.default.template,
	    forceSelection: _PropTypes2.default.bool,
	    checkedClass: _PropTypes2.default.cssClass,
	    options: _PropTypes2.default.options.isRequired
	}, _temp);
	exports.default = RadioInput;

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(162);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _RestrictedMixin2 = __webpack_require__(320);
	
	var _RestrictedMixin3 = _interopRequireDefault(_RestrictedMixin2);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Restricted = (_temp2 = _class = function (_RestrictedMixin) {
	    _inherits(Restricted, _RestrictedMixin);
	
	    function Restricted() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Restricted);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Restricted)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.handleSelectionRange = function (caret) {
	            var input = _this.refs && _reactDom2.default.findDOMNode(_this.refs.input);
	            if (!input) return;
	
	            if (_this.state.caret != null) input && input.setSelectionRange(_this.state.caret, _this.state.caret);
	        }, _this.handleValueChange = function (e) {
	            _this._value(e.target.value, false);
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(Restricted, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var onValid = _props.onValid;
	            var formatter = _props.formatter;
	            var onChange = _props.onChange;
	            var onKeyDown = _props.onKeyDown;
	            var value = _props.value;
	
	            var props = _objectWithoutProperties(_props, ['onValid', 'formatter', 'onChange', 'onKeyDown', 'value']);
	
	            return _react2.default.createElement('input', _extends({ ref: 'input' }, props, { value: this.state.value, onKeyDown: this.handleKeyDown,
	                onChange: this.handleValueChange }));
	        }
	    }]);
	
	    return Restricted;
	}(_RestrictedMixin3.default), _class.contextTypes = _PropTypes2.default.contextTypes, _class.defaultProps = {
	    onValid: _tutils.noop
	}, _class.propTypes = {
	    onValid: _PropTypes2.default.validEvent,
	    onChange: _PropTypes2.default.valueEvent,
	    formatter: _PropTypes2.default.string
	}, _temp2);
	exports.default = Restricted;

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var zipRe = /^(\d{0,5})(?:[^\d]?(\d{0,4}))?$/,
	    reRe = /(#{1,}|A{1,}|a{1,}|0{1,}(?:\.0{1,})?)?(.+?)?/mg;
	
	function lastEq(input, val) {
	    return input && input[input.length - 1] === val;
	}
	
	function fixDelim(str) {
	    return (str || '').replace(/([ ().-])/g, '\\$1');
	}
	
	function ret(exact, val, d, backward) {
	    return exact != null && exact === d ? exact : exact == null || exact == '' ? val : exact;
	}
	
	function fmt(delim, placeholder) {
	    delim = delim || '';
	    function fmt$return(exact, val, d, backward) {
	        if (placeholder && !backward) {
	            return delim;
	        }
	        if (exact === d) {
	            return exact || '';
	        }
	        return exact == null || exact === '' ? val : backward ? exact : exact + delim;
	    };
	    fmt$return.placeholder = placeholder;
	    return fmt$return;
	}
	
	function upper(delim) {
	    return function fmt$return(exact, val, d, backward) {
	        exact = (ret(exact, val, d) || '').toUpperCase();
	        return backward ? exact : exact + delim;
	    };
	}
	function lower(delim) {
	    return function fmt$return(exact, val, d, backward) {
	        exact = (ret(exact, val, d) || '').toUpperCase();
	        return backward ? exact : exact + delim;
	    };
	}
	function _pad(value, length, right) {
	    value = value || '';
	    while (value.length < length) {
	        if (right) {
	            value += '0';
	        } else {
	            value = '0' + value;
	        }
	    }
	    return value;
	}
	function pad(delim, padding) {
	    var parts = padding.split('.', 2);
	    return function fmt$return(exact, val, d, backward) {
	        exact = ret(exact, val, d).split('.', 2);
	        return _pad(exact[0], parts[0].length, false) + (parts.length > 1 ? '.' + _pad(exact[1], parts[1].length, true) : '');
	    };
	}
	function defaultValidator(value, regex) {
	    return regex.test(value);
	}
	function findCharPosAfter(value, char, pos) {
	    for (var i = pos, l = value.length; i < l; i++) {
	        if (value[i] === char) {
	            return i + 1;
	        }
	    }
	    return value.length;
	}
	function makeFormatter(format, validator) {
	    validator = validator || defaultValidator;
	    var parts;
	    var pattern = '',
	        validPattern = '';
	    var handlers = [];
	    reRe.lastIndex = 0;
	    while ((parts = reRe.exec(format)) != null && parts.index < format.length) {
	        var first = parts[1],
	            delim = parts[2],
	            exact;
	        switch (first && first[0] || '') {
	            //mixed case
	            case 'M':
	                {
	                    exact = '(\\[a-zA-Z]{' + first.length + '})';
	                    pattern += exact + '|(\\[a-zA-Z]{0,' + (first.length - 1) + '})';
	                    validPattern += exact;
	                    handlers.push(fmt(delim));
	                    break;
	                }
	            //upper case
	            case 'A':
	                {
	                    exact = '(\\[A-Z]{' + first.length + '})';
	                    pattern += exact + '|(\\[a-zA-Z]{0,' + (first.length - 1) + '})';
	                    validPattern += exact;
	                    handlers.push(upper(delim));
	
	                    break;
	                }
	            //lower case
	            case 'a':
	                {
	                    exact = '(\\[A-Z]{' + first.length + '})';
	                    pattern += exact + '|(\\[a-zA-Z]{0,' + (first.length - 1) + '})';
	                    validPattern += exact;
	                    handlers.push(lower(delim));
	
	                    break;
	                }
	            //padding
	            case '0':
	                exact = '(\\d{' + first.length + ',})';
	                pattern += '(' + exact + '|(\\d{0,}))(?:[^\\d])?';
	                validPattern += exact + fixDelim(delim);
	                handlers.push(pad(delim, first));
	                break;
	
	            //Number
	            case '#':
	                {
	                    var fdelim = fixDelim(delim);
	                    exact = '(\\d{' + first.length + '})';
	                    pattern += '(' + exact + '|(\\d{0,' + (first.length - 1) + '}))(?:' + fdelim + '|[^\\d]+?)?';
	                    validPattern += exact + fdelim;
	                    handlers.push(fmt(delim));
	                    break;
	                }
	            default:
	                {
	                    //empty pattern so that the patterns
	                    // and the input align when its a non matching pattern
	                    var fdelim = fixDelim(delim);
	                    exact = '(' + fdelim + ')';
	                    pattern += '(' + fdelim + '|)()(?:' + fdelim + '|(!' + fdelim + '))?';
	                    validPattern += '()(' + fdelim + ')';
	                    handlers.push(fmt(delim, true));
	                    break;
	                }
	        }
	    }
	    var re = new RegExp('^' + pattern),
	        vre = new RegExp('^' + validPattern + '$', 'g');
	    return function makeFormatter$formatter(input, isBackward, end) {
	        vre.lastIndex = re.index = re.lastIndex = 0;
	        var idx = 0,
	            d = 0,
	            p,
	            parts = re.exec(input),
	            position = end || 0;
	        parts.shift();
	        //remove delimeters
	
	        parts = re.exec(clean(parts));
	        parts.shift();
	        while (parts.length) {
	            p = parts[parts.length - 1];
	            if (p == null || p == '') parts.pop();else break;
	        }
	        var incr = handlers.length;
	        var value = '',
	            done = false;
	        for (var i = 0, l = incr * 3; i < l; i += 3, d++) {
	
	            /*if (parts[i] == '' && parts[i + 1] == null) {
	             break;
	             }*/
	            var isNextPlaceholder = parts[i] !== parts[i + 2] && handlers[d + 1] && handlers[d + 1].placeholder === true;
	            done = i + 3 !== l ? parts[i + 3] == null && parts[i + 4] == null ? isBackward ? true : !isNextPlaceholder : false : isNextPlaceholder;
	            value += handlers[d](parts[i], parts[i + 1], parts[i + 2], done ? isBackward : false);
	            if (done) {
	                break;
	            }
	        }
	        if (!isBackward && end) {
	            position = findCharPosAfter(value, input[end], end);
	        }
	        return {
	            isValid: validator(value, vre),
	            value: value,
	            position: position
	        };
	    };
	}
	
	//So we only care about every 3rd group.  Remove delimeters
	// and such, so the next parse can have something nice to work with.
	function clean(parts) {
	    var p = '';
	    for (var i = 0; i < parts.length; i += 3) {
	        p += parts[i] || '';
	    }
	    return p;
	}
	
	function defaultValidator(value, regex) {
	    return regex.test(value);
	}
	var dd_yyyy = makeFormatter('##/####');
	
	function shortDate(value, isBackspace, caret) {
	    var ref = dd_yyyy(value, isBackspace, caret);
	    var parts = /(\d{1,2})([^\d]+?)?(\d{0,4})?/.exec(value) || [];
	    var position = ref.position;
	    var str = '';
	
	    var _parts = _slicedToArray(parts, 4);
	
	    var whole = _parts[0];
	    var mm = _parts[1];
	    var delim = _parts[2];
	    var last = _parts[3];
	    var mmInt = parseInt(mm || '0', 10);
	
	    //invalid month, best guess
	
	    if (!isBackspace) {
	        //13->01/3
	        if (parseInt(mm, 10) > 12) {
	            str = '0' + mm[0] + '/';
	            last = mm[1] + (last == null ? '' : last);
	        } else
	            //11->11/
	            if (delim) {
	                str = (mmInt < 10 ? '0' + mmInt : mmInt) + '/';
	            } else if (mmInt > 9) {
	                str = mmInt + '/';
	            } else if (mmInt > 1) {
	                str = '0' + mmInt + '/';
	            } else if (!mm) {
	                //swallow
	            } else if (mm.length === 2) {
	                    str = mm + '/';
	                } else {
	                    str = mm;
	                }
	
	        if (last) {
	            last = parseInt(last, 10);
	            if (last === 2) {
	                str += '2';
	            } else if (last < 2) {
	                str += '20' + last;
	            } else if (last === 20) {
	                str += '20';
	            } else if (last < 21) {
	                str += '20' + last;
	            } else if (last > 100) {
	                str += last;
	            } else if (last > 10) {
	                str += '20' + last;
	            }
	        }
	    } else {
	        str = ref.value;
	    }
	    var isValid = false;
	    if (str.length === 7) {
	        isValid = true;
	        var parts = str.split('/');
	        parts.push(parts.pop().replace(/^20/, ''));
	        str = parts.join('/');
	    } else {
	        str = str.substring(0, 7);
	    }
	    return {
	        value: str,
	        isValid: isValid,
	        position: position
	    };
	};
	function createValidator(validator, loader) {
	    if (validator === void 0) {
	        return defaultValidator;
	    }
	    if (typeof validator === 'function') {
	        return validator;
	    }
	    if (typeof validator === 'string') {
	        validator = loader.loadValidator(validator)();
	        return function (value) {
	            return !validator(value);
	        };
	    }
	    if (validator instanceof RegExp) {
	        return RegExp.prototype.test.bind(re);
	    }
	    throw 'Do not know what to do with ' + validator;
	}
	function _title(value) {
	    if (value.length === 0) {
	        return value;
	    }
	    return value.substring(0, 1).toUpperCase() + value.substring(1);
	}
	var RestrictedMixin = (_temp = _class = function (_Component) {
	    _inherits(RestrictedMixin, _Component);
	
	    function RestrictedMixin(props) {
	        var _Object$getPrototypeO;
	
	        _classCallCheck(this, RestrictedMixin);
	
	        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            rest[_key - 1] = arguments[_key];
	        }
	
	        var _this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(RestrictedMixin)).call.apply(_Object$getPrototypeO, [this, props].concat(rest)));
	
	        _this.handleKeyDown = function (e) {
	            if (_this.props.onKeyDown) {
	                _this.props.onKeyDown.call(_this, e);
	            }
	            var pos = e.target.selectionStart,
	                end = e.target.selectionEnd,
	                value = _this.state.value || '';
	            if (e.key === 'Enter') {
	                _this.props.onValid(_this.state.hasValidValue, {
	                    isValid: _this.state.hasValidValue,
	                    value: _this.state.value
	                });
	                return;
	            }
	            if (e.key === 'Delete') {
	                e.preventDefault();
	                value = value.substring(0, pos) + value.substring(end);
	                _this._value(value, false, pos);
	                return;
	            }
	            if (e.key === 'Backspace') {
	                e.preventDefault();
	                e.stopPropagation();
	                var back = false;
	                if (pos === end) {
	                    value = value.trim().substring(0, value.length - 1);
	                    back = true;
	                } else {
	                    value = value.substring(0, pos) + value.substring(end);
	                }
	                _this._value(value, back, pos + value.length);
	                return;
	            }
	            if (e.key !== 'Unidentified') {
	                return;
	            }
	            /* if (e.key === 'Shift'){
	             this._shift = true;
	             return
	             }
	             */
	            if (pos < value.length) {
	                //This prevents onChange from firing.
	                e.preventDefault();
	                e.stopPropagation();
	                var nvalue = value.split('');
	                var char = String.fromCharCode(e.keyCode);
	                if (!e.shiftKey) {
	                    char = char.toLowerCase();
	                }
	                nvalue.splice(pos, Math.max(end - pos, 1), char);
	                _this._value(nvalue.join(''), false, pos);
	            }
	        };
	
	        if (!_this.state) {
	            _this.state = {};
	        }
	        return _this;
	    }
	
	    _createClass(RestrictedMixin, [{
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            this._handleProps(this.props);
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(props) {
	            this._handleProps(props);
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.handleSelectionRange(this.state.caret);
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.handleSelectionRange(this.state.caret);
	        }
	    }, {
	        key: '_handleProps',
	        value: function _handleProps(props) {
	            if (props && 'value' in props && props.value !== this.state.value) {
	                var value = props.value ? this.formatter(props.value) : {
	                    isValid: false,
	                    value: ''
	                };
	                this.state.value = value.value;
	                this.state.hasValidValue = value.isValid;
	            }
	        }
	    }, {
	        key: 'formatter',
	        value: function formatter(value, isBackspace, caret) {
	            if (this._formatter) {
	                return this._formatter.call(this, value, isBackspace, caret);
	            }
	            var formatter = this.props.formatter;
	
	            if (typeof formatter === 'string') {
	                formatter = RestrictedMixin.formatters[formatter] || formatter;
	                if (typeof formatter === 'function') {
	                    return (this._formatter = formatter).call(this, value, isBackspace, caret);
	                } else {
	                    return (this._formatter = makeFormatter(formatter, createValidator(this.props.validator, this.context.loader))).call(this, value, isBackspace);
	                }
	            } else if (typeof formatter === 'function') {
	                return (this._formatter = formatter).call(this, value, isBackspace, caret);
	            }
	            (0, _warning2.default)(false, 'Did not find a formatter for %s', this.props.formatter);
	            return { value: value };
	        }
	    }, {
	        key: 'handleState',
	        value: function handleState(str, isBackspace, caret) {
	            var value = this.formatter(str, isBackspace, caret) || { isValid: false };
	
	            if (caret != null && typeof value.position === 'number') {
	                if (isBackspace) {
	                    caret += value.position - 1;
	                } else {
	                    caret = value.position;
	                }
	            }
	            var state = this.state;
	            state.caret = caret;
	            state.value = value.value;
	            state.hasValue = value.value != null && value.value.length !== 0;
	            state.hasValidValue = value.isValid;
	            /*
	             this.setState({
	             caret,
	             value: value.value,
	             hasValue: value.value != null && value.value.length !== 0,
	             hasValidValue: value.isValid
	             }, this.handleSelectionRange);
	             */
	            return value;
	        }
	    }, {
	        key: '_value',
	        value: function _value(str, isBackspace, caret) {
	            var value = this.handleState(str, isBackspace, caret);
	            this.props.onChange(value.value);
	            this.props.onValid(value.isValid, value);
	        }
	    }]);
	
	    return RestrictedMixin;
	}(_react.Component), _class.makeFormatter = makeFormatter, _class.formatters = {
	    uszip: function uszip(value, isBackspace, position) {
	        value = (value || '').substring(0, 10);
	        var parts = zipRe.exec(value) || [],
	            isValid = false;
	
	        if (parts) {
	            if (parts[2]) {
	                value = parts[1] + '-' + parts[2];
	            } else {
	                value = parts[1] || '';
	            }
	            isValid = value.length === 5 || value.length === 10;
	        } else {
	            value = '';
	        }
	
	        return {
	            value: value,
	            isValid: isValid
	        };
	    },
	    capitalize: function capitalize(value, isBackward, position) {
	        value = value || '';
	        var isValid = value && value.length > 2 || false;
	        if (isBackward) {
	            position--;
	        } else {
	            position++;
	            value = _title(value);
	        }
	        return {
	            value: value,
	            isValid: isValid,
	            position: position
	        };
	    },
	    title: function title(value, isBackward, position) {
	        value = value || '';
	        var isValid = value && value.length > 2 || false;
	        if (isBackward) {
	            position--;
	        } else {
	            value = value.replace(/([^\s]*)(\s*)/g, _title);
	            position++;
	        }
	        return {
	            value: value,
	            isValid: isValid,
	            position: position
	        };
	    },
	
	    creditcard: '#### #### #### ####',
	    mm20YY: shortDate,
	    shortDate: shortDate
	}, _temp);
	exports.default = RestrictedMixin;

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Select = (_temp2 = _class = function (_Component) {
	    _inherits(Select, _Component);
	
	    function Select() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Select);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Select)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.handleSelect = function (e) {
	            var _this$props = _this.props;
	            var multiple = _this$props.multiple;
	            var placeholder = _this$props.placeholder;
	
	            if (multiple) {
	                //normalize multiple  selection
	                var values = [],
	                    options = e.target.options,
	                    i = 0,
	                    l = options.length,
	                    option;
	                for (; i < l; i++) {
	                    option = options[i];
	                    if (option.selected) {
	                        if (option.label != placeholder) values.push(option.value);
	                    }
	                }
	                _this.props.onChange(values);
	                return;
	            } else if (e.target.value === placeholder) {
	                _this.props.onChange(null);
	                return;
	            }
	            _this.props.onChange(e.target.value);
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(Select, [{
	        key: 'renderOptions',
	        value: function renderOptions(value) {
	            var _props = this.props;
	            var multiple = _props.multiple;
	            var options = _props.options;
	            var placeholder = _props.placeholder;
	
	
	            options = options || [];
	            var hasValue = false,
	                ret = options.map(multiple ? function (o, i) {
	                return _react2.default.createElement(
	                    'option',
	                    { key: 's' + i, value: o.val },
	                    o.label
	                );
	            } : function (o, i) {
	                if (!hasValue && o.val + '' == value + '') hasValue = true;
	                return _react2.default.createElement(
	                    'option',
	                    { key: 's' + i, value: o.val },
	                    o.label
	                );
	            });
	
	            if (placeholder) {
	                ret.unshift(_react2.default.createElement(
	                    'option',
	                    { key: 'null-' + options.length },
	                    placeholder
	                ));
	            }
	            return ret;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props2 = this.props;
	            var onChange = _props2.onChange;
	            var value = _props2.value;
	
	            var props = _objectWithoutProperties(_props2, ['onChange', 'value']);
	
	            if (props.multiple && !(0, _tutils.isArray)(value)) {
	                value = value ? [value] : value;
	            }
	            return _react2.default.createElement(
	                'select',
	                _extends({}, props, { value: value, onChange: this.handleSelect }),
	                this.renderOptions(value)
	            );
	        }
	    }]);
	
	    return Select;
	}(_react.Component), _class.propTypes = {
	    options: _PropTypes2.default.options,
	    multiple: _PropTypes2.default.bool,
	    onChange: _PropTypes2.default.valueEvent,
	    placeholder: _PropTypes2.default.placeholder
	}, _class.defaultProps = {
	    options: [],
	    multiple: false
	}, _temp2);
	exports.default = Select;

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = substitute;
	
	var _escape = __webpack_require__(323);
	
	var _escape2 = _interopRequireDefault(_escape);
	
	var _get = __webpack_require__(275);
	
	var _get2 = _interopRequireDefault(_get);
	
	var _defaults = __webpack_require__(270);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	var _isObject = __webpack_require__(178);
	
	var _isObject2 = _interopRequireDefault(_isObject);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function escapeGet(obj, key) {
	    return (0, _escape2.default)((0, _get2.default)(obj, key, ''));
	}
	
	function substitute(str) {
	
	    if (str == null) {
	        str = '';
	    }
	    var checks = {};
	
	    function substitute$inner(v, key) {
	        checks[key] = true;
	        return "'+(escapeGet(obj, '" + key + "'))+'";
	    }
	
	    str = str.replace(/'/g, "\\'");
	    var format = new Function('escapeGet', 'obj', "obj = obj || {}; return \'" + str.replace(/\{([^\{\}]*)\}/g, substitute$inner) + "'").bind(null, escapeGet);
	    var listen = Object.keys(checks);
	    return {
	        format: format,
	        listen: listen
	    };
	}

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(228),
	    escapeHtmlChar = __webpack_require__(324);
	
	/** Used to match HTML entities and HTML characters. */
	var reUnescapedHtml = /[&<>"'`]/g,
	    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
	
	/**
	 * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
	 * their corresponding HTML entities.
	 *
	 * **Note:** No other characters are escaped. To escape additional characters
	 * use a third-party library like [_he_](https://mths.be/he).
	 *
	 * Though the ">" character is escaped for symmetry, characters like
	 * ">" and "/" don't need escaping in HTML and have no special meaning
	 * unless they're part of a tag or unquoted attribute value.
	 * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	 * (under "semi-related fun fact") for more details.
	 *
	 * Backticks are escaped because in Internet Explorer < 9, they can break out
	 * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	 * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
	 * for more details.
	 *
	 * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
	 * to reduce XSS vectors.
	 *
	 * @static
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escape('fred, barney, & pebbles');
	 * // => 'fred, barney, &amp; pebbles'
	 */
	function escape(string) {
	  // Reset `lastIndex` because in IE < 9 `String#replace` does not.
	  string = baseToString(string);
	  return (string && reHasUnescapedHtml.test(string))
	    ? string.replace(reUnescapedHtml, escapeHtmlChar)
	    : string;
	}
	
	module.exports = escape;


/***/ },
/* 324 */
/***/ function(module, exports) {

	/** Used to map characters to HTML entities. */
	var htmlEscapes = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;',
	  '`': '&#96;'
	};
	
	/**
	 * Used by `_.escape` to convert characters to HTML entities.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped character.
	 */
	function escapeHtmlChar(chr) {
	  return htmlEscapes[chr];
	}
	
	module.exports = escapeHtmlChar;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TextInput = (_temp = _class = function (_Component) {
	    _inherits(TextInput, _Component);
	
	    function TextInput() {
	        _classCallCheck(this, TextInput);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(TextInput).apply(this, arguments));
	    }
	
	    _createClass(TextInput, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('input', this.props);
	        }
	    }]);
	
	    return TextInput;
	}(_react.Component), _class.defaultProps = {
	    type: 'text'
	}, _temp);
	exports.default = TextInput;

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TextArea = function (_Component) {
	    _inherits(TextArea, _Component);
	
	    function TextArea() {
	        _classCallCheck(this, TextArea);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(TextArea).apply(this, arguments));
	    }
	
	    _createClass(TextArea, [{
	        key: "render",
	        value: function render() {
	            return _react2.default.createElement("textarea", this.props);
	        }
	    }]);
	
	    return TextArea;
	}(_react.Component);

	exports.default = TextArea;

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var context = __webpack_require__(328),
	    api = {}; //make sure you have your directory and regex test set correctly!
	context.keys().forEach(function (key) {
	    var k = key.replace(/^\.\/(.*)\.js(x)?$/, '$1');
	    api[k] = context(key).default;
	});
	module.exports = api;

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./ArrayProcessor.js": 329,
		"./OptionsProcessor.js": 330,
		"./index.js": 327
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 328;


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _tutils = __webpack_require__(170);
	
	var api = { value: _tutils.toArray };
	exports.default = api;

/***/ },
/* 330 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var api = {
	    /** fetch will be called when value changes **/
	
	    fetch: function fetch(url, value, component, cb) {
	        value = value && value.toLowerCase();
	        var data = (component.props.options || []).filter(function (v) {
	            var l = ('' + v.val).toLowerCase();
	            if (l.indexOf(value) > -1) {
	                return true;
	            }
	        });
	
	        cb(null, data);
	    },
	
	    /**Value returns the value of the object, not necessarily whats in the input box**/
	    value: function value(obj) {
	        return obj == null ? null : obj.val || obj;
	    },
	
	    /**
	     * Format returns the format.
	     * @param v
	     * @returns {null}
	     */
	    format: function format(v) {
	        return v == null ? null : v.label || v;
	    }
	};
	exports.default = api;

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	//==================================================================================================
	//VALIDATORS
	//==================================================================================================
	//Borrowed from backbone-forms, thanks!
	
	module.exports = function (_) {
	
	    var validators = {};
	
	    validators.errMessages = {
	        required: 'Required',
	        regexp: 'Invalid',
	        number: 'Must be a number',
	        email: 'Invalid email address',
	        url: 'Invalid URL',
	        match: function match(field) {
	            return 'Must match field "{}"';
	        }
	    };
	
	    validators.required = function (options) {
	        options = _.extend({
	            type: 'required',
	            message: validators.errMessages.required
	        }, options);
	
	        return function required(value) {
	            options.value = value;
	
	            var err = {
	                type: options.type,
	                message: _.isFunction(options.message) ? options.message(options) : options.message
	            };
	
	            if (value === null || value === undefined || value === false || value === '') return err;
	        };
	    };
	
	    validators.regexp = function (options) {
	        if (!options.regexp) throw new Error('Missing required "regexp" option for "regexp" validator');
	
	        options = _.extend({
	            type: 'regexp',
	            match: true,
	            message: validators.errMessages.regexp
	        }, options);
	
	        return function regexp(value) {
	            options.value = value;
	
	            var err = {
	                type: options.type,
	                message: _.isFunction(options.message) ? options.message(options) : options.message
	            };
	
	            //Don't check empty values (add a 'required' validator for validators)
	            if (value === null || value === undefined || value === '') return;
	
	            //Create RegExp from string if it's valid
	            if ('string' === typeof options.regexp) options.regexp = new RegExp(options.regexp.replace(/^\/(.*)\/$/, '$1'), options.flags);
	
	            if (options.match ? !options.regexp.test(value) : options.regexp.test(value)) return err;
	        };
	    };
	
	    validators.number = function (options) {
	        options = _.extend({
	            type: 'number',
	            message: validators.errMessages.number,
	            regexp: /^[0-9]*\.?[0-9]*?$/
	        }, options);
	
	        return validators.regexp(options);
	    };
	
	    validators.email = function (options) {
	        options = _.extend({
	            type: 'email',
	            message: validators.errMessages.email,
	            regexp: /^[\w\-]{1,}([\w\-\+.]{1,1}[\w\-]{1,}){0,}[@][\w\-]{1,}([.]([\w\-]{1,})){1,3}$/
	        }, options);
	
	        return validators.regexp(options);
	    };
	
	    validators.url = function (options) {
	        options = _.extend({
	            type: 'url',
	            message: validators.errMessages.url,
	            regexp: /^(http|https):\/\/(([A-Z0-9][A-Z0-9_\-]*)(\.[A-Z0-9][A-Z0-9_\-]*)+)(:(\d+))?\/?/i
	        }, options);
	
	        return validators.regexp(options);
	    };
	
	    validators.match = function (options) {
	        if (!options.field) throw new Error('Missing required "field" options for "match" validator');
	
	        options = _.extend({
	            type: 'match',
	            message: validators.errMessages.match
	        }, options);
	
	        return function match(value, attrs) {
	            options.value = value;
	
	            var err = {
	                type: options.type,
	                message: _.isFunction(options.message) ? options.message(options) : options.message
	            };
	
	            //Don't check empty values (add a 'required' validator for validators)
	            if (value === null || value === undefined || value === '') return;
	
	            if (value !== attrs.path(options.field)) return err;
	        };
	    };
	
	    return validators;
	}(__webpack_require__(170));

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var styleCtx = __webpack_require__(333);
	var lessCtx = __webpack_require__(348);
	
	var api = {};
	/**
	 * This loads the style.js and then the less/css files merging
	 * the styles from the css if they exist.
	 */
	styleCtx.keys().reduce(function (obj, key) {
	    obj[key.replace(/^\.\/(.*)-style\.js$/, '$1')] = styleCtx(key);
	    return obj;
	}, api);
	
	lessCtx.keys().reduce(function (obj, key) {
	    var nkey = key.replace(/^\.\/(.*)\.(less|css)$/, '$1');
	    var cobj = obj[nkey];
	    var Style = lessCtx(key);
	    if (cobj) {
	        Object.keys(Style).forEach(function (skey) {
	            if (cobj[skey]) {
	                cobj[skey] += ' ' + Style[skey];
	            } else {
	                cobj[skey] = Style[skey];
	            }
	        });
	    } else {
	        obj[nkey] = Style;
	    }
	    return obj;
	}, api);
	
	console.log('style', api);
	module.exports = api;

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./AutocompleteItemTemplate-style.js": 334,
		"./ButtonsTemplate-style.js": 335,
		"./CheckboxTemplate-style.js": 336,
		"./CheckboxesGroupTemplate-style.js": 337,
		"./CollectionCreateTemplate-style.js": 338,
		"./CollectionMixin-style.js": 339,
		"./EditorTemplate-style.js": 340,
		"./FormTemplate-style.js": 341,
		"./ItemToStringTemplate-style.js": 342,
		"./List-style.js": 343,
		"./ListItemTemplate-style.js": 344,
		"./Mixed-style.js": 345,
		"./ModalTemplate-style.js": 346,
		"./RadioItemTemplate-style.js": 347
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 333;


/***/ },
/* 334 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    item: 'addr_itm list-group-item ',
	    focused: 'focused'
	};

/***/ },
/* 335 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    buttons: 'col-sm-offset-2 col-sm-10 btn-group',
	    button: 'btn',
	    buttonContainer: "form-group",
	    primary: 'btn-primary'
	};

/***/ },
/* 336 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	    "checkbox": "checkbox",
	    "checked": "checked"
	};

/***/ },
/* 337 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	    "group": "group"
	};

/***/ },
/* 338 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    panel: "panel panel-default clearfix",
	    panelTitle: 'panel-title clearfix',
	    panelHeading: 'panel-heading',
	    panelBody: "panel-body",
	    group: "form-group",
	    inline: "clearfix"
	};

/***/ },
/* 339 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	    addBtn: 'btn btn-xs btn-default',
	    iconAdd: "icon-add"
	};

/***/ },
/* 340 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    field: 'form-group field-name ',
	    label: "col-sm-2 control-label",
	    error: 'error-block help-block',
	    help: 'help-block',
	    hasError: 'has-error',
	    hasTitle: "col-sm-10",
	    noTitle: "col-sm-12"
	};

/***/ },
/* 341 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    //use to be form-horizontal
	    formClass: ''
	};

/***/ },
/* 342 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	    label: "brf-value list-group-item-text"
	};

/***/ },
/* 343 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	    item: "brf-value list-group-item-text"
	};

/***/ },
/* 344 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    moveUp: 'glyphicon glyphicon-chevron-up btn-up',
	    moveDown: 'glyphicon glyphicon-chevron-down btn-down',
	    delete: 'glyphicon glyphicon-remove btn-delete',
	    itemValue: "item-value btn-edit",
	    button: 'btn btn-xs btn-default',
	    listGroupItem: 'list-group-item',
	    hasError: 'has-error',
	    help: "help-block",
	    clickable: 'clickable',
	    ctrlButtons: 'btn-group'
	};

/***/ },
/* 345 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	    item: "brf-key list-group-item-heading",
	    itemInner: "brf-value list-group-item-text",
	    buttonsClass: 'btn-group pull-right',
	    buttonCancel: 'btn btn-default',
	    buttonSave: 'btn-primary btn'
	};

/***/ },
/* 346 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	    namespace: 'modal',
	    backdrop: "modal-backdrop fade in",
	    dialog: "modal-dialog",
	    content: "modal-content",
	    close: 'close',
	    body: 'modal-body clearfix',
	    header: 'modal-header',
	    footer: "modal-footer",
	    overlay: ''
	};

/***/ },
/* 347 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    namespace: "radio",
	    checked: '',
	    unchecked: ''
	};

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./Autocomplete.less": 349,
		"./ListItemTemplate.less": 353,
		"./WizardProgressTemplate.less": 355,
		"./WizardTemplate.less": 357
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 348;


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(350);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(352)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./Autocomplete.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./Autocomplete.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(351)();
	// imports
	
	
	// module
	exports.push([module.id, ".Autocomplete__namespace___1NT1- {\n  position: relative;\n}\n.Autocomplete__found___3PuLD .form-control {\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.Autocomplete__found___3PuLD .Autocomplete__listGroup___1B9Z5 {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  z-index: 1000;\n  width: 100%;\n  padding-left: 0;\n}\n.Autocomplete__found___3PuLD .list-group-item:first-child {\n  border-top-right-radius: 0;\n  border-top-left-radius: 0;\n  border-top: none;\n}\n.Autocomplete__found___3PuLD .list-group-item {\n  cursor: pointer;\n}\n.Autocomplete__found___3PuLD .list-group-item:hover {\n  background-color: #eee;\n}\n.Autocomplete__found___3PuLD .focused {\n  background-color: #ddd;\n}\n", ""]);
	
	// exports
	exports.locals = {
		"namespace": "Autocomplete__namespace___1NT1-",
		"found": "Autocomplete__found___3PuLD",
		"listGroup": "Autocomplete__listGroup___1B9Z5"
	};

/***/ },
/* 351 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(354);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(352)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./ListItemTemplate.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./ListItemTemplate.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(351)();
	// imports
	
	
	// module
	exports.push([module.id, ".ListItemTemplate__ctrlButtons___fQXC_ {\n  position: absolute;\n  top: 5px;\n  right: 5px;\n  display: inline-block;\n  min-width: 10px;\n  font-size: 12px;\n  font-weight: 700;\n  line-height: 1;\n  color: #fff;\n  text-align: center;\n  white-space: nowrap;\n  vertical-align: baseline;\n  border-radius: 10px;\n}\n.ListItemTemplate__listEditor___3Ll14 > ul {\n  margin-top: 10px;\n  padding-left: 0;\n}\n", ""]);
	
	// exports
	exports.locals = {
		"ctrlButtons": "ListItemTemplate__ctrlButtons___fQXC_",
		"listEditor": "ListItemTemplate__listEditor___3Ll14"
	};

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(356);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(352)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./WizardProgressTemplate.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./WizardProgressTemplate.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(351)();
	// imports
	
	
	// module
	exports.push([module.id, ".WizardProgressTemplate__namespace___1ypeo {\n  margin: 0;\n  padding-bottom: 2.2rem;\n  list-style-type: none;\n  display: table;\n  padding-left: 0;\n  padding-right: 0;\n  width: 100%;\n}\n.WizardProgressTemplate__todo___3RSiL,\n.WizardProgressTemplate__doing___3tsOf,\n.WizardProgressTemplate__done___3bWTB {\n  text-align: center;\n  line-height: 4.5rem;\n  padding: 0 0.7rem;\n  cursor: pointer;\n  display: table-cell;\n}\n.WizardProgressTemplate__todo___3RSiL {\n  color: silver;\n  border-bottom: 4px solid silver;\n}\n.WizardProgressTemplate__doing___3tsOf {\n  color: black;\n  border-bottom: 4px solid #33C3F0;\n}\n.WizardProgressTemplate__done___3bWTB {\n  color: black;\n  border-bottom: 4px solid #33C3F0;\n}\n.WizardProgressTemplate__todo___3RSiL span,\n.WizardProgressTemplate__doing___3tsOf span,\n.WizardProgressTemplate__done___3bWTB span {\n  padding: 0 1.5rem;\n}\n.WizardProgressTemplate__todo___3RSiL em,\n.WizardProgressTemplate__doing___3tsOf em,\n.WizardProgressTemplate__done___3bWTB em {\n  display: none;\n  font-weight: 700;\n  padding-left: 1rem;\n}\n.WizardProgressTemplate__todo___3RSiL:before,\n.WizardProgressTemplate__doing___3tsOf:before,\n.WizardProgressTemplate__done___3bWTB:before {\n  position: relative;\n  bottom: -3.7rem;\n  float: left;\n  left: 50%;\n}\n.WizardProgressTemplate__doing___3tsOf:hover:before,\n.WizardProgressTemplate__done___3bWTB:hover:before {\n  color: #0FA0CE;\n}\n.WizardProgressTemplate__todo___3RSiL:hover:before {\n  color: #203c31;\n}\n.WizardProgressTemplate__todo___3RSiL:before {\n  content: \"\\2022\";\n  color: white;\n  background-color: silver;\n  border-color: white;\n  border-width: 1px;\n  width: 1.2em;\n  height: 1.2em;\n  border-width: 0px;\n  line-height: 1.2em;\n  border-radius: 1.2em;\n}\n.WizardProgressTemplate__doing___3tsOf:before {\n  content: \"\\2022\";\n  color: white;\n  background-color: #33C3F0;\n  width: 1.2em;\n  line-height: 1.2em;\n  border-radius: 1.2em;\n}\n.WizardProgressTemplate__done___3bWTB:before {\n  content: \"\\2713\";\n  color: white;\n  background-color: #33C3F0;\n  width: 1.2em;\n  line-height: 1.2em;\n  border-radius: 1.2em;\n}\n", ""]);
	
	// exports
	exports.locals = {
		"namespace": "WizardProgressTemplate__namespace___1ypeo",
		"todo": "WizardProgressTemplate__todo___3RSiL",
		"doing": "WizardProgressTemplate__doing___3tsOf",
		"done": "WizardProgressTemplate__done___3bWTB"
	};

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(358);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(352)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./WizardTemplate.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./WizardTemplate.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(351)();
	// imports
	
	
	// module
	exports.push([module.id, ".WizardTemplate__transitionContainer___36qMc {\n  display: inline-block;\n  white-space: nowrap;\n  vertical-align: top;\n  min-width: 100%;\n}\n.WizardTemplate__transitionContainer___36qMc form {\n  background-color: #fff;\n  display: inline-block;\n  min-width: 100%;\n  white-space: normal;\n  vertical-align: top;\n}\n", ""]);
	
	// exports
	exports.locals = {
		"transitionContainer": "WizardTemplate__transitionContainer___36qMc"
	};

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var styleCtx = __webpack_require__(360);
	var lessCtx = __webpack_require__(362);
	
	/**
	 * This loads the style.js and then the less/css files merging
	 * the styles from the css if they exist.
	 */
	module.exports = lessCtx.keys().reduce(function (obj, key) {
	    var nkey = key.replace(/^\.\/(.*)\.(less|css)$/, '$1');
	    var cobj = obj[nkey];
	    var Style = lessCtx(key);
	    if (cobj) {
	        Object.keys(cobj).forEach(function (skey) {
	            ['Enter', 'Leave', 'Appear'].reduce(function (obj, k) {
	                var lkey = k.toLowerCase();
	                var nobj = obj.transitionName || (obj.transitionName = {});
	                if (Style['' + skey + k]) {
	                    nobj[lkey] = Style['' + skey + k];
	                    nobj[lkey + 'Active'] = Style['' + skey + k + 'Active'];
	                }
	                return obj;
	            }, cobj[skey])['transitionHeightClass'] = Style[skey + 'Height'];
	        });
	    } else {
	        obj[nkey] = Style;
	    }
	    return obj;
	},
	//First find the style.js.
	styleCtx.keys().reduce(function (obj, key) {
	    obj[key.replace(/^\.\/(.*)-style\.js$/, '$1')] = styleCtx(key);
	
	    return obj;
	}, {}));

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./transitions-style.js": 361
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 360;


/***/ },
/* 361 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	    rollUp: {
	        transitionAppearTimeout: 800,
	        transitionEnterTimeout: 800,
	        transitionLeaveTimeout: 800
	    },
	    slideLeft: {
	        transitionAppearTimeout: 500,
	        transitionEnterTimeout: 500,
	        transitionLeaveTimeout: 500
	    },
	    slideRight: {
	        transitionAppearTimeout: 500,
	        transitionEnterTimeout: 500,
	        transitionLeaveTimeout: 500
	    }
	};

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./transitions.less": 363
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 362;


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(364);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(352)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./transitions.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../../node_modules/less-loader/index.js!./transitions.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(351)();
	// imports
	
	
	// module
	exports.push([module.id, ".transitions__rollUpLeave___3vANd {\n  transform: translate(0, 0);\n  opacity: 1;\n}\n.transitions__rollUpLeave___3vANd.transitions__rollUpLeaveActive___wnuLX {\n  transform: translate(0, -100%);\n  opacity: 0;\n  transition: opacity 800ms ease-in-out, transform 800ms ease-in-out;\n}\n.transitions__rollUpEnter___39MsO,\n.transitions__rollUpAppear___YJA3N {\n  transform: translate(0, -100%);\n  opacity: 0;\n}\n.transitions__rollUpEnter___39MsO.transitions__rollUpEnterActive___MEUfZ,\n.transitions__rollUpAppear___YJA3N.transitions__rollUpEnterActive___MEUfZ,\n.transitions__rollUpEnter___39MsO.transitions__rollUpAppearActive___Q-K2T,\n.transitions__rollUpAppear___YJA3N.transitions__rollUpAppearActive___Q-K2T {\n  transform: translate(0, 0);\n  opacity: 1;\n  transition: opacity 800ms ease-in-out, transform 800ms ease-in-out;\n}\n.transitions__rollUpHeight____tNEb {\n  transition: height 800ms ease-in-out;\n}\n.transitions__slideRightLeave___21N0k {\n  transition: transform 500ms ease-in-out;\n  transform: translate(0, 0);\n}\n.transitions__slideRightLeaveActive___33RMp {\n  transform: translate(100%, 0);\n}\n.transitions__slideRightEnter___2cTx3,\n.transitions__slideRightAppear___cXjW1 {\n  transition: transform 500ms ease-in-out;\n  transform: translate(-100%, 0);\n}\n.transitions__slideRightEnterActive___1dtZe,\n.transitions__slideRightAppearActive___2Mjye {\n  transform: translate(0, 0);\n}\n.transitions__slideRightHeight___1IFAQ {\n  transition: height 500ms ease-in-out;\n}\n.transitions__slideLeftLeave___29_p4 {\n  transition: transform 500ms ease-in-out;\n  transform: translate(0, 0);\n}\n.transitions__slideLeftLeaveActive___2Cl5D {\n  transform: translate(-100%, 0);\n}\n.transitions__slideLeftEnter___nTeqA,\n.transitions__slideLeftAppear___1ZANj {\n  transition: transform 500ms ease-in-out;\n  transform: translate(100%, 0);\n}\n.transitions__slideLeftEnterActive___38hrt,\n.transitions__slideLeftAppearActive___3L8Zy {\n  transform: translate(0, 0);\n}\n.transitions__slideLeftHeight___3qA-y {\n  transition: height 500ms ease-in-out;\n}\n", ""]);
	
	// exports
	exports.locals = {
		"rollUpLeave": "transitions__rollUpLeave___3vANd",
		"rollUpLeaveActive": "transitions__rollUpLeaveActive___wnuLX",
		"rollUpEnter": "transitions__rollUpEnter___39MsO",
		"rollUpAppear": "transitions__rollUpAppear___YJA3N",
		"rollUpEnterActive": "transitions__rollUpEnterActive___MEUfZ",
		"rollUpAppearActive": "transitions__rollUpAppearActive___Q-K2T",
		"rollUpHeight": "transitions__rollUpHeight____tNEb",
		"slideRightLeave": "transitions__slideRightLeave___21N0k",
		"slideRightLeaveActive": "transitions__slideRightLeaveActive___33RMp",
		"slideRightEnter": "transitions__slideRightEnter___2cTx3",
		"slideRightAppear": "transitions__slideRightAppear___cXjW1",
		"slideRightEnterActive": "transitions__slideRightEnterActive___1dtZe",
		"slideRightAppearActive": "transitions__slideRightAppearActive___2Mjye",
		"slideRightHeight": "transitions__slideRightHeight___1IFAQ",
		"slideLeftLeave": "transitions__slideLeftLeave___29_p4",
		"slideLeftLeaveActive": "transitions__slideLeftLeaveActive___2Cl5D",
		"slideLeftEnter": "transitions__slideLeftEnter___nTeqA",
		"slideLeftAppear": "transitions__slideLeftAppear___1ZANj",
		"slideLeftEnterActive": "transitions__slideLeftEnterActive___38hrt",
		"slideLeftAppearActive": "transitions__slideLeftAppearActive___3L8Zy",
		"slideLeftHeight": "transitions__slideLeftHeight___3qA-y"
	};

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ctx = __webpack_require__(366);
	module.exports = ctx.keys().reduce(function (ret, key) {
	    var imp = ctx(key);
	    ret[key.replace(/.*\/(.*)\.jsx?$/, '$1')] = Object.keys(imp).reduce(function (o, k) {
	        o[k] = imp[k];
	        return o;
	    }, imp.default);
	    return ret;
	}, {});

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./blurValidate.js": 367,
		"./changeValidate.js": 369,
		"./conditional.js": 370,
		"./content.js": 372,
		"./dataType.js": 373,
		"./domType.js": 374,
		"./error.js": 375,
		"./errorEvent.js": 376,
		"./errors.js": 377,
		"./event.js": 378,
		"./expression.js": 379,
		"./field.js": 380,
		"./fieldAttrs.js": 383,
		"./fields.js": 384,
		"./fieldset.js": 385,
		"./htmlFor.js": 386,
		"./id.js": 387,
		"./injectClass.js": 388,
		"./injectedClass.js": 389,
		"./listener.js": 390,
		"./operator.js": 391,
		"./options.js": 392,
		"./processor.js": 393,
		"./schema.js": 394,
		"./style.js": 395,
		"./targetEvent.js": 396,
		"./template.js": 381,
		"./title.js": 397,
		"./transition.js": 398,
		"./type.js": 382,
		"./typeClass.js": 399,
		"./validate.js": 368,
		"./value.js": 400,
		"./valueEvent.js": 403
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 366;


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = blurValidate;
	
	var _validate = __webpack_require__(368);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Blur validate follows the behaviour
	 *
	 * if a field has not changed and blurred no validation.
	 * if a field has changed and blurred validate.
	 * if a validate listener is called validate.
	 *
	 * @param Clazz
	 * @param key
	 */
	function blurValidate(Clazz, key) {
	
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	
	    this.property.call(Clazz, key, function blurValidate$prop(validate, key, props, context) {
	        if (validate == null) return void 0;
	        validate = typeof validate === 'function' ? validate : _validate.loadValidators.call(this, validate, key, props, context);
	
	        var path = props.path;
	
	
	        var hasChanged = false,
	            hasBlurred = false;
	
	        this._validateListener = context.valueManager.addValidateListener(path, function () {
	            return validate();
	        }).remove;
	
	        this._validateChangeListeners = context.valueManager.addListener(path, function (val) {
	            //fires onChange so its true.
	            hasChanged = true;
	            //at some point it has blurred
	            if (hasBlurred) {
	                validate(val);
	            }
	        }, this, false).remove;
	
	        //blur event if its changed we will validate.
	        return function handleBlur(e) {
	            hasBlurred = true;
	            if (hasChanged) {
	                validate();
	            }
	        }.bind(this);
	    });
	
	    this.unmount.call(Clazz, function () {
	        this._validateChangeListeners && this._validateChangeListeners();
	        this._validateListener && this._validateListener();
	    });
	}

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.loadValidators = loadValidators;
	exports.default = validate;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function initValidators(nval) {
	    if (typeof nval === 'function') {
	        return nval;
	    }
	    if (typeof nval === 'string') {
	        return this.loadValidator(nval)({});
	    }
	    return this.loadValidator(nval.type)(nval);
	}
	
	function loadValidators(value, key, props, _ref) {
	    var loader = _ref.loader;
	    var valueManager = _ref.valueManager;
	
	    var validators = (0, _tutils.toArray)(value).map(initValidators, loader);
	    return function () {
	
	        var v = arguments.length === 0 ? valueManager.path(props.path) : arguments.length <= 0 ? undefined : arguments[0];
	        var length = validators.length;
	        var errors = null;
	        for (var i = 0; i < length; i++) {
	            var error = validators[i](v, valueManager);
	            if (error != null) {
	                if (errors == null) {
	                    errors = [];
	                }
	                if (!Array.isArray(error)) {
	                    errors.push(error);
	                } else {
	                    var _errors;
	
	                    (_errors = errors).push.apply(_errors, _toConsumableArray(error));
	                }
	            }
	        }
	        valueManager.updateErrors(props.path, errors);
	        return errors;
	    };
	}
	
	function validate(Clazz, key) {
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	
	    this.property.call(Clazz, key, loadValidators);
	}

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = changeValidate;
	
	var _validate = __webpack_require__(368);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Validates on change, used in checkbox.  As it needs validation without blur.  In cases like text,
	 * the behaviour is different.
	 *
	 * @param Clazz
	 * @param key
	 */
	function changeValidate(Clazz, key) {
	
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	
	    this.property.call(Clazz, key, function blurValidate$prop(validate, key, props, context) {
	        if (validate == null) return _tutils.noop;
	        validate = typeof validate === 'function' ? validate : _validate.loadValidators.call(this, validate, key, props, context);
	
	        var path = props.path;
	
	
	        this._validateListener = context.valueManager.addValidateListener(path, function () {
	            return validate();
	        }).remove;
	
	        this._validateChangeListeners = context.valueManager.addListener(path, function (val) {
	            validate(val);
	        }, this, false).remove;
	
	        //blur event if its changed we will validate.
	        return validate;
	    });
	
	    this.unmount.call(Clazz, function () {
	        this._validateChangeListeners && this._validateChangeListeners();
	        this._validateListener && this._validateListener();
	    });
	}

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.normalize = normalize;
	exports.default = conditional;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _Conditional = __webpack_require__(371);
	
	var _Conditional2 = _interopRequireDefault(_Conditional);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var settings = exports.settings = {
	    operator: "truthy",
	    Conditional: _Conditional2.default
	};
	
	function normalize(value, key, props, _ref) {
	    var injector = _ref.injector;
	
	    if (value == null || value === false) {
	        return value;
	    }
	    var Conditional = injector.inject(settings.Conditional);
	    var conditional = typeof value === 'string' ? _extends({}, settings, { Conditional: Conditional, operator: value }) : _extends({}, settings, {
	        Conditional: Conditional
	    }, value);
	    return conditional;
	}
	/**
	 * Configures the configurable object.
	 *
	 * @param Clazz
	 * @param key
	 */
	function conditional(Clazz, key) {
	
	    Clazz.contextTypes.injector = _PropTypes2.default.injector;
	
	    this.property.call(Clazz, key, normalize);
	}

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _ReactCSSReplaceTransition = __webpack_require__(161);
	
	var _ReactCSSReplaceTransition2 = _interopRequireDefault(_ReactCSSReplaceTransition);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Conditional = (_temp = _class = function (_Component) {
	    _inherits(Conditional, _Component);
	
	    function Conditional() {
	        _classCallCheck(this, Conditional);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Conditional).apply(this, arguments));
	    }
	
	    _createClass(Conditional, [{
	        key: 'renderTemplate',
	        value: function renderTemplate() {
	            var Template = this.props.template;
	            var _props = this.props;
	            var value = _props.value;
	            var listen = _props.listen;
	            var error = _props.error;
	            var template = _props.template;
	            var falseTemplate = _props.falseTemplate;
	            var dismiss = _props.dismiss;
	            var operator = _props.operator;
	            var transition = _props.transition;
	            var children = _props.children;
	
	            var props = _objectWithoutProperties(_props, ['value', 'listen', 'error', 'template', 'falseTemplate', 'dismiss', 'operator', 'transition', 'children']);
	
	            if (dismiss) {
	                children = _react2.default.cloneElement(children, { dismiss: dismiss });
	            }
	            return Template ? _react2.default.createElement(
	                Template,
	                _extends({ key: 'true-conditional' }, props),
	                children
	            ) : children;
	        }
	    }, {
	        key: 'renderFalseTemplate',
	        value: function renderFalseTemplate() {
	            var FalseTemplate = this.props.falseTemplate;
	
	            var _props2 = this.props;
	            var value = _props2.value;
	            var listen = _props2.listen;
	            var error = _props2.error;
	            var template = _props2.template;
	            var falseTemplate = _props2.falseTemplate;
	            var dismiss = _props2.dismiss;
	            var operator = _props2.operator;
	            var transition = _props2.transition;
	            var children = _props2.children;
	
	            var props = _objectWithoutProperties(_props2, ['value', 'listen', 'error', 'template', 'falseTemplate', 'dismiss', 'operator', 'transition', 'children']);
	
	            return FalseTemplate ? _react2.default.createElement(
	                FalseTemplate,
	                _extends({ key: 'false-conditional' }, props),
	                children
	            ) : _react2.default.createElement('span', { key: 'false-conditional' });
	        }
	    }, {
	        key: 'renderContent',
	        value: function renderContent() {
	
	            var isMatch = this.props.operator(this.props.listen, this.props.value);
	            // console.log('isMatch', this.props.listen, this.props.value);
	            return isMatch ? this.renderTemplate() : this.renderFalseTemplate();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            if (!this.props.transition) {
	                return this.renderContent();
	            }
	            return _react2.default.createElement(
	                _ReactCSSReplaceTransition2.default,
	                this.props.transition,
	                this.renderContent()
	            );
	        }
	    }]);
	
	    return Conditional;
	}(_react.Component), _class.contextTypes = _PropTypes2.default.contextTypes, _class.displayName = "Conditional", _class.defaultProps = {
	    operator: "!=",
	    animate: false,
	    error: null,
	    listen: '.',
	    value: null
	}, _class.propTypes = {
	    /**
	     * Current path of the component
	     */
	    path: _PropTypes2.default.path,
	    /**
	     * The value  to use too compare against  if not given, than
	     * it will be a compare against null.
	     */
	    value: _PropTypes2.default.any,
	    /**
	     * The path to listen to can be empty,
	     * in which case will look for
	     * defaults to the current path.
	     */
	    listen: _PropTypes2.default.listener,
	
	    /**
	     * The template to use if it evaluates to true
	     * IE - Modal, ShowHide
	     */
	    template: _PropTypes2.default.template,
	    /**
	     * The template to use if it evaluates to false
	     * defaults to a null span
	     */
	    falseTemplate: _PropTypes2.default.template,
	    /**
	     * A string to use  a named transition,or a boolean.
	     *
	     * if a string that string will be the "name" to use to animate.
	     * If an object is passed than it will passed as props to the transition group.
	     * If === true than the default animation will be used.
	     * If === false than no animation is used
	     *
	     */
	    transition: _PropTypes2.default.transition,
	    /**
	     * How to compare the value to the matched value.
	     * If ommitted and a value is given than === is used.
	     * If ommitted and the value is omitted than a !(value == null) is used.
	     *
	     */
	    operator: _PropTypes2.default.operator,
	    /**
	     * Listen to an error rather than the mutually exclusive with listen.
	     */
	    error: _PropTypes2.default.error,
	    /**
	     * Path to update to make conditional false.
	     */
	    dismiss: _PropTypes2.default.path,
	
	    buttons: _PropTypes2.default.buttons,
	    field: _PropTypes2.default.any
	}, _temp);
	exports.default = Conditional;

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	exports.loadContent = loadContent;
	exports.default = content;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _Content = __webpack_require__(269);
	
	var _Content2 = _interopRequireDefault(_Content);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var settings = exports.settings = {
	    Content: _Content2.default
	};
	function loadContent(content, key, props, _ref) {
	    var injector = _ref.injector;
	
	
	    var Content = injector.inject(settings.Content);
	    return {
	        Content: Content,
	        content: content
	    };
	}
	
	function content(Clazz, key) {
	
	    Clazz.contextTypes.injector = _PropTypes2.default.injector;
	    this.property.call(Clazz, key, loadContent);
	};

/***/ },
/* 373 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Convert the dataType property to the type property.  Only
	 * useful for making schema conversions easier, and avoid conflicts with
	 * type types.
	 *
	 * @param Clazz
	 * @param props
	 * @param key
	 * @param value
	 */
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = dataType;
	function dataType(Clazz, key, propTypeKeys) {
	
	    //array of keys to allow for prop type renames.  This should not happen much, but we have dataType->type conversion.
	    propTypeKeys.splice(propTypeKeys.indexOf(key), 1, 'type');
	
	    this.extendPrototype.call(Clazz, 'componentWillMount', function dataType$willMount() {
	        this.injected.type = this.props[key];
	    });
	
	    this.extendPrototype.call(Clazz, 'componentWillReceiveProps', function dataType$willRecieveProps(newProps) {
	        if (this.props[key] !== newProps[key]) {
	            this.injected.type = this.props[key];
	        }
	    });
	}

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.loadType = loadType;
	exports.default = type;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var DOM = _react2.default.DOM || _tutils.FREEZE_OBJ;
	
	//Expose for configurability
	var settings = exports.settings = {
	    type: 'span'
	};
	
	function loadType(val, key, props, _ref) {
	    var loader = _ref.loader;
	    var injector = _ref.injector;
	
	    var _ref2 = typeof val === 'string' ? _extends({}, settings, {
	        type: val
	    }) : val == null ? settings : _extends({}, settings, val);
	
	    var type = _ref2.type;
	
	    var rest = _objectWithoutProperties(_ref2, ['type']);
	
	    if (DOM[type]) {
	        return type;
	    }
	
	    var Type = loader.loadType(type);
	
	    var injectedClazz = injector.inject(Type, null, rest);
	    return injectedClazz;
	}
	
	function type(Clazz, key, propList, OrigClazz) {
	
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	    Clazz.contextTypes.injector = _PropTypes2.default.injector;
	
	    this.property.call(Clazz, key, loadType);
	}

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = error;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function handleErrorListeners(value, key, props, _ref) {
	    var _this = this;
	
	    var valueManager = _ref.valueManager;
	
	    var resolvedPath = (0, _tutils.resolveKey)(props.path, value);
	    return valueManager.addErrorListener(resolvedPath, function (err) {
	        _this.injected[key] = err && err[0] && err[0].message;
	        _this.mounted && _this.forceUpdate();
	    }, this, true).remove;
	}
	
	function error(Clazz, key) {
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	
	    this.listener.call(Clazz, key, handleErrorListeners);
	}

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = errorEvent;
	
	var _tutils = __webpack_require__(170);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function errorUpdate(value, key, props, context) {
	    var resolvedKey = (0, _tutils.resolveKey)(props.path, value);
	    return function (val) {
	        return context.valueManager.updateErrors(resolvedKey, val);
	    };
	}
	
	function errorEvent(Clazz, key) {
	
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	
	    this.property.call(Clazz, errorUpdate);
	}

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = errors;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function handleErrorsListeners(value, key, props, _ref) {
	    var _this = this;
	
	    var valueManager = _ref.valueManager;
	
	    return valueManager.addErrorListener((0, _tutils.resolveKey)(props.path, value), function (err, old, path) {
	        var errors = _this.injected[key] || (_this.injected[key] = {});
	        if (err) {
	            errors[path] = err;
	        } else {
	            delete errors[path];
	        }
	        _this.injected[key] = Object.keys(errors).length > 0 ? errors : null;
	        _this.mounted && _this.forceUpdate();
	    }, this, true).remove;
	}
	
	/**
	 * Listens to errors on the path and returns them.  This is similar to resolvers/error except
	 * that it provides the path and all errors.
	 *
	 * @param Clazz
	 * @param key
	 */
	function errors(Clazz, key) {
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	
	    this.listener.call(Clazz, key, handleErrorsListeners);
	}

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = event;
	
	var _tutils = __webpack_require__(170);
	
	function handleEvent(value) {
	    if (value == null) return _tutils.noop;
	    return value;
	}
	
	function event(Clazz, key) {
	    this.property.call(Clazz, key, handleEvent);
	}

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = expression;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _SubstituteMixin2 = __webpack_require__(322);
	
	var _SubstituteMixin3 = _interopRequireDefault(_SubstituteMixin2);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function handleExpression(value, key, props, context) {
	    var scope = this;
	    var expressionVals = {};
	    var valueManager = context.valueManager;
	
	    var _SubstituteMixin = (0, _SubstituteMixin3.default)(value);
	
	    var listen = _SubstituteMixin.listen;
	    var format = _SubstituteMixin.format;
	    var injected = this.injected;
	    var path = props.path;
	
	    var ret = listen.reduce(function (fn, v) {
	        if (!(v in expressionVals)) {
	            //only need to listen to a value once.
	            var resolvedKey = (0, _tutils.resolveKey)(path, v);
	            return (0, _tutils.applyFuncs)(valueManager.addListener(resolvedKey, function (val) {
	                if (!(v in expressionVals) || expressionVals[v] !== val) {
	                    //if the values don't cange the state don't change.
	                    expressionVals[v] = val == null ? '' : val;
	                    injected[key] = format(expressionVals);
	                    scope.forceUpdate();
	                }
	            }, null, true).remove, fn);
	        }
	        return fn;
	    }, null);
	    return ret;
	}
	
	function expression(Clazz, key) {
	
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	
	    this.listener.call(Clazz, key, handleExpression);
	}

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = field;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	var _template = __webpack_require__(381);
	
	var _type = __webpack_require__(382);
	
	var _validate = __webpack_require__(368);
	
	var _Conditional = __webpack_require__(371);
	
	var _Conditional2 = _interopRequireDefault(_Conditional);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var settings = exports.settings = {
	    type: 'Text',
	    template: 'EditorTemplate'
	};
	
	function bare(value) {
	    var type = value.type;
	    var template = value.template;
	
	    var rest = _objectWithoutProperties(value, ['type', 'template']);
	
	    return rest;
	}
	function spreadable(value) {
	    var key = arguments.length <= 1 || arguments[1] === undefined ? 'template' : arguments[1];
	
	    if (value == null) {
	        return _tutils.FREEZE_OBJ;
	    }
	    if (typeof value === 'string' || typeof value === 'boolean' || typeof value === 'function') {
	        return _defineProperty({}, key, value);
	    }
	
	    if (!key in value) {
	        return _tutils.FREEZE_OBJ;
	    }
	    return value;
	}
	
	function field(Clazz, key, propList) {
	
	    var setts = bare(settings);
	
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	    Clazz.contextTypes.injector = _PropTypes2.default.injector;
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	
	    this.property.call(Clazz, key, function field$prop(value, key, props, context, OrigClazz) {
	
	        if (value == null) {
	            var copy = _objectWithoutProperties(settings, []);
	
	            value = copy;
	        } else if (typeof value === 'string') {
	            value = _extends({}, settings, { type: value });
	        } else if (!value.type) {
	            value.type = settings.type;
	        }
	        if (value.validators) {
	            value.validators = (0, _validate.loadValidators)(value.validators, key, props, context);
	        }
	        if (value.conditional) {
	            if (value.conditional === 'string') {
	                value.conditional = { operator: value.conditional };
	            }
	        }
	        var Type = (0, _type.loadType)(value.type, null, null, context);
	        var Template = void 0;
	        if (value.template === false) {
	            Template = null;
	        } else if (value.template) {
	            var lookup = _extends({}, spreadable(settings.template), spreadable(Type.template), spreadable(value.template));
	            Template = (0, _template.loadTemplate)(lookup, key, props, context);
	        } else if ('template' in Type) {
	            //template is false with no override.
	            if (Type.template === false) {
	                Template = null;
	            } else {
	                var _lookup = _extends({}, spreadable(settings.template), spreadable(Type.template));
	                Template = (0, _template.loadTemplate)(_lookup, key, props, context);
	            }
	        } else {
	            Template = (0, _template.loadTemplate)(settings.template, key, props, context);
	        }
	
	        return _extends({}, setts, bare(value), {
	            Type: Type,
	            Template: Template
	        });
	    });
	}

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.normalize = normalize;
	exports.loadTemplate = loadTemplate;
	exports.default = template;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var settings = exports.settings = {
	    propTypes: {
	        className: _PropTypes2.default.cssClass,
	        id: _PropTypes2.default.id,
	        fieldClass: _PropTypes2.default.fieldClass
	    }
	};
	
	function normalize(template) {
	    var _settings = arguments.length <= 1 || arguments[1] === undefined ? settings : arguments[1];
	
	    if (template == null) {
	        return _settings;
	    }
	
	    if (typeof template === 'string' || typeof template === 'function') {
	        return { template: template };
	    }
	    if (template === false) {
	        return { template: template };
	    }
	
	    if (template === true) {
	        return _settings;
	    }
	
	    if (template.template === false) {
	        return template;
	    }
	    return _extends({}, _settings, template);
	}
	
	function loadTemplate(value, key, props, _ref) {
	    var loader = _ref.loader;
	    var injector = _ref.injector;
	
	    var _normalize = normalize(value);
	
	    var template = _normalize.template;
	    var propTypes = _normalize.propTypes;
	
	    var rest = _objectWithoutProperties(_normalize, ['template', 'propTypes']);
	
	    if (template == null || template === false) {
	        return null;
	    }
	
	    var Template = void 0;
	    if ((0, _tutils.isFunction)(template)) {
	        Template = template;
	    } else {
	        Template = loader.loadTemplate(template);
	        (0, _warning2.default)(Template, 'Template for name "%s" is not defined', template);
	        if (!Template.displayName) {
	            Template.displayName = template;
	        }
	    }
	    var InjectedTemplate = injector.inject(Template, propTypes, rest);
	
	    return InjectedTemplate;
	}
	
	function template(Clazz, key) {
	
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	    Clazz.contextTypes.injector = _PropTypes2.default.injector;
	
	    this.property.call(Clazz, key, loadTemplate);
	};

/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = exports.defaultPropTypes = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.loadType = loadType;
	exports.default = type;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var defaultPropTypes = exports.defaultPropTypes = {
	    onChange: _PropTypes2.default.targetEvent,
	    onBlur: _PropTypes2.default.blurValidate,
	    onKeyDown: _PropTypes2.default.event,
	    onKeyUp: _PropTypes2.default.event,
	    onFocus: _PropTypes2.default.event,
	    onPaste: _PropTypes2.default.event,
	    value: _PropTypes2.default.value,
	    id: _PropTypes2.default.id,
	    name: _PropTypes2.default.htmlFor,
	    className: _PropTypes2.default.typeClass,
	    placeholder: _PropTypes2.default.string,
	    fieldAttrs: _PropTypes2.default.fieldAttrs
	};
	//Expose for configurability
	var settings = exports.settings = {
	    type: 'Text'
	};
	
	function loadType(val, key, props, context) {
	    var _ref = typeof val === 'string' ? _extends({}, settings, {
	        type: val
	    }) : val == null ? settings : _extends({}, settings, val);
	
	    var type = _ref.type;
	    var propTypes = _ref.propTypes;
	
	    var rest = _objectWithoutProperties(_ref, ['type', 'propTypes']);
	
	    if (!propTypes) {
	        propTypes = defaultPropTypes;
	    } else {
	        propTypes = _extends({}, defaultPropTypes, propTypes);
	    }
	    var Type = void 0;
	    if (typeof type === 'string') {
	        Type = context.loader.loadType(type);
	        (0, _warning2.default)(Type, 'Could not find a type for %s', type);
	
	        if (!Type.displayName) {
	            Type.displayName = type;
	        }
	    } else {
	        Type = type;
	    }
	
	    var injectedClazz = context.injector.inject(Type, propTypes, rest.defaultProps);
	
	    if ('template' in Type) {
	        injectedClazz.template = Type.template;
	    }
	
	    return injectedClazz;
	}
	
	function type(Clazz, key, propList, OrigClazz) {
	
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	    Clazz.contextTypes.injector = _PropTypes2.default.injector;
	
	    this.property.call(Clazz, key, loadType);
	}

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = fieldAttrs;
	
	var _tutils = __webpack_require__(170);
	
	function handleAttrs(value, key) {
	    if (!value) return;
	    var keys = Object.keys(value);
	    for (var i = 0, l = keys.length; i < l; i++) {
	        var _key = keys[i];
	        if (propKeys.indexOf(_key) === -1) {
	            propKeys.push(_key);
	        }
	        //This may be indeterminate, depending if something sets it later.
	        this.injected[_key] = value[_key];
	    }
	}
	
	function fieldAttrs(Clazz, key, propKeys) {
	
	    var ClazzP = Clazz.prototype;
	
	    ClazzP.componentWillMount = (0, _tutils.applyFuncs)(function () {
	        handleAttrs.call(this, this.props[key], key);
	    }, ClazzP.componentWillMount);
	
	    ClazzP.componentWillReceiveProps = (0, _tutils.applyFuncs)(function (newProps) {
	        if (this.props[key] !== newProps[key]) {
	            handleAttrs.call(this, newProps[key], key);
	        }
	    }, ClazzP.componentWillReceiveProps);
	}

/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.normalizeFields = normalizeFields;
	exports.default = fields;
	
	var _tutils = __webpack_require__(170);
	
	function normalizeFields(fields) {
	    if (fields == null) {
	        return fields;
	    }
	    fields = (0, _tutils.toArray)(fields);
	    if (fields.length === 0) {
	        return null;
	    }
	    return fields;
	}
	function fields(Clazz, key) {
	    this.property.call(Clazz, key, normalizeFields);
	}

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.normalizeFieldsets = normalizeFieldsets;
	
	var _tutils = __webpack_require__(170);
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function normalizeFieldsets(fieldsets, fields) {
	    if (!(fieldsets || fields)) return {};
	    fields = (0, _tutils.toArray)(fields);
	    //fields trump fieldsets
	    //otherwise recurse
	    fieldsets = (0, _tutils.toArray)(fieldsets).map(function (f) {
	        if (f.fields) {
	            var rest = _objectWithoutProperties(f, []);
	
	            rest.fields = (0, _tutils.toArray)(rest.fields);
	            (0, _tutils.push)(fields, rest.fields);
	            return rest;
	        } else if (f.fieldsets) {
	            var fieldsets = f.fieldsets;
	
	            var rest = _objectWithoutProperties(f, ["fieldsets"]);
	
	            rest.fieldsets = normalizeFieldsets(fieldsets, fields).fieldsets;
	
	            return rest;
	        } else if ((0, _tutils.isString)(f) || Array.isArray(f)) {
	            var processFields = (0, _tutils.toArray)(f);
	            (0, _tutils.push)(fields, processFields);
	            return {
	                fields: processFields
	            };
	        } else if (f.fieldsets) {
	            var fieldsets = f.fieldsets;
	
	            var rest = _objectWithoutProperties(f, ["fieldsets"]);
	
	            rest.fieldsets = normalizeFieldsets(fieldsets, fields).fieldsets;
	            return rest;
	        } else {
	            return f;
	            //            warning(false, 'do not know what %s this is ', f);
	        }
	    });
	    if (fieldsets.length === 0) {
	        fieldsets = [{ fields: fields }];
	    }
	    return {
	        fieldsets: fieldsets,
	        fields: fields
	    };
	}
	function normal(value) {
	    return normalizeFieldsets(value, []);
	}
	function fieldsets(Clazz, key) {
	    this.property.call(Clazz, key, normal);
	}
	fieldsets.normalizeFieldsets = normalizeFieldsets;
	exports.default = fieldsets;

/***/ },
/* 386 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = htmlFor;
	function idValue(value, key, props) {
	    if (value == null) return props.id || props.path;
	    return value;
	}
	function htmlFor(Clazz, key) {
	
	    this.property.call(Clazz, key, idValue);
	}

/***/ },
/* 387 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = id;
	function idValue(value, key, props) {
	    if (value == null) return props.path;
	    return value;
	}
	function id(Clazz, key) {
	
	    this.property.call(Clazz, key, idValue);
	}

/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.injectClass = injectClass;
	exports.default = inject;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function injectClass(value, key, props, _ref) {
	    var injector = _ref.injector;
	
	    if (value == null) return;
	
	    if (value.injectClass) {
	        var _injectClass = value.injectClass;
	        var propTypes = value.propTypes;
	        var injectProps = value.injectProps;
	        var strict = value.strict;
	
	        return injector.inject(_injectClass, propTypes, injectProps, strict);
	    }
	
	    return injector.inject(value);
	}
	
	function inject(Clazz, key) {
	
	    Clazz.contextTypes.injector = _PropTypes2.default.injector;
	    this.property.call(Clazz, key, injectClass);
	}

/***/ },
/* 389 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Returns the injected class as a property to the child class.
	 * Useful for Content.
	 *
	 * @param Clazz
	 * @param key
	 */
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = injected;
	function injected(Clazz, key) {
	
	    this.property.call(Clazz, key, function () {
	        return Clazz;
	    });
	}

/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = listen;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function handleListeners(value, key, props, context) {
	    var _this = this;
	
	    if (value == null) {
	        return null;
	    }
	    var resolvedPath = (0, _tutils.resolveKey)(props.path, value);
	    var injected = this.injected;
	
	    return context.valueManager.addListener(resolvedPath, function (v) {
	        injected[key] = v;
	        _this.mounted && _this.forceUpdate();
	    }, null, true).remove;
	}
	
	function listen(Clazz, key) {
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	
	    this.listener.call(Clazz, key, handleListeners);
	}

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.loadOperator = loadOperator;
	exports.default = operator;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var opRe = /^(==|===|!=|!==|>=|>|truthy|falsey|<|<=|(\!)?\/(.*)\/([gimy])?)$/;
	var eq = function eq(compare, value) {
	    return value == compare;
	},
	    eqeq = function eqeq(compare, value) {
	    return value === compare;
	},
	    ne = function ne(compare, value) {
	    return value != compare;
	},
	    neeq = function neeq(compare, value) {
	    return value !== compare;
	},
	    gt = function gt(compare, value) {
	    return value > compare;
	},
	    gteq = function gteq(compare, value) {
	    return value >= compare;
	},
	    lt = function lt(compare, value) {
	    return value < compare;
	},
	    lteq = function lteq(compare, value) {
	    return value <= compare;
	},
	    truthy = function truthy(compare) {
	    return !!compare;
	},
	    falsey = function falsey(compare) {
	    return !compare;
	};
	
	var opFactory = function opFactory$factory(scope) {
	
	    return function (operator) {
	        switch (operator) {
	            case 'truthy':
	                return truthy;
	            case 'falsey':
	                return falsey;
	            case '==':
	                return eq;
	            case '===':
	                return eqeq;
	            case '!=':
	                return ne;
	            case '!==':
	                return neeq;
	            case '>':
	                return gt;
	            case '>=':
	                return gteq;
	            case '<':
	                return lt;
	            case '<=':
	                return lteq;
	
	            default:
	                {
	                    throw new Error('Unknown operator [' + operator + ']');
	                }
	        }
	    };
	}();
	function loadOperator(operator, key, props, context) {
	
	    if (operator instanceof RegExp) {
	        return function (compare, value) {
	            return operator.test(compare, value);
	        };
	    }
	    if (typeof operator === 'function') {
	        return operator;
	    }
	    if (typeof operator === 'string') {
	        var os = opRe.exec(operator);
	        if (os) {
	            if (os[3] != null) {
	                operator = new RegExp(os[3], os[4]);
	                if (os[2] == null) {
	                    return function (compare, value) {
	                        return operator.test(compare);
	                    };
	                } else {
	                    return function (compare, value) {
	                        return !operator.test(compare);
	                    };
	                }
	            }
	            return opFactory(operator);
	        } else {
	            return context.loader.loadOperator(operator);
	        }
	    }
	    return operator;
	}
	
	function operator(Clazz, key) {
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	    this.property.call(Clazz, key, loadOperator);
	}

/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = options;
	
	var _tutils = __webpack_require__(170);
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function toOptions(nval) {
	    if (typeof nval === 'string') {
	        return { label: nval, val: nval };
	    }
	
	    if ('label' in nval && 'val' in nval) {
	        return nval;
	    }
	    var label = nval.label;
	    var val = nval.val;
	
	    var rest = _objectWithoutProperties(nval, ['label', 'val']);
	
	    if (!val) {
	        rest.val = label;
	    }
	    if (!label) {
	        rest.label = val;
	    }
	    return rest;
	}
	
	function asOptions(val) {
	    return (0, _tutils.toArray)(val).map(toOptions);
	}
	function options(Clazz, key) {
	    this.property.call(Clazz, key, asOptions);
	}

/***/ },
/* 393 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = processor;
	function loadProcessor(value, key, props, _ref) {
	    var loader = _ref.loader;
	
	    return loader.loadProcessor(value);
	}
	
	function processor(Clazz, key) {
	    this.property.call(Clazz, key, loadProcessor);
	}

/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.normalize = normalize;
	exports.normalizeSchema = normalizeSchema;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	var _fieldset = __webpack_require__(385);
	
	var _template = __webpack_require__(381);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * So a schema can be
	 * EX: {
	 *   key:'Text'
	 * }
	 * or
	 * {
	 *   schema:{
	 *     key:'Text'
	 *   }
	 * }
	 * or
	 *
	 * {
	 *   schema:{
	 *    f1:'Text',
	 *    f2:'Text'
	 *   },
	 *   fields:['f1']
	 *
	 * }
	 * or
	 *
	 * {
	 *   schema:'Hello'
	 * }
	 *
	 * or
	 *
	 * 'Hello'
	 *
	 * @param oschema
	 * @param ofields
	 * @param ofieldsets
	 * @param loader
	 * @param orest
	 * @returns {*}
	 */
	function normalize(oschema, ofields, ofieldsets, _ref) {
	    var loader = _ref.loader;
	    var orest = arguments.length <= 4 || arguments[4] === undefined ? _tutils.FREEZE_OBJ : arguments[4];
	
	    if (oschema == null) {
	        return oschema;
	    }
	
	    if (typeof oschema === 'string') {
	        return normalize(loader.loadSchema(oschema), ofields, ofieldsets, loader, orest);
	    }
	    //use the overrided fieldsets.
	    if (ofields || ofieldsets) {
	
	        if (oschema.schema) {
	            var _fields = oschema.fields;
	            var fieldsets = oschema.fieldsets;
	            var _schema = oschema.schema;
	
	            var rest = _objectWithoutProperties(oschema, ['fields', 'fieldsets', 'schema']);
	
	            if (typeof _schema === 'string') {
	                return normalize(loader.loadSchema(_schema), ofields, ofieldsets, loader, rest);
	            }
	            return _extends({}, rest, (0, _fieldset.normalizeFieldsets)(ofieldsets, ofields), {
	                schema: _schema
	            });
	        } else {
	            return _extends({}, orest, (0, _fieldset.normalizeFieldsets)(ofieldsets, ofields), {
	                schema: oschema
	            });
	        }
	    }
	
	    if (oschema.fields || oschema.fieldsets) {
	        var _fields2 = oschema.fields;
	        var _fieldsets = oschema.fieldsets;
	        var _schema2 = oschema.schema;
	
	        var _rest = _objectWithoutProperties(oschema, ['fields', 'fieldsets', 'schema']);
	
	        if (typeof _schema2 === 'string') {
	            return normalize(_schema2, _fields2, _fieldsets, loader, _rest);
	        }
	        return _extends({}, _rest, (0, _fieldset.normalizeFieldsets)(oschema.fieldsets, oschema.fields), {
	            schema: _schema2
	        });
	    }
	    //schema without fields, or fieldsets
	    if (oschema.schema) {
	        var _schema3 = oschema.schema;
	
	        var _rest2 = _objectWithoutProperties(oschema, ['schema']);
	
	        if (typeof _schema3 === 'string') {
	            //ofields and ofields should be null here.
	            return normalize(_schema3, ofields, ofieldsets, loader, _rest2);
	        }
	        var _fields3 = Object.keys(_schema3);
	        return _extends({}, _rest2, {
	            schema: _schema3,
	            fields: _fields3,
	            fieldsets: [{ fields: _fields3 }]
	        });
	    }
	    var fields = Object.keys(oschema);
	    return _extends({}, orest, {
	        fields: fields,
	        fieldsets: [{ fields: fields }],
	        schema: oschema
	    });
	}
	
	var settings = exports.settings = {
	    template: 'ObjectTemplate'
	};
	
	function normalizeSchema(oschema, key, props, context) {
	    if (oschema == null) return oschema;
	    var schema = normalize(oschema, props.fieldsets, props.fields, context);
	    if (props.objectTemplate) {
	        schema.Template = (0, _template.loadTemplate)(props.objectTemplate, key, props, context);
	    } else if (schema.template) {
	        schema.Template = (0, _template.loadTemplate)(schema.template, key, props, context);
	    } else if (props.fallbackTemplate) {
	        schema.Template = (0, _template.loadTemplate)(props.fallbackTemplate, key, props, context);
	    } else {
	        schema.Template = (0, _template.loadTemplate)(settings.template, key, props, context);
	    }
	    return schema;
	}
	
	function schema(Clazz, key) {
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	    this.property.call(Clazz, key, normalizeSchema);
	}
	
	schema.normalizeSchema = normalizeSchema;
	exports.default = schema;

/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.styleToProps = styleToProps;
	exports.default = style;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Takes the keys of a style object and converts them to an object
	 * suitable to default props with the default value being the styles
	 * resolved default style.
	 *
	 * @param styles
	 * @param props
	 * @param preFix
	 * @param postFix
	 * @returns {*}
	 */
	function styleToProps(styles) {
	    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	    var preFix = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
	    var postFix = arguments.length <= 3 || arguments[3] === undefined ? "Class" : arguments[3];
	
	    return Object.keys(styles).reduce(function (ret, key) {
	        ret['' + preFix + key + postFix] = styles[key];
	        return ret;
	    }, props);
	}
	/**
	 * So styles tries toload via loader.loadStyle(ClassName or the value of the style) which
	 * should return an object.
	 *
	 * It will iterate over said object and properties with the key being renamed ${key}Class
	 * and the value being installed.
	 *
	 * If a value is passed to the object, for a field, than that value is used.  Rather
	 * than the
	 *
	 *
	 * @param Clazz
	 * @param key
	 * @param propList
	 * @param OrigClazz
	 */
	function style(Clazz, key, propList, OrigClazz) {
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	
	    this.property.call(Clazz, key, function style$resolver$property(value, key, props, _ref) {
	        var loader = _ref.loader;
	        var injected = this.injected;
	
	        var Style = value == null || typeof value === 'string' ? loader.loadStyle(value || OrigClazz.displayName || OrigClazz.name) : value;
	        if (Style == null) {
	            return Style;
	        }
	        var obj = styleToProps(Style, {});
	        Object.keys(obj).forEach(function (key) {
	            if (key in props) {
	                injected[key] = props[key] || '';
	            } else {
	                injected[key] = obj[key];
	            }
	            if (propList.indexOf(key) === -1) {
	                propList.push(key);
	            }
	        });
	        return Style;
	    });
	}

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = targetEvent;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function resolve(value, key, props, _ref) {
	    var valueManager = _ref.valueManager;
	
	    if (typeof value === 'function') {
	        return value;
	    }
	    var resolvedPath = (0, _tutils.resolveKey)(props.path, value);
	    return function targetEvent$resolve(e) {
	        valueManager.update(resolvedPath, e.target.value);
	    };
	}
	function targetEvent(Clazz, key) {
	
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	
	    this.property.call(Clazz, key, resolve);
	}

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = valueEvent;
	
	var _tutils = __webpack_require__(170);
	
	function resolve(value, key, props) {
	    if (value === false) {
	        return '';
	    }
	    if (value) {
	        return value;
	    }
	    var val = props.name || props.id || props.path || '';
	
	    return (0, _tutils.titlelize)(val.split(/\./).pop());
	}
	
	function valueEvent(Clazz, key) {
	
	    this.property.call(Clazz, key, resolve);
	}

/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.handleTransition = handleTransition;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _ReactCSSReplaceTransition = __webpack_require__(161);
	
	var _ReactCSSReplaceTransition2 = _interopRequireDefault(_ReactCSSReplaceTransition);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var settings = exports.settings = {
	    transition: 'rollUp',
	    on: ['enter', 'leave'],
	    Transition: _ReactCSSReplaceTransition2.default
	};
	
	function handleTransition(value, key, props, _ref) {
	    var loader = _ref.loader;
	
	    if (value == null || value === false || value.transition === false) {
	        return null;
	    }
	    if (typeof value === 'string') {
	        value = { transition: value };
	    }
	
	    var _settings$value = _extends({}, settings, value);
	
	    var transition = _settings$value.transition;
	
	    var config = _objectWithoutProperties(_settings$value, ['transition']);
	
	    var _ref2 = typeof transition === 'string' ? _extends({}, config, loader.loadTransition(transition)) : transition;
	
	    var transitionAppearTimeout = _ref2.transitionAppearTimeout;
	    var transitionLeaveTimeout = _ref2.transitionLeaveTimeout;
	    var transitionEnterTimeout = _ref2.transitionEnterTimeout;
	    var on = _ref2.on;
	    var _ref2$transitionName = _ref2.transitionName;
	    var enter = _ref2$transitionName.enter;
	    var enterActive = _ref2$transitionName.enterActive;
	    var appear = _ref2$transitionName.appear;
	    var appearActive = _ref2$transitionName.appearActive;
	    var leave = _ref2$transitionName.leave;
	    var leaveActive = _ref2$transitionName.leaveActive;
	
	    var rest = _objectWithoutProperties(_ref2, ['transitionAppearTimeout', 'transitionLeaveTimeout', 'transitionEnterTimeout', 'on', 'transitionName']);
	
	    var _on = Array.isArray(on) ? on : [on];
	    var transitionName = rest.transitionName = {};
	    //either the original value has the timeout or we have an on
	    if (value.transitionEnterTimeout || _on.indexOf('enter') != -1) {
	        rest.transitionEnterTimeout = transitionEnterTimeout;
	        transitionName.enter = enter;
	        transitionName.enterActive = enterActive;
	        rest.transitionEnter = true;
	    } else {
	        rest.transitionEnter = false;
	    }
	
	    if (value.transitionAppearTimeout || _on.indexOf('appear') != -1) {
	        rest.transitionAppearTimeout = transitionAppearTimeout;
	        transitionName.appear = appear;
	        transitionName.appearActive = appearActive;
	        rest.transitionAppear = true;
	    } else {
	        rest.transitionAppear = false;
	    }
	
	    if (value.transitionLeaveTimeout || _on.indexOf('leave') != -1) {
	        rest.transitionLeaveTimeout = transitionLeaveTimeout;
	        transitionName.leave = leave;
	        transitionName.leaveActive = leaveActive;
	        rest.transitionLeave = true;
	    } else {
	        rest.transitionLeave = false;
	    }
	
	    return rest;
	}
	
	function transition(Clazz, key) {
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	    this.property.call(Clazz, key, handleTransition);
	}
	//because es6 modules.
	transition.handleTransition = handleTransition;
	
	exports.default = transition;

/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	exports.addClasses = addClasses;
	exports.forType = forType;
	exports.default = typeClass;
	
	var _tutils = __webpack_require__(170);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var settings = exports.settings = {
	    inputClassName: 'form-control'
	};
	
	function addClasses(classes) {
	    for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        rest[_key - 1] = arguments[_key];
	    }
	
	    if (rest == null || rest.length === 0) {
	        return classes;
	    }
	    for (var i = 0, l = rest.length; i < l; i++) {
	        var str = rest[i];
	
	        if (str == null) continue;
	
	        if ((0, _tutils.isString)(str)) {
	            var parts = str.split(/\s+?/);
	
	            if (parts.length > 1) {
	
	                addClasses.apply(undefined, [classes].concat(_toConsumableArray(parts)));
	            } else {
	
	                if (classes.indexOf(str) === -1) {
	                    classes.push(str);
	                }
	            }
	        } else if ((0, _tutils.isArray)(str)) {
	            addClasses.apply(undefined, [classes].concat(_toConsumableArray(str)));
	        } else if ((0, _tutils.isFunction)(str)) {
	            addClasses(classes, str.call(this));
	        }
	    }
	    return classes;
	}
	
	/**
	 * Determines the classes for a type.
	 * Takes a react node as the first argument.
	 * @param {Reactnode} node - node to create for.
	 * @param {String|Function|Array<String|Function|Array>} [clases] -classes to add.
	 */
	function forType(OrigClazz, value) {
	    return addClasses([], value || OrigClazz.inputClassName || settings.inputClassName).join(' ');
	}
	
	function typeClass(Clazz, key, propList, OrigClazz) {
	
	    this.property.call(Clazz, key, function (value) {
	        return forType(OrigClazz, value);
	    });
	}

/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.handleListeners = handleListeners;
	exports.default = value;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	var _isPlainObject = __webpack_require__(401);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createHandler(value, key, loader) {
	    if (value.processor) {
	        var _ret = function () {
	            var process = typeof value.processor == 'function' ? value.processor : loader.loadProcessor(value.processor).value;
	            return {
	                v: function value$processsorHandler(v) {
	                    this.injected[key] = process(v);
	                    this.mounted && this.forceUpdate();
	                }
	            };
	        }();
	
	        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	    }
	    return function value$handler(v) {
	        this.injected[key] = v;
	        this.mounted && this.forceUpdate();
	    };
	}
	
	function handleListeners(value, key, props, _ref) {
	    var valueManager = _ref.valueManager;
	    var loader = _ref.loader;
	
	    var resolvedPath = void 0;
	    if (value == null || typeof value === 'string') {
	        resolvedPath = (0, _tutils.resolveKey)(props.path, value);
	        value = settings;
	    } else if ((0, _isPlainObject2.default)(value)) {
	        resolvedPath = (0, _tutils.resolveKey)(props.path, value.value);
	        value = _extends({}, settings, value);
	    }
	
	    return valueManager.addListener(resolvedPath, createHandler(value, key, loader), this, value.init).remove;
	}
	
	var settings = exports.settings = {
	    //fire the listener immediately, do not wait for a change.
	    init: true
	};
	
	function value(Clazz, key) {
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	    Clazz.contextTypes.loader = _PropTypes2.default.loader;
	
	    this.listener.call(Clazz, key, handleListeners);
	}

/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	var baseForIn = __webpack_require__(402),
	    isArguments = __webpack_require__(185),
	    isObjectLike = __webpack_require__(179);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * **Note:** This method assumes objects created by the `Object` constructor
	 * have no inherited enumerable properties.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  var Ctor;
	
	  // Exit early for non `Object` objects.
	  if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
	      (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	    return false;
	  }
	  // IE < 9 iterates inherited properties before own properties. If the first
	  // iterated property is an object's own property then there are no inherited
	  // enumerable properties.
	  var result;
	  // In most environments an object's own properties are iterated before
	  // its inherited properties. If the last iterated property is an object's
	  // own property then there are no inherited enumerable properties.
	  baseForIn(value, function(subValue, key) {
	    result = key;
	  });
	  return result === undefined || hasOwnProperty.call(value, result);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(204),
	    keysIn = __webpack_require__(188);
	
	/**
	 * The base implementation of `_.forIn` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForIn(object, iteratee) {
	  return baseFor(object, iteratee, keysIn);
	}
	
	module.exports = baseForIn;


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = valueEvent;
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _tutils = __webpack_require__(170);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function resolve(value, key, props, context) {
	    if (typeof value === 'function') {
	        return value;
	    }
	    var resolvedPath = (0, _tutils.resolveKey)(props.path, value);
	    return function (v) {
	        context.valueManager.update(resolvedPath, v);
	    };
	}
	
	function valueEvent(Clazz, key) {
	
	    Clazz.contextTypes.valueManager = _PropTypes2.default.valueManager;
	
	    this.property.call(Clazz, key, resolve);
	}

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = providerFactory;
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _map = __webpack_require__(253);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _decorator = __webpack_require__(167);
	
	var _decorator2 = _interopRequireDefault(_decorator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function providerFactory(_ref) {
	    var defaultLoader = _ref.defaultLoader;
	    var types = arguments.length <= 1 || arguments[1] === undefined ? ['type', 'validator', 'template', 'processor', 'operator', 'transition'] : arguments[1];
	
	    var provide = (0, _decorator2.default)(provideProperty, provideClass);
	    provide.defaultLoader = defaultLoader;
	
	    /***
	     *
	     * To add a type
	     *
	     * @provider.type("SomethingElse")
	     * @field
	     * class NewType extends Component {
	    *
	    *
	    * }
	     *
	     *
	     *
	     * @param type
	     * @param name
	     * @param propType
	     * @param loader
	     * @returns {provideClass$config}
	     */
	    function provideClass(type, name, propType) {
	        var loader = arguments.length <= 3 || arguments[3] === undefined ? defaultLoader : arguments[3];
	
	
	        return function provideClass$config(target) {
	            name = name || target.name;
	            type = _type(type);
	            loader[type](name, target);
	            return target;
	        };
	    }
	
	    function provideSchemaClass(name, propType) {
	        var loader = arguments.length <= 2 || arguments[2] === undefined ? defaultLoader : arguments[2];
	
	
	        return function provideClass$config(Target) {
	            name = name || Target.name;
	            loader.addSchema(name, new Target());
	            return Target;
	        };
	    }
	
	    function provideProperty(type, name, propType) {
	        var loader = arguments.length <= 3 || arguments[3] === undefined ? defaultLoader : arguments[3];
	
	        return function provideProperty$config(target, property, descriptor) {
	            var _this = this,
	                _loader$addLoader;
	
	            name = name || property;
	
	            var value = descriptor.value;
	            var initializer = descriptor.initializer;
	            var writable = descriptor.writable;
	            var configurable = descriptor.configurable;
	
	            var rest = _objectWithoutProperties(descriptor, ['value', 'initializer', 'writable', 'configurable']);
	
	            value = value || initializer;
	            loader.addLoader((_loader$addLoader = {}, _defineProperty(_loader$addLoader, _type(type, 'load'), function (loadName) {
	                for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	                    rest[_key - 1] = arguments[_key];
	                }
	
	                if (loadName === name) {
	                    return value.apply(_this, rest);
	                }
	            }), _defineProperty(_loader$addLoader, _type(type, 'list', 's'), function () {
	                return {
	                    name: name
	                };
	            }), _loader$addLoader));
	
	            rest.set = function (newValue) {
	                value = newValue;
	            };
	
	            return rest;
	        };
	    }
	
	    function _type(type) {
	        var prefix = arguments.length <= 1 || arguments[1] === undefined ? 'add' : arguments[1];
	        var postfix = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
	
	
	        if (!type) {
	            (0, _warning2.default)(false, 'must provide for a type');
	            return null;
	        }
	
	        return prefix + (type.substring(0, 1).toUpperCase() + type.substring(1)) + postfix;
	    }
	
	    /**/
	
	    types.forEach(function (key) {
	        this[key] = (0, _decorator2.default)(provideProperty.bind(null, key), provideClass.bind(null, key));
	    }, provide);
	
	    provide.schema = (0, _decorator2.default)(provideClass.bind(null, 'schema'), provideSchemaClass);
	    return provide;
	}
	/*

	 export var type =  decorator(provideProperty.bind(null, 'type'), provideClass.bind(null, 'type'));
	 export var validator =  decorator(provideProperty.bind(null, 'validator'), provideClass.bind(null, 'validator'));
	 export var schema =  decorator(provideProperty.bind(null, 'schema'), provideClass.bind(null, 'schema'));
	 export var template =  decorator(provideProperty.bind(null, 'template'), provideClass.bind(null, 'template'));
	 export var processor =  decorator(provideProperty.bind(null, 'processor'), provideClass.bind(null, 'processor'));
	 export var operator =  decorator(provideProperty.bind(null, 'operator'), provideClass.bind(null, 'operator'));

	 */

/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = cachedInject;
	
	var _hash = __webpack_require__(406);
	
	function cachedInject(injector) {
	    var cache = void 0;
	    var count = 0;
	    /**
	     * Resolver gets called  a bunch of times,
	     * rather than initing WeakMap a million times,
	     * let's just do it in the main inject loop.
	     *
	     * @param propType
	     * @param resolver
	     * @returns {*}
	     */
	    function resolver(propType, resolver) {
	        if (propType && resolver) {
	            //invalidate cache with new resolver
	            cache = null;
	            count = 0;
	        }
	        return injector.resolver(propType, resolver);
	    }
	
	    function inject(Clazz, extraPropTypes, extraProps, strictProps) {
	        if (Clazz == null) {
	            return Clazz;
	        }
	        //we need to generate the hash regardless of having a cache.
	        var hash = new _hash.HashBuilder(strictProps).addObject(extraPropTypes).addObject(extraProps).toString();
	        var cur = void 0;
	        //no cache so no point in checking it.
	        if (cache == null) {
	            cache = new WeakMap();
	            cur = new Map();
	            cache.set(Clazz, cur);
	        } else {
	            cur = cache.get(Clazz);
	            if (cur) {
	                var klazz = cur.get(hash);
	                if (klazz != null) {
	                    return klazz;
	                }
	            } else {
	                cur = new Map();
	                cache.set(Clazz, cur);
	            }
	        }
	
	        var injected = injector.inject(Clazz, extraPropTypes, extraProps, strictProps);
	        injected.displayName = injected.displayName + "$" + hash;
	        injected.$hash = hash;
	        cur.set(hash, injected);
	        count++;
	        return injected;
	    }
	    function size() {
	        return count;
	    }
	
	    return {
	        resolver: resolver,
	        inject: inject,
	        size: size
	    };
	}

/***/ },
/* 406 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.hashFunc = hashFunc;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function hash(string) {
	    string = string == null ? '' : string + '';
	    var hash = 0;
	    if (!string) return '' + hash;
	    var length = string.length;
	    for (var i = 0; i < length; i++) {
	        hash = (hash << 5) - hash + string.charCodeAt(i);
	        hash = hash & hash; // Convert to 32bit integer
	    }
	    return hash.toString(16);
	}
	
	var HashBuilder = exports.HashBuilder = function () {
	    function HashBuilder(str) {
	        _classCallCheck(this, HashBuilder);
	
	        this.hash = 0;
	
	        this.add(str);
	    }
	
	    _createClass(HashBuilder, [{
	        key: 'addValue',
	        value: function addValue(val) {
	            if (val == null) {
	                return this;
	            }
	            var tval = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	            if (tval === 'string') {
	                return this.add(val);
	            }
	            if (tval === 'number') {
	                this.hash += val;
	                return this;
	            }
	            if (tval === 'boolean') {
	                return this.add('' + val);
	            }
	
	            if (tval === 'function') {
	                return this.addFunction(val);
	            }
	
	            return this.addObject(val);
	        }
	    }, {
	        key: 'addObject',
	        value: function addObject(obj) {
	            this.addChar('=');
	            if (obj != null) {
	                var keys = Object.keys(obj);
	                for (var i = 0, l = keys.length; i < l; i++) {
	                    var key = keys[i];
	                    this.addKey(key).addValue(obj[key]);
	                }
	            }
	            return this;
	        }
	    }, {
	        key: 'addKey',
	        value: function addKey(key) {
	            return this.addChar(',').add(key).addChar(':');
	        }
	    }, {
	        key: 'addFunction',
	        value: function addFunction(func) {
	            this.hash += parseInt(hashFunc(func), 16);
	            return this;
	        }
	    }, {
	        key: 'addChar',
	        value: function addChar(val) {
	            var hash = this.hash;
	            hash = (hash << 5) - hash + val.charCodeAt(0);
	            this.hash = hash & hash; // Convert to 32bit integer
	            return this;
	        }
	    }, {
	        key: 'add',
	        value: function add(str) {
	            str = str == null ? '' : str + '';
	            var hash = this.hash;
	            for (var i = 0, l = str.length; i < l; i++) {
	                hash = (hash << 5) - hash + str.charCodeAt(i);
	                hash = hash & hash; // Convert to 32bit integer
	            }
	            this.hash = hash;
	            return this;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.hash.toString(16);
	        }
	    }]);
	
	    return HashBuilder;
	}();
	
	function hashFunc(func) {
	    return func == null ? 0 : func.$hash || (func.$hash = hash(func.toString()));
	}
	
	exports.default = hash;

/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.newSubschemaContext = exports.cachedInjector = exports.warning = exports.validators = exports.tutils = exports.loaderFactory = exports.injectorFactory = exports.eventable = exports.decorators = exports.css = exports.ValueManager = exports.PropTypes = exports.Dom = exports.NewChildContext = exports.Form = exports.FieldSet = exports.Field = exports.Conditional = undefined;
	
	var _Conditional = __webpack_require__(371);
	
	var _Conditional2 = _interopRequireDefault(_Conditional);
	
	var _Field = __webpack_require__(297);
	
	var _Field2 = _interopRequireDefault(_Field);
	
	var _FieldSet = __webpack_require__(298);
	
	var _FieldSet2 = _interopRequireDefault(_FieldSet);
	
	var _NewChildContext = __webpack_require__(283);
	
	var _NewChildContext2 = _interopRequireDefault(_NewChildContext);
	
	var _Form = __webpack_require__(408);
	
	var _Form2 = _interopRequireDefault(_Form);
	
	var _Dom = __webpack_require__(303);
	
	var _Dom2 = _interopRequireDefault(_Dom);
	
	var _eventable = __webpack_require__(282);
	
	var _eventable2 = _interopRequireDefault(_eventable);
	
	var _loaderFactory = __webpack_require__(251);
	
	var _loaderFactory2 = _interopRequireDefault(_loaderFactory);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _validators = __webpack_require__(331);
	
	var _validators2 = _interopRequireDefault(_validators);
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _tutils = __webpack_require__(170);
	
	var tutils = _interopRequireWildcard(_tutils);
	
	var _ValueManager = __webpack_require__(281);
	
	var _ValueManager2 = _interopRequireDefault(_ValueManager);
	
	var _css = __webpack_require__(410);
	
	var _css2 = _interopRequireDefault(_css);
	
	var _index = __webpack_require__(166);
	
	var decorators = _interopRequireWildcard(_index);
	
	var _subschemaInjection = __webpack_require__(256);
	
	var _cachedInjector = __webpack_require__(405);
	
	var _cachedInjector2 = _interopRequireDefault(_cachedInjector);
	
	var _provideFactory = __webpack_require__(404);
	
	var _provideFactory2 = _interopRequireDefault(_provideFactory);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	exports.Conditional = _Conditional2.default;
	exports.Field = _Field2.default;
	exports.FieldSet = _FieldSet2.default;
	exports.Form = _Form2.default;
	exports.NewChildContext = _NewChildContext2.default;
	exports.Dom = _Dom2.default;
	exports.PropTypes = _PropTypes2.default;
	exports.ValueManager = _ValueManager2.default;
	exports.css = _css2.default;
	exports.decorators = decorators;
	exports.eventable = _eventable2.default;
	exports.injectorFactory = _subschemaInjection.injectorFactory;
	exports.loaderFactory = _loaderFactory2.default;
	exports.tutils = tutils;
	exports.validators = _validators2.default;
	exports.warning = _warning2.default;
	exports.injectorFactory = _subschemaInjection.injectorFactory;
	exports.cachedInjector = _cachedInjector2.default;
	exports.newSubschemaContext = newSubschemaContext;
	exports.default = {
	    Conditional: _Conditional2.default,
	    Field: _Field2.default,
	    FieldSet: _FieldSet2.default,
	    Form: _Form2.default,
	    NewChildContext: _NewChildContext2.default,
	    Dom: _Dom2.default,
	    PropTypes: _PropTypes2.default,
	    ValueManager: _ValueManager2.default,
	    css: _css2.default,
	    decorators: decorators,
	    eventable: _eventable2.default,
	    cachedInjector: _cachedInjector2.default,
	    injectorFactory: _subschemaInjection.injectorFactory,
	    loaderFactory: _loaderFactory2.default,
	    tutils: tutils,
	    validators: _validators2.default,
	    warning: _warning2.default,
	    newSubschemaContext: newSubschemaContext
	};
	
	/**
	 * Used to initialize new subschema for testing.  But also to override behaviours if necessary.
	 *
	 * @param defaultLoaders
	 * @param defaultResolvers
	 * @param defaultPropTypes
	 * @param defaultInjectorFactory
	 * @param Subschema
	 */
	
	function newSubschemaContext() {
	    var defaultLoaders = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var defaultResolvers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	    var defaultPropTypes = arguments.length <= 2 || arguments[2] === undefined ? _PropTypes2.default : arguments[2];
	    var defaultInjectorFactory = arguments.length <= 3 || arguments[3] === undefined ? _subschemaInjection.injectorFactory : arguments[3];
	    var Subschema = arguments.length <= 4 || arguments[4] === undefined ? {
	        Conditional: _Conditional2.default,
	        Field: _Field2.default,
	        Form: _Form2.default,
	        NewChildContext: _NewChildContext2.default,
	        Dom: _Dom2.default,
	        PropTypes: _PropTypes2.default,
	        ValueManager: _ValueManager2.default,
	        css: _css2.default,
	        decorators: decorators,
	        eventable: _eventable2.default,
	        injector: injector,
	        loader: loader,
	        loaderFactory: _loaderFactory2.default,
	        tutils: tutils,
	        validators: _validators2.default,
	        warning: _warning2.default,
	        injectorFactory: _subschemaInjection.injectorFactory,
	        cachedInjector: _cachedInjector2.default
	
	    } : arguments[4];
	    return function () {
	        var loader = Subschema.loader;
	        var injector = Subschema.injector;
	
	        var rest = _objectWithoutProperties(Subschema, ['loader', 'injector']);
	
	        var _injector = defaultInjectorFactory();
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	            for (var _iterator = Object.keys(defaultResolvers)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var key = _step.value;
	
	                if (key in defaultPropTypes) {
	                    _injector.resolver(defaultPropTypes[key], defaultResolvers[key]);
	                }
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }
	
	        var defaultLoader = (0, _loaderFactory2.default)(defaultLoaders);
	        var defaultInjector = (0, _cachedInjector2.default)(_injector);
	
	        //Form needs these to kick off the whole thing.  Its defaults can be overriden with
	        // properties.
	        rest.Form.defaultProps.loader = defaultLoader;
	        rest.Form.defaultProps.injector = defaultInjector;
	        rest.loader = defaultLoader;
	        rest.injector = defaultInjector;
	        var provide = decorators.provide;
	
	        var decs = _objectWithoutProperties(decorators, ['provide']);
	
	        rest.decorators = decs;
	        //provide has a reference to the current status loader.   this makes it work.
	        decs.provide = (0, _provideFactory2.default)({ defaultLoader: defaultLoader });
	
	        return rest;
	    }();
	}

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PropTypes = __webpack_require__(252);
	
	var _PropTypes2 = _interopRequireDefault(_PropTypes);
	
	var _ValueManager = __webpack_require__(281);
	
	var _ValueManager2 = _interopRequireDefault(_ValueManager);
	
	var _Object = __webpack_require__(296);
	
	var _Object2 = _interopRequireDefault(_Object);
	
	var _set2 = __webpack_require__(409);
	
	var _set3 = _interopRequireDefault(_set2);
	
	var _tutils = __webpack_require__(170);
	
	var _warning = __webpack_require__(168);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Form = (_temp = _class = function (_Component) {
	    _inherits(Form, _Component);
	
	    _createClass(Form, [{
	        key: 'getChildContext',
	        value: function getChildContext() {
	            return {
	                valueManager: this.valueManager, loader: this.loader, injector: this.injector
	            };
	        }
	    }]);
	
	    function Form(props, context, whatever) {
	        _classCallCheck(this, Form);
	
	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Form).call(this, props, context, whatever));
	
	        _this.handleSubmit = function (e) {
	            e && e.preventDefault();
	            var vm = _this.valueManager;
	            if (!_this.props.noValidate) {
	                vm.validate();
	            }
	            if (vm.onSubmit(e, vm.getErrors(), vm.getValue(), _this.props.path) !== false) {
	                _this.props.onSubmit(e, vm.getErrors(), vm.getValue());
	            }
	        };
	
	        _this.setErrors = function (errors) {
	            _this.valueManager.setErrors(errors);
	        };
	
	        _this.loader = props.loader;
	        _this.injector = props.injector;
	        if (!props.valueManager) {
	            _this.valueManager = (0, _ValueManager2.default)(_this.props.value, _this.props.errors);
	        } else {
	            _this.valueManager = props.valueManager;
	            if (props.value) {
	                _this.valueManager.setValue(_this.props.value);
	            }
	            if (_this.props.errors) {
	                _this.valueManager.setErrors(_this.props.errors);
	            }
	        }
	        _this.ObjectWrapper = _this.injector.inject(_Object2.default);
	        return _this;
	    }
	
	    _createClass(Form, [{
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(newProps) {
	            if (newProps.loader !== this.props.loader) {
	                this.loader = newProps.loader;
	            }
	            if (newProps.valueManager !== this.props.valueManager) {
	                this.valueManager = newProps.valueManager;
	            }
	
	            if (this.props.value !== newProps.value) {
	                this.valueManager.setValue(newProps.value);
	            }
	            if (this.props.errors !== newProps.errors) {
	                this.valueManager.setErrors(newProps.errors);
	            }
	            if (this.props.injector !== newProps.injector) {
	                this.injector = newProps.injector;
	                this.ObjectWrapper = this.injector.inject(_Object2.default);
	            }
	        }
	    }, {
	        key: 'getValue',
	        value: function getValue() {
	            return this.valueManager.getValue();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props;
	            var valueManager = _props.valueManager;
	            var injector = _props.injector;
	            var loader = _props.loader;
	            var template = _props.template;
	            var onSubmit = _props.onSubmit;
	
	            var props = _objectWithoutProperties(_props, ['valueManager', 'injector', 'loader', 'template', 'onSubmit']);
	
	            var ObjectWrapper = this.ObjectWrapper;
	            return _react2.default.createElement(ObjectWrapper, _extends({ ref: 'form' }, props, { objectTemplate: template, onSubmit: this.handleSubmit }));
	        }
	    }]);
	
	    return Form;
	}(_react.Component), _class.displayName = "Form", _class.childContextTypes = _PropTypes2.default.contextTypes, _class.propTypes = {
	    schema: _PropTypes2.default.schema.isRequired,
	    loader: _PropTypes2.default.loader,
	    injector: _PropTypes2.default.injector,
	    valueManager: _PropTypes2.default.valueManager,
	    template: _PropTypes2.default.string,
	    method: _PropTypes2.default.string,
	    action: _PropTypes2.default.string,
	    enctype: _PropTypes2.default.string,
	    onSubmit: _PropTypes2.default.event,
	    noValidate: _PropTypes2.default.bool
	}, _class.defaultProps = {
	    fallbackTemplate: 'FormTemplate',
	    onSubmit: _tutils.noop,
	    noValidate: false
	}, _temp);
	exports.default = Form;

/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	var isIndex = __webpack_require__(187),
	    isKey = __webpack_require__(225),
	    isObject = __webpack_require__(178),
	    toPath = __webpack_require__(227);
	
	/**
	 * Sets the property value of `path` on `object`. If a portion of `path`
	 * does not exist it's created.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to augment.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, 'x[0].y.z', 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  if (object == null) {
	    return object;
	  }
	  var pathKey = (path + '');
	  path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
	
	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;
	
	  while (nested != null && ++index < length) {
	    var key = path[index];
	    if (isObject(nested)) {
	      if (index == lastIndex) {
	        nested[key] = value;
	      } else if (nested[key] == null) {
	        nested[key] = isIndex(path[index + 1]) ? [] : {};
	      }
	    }
	    nested = nested[key];
	  }
	  return object;
	}
	
	module.exports = set;


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.addClasses = addClasses;
	exports.addClass = addClass;
	exports.hasClass = hasClass;
	exports.removeClass = removeClass;
	
	var _tutils = __webpack_require__(170);
	
	function addClasses(classes, str) {
	    if (str == null) {
	        return;
	    }
	    if ((0, _tutils.isString)(str)) {
	        (0, _tutils.push)(classes, str.split(/\s+?/));
	    }
	    if ((0, _tutils.isArray)(str)) {
	        str.forEach(function (v) {
	            return addClasses(classes, v);
	        });
	    }
	    if ((0, _tutils.isFunction)(str)) {
	        addClasses(classes, str.call(this));
	    }
	}
	
	function addClass(node, className) {
	    if (className) {
	        if (node.classList) {
	            node.classList.add(className);
	        } else if (!api.hasClass(node, className)) {
	            node.className = node.className + ' ' + className;
	        }
	    }
	    return node;
	}
	
	function hasClass(node, className) {
	    if (node.classList) {
	        return !!className && node.classList.contains(className);
	    }
	    return node.className.split(/\s+?/).indexOf(className) > -1;
	}
	
	function removeClass(node, className) {
	    if (className) {
	        if (node.classList) {
	            node.classList.remove(className);
	        } else {
	            var parts = node.className.split(/\s+?/),
	                idx;
	            while ((idx = parts.indexOf(className)) > -1) {
	                parts.splice(idx, 1);
	            }
	            node.className = parts.join(' ');
	        }
	    }
	    return node;
	}
	
	exports.default = {
	    hasClass: hasClass,
	    removeClass: removeClass,
	    addClass: addClass,
	    addClasses: addClasses
	};

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate) {/*! hellojs v1.12.0 | (c) 2012-2016 Andrew Dodson | MIT https://adodson.com/hello.js/LICENSE */
	// ES5 Object.create
	if (!Object.create) {
	
		// Shim, Object create
		// A shim for Object.create(), it adds a prototype to a new object
		Object.create = (function() {
	
			function F() {}
	
			return function(o) {
	
				if (arguments.length != 1) {
					throw new Error('Object.create implementation only accepts one parameter.');
				}
	
				F.prototype = o;
				return new F();
			};
	
		})();
	
	}
	
	// ES5 Object.keys
	if (!Object.keys) {
		Object.keys = function(o, k, r) {
			r = [];
			for (k in o) {
				if (r.hasOwnProperty.call(o, k))
					r.push(k);
			}
	
			return r;
		};
	}
	
	// ES5 [].indexOf
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function(s) {
	
			for (var j = 0; j < this.length; j++) {
				if (this[j] === s) {
					return j;
				}
			}
	
			return -1;
		};
	}
	
	// ES5 [].forEach
	if (!Array.prototype.forEach) {
		Array.prototype.forEach = function(fun/*, thisArg*/) {
	
			if (this === void 0 || this === null) {
				throw new TypeError();
			}
	
			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun !== 'function') {
				throw new TypeError();
			}
	
			var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
			for (var i = 0; i < len; i++) {
				if (i in t) {
					fun.call(thisArg, t[i], i, t);
				}
			}
	
			return this;
		};
	}
	
	// ES5 [].filter
	if (!Array.prototype.filter) {
		Array.prototype.filter = function(fun, thisArg) {
	
			var a = [];
			this.forEach(function(val, i, t) {
				if (fun.call(thisArg || void 0, val, i, t)) {
					a.push(val);
				}
			});
	
			return a;
		};
	}
	
	// Production steps of ECMA-262, Edition 5, 15.4.4.19
	// Reference: http://es5.github.io/#x15.4.4.19
	if (!Array.prototype.map) {
	
		Array.prototype.map = function(fun, thisArg) {
	
			var a = [];
			this.forEach(function(val, i, t) {
				a.push(fun.call(thisArg || void 0, val, i, t));
			});
	
			return a;
		};
	}
	
	// ES5 isArray
	if (!Array.isArray) {
	
		// Function Array.isArray
		Array.isArray = function(o) {
			return Object.prototype.toString.call(o) === '[object Array]';
		};
	
	}
	
	// Test for location.assign
	if (typeof window === 'object' && typeof window.location === 'object' && !window.location.assign) {
	
		window.location.assign = function(url) {
			window.location = url;
		};
	
	}
	
	// Test for Function.bind
	if (!Function.prototype.bind) {
	
		// MDN
		// Polyfill IE8, does not support native Function.bind
		Function.prototype.bind = function(b) {
	
			if (typeof this !== 'function') {
				throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
			}
	
			function C() {}
	
			var a = [].slice;
			var f = a.call(arguments, 1);
			var _this = this;
			var D = function() {
				return _this.apply(this instanceof C ? this : b || window, f.concat(a.call(arguments)));
			};
	
			C.prototype = this.prototype;
			D.prototype = new C();
	
			return D;
		};
	
	}
	
	/**
	 * @hello.js
	 *
	 * HelloJS is a client side Javascript SDK for making OAuth2 logins and subsequent REST calls.
	 *
	 * @author Andrew Dodson
	 * @website https://adodson.com/hello.js/
	 *
	 * @copyright Andrew Dodson, 2012 - 2015
	 * @license MIT: You are free to use and modify this code for any use, on the condition that this copyright notice remains.
	 */
	
	var hello = function(name) {
		return hello.use(name);
	};
	
	hello.utils = {
	
		// Extend the first object with the properties and methods of the second
		extend: function(r /*, a[, b[, ...]] */) {
	
			// Get the arguments as an array but ommit the initial item
			Array.prototype.slice.call(arguments, 1).forEach(function(a) {
				if (Array.isArray(r) && Array.isArray(a)) {
					Array.prototype.push.apply(r, a);
				}
				else if (r instanceof Object && a instanceof Object && r !== a) {
					for (var x in a) {
						r[x] = hello.utils.extend(r[x], a[x]);
					}
				}
				else {
	
					if (Array.isArray(a)) {
						// Clone it
						a = a.slice(0);
					}
	
					r = a;
				}
			});
	
			return r;
		}
	};
	
	// Core library
	hello.utils.extend(hello, {
	
		settings: {
	
			// OAuth2 authentication defaults
			redirect_uri: window.location.href.split('#')[0],
			response_type: 'token',
			display: 'popup',
			state: '',
	
			// OAuth1 shim
			// The path to the OAuth1 server for signing user requests
			// Want to recreate your own? Checkout https://github.com/MrSwitch/node-oauth-shim
			oauth_proxy: 'https://auth-server.herokuapp.com/proxy',
	
			// API timeout in milliseconds
			timeout: 20000,
	
			// Popup Options
			popup: {
				resizable: 1,
				scrollbars: 1,
				width: 500,
				height: 550
			},
	
			// Default scope
			// Many services require atleast a profile scope,
			// HelloJS automatially includes the value of provider.scope_map.basic
			// If that's not required it can be removed via hello.settings.scope.length = 0;
			scope: ['basic'],
	
			// Scope Maps
			// This is the default module scope, these are the defaults which each service is mapped too.
			// By including them here it prevents the scope from being applied accidentally
			scope_map: {
				basic: ''
			},
	
			// Default service / network
			default_service: null,
	
			// Force authentication
			// When hello.login is fired.
			// (null): ignore current session expiry and continue with login
			// (true): ignore current session expiry and continue with login, ask for user to reauthenticate
			// (false): if the current session looks good for the request scopes return the current session.
			force: null,
	
			// Page URL
			// When 'display=page' this property defines where the users page should end up after redirect_uri
			// Ths could be problematic if the redirect_uri is indeed the final place,
			// Typically this circumvents the problem of the redirect_url being a dumb relay page.
			page_uri: window.location.href
		},
	
		// Service configuration objects
		services: {},
	
		// Use
		// Define a new instance of the HelloJS library with a default service
		use: function(service) {
	
			// Create self, which inherits from its parent
			var self = Object.create(this);
	
			// Inherit the prototype from its parent
			self.settings = Object.create(this.settings);
	
			// Define the default service
			if (service) {
				self.settings.default_service = service;
			}
	
			// Create an instance of Events
			self.utils.Event.call(self);
	
			return self;
		},
	
		// Initialize
		// Define the client_ids for the endpoint services
		// @param object o, contains a key value pair, service => clientId
		// @param object opts, contains a key value pair of options used for defining the authentication defaults
		// @param number timeout, timeout in seconds
		init: function(services, options) {
	
			var utils = this.utils;
	
			if (!services) {
				return this.services;
			}
	
			// Define provider credentials
			// Reformat the ID field
			for (var x in services) {if (services.hasOwnProperty(x)) {
				if (typeof (services[x]) !== 'object') {
					services[x] = {id: services[x]};
				}
			}}
	
			// Merge services if there already exists some
			utils.extend(this.services, services);
	
			// Update the default settings with this one.
			if (options) {
				utils.extend(this.settings, options);
	
				// Do this immediatly incase the browser changes the current path.
				if ('redirect_uri' in options) {
					this.settings.redirect_uri = utils.url(options.redirect_uri).href;
				}
			}
	
			return this;
		},
	
		// Login
		// Using the endpoint
		// @param network stringify       name to connect to
		// @param options object    (optional)  {display mode, is either none|popup(default)|page, scope: email,birthday,publish, .. }
		// @param callback  function  (optional)  fired on signin
		login: function() {
	
			// Create an object which inherits its parent as the prototype and constructs a new event chain.
			var _this = this;
			var utils = _this.utils;
			var error = utils.error;
			var promise = utils.Promise();
	
			// Get parameters
			var p = utils.args({network: 's', options: 'o', callback: 'f'}, arguments);
	
			// Local vars
			var url;
	
			// Get all the custom options and store to be appended to the querystring
			var qs = utils.diffKey(p.options, _this.settings);
	
			// Merge/override options with app defaults
			var opts = p.options = utils.merge(_this.settings, p.options || {});
	
			// Merge/override options with app defaults
			opts.popup = utils.merge(_this.settings.popup, p.options.popup || {});
	
			// Network
			p.network = p.network || _this.settings.default_service;
	
			// Bind callback to both reject and fulfill states
			promise.proxy.then(p.callback, p.callback);
	
			// Trigger an event on the global listener
			function emit(s, value) {
				hello.emit(s, value);
			}
	
			promise.proxy.then(emit.bind(this, 'auth.login auth'), emit.bind(this, 'auth.failed auth'));
	
			// Is our service valid?
			if (typeof (p.network) !== 'string' || !(p.network in _this.services)) {
				// Trigger the default login.
				// Ahh we dont have one.
				return promise.reject(error('invalid_network', 'The provided network was not recognized'));
			}
	
			var provider = _this.services[p.network];
	
			// Create a global listener to capture events triggered out of scope
			var callbackId = utils.globalEvent(function(str) {
	
				// The responseHandler returns a string, lets save this locally
				var obj;
	
				if (str) {
					obj = JSON.parse(str);
				}
				else {
					obj = error('cancelled', 'The authentication was not completed');
				}
	
				// Handle these response using the local
				// Trigger on the parent
				if (!obj.error) {
	
					// Save on the parent window the new credentials
					// This fixes an IE10 bug i think... atleast it does for me.
					utils.store(obj.network, obj);
	
					// Fulfill a successful login
					promise.fulfill({
						network: obj.network,
						authResponse: obj
					});
				}
				else {
					// Reject a successful login
					promise.reject(obj);
				}
			});
	
			var redirectUri = utils.url(opts.redirect_uri).href;
	
			// May be a space-delimited list of multiple, complementary types
			var responseType = provider.oauth.response_type || opts.response_type;
	
			// Fallback to token if the module hasn't defined a grant url
			if (/\bcode\b/.test(responseType) && !provider.oauth.grant) {
				responseType = responseType.replace(/\bcode\b/, 'token');
			}
	
			// Query string parameters, we may pass our own arguments to form the querystring
			p.qs = utils.merge(qs, {
				client_id: encodeURIComponent(provider.id),
				response_type: encodeURIComponent(responseType),
				redirect_uri: encodeURIComponent(redirectUri),
				display: opts.display,
				state: {
					client_id: provider.id,
					network: p.network,
					display: opts.display,
					callback: callbackId,
					state: opts.state,
					redirect_uri: redirectUri
				}
			});
	
			// Get current session for merging scopes, and for quick auth response
			var session = utils.store(p.network);
	
			// Scopes (authentication permisions)
			// Ensure this is a string - IE has a problem moving Arrays between windows
			// Append the setup scope
			var SCOPE_SPLIT = /[,\s]+/;
	
			// Include default scope settings (cloned).
			var scope = _this.settings.scope ? [_this.settings.scope.toString()] : [];
	
			// Extend the providers scope list with the default
			var scopeMap = utils.merge(_this.settings.scope_map, provider.scope || {});
	
			// Add user defined scopes...
			if (opts.scope) {
				scope.push(opts.scope.toString());
			}
	
			// Append scopes from a previous session.
			// This helps keep app credentials constant,
			// Avoiding having to keep tabs on what scopes are authorized
			if (session && 'scope' in session && session.scope instanceof String) {
				scope.push(session.scope);
			}
	
			// Join and Split again
			scope = scope.join(',').split(SCOPE_SPLIT);
	
			// Format remove duplicates and empty values
			scope = utils.unique(scope).filter(filterEmpty);
	
			// Save the the scopes to the state with the names that they were requested with.
			p.qs.state.scope = scope.join(',');
	
			// Map scopes to the providers naming convention
			scope = scope.map(function(item) {
				// Does this have a mapping?
				return (item in scopeMap) ? scopeMap[item] : item;
			});
	
			// Stringify and Arrayify so that double mapped scopes are given the chance to be formatted
			scope = scope.join(',').split(SCOPE_SPLIT);
	
			// Again...
			// Format remove duplicates and empty values
			scope = utils.unique(scope).filter(filterEmpty);
	
			// Join with the expected scope delimiter into a string
			p.qs.scope = scope.join(provider.scope_delim || ',');
	
			// Is the user already signed in with the appropriate scopes, valid access_token?
			if (opts.force === false) {
	
				if (session && 'access_token' in session && session.access_token && 'expires' in session && session.expires > ((new Date()).getTime() / 1e3)) {
					// What is different about the scopes in the session vs the scopes in the new login?
					var diff = utils.diff((session.scope || '').split(SCOPE_SPLIT), (p.qs.state.scope || '').split(SCOPE_SPLIT));
					if (diff.length === 0) {
	
						// OK trigger the callback
						promise.fulfill({
							unchanged: true,
							network: p.network,
							authResponse: session
						});
	
						// Nothing has changed
						return promise;
					}
				}
			}
	
			// Page URL
			if (opts.display === 'page' && opts.page_uri) {
				// Add a page location, place to endup after session has authenticated
				p.qs.state.page_uri = utils.url(opts.page_uri).href;
			}
	
			// Bespoke
			// Override login querystrings from auth_options
			if ('login' in provider && typeof (provider.login) === 'function') {
				// Format the paramaters according to the providers formatting function
				provider.login(p);
			}
	
			// Add OAuth to state
			// Where the service is going to take advantage of the oauth_proxy
			if (!/\btoken\b/.test(responseType) ||
			parseInt(provider.oauth.version, 10) < 2 ||
			(opts.display === 'none' && provider.oauth.grant && session && session.refresh_token)) {
	
				// Add the oauth endpoints
				p.qs.state.oauth = provider.oauth;
	
				// Add the proxy url
				p.qs.state.oauth_proxy = opts.oauth_proxy;
	
			}
	
			// Convert state to a string
			p.qs.state = encodeURIComponent(JSON.stringify(p.qs.state));
	
			// URL
			if (parseInt(provider.oauth.version, 10) === 1) {
	
				// Turn the request to the OAuth Proxy for 3-legged auth
				url = utils.qs(opts.oauth_proxy, p.qs, encodeFunction);
			}
	
			// Refresh token
			else if (opts.display === 'none' && provider.oauth.grant && session && session.refresh_token) {
	
				// Add the refresh_token to the request
				p.qs.refresh_token = session.refresh_token;
	
				// Define the request path
				url = utils.qs(opts.oauth_proxy, p.qs, encodeFunction);
			}
			else {
				url = utils.qs(provider.oauth.auth, p.qs, encodeFunction);
			}
	
			// Broadcast this event as an auth:init
			emit('auth.init', p);
	
			// Execute
			// Trigger how we want self displayed
			if (opts.display === 'none') {
				// Sign-in in the background, iframe
				utils.iframe(url, redirectUri);
			}
	
			// Triggering popup?
			else if (opts.display === 'popup') {
	
				var popup = utils.popup(url, redirectUri, opts.popup);
	
				var timer = setInterval(function() {
					if (!popup || popup.closed) {
						clearInterval(timer);
						if (!promise.state) {
	
							var response = error('cancelled', 'Login has been cancelled');
	
							if (!popup) {
								response = error('blocked', 'Popup was blocked');
							}
	
							response.network = p.network;
	
							promise.reject(response);
						}
					}
				}, 100);
			}
	
			else {
				window.location = url;
			}
	
			return promise.proxy;
	
			function encodeFunction(s) {return s;}
	
			function filterEmpty(s) {return !!s;}
		},
	
		// Remove any data associated with a given service
		// @param string name of the service
		// @param function callback
		logout: function() {
	
			var _this = this;
			var utils = _this.utils;
			var error = utils.error;
	
			// Create a new promise
			var promise = utils.Promise();
	
			var p = utils.args({name:'s', options: 'o', callback: 'f'}, arguments);
	
			p.options = p.options || {};
	
			// Add callback to events
			promise.proxy.then(p.callback, p.callback);
	
			// Trigger an event on the global listener
			function emit(s, value) {
				hello.emit(s, value);
			}
	
			promise.proxy.then(emit.bind(this, 'auth.logout auth'), emit.bind(this, 'error'));
	
			// Network
			p.name = p.name || this.settings.default_service;
			p.authResponse = utils.store(p.name);
	
			if (p.name && !(p.name in _this.services)) {
	
				promise.reject(error('invalid_network', 'The network was unrecognized'));
	
			}
			else if (p.name && p.authResponse) {
	
				// Define the callback
				var callback = function(opts) {
	
					// Remove from the store
					utils.store(p.name, null);
	
					// Emit events by default
					promise.fulfill(hello.utils.merge({network:p.name}, opts || {}));
				};
	
				// Run an async operation to remove the users session
				var _opts = {};
				if (p.options.force) {
					var logout = _this.services[p.name].logout;
					if (logout) {
						// Convert logout to URL string,
						// If no string is returned, then this function will handle the logout async style
						if (typeof (logout) === 'function') {
							logout = logout(callback, p);
						}
	
						// If logout is a string then assume URL and open in iframe.
						if (typeof (logout) === 'string') {
							utils.iframe(logout);
							_opts.force = null;
							_opts.message = 'Logout success on providers site was indeterminate';
						}
						else if (logout === undefined) {
							// The callback function will handle the response.
							return promise.proxy;
						}
					}
				}
	
				// Remove local credentials
				callback(_opts);
			}
			else {
				promise.reject(error('invalid_session', 'There was no session to remove'));
			}
	
			return promise.proxy;
		},
	
		// Returns all the sessions that are subscribed too
		// @param string optional, name of the service to get information about.
		getAuthResponse: function(service) {
	
			// If the service doesn't exist
			service = service || this.settings.default_service;
	
			if (!service || !(service in this.services)) {
				return null;
			}
	
			return this.utils.store(service) || null;
		},
	
		// Events: placeholder for the events
		events: {}
	});
	
	// Core utilities
	hello.utils.extend(hello.utils, {
	
		// Error
		error: function(code, message) {
			return {
				error: {
					code: code,
					message: message
				}
			};
		},
	
		// Append the querystring to a url
		// @param string url
		// @param object parameters
		qs: function(url, params, formatFunction) {
	
			if (params) {
	
				// Set default formatting function
				formatFunction = formatFunction || encodeURIComponent;
	
				// Override the items in the URL which already exist
				for (var x in params) {
					var str = '([\\?\\&])' + x + '=[^\\&]*';
					var reg = new RegExp(str);
					if (url.match(reg)) {
						url = url.replace(reg, '$1' + x + '=' + formatFunction(params[x]));
						delete params[x];
					}
				}
			}
	
			if (!this.isEmpty(params)) {
				return url + (url.indexOf('?') > -1 ? '&' : '?') + this.param(params, formatFunction);
			}
	
			return url;
		},
	
		// Param
		// Explode/encode the parameters of an URL string/object
		// @param string s, string to decode
		param: function(s, formatFunction) {
			var b;
			var a = {};
			var m;
	
			if (typeof (s) === 'string') {
	
				formatFunction = formatFunction || decodeURIComponent;
	
				m = s.replace(/^[\#\?]/, '').match(/([^=\/\&]+)=([^\&]+)/g);
				if (m) {
					for (var i = 0; i < m.length; i++) {
						b = m[i].match(/([^=]+)=(.*)/);
						a[b[1]] = formatFunction(b[2]);
					}
				}
	
				return a;
			}
			else {
	
				formatFunction = formatFunction || encodeURIComponent;
	
				var o = s;
	
				a = [];
	
				for (var x in o) {if (o.hasOwnProperty(x)) {
					if (o.hasOwnProperty(x)) {
						a.push([x, o[x] === '?' ? '?' : formatFunction(o[x])].join('='));
					}
				}}
	
				return a.join('&');
			}
		},
	
		// Local storage facade
		store: (function() {
	
			var a = ['localStorage', 'sessionStorage'];
			var i = -1;
			var prefix = 'test';
	
			// Set LocalStorage
			var localStorage;
	
			while (a[++i]) {
				try {
					// In Chrome with cookies blocked, calling localStorage throws an error
					localStorage = window[a[i]];
					localStorage.setItem(prefix + i, i);
					localStorage.removeItem(prefix + i);
					break;
				}
				catch (e) {
					localStorage = null;
				}
			}
	
			if (!localStorage) {
	
				var cache = null;
	
				localStorage = {
					getItem: function(prop) {
						prop = prop + '=';
						var m = document.cookie.split(';');
						for (var i = 0; i < m.length; i++) {
							var _m = m[i].replace(/(^\s+|\s+$)/, '');
							if (_m && _m.indexOf(prop) === 0) {
								return _m.substr(prop.length);
							}
						}
	
						return cache;
					},
	
					setItem: function(prop, value) {
						cache = value;
						document.cookie = prop + '=' + value;
					}
				};
	
				// Fill the cache up
				cache = localStorage.getItem('hello');
			}
	
			function get() {
				var json = {};
				try {
					json = JSON.parse(localStorage.getItem('hello')) || {};
				}
				catch (e) {}
	
				return json;
			}
	
			function set(json) {
				localStorage.setItem('hello', JSON.stringify(json));
			}
	
			// Check if the browser support local storage
			return function(name, value, days) {
	
				// Local storage
				var json = get();
	
				if (name && value === undefined) {
					return json[name] || null;
				}
				else if (name && value === null) {
					try {
						delete json[name];
					}
					catch (e) {
						json[name] = null;
					}
				}
				else if (name) {
					json[name] = value;
				}
				else {
					return json;
				}
	
				set(json);
	
				return json || null;
			};
	
		})(),
	
		// Create and Append new DOM elements
		// @param node string
		// @param attr object literal
		// @param dom/string
		append: function(node, attr, target) {
	
			var n = typeof (node) === 'string' ? document.createElement(node) : node;
	
			if (typeof (attr) === 'object') {
				if ('tagName' in attr) {
					target = attr;
				}
				else {
					for (var x in attr) {if (attr.hasOwnProperty(x)) {
						if (typeof (attr[x]) === 'object') {
							for (var y in attr[x]) {if (attr[x].hasOwnProperty(y)) {
								n[x][y] = attr[x][y];
							}}
						}
						else if (x === 'html') {
							n.innerHTML = attr[x];
						}
	
						// IE doesn't like us setting methods with setAttribute
						else if (!/^on/.test(x)) {
							n.setAttribute(x, attr[x]);
						}
						else {
							n[x] = attr[x];
						}
					}}
				}
			}
	
			if (target === 'body') {
				(function self() {
					if (document.body) {
						document.body.appendChild(n);
					}
					else {
						setTimeout(self, 16);
					}
				})();
			}
			else if (typeof (target) === 'object') {
				target.appendChild(n);
			}
			else if (typeof (target) === 'string') {
				document.getElementsByTagName(target)[0].appendChild(n);
			}
	
			return n;
		},
	
		// An easy way to create a hidden iframe
		// @param string src
		iframe: function(src) {
			this.append('iframe', {src: src, style: {position:'absolute', left: '-1000px', bottom: 0, height: '1px', width: '1px'}}, 'body');
		},
	
		// Recursive merge two objects into one, second parameter overides the first
		// @param a array
		merge: function(/* Args: a, b, c, .. n */) {
			var args = Array.prototype.slice.call(arguments);
			args.unshift({});
			return this.extend.apply(null, args);
		},
	
		// Makes it easier to assign parameters, where some are optional
		// @param o object
		// @param a arguments
		args: function(o, args) {
	
			var p = {};
			var i = 0;
			var t = null;
			var x = null;
	
			// 'x' is the first key in the list of object parameters
			for (x in o) {if (o.hasOwnProperty(x)) {
				break;
			}}
	
			// Passing in hash object of arguments?
			// Where the first argument can't be an object
			if ((args.length === 1) && (typeof (args[0]) === 'object') && o[x] != 'o!') {
	
				// Could this object still belong to a property?
				// Check the object keys if they match any of the property keys
				for (x in args[0]) {if (o.hasOwnProperty(x)) {
					// Does this key exist in the property list?
					if (x in o) {
						// Yes this key does exist so its most likely this function has been invoked with an object parameter
						// Return first argument as the hash of all arguments
						return args[0];
					}
				}}
			}
	
			// Else loop through and account for the missing ones.
			for (x in o) {if (o.hasOwnProperty(x)) {
	
				t = typeof (args[i]);
	
				if ((typeof (o[x]) === 'function' && o[x].test(args[i])) || (typeof (o[x]) === 'string' && (
				(o[x].indexOf('s') > -1 && t === 'string') ||
				(o[x].indexOf('o') > -1 && t === 'object') ||
				(o[x].indexOf('i') > -1 && t === 'number') ||
				(o[x].indexOf('a') > -1 && t === 'object') ||
				(o[x].indexOf('f') > -1 && t === 'function')
				))
				) {
					p[x] = args[i++];
				}
	
				else if (typeof (o[x]) === 'string' && o[x].indexOf('!') > -1) {
					return false;
				}
			}}
	
			return p;
		},
	
		// Returns a URL instance
		url: function(path) {
	
			// If the path is empty
			if (!path) {
				return window.location;
			}
	
			// Chrome and FireFox support new URL() to extract URL objects
			else if (window.URL && URL instanceof Function && URL.length !== 0) {
				return new URL(path, window.location);
			}
	
			// Ugly shim, it works!
			else {
				var a = document.createElement('a');
				a.href = path;
				return a.cloneNode(false);
			}
		},
	
		diff: function(a, b) {
			return b.filter(function(item) {
				return a.indexOf(item) === -1;
			});
		},
	
		// Get the different hash of properties unique to `a`, and not in `b`
		diffKey: function(a, b) {
			if (a || !b) {
				var r = {};
				for (var x in a) {
					// Does the property not exist?
					if (!(x in b)) {
						r[x] = a[x];
					}
				}
	
				return r;
			}
	
			return a;
		},
	
		// Unique
		// Remove duplicate and null values from an array
		// @param a array
		unique: function(a) {
			if (!Array.isArray(a)) { return []; }
	
			return a.filter(function(item, index) {
				// Is this the first location of item
				return a.indexOf(item) === index;
			});
		},
	
		isEmpty: function(obj) {
	
			// Scalar
			if (!obj)
				return true;
	
			// Array
			if (Array.isArray(obj)) {
				return !obj.length;
			}
			else if (typeof (obj) === 'object') {
				// Object
				for (var key in obj) {
					if (obj.hasOwnProperty(key)) {
						return false;
					}
				}
			}
	
			return true;
		},
	
		//jscs:disable
	
		/*!
		 **  Thenable -- Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
		 **  Copyright (c) 2013-2014 Ralf S. Engelschall <http://engelschall.com>
		 **  Licensed under The MIT License <http://opensource.org/licenses/MIT>
		 **  Source-Code distributed on <http://github.com/rse/thenable>
		 */
		Promise: (function(){
			/*  promise states [Promises/A+ 2.1]  */
			var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
			var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
			var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */
	
			/*  promise object constructor  */
			var api = function (executor) {
				/*  optionally support non-constructor/plain-function call  */
				if (!(this instanceof api))
					return new api(executor);
	
				/*  initialize object  */
				this.id           = "Thenable/1.0.6";
				this.state        = STATE_PENDING; /*  initial state  */
				this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
				this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
				this.onFulfilled  = [];            /*  initial handlers  */
				this.onRejected   = [];            /*  initial handlers  */
	
				/*  provide optional information-hiding proxy  */
				this.proxy = {
					then: this.then.bind(this)
				};
	
				/*  support optional executor function  */
				if (typeof executor === "function")
					executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
			};
	
			/*  promise API methods  */
			api.prototype = {
				/*  promise resolving methods  */
				fulfill: function (value) { return deliver(this, STATE_FULFILLED, "fulfillValue", value); },
				reject:  function (value) { return deliver(this, STATE_REJECTED,  "rejectReason", value); },
	
				/*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
				then: function (onFulfilled, onRejected) {
					var curr = this;
					var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
					curr.onFulfilled.push(
						resolver(onFulfilled, next, "fulfill"));             /*  [Promises/A+ 2.2.2/2.2.6]  */
					curr.onRejected.push(
						resolver(onRejected,  next, "reject" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
					execute(curr);
					return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
				}
			};
	
			/*  deliver an action  */
			var deliver = function (curr, state, name, value) {
				if (curr.state === STATE_PENDING) {
					curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
					curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
					execute(curr);
				}
				return curr;
			};
	
			/*  execute all handlers  */
			var execute = function (curr) {
				if (curr.state === STATE_FULFILLED)
					execute_handlers(curr, "onFulfilled", curr.fulfillValue);
				else if (curr.state === STATE_REJECTED)
					execute_handlers(curr, "onRejected",  curr.rejectReason);
			};
	
			/*  execute particular set of handlers  */
			var execute_handlers = function (curr, name, value) {
				/* global process: true */
				/* global setImmediate: true */
				/* global setTimeout: true */
	
				/*  short-circuit processing  */
				if (curr[name].length === 0)
					return;
	
				/*  iterate over all handlers, exactly once  */
				var handlers = curr[name];
				curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
				var func = function () {
					for (var i = 0; i < handlers.length; i++)
						handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
				};
	
				/*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
				if (typeof process === "object" && typeof process.nextTick === "function")
					process.nextTick(func);
				else if (typeof setImmediate === "function")
					setImmediate(func);
				else
					setTimeout(func, 0);
			};
	
			/*  generate a resolver function  */
			var resolver = function (cb, next, method) {
				return function (value) {
					if (typeof cb !== "function")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
						next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
					else {
						var result;
						try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
						catch (e) {
							next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
							return;
						}
						resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
					}
				};
			};
	
			/*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
			var resolve = function (promise, x) {
				/*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
				if (promise === x || promise.proxy === x) {
					promise.reject(new TypeError("cannot resolve promise with itself"));
					return;
				}
	
				/*  surgically check for a "then" method
					(mainly to just call the "getter" of "then" only once)  */
				var then;
				if ((typeof x === "object" && x !== null) || typeof x === "function") {
					try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
					catch (e) {
						promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
						return;
					}
				}
	
				/*  handle own Thenables    [Promises/A+ 2.3.2]
					and similar "thenables" [Promises/A+ 2.3.3]  */
				if (typeof then === "function") {
					var resolved = false;
					try {
						/*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
						then.call(x,
							/*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
							function (y) {
								if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
								if (y === x)                                 /*  [Promises/A+ 3.6]  */
									promise.reject(new TypeError("circular thenable chain"));
								else
									resolve(promise, y);
							},
	
							/*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
							function (r) {
								if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
								promise.reject(r);
							}
						);
					}
					catch (e) {
						if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
							promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
					}
					return;
				}
	
				/*  handle other values  */
				promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
			};
	
			/*  export API  */
			return api;
		})(),
	
		//jscs:enable
	
		// Event
		// A contructor superclass for adding event menthods, on, off, emit.
		Event: function() {
	
			var separator = /[\s\,]+/;
	
			// If this doesn't support getPrototype then we can't get prototype.events of the parent
			// So lets get the current instance events, and add those to a parent property
			this.parent = {
				events: this.events,
				findEvents: this.findEvents,
				parent: this.parent,
				utils: this.utils
			};
	
			this.events = {};
	
			// On, subscribe to events
			// @param evt   string
			// @param callback  function
			this.on = function(evt, callback) {
	
				if (callback && typeof (callback) === 'function') {
					var a = evt.split(separator);
					for (var i = 0; i < a.length; i++) {
	
						// Has this event already been fired on this instance?
						this.events[a[i]] = [callback].concat(this.events[a[i]] || []);
					}
				}
	
				return this;
			};
	
			// Off, unsubscribe to events
			// @param evt   string
			// @param callback  function
			this.off = function(evt, callback) {
	
				this.findEvents(evt, function(name, index) {
					if (!callback || this.events[name][index] === callback) {
						this.events[name][index] = null;
					}
				});
	
				return this;
			};
	
			// Emit
			// Triggers any subscribed events
			this.emit = function(evt /*, data, ... */) {
	
				// Get arguments as an Array, knock off the first one
				var args = Array.prototype.slice.call(arguments, 1);
				args.push(evt);
	
				// Handler
				var handler = function(name, index) {
	
					// Replace the last property with the event name
					args[args.length - 1] = (name === '*' ? evt : name);
	
					// Trigger
					this.events[name][index].apply(this, args);
				};
	
				// Find the callbacks which match the condition and call
				var _this = this;
				while (_this && _this.findEvents) {
	
					// Find events which match
					_this.findEvents(evt + ',*', handler);
					_this = _this.parent;
				}
	
				return this;
			};
	
			//
			// Easy functions
			this.emitAfter = function() {
				var _this = this;
				var args = arguments;
				setTimeout(function() {
					_this.emit.apply(_this, args);
				}, 0);
	
				return this;
			};
	
			this.findEvents = function(evt, callback) {
	
				var a = evt.split(separator);
	
				for (var name in this.events) {if (this.events.hasOwnProperty(name)) {
	
					if (a.indexOf(name) > -1) {
	
						for (var i = 0; i < this.events[name].length; i++) {
	
							// Does the event handler exist?
							if (this.events[name][i]) {
								// Emit on the local instance of this
								callback.call(this, name, i);
							}
						}
					}
				}}
			};
	
			return this;
		},
	
		// Global Events
		// Attach the callback to the window object
		// Return its unique reference
		globalEvent: function(callback, guid) {
			// If the guid has not been supplied then create a new one.
			guid = guid || '_hellojs_' + parseInt(Math.random() * 1e12, 10).toString(36);
	
			// Define the callback function
			window[guid] = function() {
				// Trigger the callback
				try {
					if (callback.apply(this, arguments)) {
						delete window[guid];
					}
				}
				catch (e) {
					console.error(e);
				}
			};
	
			return guid;
		},
	
		// Trigger a clientside popup
		// This has been augmented to support PhoneGap
		popup: function(url, redirectUri, options) {
	
			var documentElement = document.documentElement;
	
			// Multi Screen Popup Positioning (http://stackoverflow.com/a/16861050)
			// Credit: http://www.xtf.dk/2011/08/center-new-popup-window-even-on.html
			// Fixes dual-screen position                         Most browsers      Firefox
	
			if (options.height) {
				var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;
				var height = screen.height || window.innerHeight || documentElement.clientHeight;
				options.top = parseInt((height - options.height) / 2, 10) + dualScreenTop;
			}
	
			if (options.width) {
				var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;
				var width = screen.width || window.innerWidth || documentElement.clientWidth;
				options.left = parseInt((width - options.width) / 2, 10) + dualScreenLeft;
			}
	
			// Convert options into an array
			var optionsArray = [];
			Object.keys(options).forEach(function(name) {
				var value = options[name];
				optionsArray.push(name + (value !== null ? '=' + value : ''));
			});
	
			// Call the open() function with the initial path
			//
			// OAuth redirect, fixes URI fragments from being lost in Safari
			// (URI Fragments within 302 Location URI are lost over HTTPS)
			// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
			//
			// Firefox  decodes URL fragments when calling location.hash.
			//  - This is bad if the value contains break points which are escaped
			//  - Hence the url must be encoded twice as it contains breakpoints.
			if (navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1) {
				url = redirectUri + '#oauth_redirect=' + encodeURIComponent(encodeURIComponent(url));
			}
	
			var popup = window.open(
				url,
				'_blank',
				optionsArray.join(',')
			);
	
			if (popup && popup.focus) {
				popup.focus();
			}
	
			return popup;
		},
	
		// OAuth and API response handler
		responseHandler: function(window, parent) {
	
			var _this = this;
			var p;
			var location = window.location;
	
			// Is this an auth relay message which needs to call the proxy?
			p = _this.param(location.search);
	
			// OAuth2 or OAuth1 server response?
			if (p && p.state && (p.code || p.oauth_token)) {
	
				var state = JSON.parse(p.state);
	
				// Add this path as the redirect_uri
				p.redirect_uri = state.redirect_uri || location.href.replace(/[\?\#].*$/, '');
	
				// Redirect to the host
				var path = state.oauth_proxy + '?' + _this.param(p);
	
				location.assign(path);
	
				return;
			}
	
			// Save session, from redirected authentication
			// #access_token has come in?
			//
			// FACEBOOK is returning auth errors within as a query_string... thats a stickler for consistency.
			// SoundCloud is the state in the querystring and the token in the hashtag, so we'll mix the two together
	
			p = _this.merge(_this.param(location.search || ''), _this.param(location.hash || ''));
	
			// If p.state
			if (p && 'state' in p) {
	
				// Remove any addition information
				// E.g. p.state = 'facebook.page';
				try {
					var a = JSON.parse(p.state);
					_this.extend(p, a);
				}
				catch (e) {
					console.error('Could not decode state parameter');
				}
	
				// Access_token?
				if (('access_token' in p && p.access_token) && p.network) {
	
					if (!p.expires_in || parseInt(p.expires_in, 10) === 0) {
						// If p.expires_in is unset, set to 0
						p.expires_in = 0;
					}
	
					p.expires_in = parseInt(p.expires_in, 10);
					p.expires = ((new Date()).getTime() / 1e3) + (p.expires_in || (60 * 60 * 24 * 365));
	
					// Lets use the "state" to assign it to one of our networks
					authCallback(p, window, parent);
				}
	
				// Error=?
				// &error_description=?
				// &state=?
				else if (('error' in p && p.error) && p.network) {
	
					p.error = {
						code: p.error,
						message: p.error_message || p.error_description
					};
	
					// Let the state handler handle it
					authCallback(p, window, parent);
				}
	
				// API call, or a cancelled login
				// Result is serialized JSON string
				else if (p.callback && p.callback in parent) {
	
					// Trigger a function in the parent
					var res = 'result' in p && p.result ? JSON.parse(p.result) : false;
	
					// Trigger the callback on the parent
					parent[p.callback](res);
					closeWindow();
				}
	
				// If this page is still open
				if (p.page_uri) {
					location.assign(p.page_uri);
				}
			}
	
			// OAuth redirect, fixes URI fragments from being lost in Safari
			// (URI Fragments within 302 Location URI are lost over HTTPS)
			// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
			else if ('oauth_redirect' in p) {
	
				location.assign(decodeURIComponent(p.oauth_redirect));
				return;
			}
	
			// Trigger a callback to authenticate
			function authCallback(obj, window, parent) {
	
				var cb = obj.callback;
				var network = obj.network;
	
				// Trigger the callback on the parent
				_this.store(network, obj);
	
				// If this is a page request it has no parent or opener window to handle callbacks
				if (('display' in obj) && obj.display === 'page') {
					return;
				}
	
				// Remove from session object
				if (parent && cb && cb in parent) {
	
					try {
						delete obj.callback;
					}
					catch (e) {}
	
					// Update store
					_this.store(network, obj);
	
					// Call the globalEvent function on the parent
					// It's safer to pass back a string to the parent,
					// Rather than an object/array (better for IE8)
					var str = JSON.stringify(obj);
	
					try {
						parent[cb](str);
					}
					catch (e) {
						// Error thrown whilst executing parent callback
					}
				}
	
				closeWindow();
			}
	
			function closeWindow() {
	
				if (window.frameElement) {
					// Inside an iframe, remove from parent
					parent.document.body.removeChild(window.frameElement);
				}
				else {
					// Close this current window
					try {
						window.close();
					}
					catch (e) {}
	
					// IOS bug wont let us close a popup if still loading
					if (window.addEventListener) {
						window.addEventListener('load', function() {
							window.close();
						});
					}
				}
	
			}
		}
	});
	
	// Events
	// Extend the hello object with its own event instance
	hello.utils.Event.call(hello);
	
	///////////////////////////////////
	// Monitoring session state
	// Check for session changes
	///////////////////////////////////
	
	(function(hello) {
	
		// Monitor for a change in state and fire
		var oldSessions = {};
	
		// Hash of expired tokens
		var expired = {};
	
		// Listen to other triggers to Auth events, use these to update this
		hello.on('auth.login, auth.logout', function(auth) {
			if (auth && typeof (auth) === 'object' && auth.network) {
				oldSessions[auth.network] = hello.utils.store(auth.network) || {};
			}
		});
	
		(function self() {
	
			var CURRENT_TIME = ((new Date()).getTime() / 1e3);
			var emit = function(eventName) {
				hello.emit('auth.' + eventName, {
					network: name,
					authResponse: session
				});
			};
	
			// Loop through the services
			for (var name in hello.services) {if (hello.services.hasOwnProperty(name)) {
	
				if (!hello.services[name].id) {
					// We haven't attached an ID so dont listen.
					continue;
				}
	
				// Get session
				var session = hello.utils.store(name) || {};
				var provider = hello.services[name];
				var oldSess = oldSessions[name] || {};
	
				// Listen for globalEvents that did not get triggered from the child
				if (session && 'callback' in session) {
	
					// To do remove from session object...
					var cb = session.callback;
					try {
						delete session.callback;
					}
					catch (e) {}
	
					// Update store
					// Removing the callback
					hello.utils.store(name, session);
	
					// Emit global events
					try {
						window[cb](session);
					}
					catch (e) {}
				}
	
				// Refresh token
				if (session && ('expires' in session) && session.expires < CURRENT_TIME) {
	
					// If auto refresh is possible
					// Either the browser supports
					var refresh = provider.refresh || session.refresh_token;
	
					// Has the refresh been run recently?
					if (refresh && (!(name in expired) || expired[name] < CURRENT_TIME)) {
						// Try to resignin
						hello.emit('notice', name + ' has expired trying to resignin');
						hello.login(name, {display: 'none', force: false});
	
						// Update expired, every 10 minutes
						expired[name] = CURRENT_TIME + 600;
					}
	
					// Does this provider not support refresh
					else if (!refresh && !(name in expired)) {
						// Label the event
						emit('expired');
						expired[name] = true;
					}
	
					// If session has expired then we dont want to store its value until it can be established that its been updated
					continue;
				}
	
				// Has session changed?
				else if (oldSess.access_token === session.access_token &&
				oldSess.expires === session.expires) {
					continue;
				}
	
				// Access_token has been removed
				else if (!session.access_token && oldSess.access_token) {
					emit('logout');
				}
	
				// Access_token has been created
				else if (session.access_token && !oldSess.access_token) {
					emit('login');
				}
	
				// Access_token has been updated
				else if (session.expires !== oldSess.expires) {
					emit('update');
				}
	
				// Updated stored session
				oldSessions[name] = session;
	
				// Remove the expired flags
				if (name in expired) {
					delete expired[name];
				}
			}}
	
			// Check error events
			setTimeout(self, 1000);
		})();
	
	})(hello);
	
	// EOF CORE lib
	//////////////////////////////////
	
	/////////////////////////////////////////
	// API
	// @param path    string
	// @param query   object (optional)
	// @param method  string (optional)
	// @param data    object (optional)
	// @param timeout integer (optional)
	// @param callback  function (optional)
	
	hello.api = function() {
	
		// Shorthand
		var _this = this;
		var utils = _this.utils;
		var error = utils.error;
	
		// Construct a new Promise object
		var promise = utils.Promise();
	
		// Arguments
		var p = utils.args({path: 's!', query: 'o', method: 's', data: 'o', timeout: 'i', callback: 'f'}, arguments);
	
		// Method
		p.method = (p.method || 'get').toLowerCase();
	
		// Headers
		p.headers = p.headers || {};
	
		// Query
		p.query = p.query || {};
	
		// If get, put all parameters into query
		if (p.method === 'get' || p.method === 'delete') {
			utils.extend(p.query, p.data);
			p.data = {};
		}
	
		var data = p.data = p.data || {};
	
		// Completed event callback
		promise.then(p.callback, p.callback);
	
		// Remove the network from path, e.g. facebook:/me/friends
		// Results in { network : facebook, path : me/friends }
		if (!p.path) {
			return promise.reject(error('invalid_path', 'Missing the path parameter from the request'));
		}
	
		p.path = p.path.replace(/^\/+/, '');
		var a = (p.path.split(/[\/\:]/, 2) || [])[0].toLowerCase();
	
		if (a in _this.services) {
			p.network = a;
			var reg = new RegExp('^' + a + ':?\/?');
			p.path = p.path.replace(reg, '');
		}
	
		// Network & Provider
		// Define the network that this request is made for
		p.network = _this.settings.default_service = p.network || _this.settings.default_service;
		var o = _this.services[p.network];
	
		// INVALID
		// Is there no service by the given network name?
		if (!o) {
			return promise.reject(error('invalid_network', 'Could not match the service requested: ' + p.network));
		}
	
		// PATH
		// As long as the path isn't flagged as unavaiable, e.g. path == false
	
		if (!(!(p.method in o) || !(p.path in o[p.method]) || o[p.method][p.path] !== false)) {
			return promise.reject(error('invalid_path', 'The provided path is not available on the selected network'));
		}
	
		// PROXY
		// OAuth1 calls always need a proxy
	
		if (!p.oauth_proxy) {
			p.oauth_proxy = _this.settings.oauth_proxy;
		}
	
		if (!('proxy' in p)) {
			p.proxy = p.oauth_proxy && o.oauth && parseInt(o.oauth.version, 10) === 1;
		}
	
		// TIMEOUT
		// Adopt timeout from global settings by default
	
		if (!('timeout' in p)) {
			p.timeout = _this.settings.timeout;
		}
	
		// Format response
		// Whether to run the raw response through post processing.
		if (!('formatResponse' in p)) {
			p.formatResponse = true;
		}
	
		// Get the current session
		// Append the access_token to the query
		p.authResponse = _this.getAuthResponse(p.network);
		if (p.authResponse && p.authResponse.access_token) {
			p.query.access_token = p.authResponse.access_token;
		}
	
		var url = p.path;
		var m;
	
		// Store the query as options
		// This is used to populate the request object before the data is augmented by the prewrap handlers.
		p.options = utils.clone(p.query);
	
		// Clone the data object
		// Prevent this script overwriting the data of the incoming object.
		// Ensure that everytime we run an iteration the callbacks haven't removed some data
		p.data = utils.clone(data);
	
		// URL Mapping
		// Is there a map for the given URL?
		var actions = o[{'delete': 'del'}[p.method] || p.method] || {};
	
		// Extrapolate the QueryString
		// Provide a clean path
		// Move the querystring into the data
		if (p.method === 'get') {
	
			var query = url.split(/[\?#]/)[1];
			if (query) {
				utils.extend(p.query, utils.param(query));
	
				// Remove the query part from the URL
				url = url.replace(/\?.*?(#|$)/, '$1');
			}
		}
	
		// Is the hash fragment defined
		if ((m = url.match(/#(.+)/, ''))) {
			url = url.split('#')[0];
			p.path = m[1];
		}
		else if (url in actions) {
			p.path = url;
			url = actions[url];
		}
		else if ('default' in actions) {
			url = actions['default'];
		}
	
		// Redirect Handler
		// This defines for the Form+Iframe+Hash hack where to return the results too.
		p.redirect_uri = _this.settings.redirect_uri;
	
		// Define FormatHandler
		// The request can be procesed in a multitude of ways
		// Here's the options - depending on the browser and endpoint
		p.xhr = o.xhr;
		p.jsonp = o.jsonp;
		p.form = o.form;
	
		// Make request
		if (typeof (url) === 'function') {
			// Does self have its own callback?
			url(p, getPath);
		}
		else {
			// Else the URL is a string
			getPath(url);
		}
	
		return promise.proxy;
	
		// If url needs a base
		// Wrap everything in
		function getPath(url) {
	
			// Format the string if it needs it
			url = url.replace(/\@\{([a-z\_\-]+)(\|.*?)?\}/gi, function(m, key, defaults) {
				var val = defaults ? defaults.replace(/^\|/, '') : '';
				if (key in p.query) {
					val = p.query[key];
					delete p.query[key];
				}
				else if (p.data && key in p.data) {
					val = p.data[key];
					delete p.data[key];
				}
				else if (!defaults) {
					promise.reject(error('missing_attribute', 'The attribute ' + key + ' is missing from the request'));
				}
	
				return val;
			});
	
			// Add base
			if (!url.match(/^https?:\/\//)) {
				url = o.base + url;
			}
	
			// Define the request URL
			p.url = url;
	
			// Make the HTTP request with the curated request object
			// CALLBACK HANDLER
			// @ response object
			// @ statusCode integer if available
			utils.request(p, function(r, headers) {
	
				// Is this a raw response?
				if (!p.formatResponse) {
					// Bad request? error statusCode or otherwise contains an error response vis JSONP?
					if (typeof headers === 'object' ? (headers.statusCode >= 400) : (typeof r === 'object' && 'error' in r)) {
						promise.reject(r);
					}
					else {
						promise.fulfill(r);
					}
	
					return;
				}
	
				// Should this be an object
				if (r === true) {
					r = {success:true};
				}
				else if (!r) {
					r = {};
				}
	
				// The delete callback needs a better response
				if (p.method === 'delete') {
					r = (!r || utils.isEmpty(r)) ? {success:true} : r;
				}
	
				// FORMAT RESPONSE?
				// Does self request have a corresponding formatter
				if (o.wrap && ((p.path in o.wrap) || ('default' in o.wrap))) {
					var wrap = (p.path in o.wrap ? p.path : 'default');
					var time = (new Date()).getTime();
	
					// FORMAT RESPONSE
					var b = o.wrap[wrap](r, headers, p);
	
					// Has the response been utterly overwritten?
					// Typically self augments the existing object.. but for those rare occassions
					if (b) {
						r = b;
					}
				}
	
				// Is there a next_page defined in the response?
				if (r && 'paging' in r && r.paging.next) {
	
					// Add the relative path if it is missing from the paging/next path
					if (r.paging.next[0] === '?') {
						r.paging.next = p.path + r.paging.next;
					}
	
					// The relative path has been defined, lets markup the handler in the HashFragment
					else {
						r.paging.next += '#' + p.path;
					}
				}
	
				// Dispatch to listeners
				// Emit events which pertain to the formatted response
				if (!r || 'error' in r) {
					promise.reject(r);
				}
				else {
					promise.fulfill(r);
				}
			});
		}
	};
	
	// API utilities
	hello.utils.extend(hello.utils, {
	
		// Make an HTTP request
		request: function(p, callback) {
	
			var _this = this;
			var error = _this.error;
	
			// This has to go through a POST request
			if (!_this.isEmpty(p.data) && !('FileList' in window) && _this.hasBinary(p.data)) {
	
				// Disable XHR and JSONP
				p.xhr = false;
				p.jsonp = false;
			}
	
			// Check if the browser and service support CORS
			var cors = this.request_cors(function() {
				// If it does then run this...
				return ((p.xhr === undefined) || (p.xhr && (typeof (p.xhr) !== 'function' || p.xhr(p, p.query))));
			});
	
			if (cors) {
	
				formatUrl(p, function(url) {
	
					var x = _this.xhr(p.method, url, p.headers, p.data, callback);
					x.onprogress = p.onprogress || null;
	
					// Windows Phone does not support xhr.upload, see #74
					// Feature detect
					if (x.upload && p.onuploadprogress) {
						x.upload.onprogress = p.onuploadprogress;
					}
	
				});
	
				return;
			}
	
			// Clone the query object
			// Each request modifies the query object and needs to be tared after each one.
			var _query = p.query;
	
			p.query = _this.clone(p.query);
	
			// Assign a new callbackID
			p.callbackID = _this.globalEvent();
	
			// JSONP
			if (p.jsonp !== false) {
	
				// Clone the query object
				p.query.callback = p.callbackID;
	
				// If the JSONP is a function then run it
				if (typeof (p.jsonp) === 'function') {
					p.jsonp(p, p.query);
				}
	
				// Lets use JSONP if the method is 'get'
				if (p.method === 'get') {
	
					formatUrl(p, function(url) {
						_this.jsonp(url, callback, p.callbackID, p.timeout);
					});
	
					return;
				}
				else {
					// It's not compatible reset query
					p.query = _query;
				}
	
			}
	
			// Otherwise we're on to the old school, iframe hacks and JSONP
			if (p.form !== false) {
	
				// Add some additional query parameters to the URL
				// We're pretty stuffed if the endpoint doesn't like these
				p.query.redirect_uri = p.redirect_uri;
				p.query.state = JSON.stringify({callback:p.callbackID});
	
				var opts;
	
				if (typeof (p.form) === 'function') {
	
					// Format the request
					opts = p.form(p, p.query);
				}
	
				if (p.method === 'post' && opts !== false) {
	
					formatUrl(p, function(url) {
						_this.post(url, p.data, opts, callback, p.callbackID, p.timeout);
					});
	
					return;
				}
			}
	
			// None of the methods were successful throw an error
			callback(error('invalid_request', 'There was no mechanism for handling this request'));
	
			return;
	
			// Format URL
			// Constructs the request URL, optionally wraps the URL through a call to a proxy server
			// Returns the formatted URL
			function formatUrl(p, callback) {
	
				// Are we signing the request?
				var sign;
	
				// OAuth1
				// Remove the token from the query before signing
				if (p.authResponse && p.authResponse.oauth && parseInt(p.authResponse.oauth.version, 10) === 1) {
	
					// OAUTH SIGNING PROXY
					sign = p.query.access_token;
	
					// Remove the access_token
					delete p.query.access_token;
	
					// Enfore use of Proxy
					p.proxy = true;
				}
	
				// POST body to querystring
				if (p.data && (p.method === 'get' || p.method === 'delete')) {
					// Attach the p.data to the querystring.
					_this.extend(p.query, p.data);
					p.data = null;
				}
	
				// Construct the path
				var path = _this.qs(p.url, p.query);
	
				// Proxy the request through a server
				// Used for signing OAuth1
				// And circumventing services without Access-Control Headers
				if (p.proxy) {
					// Use the proxy as a path
					path = _this.qs(p.oauth_proxy, {
						path: path,
						access_token: sign || '',
	
						// This will prompt the request to be signed as though it is OAuth1
						then: p.proxy_response_type || (p.method.toLowerCase() === 'get' ? 'redirect' : 'proxy'),
						method: p.method.toLowerCase(),
						suppress_response_codes: true
					});
				}
	
				callback(path);
			}
		},
	
		// Test whether the browser supports the CORS response
		request_cors: function(callback) {
			return 'withCredentials' in new XMLHttpRequest() && callback();
		},
	
		// Return the type of DOM object
		domInstance: function(type, data) {
			var test = 'HTML' + (type || '').replace(
				/^[a-z]/,
				function(m) {
					return m.toUpperCase();
				}
	
			) + 'Element';
	
			if (!data) {
				return false;
			}
	
			if (window[test]) {
				return data instanceof window[test];
			}
			else if (window.Element) {
				return data instanceof window.Element && (!type || (data.tagName && data.tagName.toLowerCase() === type));
			}
			else {
				return (!(data instanceof Object || data instanceof Array || data instanceof String || data instanceof Number) && data.tagName && data.tagName.toLowerCase() === type);
			}
		},
	
		// Create a clone of an object
		clone: function(obj) {
			// Does not clone DOM elements, nor Binary data, e.g. Blobs, Filelists
			if (obj === null || typeof (obj) !== 'object' || obj instanceof Date || 'nodeName' in obj || this.isBinary(obj) || (typeof FormData === 'function' && obj instanceof FormData)) {
				return obj;
			}
	
			if (Array.isArray(obj)) {
				// Clone each item in the array
				return obj.map(this.clone.bind(this));
			}
	
			// But does clone everything else.
			var clone = {};
			for (var x in obj) {
				clone[x] = this.clone(obj[x]);
			}
	
			return clone;
		},
	
		// XHR: uses CORS to make requests
		xhr: function(method, url, headers, data, callback) {
	
			var r = new XMLHttpRequest();
			var error = this.error;
	
			// Binary?
			var binary = false;
			if (method === 'blob') {
				binary = method;
				method = 'GET';
			}
	
			method = method.toUpperCase();
	
			// Xhr.responseType 'json' is not supported in any of the vendors yet.
			r.onload = function(e) {
				var json = r.response;
				try {
					json = JSON.parse(r.responseText);
				}
				catch (_e) {
					if (r.status === 401) {
						json = error('access_denied', r.statusText);
					}
				}
	
				var headers = headersToJSON(r.getAllResponseHeaders());
				headers.statusCode = r.status;
	
				callback(json || (method === 'GET' ? error('empty_response', 'Could not get resource') : {}), headers);
			};
	
			r.onerror = function(e) {
				var json = r.responseText;
				try {
					json = JSON.parse(r.responseText);
				}
				catch (_e) {}
	
				callback(json || error('access_denied', 'Could not get resource'));
			};
	
			var x;
	
			// Should we add the query to the URL?
			if (method === 'GET' || method === 'DELETE') {
				data = null;
			}
			else if (data && typeof (data) !== 'string' && !(data instanceof FormData) && !(data instanceof File) && !(data instanceof Blob)) {
				// Loop through and add formData
				var f = new FormData();
				for (x in data) if (data.hasOwnProperty(x)) {
					if (data[x] instanceof HTMLInputElement) {
						if ('files' in data[x] && data[x].files.length > 0) {
							f.append(x, data[x].files[0]);
						}
					}
					else if (data[x] instanceof Blob) {
						f.append(x, data[x], data.name);
					}
					else {
						f.append(x, data[x]);
					}
				}
	
				data = f;
			}
	
			// Open the path, async
			r.open(method, url, true);
	
			if (binary) {
				if ('responseType' in r) {
					r.responseType = binary;
				}
				else {
					r.overrideMimeType('text/plain; charset=x-user-defined');
				}
			}
	
			// Set any bespoke headers
			if (headers) {
				for (x in headers) {
					r.setRequestHeader(x, headers[x]);
				}
			}
	
			r.send(data);
	
			return r;
	
			// Headers are returned as a string
			function headersToJSON(s) {
				var r = {};
				var reg = /([a-z\-]+):\s?(.*);?/gi;
				var m;
				while ((m = reg.exec(s))) {
					r[m[1]] = m[2];
				}
	
				return r;
			}
		},
	
		// JSONP
		// Injects a script tag into the DOM to be executed and appends a callback function to the window object
		// @param string/function pathFunc either a string of the URL or a callback function pathFunc(querystringhash, continueFunc);
		// @param function callback a function to call on completion;
		jsonp: function(url, callback, callbackID, timeout) {
	
			var _this = this;
			var error = _this.error;
	
			// Change the name of the callback
			var bool = 0;
			var head = document.getElementsByTagName('head')[0];
			var operaFix;
			var result = error('server_error', 'server_error');
			var cb = function() {
				if (!(bool++)) {
					window.setTimeout(function() {
						callback(result);
						head.removeChild(script);
					}, 0);
				}
	
			};
	
			// Add callback to the window object
			callbackID = _this.globalEvent(function(json) {
				result = json;
				return true;
	
				// Mark callback as done
			}, callbackID);
	
			// The URL is a function for some cases and as such
			// Determine its value with a callback containing the new parameters of this function.
			url = url.replace(new RegExp('=\\?(&|$)'), '=' + callbackID + '$1');
	
			// Build script tag
			var script = _this.append('script', {
				id: callbackID,
				name: callbackID,
				src: url,
				async: true,
				onload: cb,
				onerror: cb,
				onreadystatechange: function() {
					if (/loaded|complete/i.test(this.readyState)) {
						cb();
					}
				}
			});
	
			// Opera fix error
			// Problem: If an error occurs with script loading Opera fails to trigger the script.onerror handler we specified
			//
			// Fix:
			// By setting the request to synchronous we can trigger the error handler when all else fails.
			// This action will be ignored if we've already called the callback handler "cb" with a successful onload event
			if (window.navigator.userAgent.toLowerCase().indexOf('opera') > -1) {
				operaFix = _this.append('script', {
					text: 'document.getElementById(\'' + callbackID + '\').onerror();'
				});
				script.async = false;
			}
	
			// Add timeout
			if (timeout) {
				window.setTimeout(function() {
					result = error('timeout', 'timeout');
					cb();
				}, timeout);
			}
	
			// TODO: add fix for IE,
			// However: unable recreate the bug of firing off the onreadystatechange before the script content has been executed and the value of "result" has been defined.
			// Inject script tag into the head element
			head.appendChild(script);
	
			// Append Opera Fix to run after our script
			if (operaFix) {
				head.appendChild(operaFix);
			}
		},
	
		// Post
		// Send information to a remote location using the post mechanism
		// @param string uri path
		// @param object data, key value data to send
		// @param function callback, function to execute in response
		post: function(url, data, options, callback, callbackID, timeout) {
	
			var _this = this;
			var error = _this.error;
			var doc = document;
	
			// This hack needs a form
			var form = null;
			var reenableAfterSubmit = [];
			var newform;
			var i = 0;
			var x = null;
			var bool = 0;
			var cb = function(r) {
				if (!(bool++)) {
					callback(r);
				}
			};
	
			// What is the name of the callback to contain
			// We'll also use this to name the iframe
			_this.globalEvent(cb, callbackID);
	
			// Build the iframe window
			var win;
			try {
				// IE7 hack, only lets us define the name here, not later.
				win = doc.createElement('<iframe name="' + callbackID + '">');
			}
			catch (e) {
				win = doc.createElement('iframe');
			}
	
			win.name = callbackID;
			win.id = callbackID;
			win.style.display = 'none';
	
			// Override callback mechanism. Triggger a response onload/onerror
			if (options && options.callbackonload) {
				// Onload is being fired twice
				win.onload = function() {
					cb({
						response: 'posted',
						message: 'Content was posted'
					});
				};
			}
	
			if (timeout) {
				setTimeout(function() {
					cb(error('timeout', 'The post operation timed out'));
				}, timeout);
			}
	
			doc.body.appendChild(win);
	
			// If we are just posting a single item
			if (_this.domInstance('form', data)) {
				// Get the parent form
				form = data.form;
	
				// Loop through and disable all of its siblings
				for (i = 0; i < form.elements.length; i++) {
					if (form.elements[i] !== data) {
						form.elements[i].setAttribute('disabled', true);
					}
				}
	
				// Move the focus to the form
				data = form;
			}
	
			// Posting a form
			if (_this.domInstance('form', data)) {
				// This is a form element
				form = data;
	
				// Does this form need to be a multipart form?
				for (i = 0; i < form.elements.length; i++) {
					if (!form.elements[i].disabled && form.elements[i].type === 'file') {
						form.encoding = form.enctype = 'multipart/form-data';
						form.elements[i].setAttribute('name', 'file');
					}
				}
			}
			else {
				// Its not a form element,
				// Therefore it must be a JSON object of Key=>Value or Key=>Element
				// If anyone of those values are a input type=file we shall shall insert its siblings into the form for which it belongs.
				for (x in data) if (data.hasOwnProperty(x)) {
					// Is this an input Element?
					if (_this.domInstance('input', data[x]) && data[x].type === 'file') {
						form = data[x].form;
						form.encoding = form.enctype = 'multipart/form-data';
					}
				}
	
				// Do If there is no defined form element, lets create one.
				if (!form) {
					// Build form
					form = doc.createElement('form');
					doc.body.appendChild(form);
					newform = form;
				}
	
				var input;
	
				// Add elements to the form if they dont exist
				for (x in data) if (data.hasOwnProperty(x)) {
	
					// Is this an element?
					var el = (_this.domInstance('input', data[x]) || _this.domInstance('textArea', data[x]) || _this.domInstance('select', data[x]));
	
					// Is this not an input element, or one that exists outside the form.
					if (!el || data[x].form !== form) {
	
						// Does an element have the same name?
						var inputs = form.elements[x];
						if (input) {
							// Remove it.
							if (!(inputs instanceof NodeList)) {
								inputs = [inputs];
							}
	
							for (i = 0; i < inputs.length; i++) {
								inputs[i].parentNode.removeChild(inputs[i]);
							}
	
						}
	
						// Create an input element
						input = doc.createElement('input');
						input.setAttribute('type', 'hidden');
						input.setAttribute('name', x);
	
						// Does it have a value attribute?
						if (el) {
							input.value = data[x].value;
						}
						else if (_this.domInstance(null, data[x])) {
							input.value = data[x].innerHTML || data[x].innerText;
						}
						else {
							input.value = data[x];
						}
	
						form.appendChild(input);
					}
	
					// It is an element, which exists within the form, but the name is wrong
					else if (el && data[x].name !== x) {
						data[x].setAttribute('name', x);
						data[x].name = x;
					}
				}
	
				// Disable elements from within the form if they weren't specified
				for (i = 0; i < form.elements.length; i++) {
	
					input = form.elements[i];
	
					// Does the same name and value exist in the parent
					if (!(input.name in data) && input.getAttribute('disabled') !== true) {
						// Disable
						input.setAttribute('disabled', true);
	
						// Add re-enable to callback
						reenableAfterSubmit.push(input);
					}
				}
			}
	
			// Set the target of the form
			form.setAttribute('method', 'POST');
			form.setAttribute('target', callbackID);
			form.target = callbackID;
	
			// Update the form URL
			form.setAttribute('action', url);
	
			// Submit the form
			// Some reason this needs to be offset from the current window execution
			setTimeout(function() {
				form.submit();
	
				setTimeout(function() {
					try {
						// Remove the iframe from the page.
						//win.parentNode.removeChild(win);
						// Remove the form
						if (newform) {
							newform.parentNode.removeChild(newform);
						}
					}
					catch (e) {
						try {
							console.error('HelloJS: could not remove iframe');
						}
						catch (ee) {}
					}
	
					// Reenable the disabled form
					for (var i = 0; i < reenableAfterSubmit.length; i++) {
						if (reenableAfterSubmit[i]) {
							reenableAfterSubmit[i].setAttribute('disabled', false);
							reenableAfterSubmit[i].disabled = false;
						}
					}
				}, 0);
			}, 100);
		},
	
		// Some of the providers require that only multipart is used with non-binary forms.
		// This function checks whether the form contains binary data
		hasBinary: function(data) {
			for (var x in data) if (data.hasOwnProperty(x)) {
				if (this.isBinary(data[x])) {
					return true;
				}
			}
	
			return false;
		},
	
		// Determines if a variable Either Is or like a FormInput has the value of a Blob
	
		isBinary: function(data) {
	
			return data instanceof Object && (
			(this.domInstance('input', data) && data.type === 'file') ||
			('FileList' in window && data instanceof window.FileList) ||
			('File' in window && data instanceof window.File) ||
			('Blob' in window && data instanceof window.Blob));
	
		},
	
		// Convert Data-URI to Blob string
		toBlob: function(dataURI) {
			var reg = /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i;
			var m = dataURI.match(reg);
			if (!m) {
				return dataURI;
			}
	
			var binary = atob(dataURI.replace(reg, ''));
			var array = [];
			for (var i = 0; i < binary.length; i++) {
				array.push(binary.charCodeAt(i));
			}
	
			return new Blob([new Uint8Array(array)], {type: m[1]});
		}
	
	});
	
	// EXTRA: Convert FormElement to JSON for POSTing
	// Wrappers to add additional functionality to existing functions
	(function(hello) {
	
		// Copy original function
		var api = hello.api;
		var utils = hello.utils;
	
		utils.extend(utils, {
	
			// DataToJSON
			// This takes a FormElement|NodeList|InputElement|MixedObjects and convers the data object to JSON.
			dataToJSON: function(p) {
	
				var _this = this;
				var w = window;
				var data = p.data;
	
				// Is data a form object
				if (_this.domInstance('form', data)) {
					data = _this.nodeListToJSON(data.elements);
				}
				else if ('NodeList' in w && data instanceof NodeList) {
					data = _this.nodeListToJSON(data);
				}
				else if (_this.domInstance('input', data)) {
					data = _this.nodeListToJSON([data]);
				}
	
				// Is data a blob, File, FileList?
				if (('File' in w && data instanceof w.File) ||
					('Blob' in w && data instanceof w.Blob) ||
					('FileList' in w && data instanceof w.FileList)) {
					data = {file: data};
				}
	
				// Loop through data if it's not form data it must now be a JSON object
				if (!('FormData' in w && data instanceof w.FormData)) {
	
					for (var x in data) if (data.hasOwnProperty(x)) {
	
						if ('FileList' in w && data[x] instanceof w.FileList) {
							if (data[x].length === 1) {
								data[x] = data[x][0];
							}
						}
						else if (_this.domInstance('input', data[x]) && data[x].type === 'file') {
							continue;
						}
						else if (_this.domInstance('input', data[x]) ||
							_this.domInstance('select', data[x]) ||
							_this.domInstance('textArea', data[x])) {
							data[x] = data[x].value;
						}
						else if (_this.domInstance(null, data[x])) {
							data[x] = data[x].innerHTML || data[x].innerText;
						}
					}
				}
	
				p.data = data;
				return data;
			},
	
			// NodeListToJSON
			// Given a list of elements extrapolate their values and return as a json object
			nodeListToJSON: function(nodelist) {
	
				var json = {};
	
				// Create a data string
				for (var i = 0; i < nodelist.length; i++) {
	
					var input = nodelist[i];
	
					// If the name of the input is empty or diabled, dont add it.
					if (input.disabled || !input.name) {
						continue;
					}
	
					// Is this a file, does the browser not support 'files' and 'FormData'?
					if (input.type === 'file') {
						json[input.name] = input;
					}
					else {
						json[input.name] = input.value || input.innerHTML;
					}
				}
	
				return json;
			}
		});
	
		// Replace it
		hello.api = function() {
	
			// Get arguments
			var p = utils.args({path: 's!', method: 's', data:'o', timeout: 'i', callback: 'f'}, arguments);
	
			// Change for into a data object
			if (p.data) {
				utils.dataToJSON(p);
			}
	
			return api.call(this, p);
		};
	
	})(hello);
	
	/////////////////////////////////////
	//
	// Save any access token that is in the current page URL
	// Handle any response solicited through iframe hash tag following an API request
	//
	/////////////////////////////////////
	
	hello.utils.responseHandler(window, window.opener || window.parent);
	
	// Script to support ChromeApps
	// This overides the hello.utils.popup method to support chrome.identity.launchWebAuthFlow
	// See https://developer.chrome.com/apps/app_identity#non
	
	// Is this a chrome app?
	
	if (typeof chrome === 'object' && typeof chrome.identity === 'object' && chrome.identity.launchWebAuthFlow) {
	
		(function() {
	
			// Swap the popup method
			hello.utils.popup = function(url) {
	
				return _open(url, true);
	
			};
	
			// Swap the hidden iframe method
			hello.utils.iframe = function(url) {
	
				_open(url, false);
	
			};
	
			// Swap the request_cors method
			hello.utils.request_cors = function(callback) {
	
				callback();
	
				// Always run as CORS
	
				return true;
			};
	
			// Swap the storage method
			var _cache = {};
			chrome.storage.local.get('hello', function(r) {
				// Update the cache
				_cache = r.hello || {};
			});
	
			hello.utils.store = function(name, value) {
	
				// Get all
				if (arguments.length === 0) {
					return _cache;
				}
	
				// Get
				if (arguments.length === 1) {
					return _cache[name] || null;
				}
	
				// Set
				if (value) {
					_cache[name] = value;
					chrome.storage.local.set({hello: _cache});
					return value;
				}
	
				// Delete
				if (value === null) {
					delete _cache[name];
					chrome.storage.local.set({hello: _cache});
					return null;
				}
			};
	
			// Open function
			function _open(url, interactive) {
	
				// Launch
				var ref = {
					closed: false
				};
	
				// Launch the webAuthFlow
				chrome.identity.launchWebAuthFlow({
					url: url,
					interactive: interactive
				}, function(responseUrl) {
	
					// Did the user cancel this prematurely
					if (responseUrl === undefined) {
						ref.closed = true;
						return;
					}
	
					// Split appart the URL
					var a = hello.utils.url(responseUrl);
	
					// The location can be augmented in to a location object like so...
					// We dont have window operations on the popup so lets create some
					var _popup = {
						location: {
	
							// Change the location of the popup
							assign: function(url) {
	
								// If there is a secondary reassign
								// In the case of OAuth1
								// Trigger this in non-interactive mode.
								_open(url, false);
							},
	
							search: a.search,
							hash: a.hash,
							href: a.href
						},
						close: function() {}
					};
	
					// Then this URL contains information which HelloJS must process
					// URL string
					// Window - any action such as window relocation goes here
					// Opener - the parent window which opened this, aka this script
	
					hello.utils.responseHandler(_popup, window);
				});
	
				// Return the reference
				return ref;
			}
	
		})();
	}
	
	// Phonegap override for hello.phonegap.js
	(function() {
	
		// Is this a phonegap implementation?
		if (!(/^file:\/{3}[^\/]/.test(window.location.href) && window.cordova)) {
			// Cordova is not included.
			return;
		}
	
		// Augment the hidden iframe method
		hello.utils.iframe = function(url, redirectUri) {
			hello.utils.popup(url, redirectUri, {hidden: 'yes'});
		};
	
		// Augment the popup
		var utilPopup = hello.utils.popup;
	
		// Replace popup
		hello.utils.popup = function(url, redirectUri, options) {
	
			// Run the standard
			var popup = utilPopup.call(this, url, redirectUri, options);
	
			// Create a function for reopening the popup, and assigning events to the new popup object
			// PhoneGap support
			// Add an event listener to listen to the change in the popup windows URL
			// This must appear before popup.focus();
			try {
				if (popup && popup.addEventListener) {
	
					// Get the origin of the redirect URI
	
					var a = hello.utils.url(redirectUri);
					var redirectUriOrigin = a.origin || (a.protocol + '//' + a.hostname);
	
					// Listen to changes in the InAppBrowser window
	
					popup.addEventListener('loadstart', function(e) {
	
						var url = e.url;
	
						// Is this the path, as given by the redirectUri?
						// Check the new URL agains the redirectUriOrigin.
						// According to #63 a user could click 'cancel' in some dialog boxes ....
						// The popup redirects to another page with the same origin, yet we still wish it to close.
	
						if (url.indexOf(redirectUriOrigin) !== 0) {
							return;
						}
	
						// Split appart the URL
						var a = hello.utils.url(url);
	
						// We dont have window operations on the popup so lets create some
						// The location can be augmented in to a location object like so...
	
						var _popup = {
							location: {
								// Change the location of the popup
								assign: function(location) {
	
									// Unfourtunatly an app is may not change the location of a InAppBrowser window.
									// So to shim this, just open a new one.
									popup.executeScript({code: 'window.location.href = "' + location + ';"'});
								},
	
								search: a.search,
								hash: a.hash,
								href: a.href
							},
							close: function() {
								if (popup.close) {
									popup.close();
									try {
										popup.closed = true;
									}
									catch (_e) {}
								}
							}
						};
	
						// Then this URL contains information which HelloJS must process
						// URL string
						// Window - any action such as window relocation goes here
						// Opener - the parent window which opened this, aka this script
	
						hello.utils.responseHandler(_popup, window);
	
					});
				}
			}
			catch (e) {}
	
			return popup;
		};
	
	})();
	
	(function(hello) {
	
		// OAuth1
		var OAuth1Settings = {
			version: '1.0',
			auth: 'https://www.dropbox.com/1/oauth/authorize',
			request: 'https://api.dropbox.com/1/oauth/request_token',
			token: 'https://api.dropbox.com/1/oauth/access_token'
		};
	
		// OAuth2 Settings
		var OAuth2Settings = {
			version: 2,
			auth: 'https://www.dropbox.com/1/oauth2/authorize',
			grant: 'https://api.dropbox.com/1/oauth2/token'
		};
	
		// Initiate the Dropbox module
		hello.init({
	
			dropbox: {
	
				name: 'Dropbox',
	
				oauth: OAuth2Settings,
	
				login: function(p) {
					// OAuth2 non-standard adjustments
					p.qs.scope = '';
					delete p.qs.display;
	
					// Should this be run as OAuth1?
					// If the redirect_uri is is HTTP (non-secure) then its required to revert to the OAuth1 endpoints
					var redirect = decodeURIComponent(p.qs.redirect_uri);
					if (redirect.indexOf('http:') === 0 && redirect.indexOf('http://localhost/') !== 0) {
	
						// Override the dropbox OAuth settings.
						hello.services.dropbox.oauth = OAuth1Settings;
					}
					else {
						// Override the dropbox OAuth settings.
						hello.services.dropbox.oauth = OAuth2Settings;
					}
	
					// The dropbox login window is a different size
					p.options.popup.width = 1000;
					p.options.popup.height = 1000;
				},
	
				/*
					Dropbox does not allow insecure HTTP URI's in the redirect_uri field
					...otherwise I'd love to use OAuth2
	
					Follow request https://forums.dropbox.com/topic.php?id=106505
	
					p.qs.response_type = 'code';
					oauth: {
						version: 2,
						auth: 'https://www.dropbox.com/1/oauth2/authorize',
						grant: 'https://api.dropbox.com/1/oauth2/token'
					}
				*/
	
				// API Base URL
				base: 'https://api.dropbox.com/1/',
	
				// Bespoke setting: this is states whether to use the custom environment of Dropbox or to use their own environment
				// Because it's notoriously difficult for Dropbox too provide access from other webservices, this defaults to Sandbox
				root: 'sandbox',
	
				// Map GET requests
				get: {
					me: 'account/info',
	
					// Https://www.dropbox.com/developers/core/docs#metadata
					'me/files': req('metadata/auto/@{parent|}'),
					'me/folder': req('metadata/auto/@{id}'),
					'me/folders': req('metadata/auto/'),
	
					'default': function(p, callback) {
						if (p.path.match('https://api-content.dropbox.com/1/files/')) {
							// This is a file, return binary data
							p.method = 'blob';
						}
	
						callback(p.path);
					}
				},
	
				post: {
					'me/files': function(p, callback) {
	
						var path = p.data.parent;
						var fileName = p.data.name;
	
						p.data = {
							file: p.data.file
						};
	
						// Does this have a data-uri to upload as a file?
						if (typeof (p.data.file) === 'string') {
							p.data.file = hello.utils.toBlob(p.data.file);
						}
	
						callback('https://api-content.dropbox.com/1/files_put/auto/' + path + '/' + fileName);
					},
	
					'me/folders': function(p, callback) {
	
						var name = p.data.name;
						p.data = {};
	
						callback('fileops/create_folder?root=@{root|sandbox}&' + hello.utils.param({
							path: name
						}));
					}
				},
	
				// Map DELETE requests
				del: {
					'me/files': 'fileops/delete?root=@{root|sandbox}&path=@{id}',
					'me/folder': 'fileops/delete?root=@{root|sandbox}&path=@{id}'
				},
	
				wrap: {
					me: function(o) {
						formatError(o);
						if (!o.uid) {
							return o;
						}
	
						o.name = o.display_name;
						var m = o.name.split(' ');
						o.first_name = m.shift();
						o.last_name = m.join(' ');
						o.id = o.uid;
						delete o.uid;
						delete o.display_name;
						return o;
					},
	
					'default': function(o, headers, req) {
						formatError(o);
						if (o.is_dir && o.contents) {
							o.data = o.contents;
							delete o.contents;
	
							o.data.forEach(function(item) {
								item.root = o.root;
								formatFile(item, headers, req);
							});
						}
	
						formatFile(o, headers, req);
	
						if (o.is_deleted) {
							o.success = true;
						}
	
						return o;
					}
				},
	
				// Doesn't return the CORS headers
				xhr: function(p) {
	
					// The proxy supports allow-cross-origin-resource
					// Alas that's the only thing we're using.
					if (p.data && p.data.file) {
						var file = p.data.file;
						if (file) {
							if (file.files) {
								p.data = file.files[0];
							}
							else {
								p.data = file;
							}
						}
					}
	
					if (p.method === 'delete') {
						p.method = 'post';
					}
	
					return true;
				},
	
				form: function(p, qs) {
					delete qs.state;
					delete qs.redirect_uri;
				}
			}
		});
	
		function formatError(o) {
			if (o && 'error' in o) {
				o.error = {
					code: 'server_error',
					message: o.error.message || o.error
				};
			}
		}
	
		function formatFile(o, headers, req) {
	
			if (typeof o !== 'object' ||
				(typeof Blob !== 'undefined' && o instanceof Blob) ||
				(typeof ArrayBuffer !== 'undefined' && o instanceof ArrayBuffer)) {
				// This is a file, let it through unformatted
				return;
			}
	
			if ('error' in o) {
				return;
			}
	
			var path = (o.root !== 'app_folder' ? o.root : '') + o.path.replace(/\&/g, '%26');
			path = path.replace(/^\//, '');
			if (o.thumb_exists) {
				o.thumbnail = req.oauth_proxy + '?path=' +
				encodeURIComponent('https://api-content.dropbox.com/1/thumbnails/auto/' + path + '?format=jpeg&size=m') + '&access_token=' + req.options.access_token;
			}
	
			o.type = (o.is_dir ? 'folder' : o.mime_type);
			o.name = o.path.replace(/.*\//g, '');
			if (o.is_dir) {
				o.files = path.replace(/^\//, '');
			}
			else {
				o.downloadLink = hello.settings.oauth_proxy + '?path=' +
				encodeURIComponent('https://api-content.dropbox.com/1/files/auto/' + path) + '&access_token=' + req.options.access_token;
				o.file = 'https://api-content.dropbox.com/1/files/auto/' + path;
			}
	
			if (!o.id) {
				o.id = o.path.replace(/^\//, '');
			}
	
			// O.media = 'https://api-content.dropbox.com/1/files/' + path;
		}
	
		function req(str) {
			return function(p, cb) {
				delete p.query.limit;
				cb(str);
			};
		}
	
	})(hello);
	
	(function(hello) {
	
		hello.init({
	
			facebook: {
	
				name: 'Facebook',
	
				// SEE https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow/v2.1
				oauth: {
					version: 2,
					auth: 'https://www.facebook.com/dialog/oauth/',
					grant: 'https://graph.facebook.com/oauth/access_token'
				},
	
				// Authorization scopes
				scope: {
					basic: 'public_profile',
					email: 'email',
					share: 'user_posts',
					birthday: 'user_birthday',
					events: 'user_events',
					photos: 'user_photos',
					videos: 'user_videos',
					friends: 'user_friends',
					files: 'user_photos,user_videos',
					publish_files: 'user_photos,user_videos,publish_actions',
					publish: 'publish_actions',
	
					// Deprecated in v2.0
					// Create_event	: 'create_event',
	
					offline_access: ''
				},
	
				// Refresh the access_token
				refresh: true,
	
				login: function(p) {
	
					// Reauthenticate
					// https://developers.facebook.com/docs/facebook-login/reauthentication
					if (p.options.force) {
						p.qs.auth_type = 'reauthenticate';
					}
	
					// The facebook login window is a different size.
					p.options.popup.width = 580;
					p.options.popup.height = 400;
				},
	
				logout: function(callback, options) {
					// Assign callback to a global handler
					var callbackID = hello.utils.globalEvent(callback);
					var redirect = encodeURIComponent(hello.settings.redirect_uri + '?' + hello.utils.param({callback:callbackID, result: JSON.stringify({force:true}), state: '{}'}));
					var token = (options.authResponse || {}).access_token;
					hello.utils.iframe('https://www.facebook.com/logout.php?next=' + redirect + '&access_token=' + token);
	
					// Possible responses:
					// String URL	- hello.logout should handle the logout
					// Undefined	- this function will handle the callback
					// True - throw a success, this callback isn't handling the callback
					// False - throw a error
					if (!token) {
						// If there isn't a token, the above wont return a response, so lets trigger a response
						return false;
					}
				},
	
				// API Base URL
				base: 'https://graph.facebook.com/v2.4/',
	
				// Map GET requests
				get: {
					me: 'me?fields=email,first_name,last_name,name,timezone,verified',
					'me/friends': 'me/friends',
					'me/following': 'me/friends',
					'me/followers': 'me/friends',
					'me/share': 'me/feed',
					'me/like': 'me/likes',
					'me/files': 'me/albums',
					'me/albums': 'me/albums?fields=cover_photo,name',
					'me/album': '@{id}/photos?fields=picture',
					'me/photos': 'me/photos',
					'me/photo': '@{id}',
					'friend/albums': '@{id}/albums',
					'friend/photos': '@{id}/photos'
	
					// Pagination
					// Https://developers.facebook.com/docs/reference/api/pagination/
				},
	
				// Map POST requests
				post: {
					'me/share': 'me/feed',
					'me/photo': '@{id}'
	
					// Https://developers.facebook.com/docs/graph-api/reference/v2.2/object/likes/
				},
	
				wrap: {
					me: formatUser,
					'me/friends': formatFriends,
					'me/following': formatFriends,
					'me/followers': formatFriends,
					'me/albums': format,
					'me/photos': format,
					'me/files': format,
					'default': format
				},
	
				// Special requirements for handling XHR
				xhr: function(p, qs) {
					if (p.method === 'get' || p.method === 'post') {
						qs.suppress_response_codes = true;
					}
	
					// Is this a post with a data-uri?
					if (p.method === 'post' && p.data && typeof (p.data.file) === 'string') {
						// Convert the Data-URI to a Blob
						p.data.file = hello.utils.toBlob(p.data.file);
					}
	
					return true;
				},
	
				// Special requirements for handling JSONP fallback
				jsonp: function(p, qs) {
					var m = p.method;
					if (m !== 'get' && !hello.utils.hasBinary(p.data)) {
						p.data.method = m;
						p.method = 'get';
					}
					else if (p.method === 'delete') {
						qs.method = 'delete';
						p.method = 'post';
					}
				},
	
				// Special requirements for iframe form hack
				form: function(p) {
					return {
						// Fire the callback onload
						callbackonload: true
					};
				}
			}
		});
	
		var base = 'https://graph.facebook.com/';
	
		function formatUser(o) {
			if (o.id) {
				o.thumbnail = o.picture = 'https://graph.facebook.com/' + o.id + '/picture';
			}
	
			return o;
		}
	
		function formatFriends(o) {
			if ('data' in o) {
				o.data.forEach(formatUser);
			}
	
			return o;
		}
	
		function format(o, headers, req) {
			if (typeof o === 'boolean') {
				o = {success: o};
			}
	
			if (o && 'data' in o) {
				var token = req.query.access_token;
	
				if (!(o.data instanceof Array)) {
					var data = o.data;
					delete o.data;
					o.data = [data];
				}
	
				o.data.forEach(function(d) {
	
					if (d.picture) {
						d.thumbnail = d.picture;
					}
	
					d.pictures = (d.images || [])
						.sort(function(a, b) {
							return a.width - b.width;
						});
	
					if (d.cover_photo && d.cover_photo.id) {
						d.thumbnail = base + d.cover_photo.id + '/picture?access_token=' + token;
					}
	
					if (d.type === 'album') {
						d.files = d.photos = base + d.id + '/photos';
					}
	
					if (d.can_upload) {
						d.upload_location = base + d.id + '/photos';
					}
				});
			}
	
			return o;
		}
	
	})(hello);
	
	(function(hello) {
	
		hello.init({
	
			flickr: {
	
				name: 'Flickr',
	
				// Ensure that you define an oauth_proxy
				oauth: {
					version: '1.0a',
					auth: 'https://www.flickr.com/services/oauth/authorize?perms=read',
					request: 'https://www.flickr.com/services/oauth/request_token',
					token: 'https://www.flickr.com/services/oauth/access_token'
				},
	
				// API base URL
				base: 'https://api.flickr.com/services/rest',
	
				// Map GET resquests
				get: {
					me: sign('flickr.people.getInfo'),
					'me/friends': sign('flickr.contacts.getList', {per_page:'@{limit|50}'}),
					'me/following': sign('flickr.contacts.getList', {per_page:'@{limit|50}'}),
					'me/followers': sign('flickr.contacts.getList', {per_page:'@{limit|50}'}),
					'me/albums': sign('flickr.photosets.getList', {per_page:'@{limit|50}'}),
					'me/album': sign('flickr.photosets.getPhotos', {photoset_id: '@{id}'}),
					'me/photos': sign('flickr.people.getPhotos', {per_page:'@{limit|50}'})
				},
	
				wrap: {
					me: function(o) {
						formatError(o);
						o = checkResponse(o, 'person');
						if (o.id) {
							if (o.realname) {
								o.name = o.realname._content;
								var m = o.name.split(' ');
								o.first_name = m.shift();
								o.last_name = m.join(' ');
							}
	
							o.thumbnail = getBuddyIcon(o, 'l');
							o.picture = getBuddyIcon(o, 'l');
						}
	
						return o;
					},
	
					'me/friends': formatFriends,
					'me/followers': formatFriends,
					'me/following': formatFriends,
					'me/albums': function(o) {
						formatError(o);
						o = checkResponse(o, 'photosets');
						paging(o);
						if (o.photoset) {
							o.data = o.photoset;
							o.data.forEach(function(item) {
								item.name = item.title._content;
								item.photos = 'https://api.flickr.com/services/rest' + getApiUrl('flickr.photosets.getPhotos', {photoset_id: item.id}, true);
							});
	
							delete o.photoset;
						}
	
						return o;
					},
	
					'me/photos': function(o) {
						formatError(o);
						return formatPhotos(o);
					},
	
					'default': function(o) {
						formatError(o);
						return formatPhotos(o);
					}
				},
	
				xhr: false,
	
				jsonp: function(p, qs) {
					if (p.method == 'get') {
						delete qs.callback;
						qs.jsoncallback = p.callbackID;
					}
				}
			}
		});
	
		function getApiUrl(method, extraParams, skipNetwork) {
			var url = ((skipNetwork) ? '' : 'flickr:') +
				'?method=' + method +
				'&api_key=' + hello.services.flickr.id +
				'&format=json';
			for (var param in extraParams) {
				if (extraParams.hasOwnProperty(param)) {
					url += '&' + param + '=' + extraParams[param];
				}
			}
	
			return url;
		}
	
		// This is not exactly neat but avoid to call
		// The method 'flickr.test.login' for each api call
	
		function withUser(cb) {
			var auth = hello.getAuthResponse('flickr');
			cb(auth && auth.user_nsid ? auth.user_nsid : null);
		}
	
		function sign(url, params) {
			if (!params) {
				params = {};
			}
	
			return function(p, callback) {
				withUser(function(userId) {
					params.user_id = userId;
					callback(getApiUrl(url, params, true));
				});
			};
		}
	
		function getBuddyIcon(profile, size) {
			var url = 'https://www.flickr.com/images/buddyicon.gif';
			if (profile.nsid && profile.iconserver && profile.iconfarm) {
				url = 'https://farm' + profile.iconfarm + '.staticflickr.com/' +
					profile.iconserver + '/' +
					'buddyicons/' + profile.nsid +
					((size) ? '_' + size : '') + '.jpg';
			}
	
			return url;
		}
	
		// See: https://www.flickr.com/services/api/misc.urls.html
		function createPhotoUrl(id, farm, server, secret, size) {
			size = (size) ? '_' + size : '';
			return 'https://farm' + farm + '.staticflickr.com/' + server + '/' + id + '_' + secret + size + '.jpg';
		}
	
		function formatUser(o) {
		}
	
		function formatError(o) {
			if (o && o.stat && o.stat.toLowerCase() != 'ok') {
				o.error = {
					code: 'invalid_request',
					message: o.message
				};
			}
		}
	
		function formatPhotos(o) {
			if (o.photoset || o.photos) {
				var set = ('photoset' in o) ? 'photoset' : 'photos';
				o = checkResponse(o, set);
				paging(o);
				o.data = o.photo;
				delete o.photo;
				for (var i = 0; i < o.data.length; i++) {
					var photo = o.data[i];
					photo.name = photo.title;
					photo.picture = createPhotoUrl(photo.id, photo.farm, photo.server, photo.secret, '');
					photo.pictures = createPictures(photo.id, photo.farm, photo.server, photo.secret);
					photo.source = createPhotoUrl(photo.id, photo.farm, photo.server, photo.secret, 'b');
					photo.thumbnail = createPhotoUrl(photo.id, photo.farm, photo.server, photo.secret, 'm');
				}
			}
	
			return o;
		}
	
		// See: https://www.flickr.com/services/api/misc.urls.html
		function createPictures(id, farm, server, secret) {
	
			var NO_LIMIT = 2048;
			var sizes = [
				{id: 't', max: 100},
				{id: 'm', max: 240},
				{id: 'n', max: 320},
				{id: '', max: 500},
				{id: 'z', max: 640},
				{id: 'c', max: 800},
				{id: 'b', max: 1024},
				{id: 'h', max: 1600},
				{id: 'k', max: 2048},
				{id: 'o', max: NO_LIMIT}
			];
	
			return sizes.map(function(size) {
				return {
					source: createPhotoUrl(id, farm, server, secret, size.id),
	
					// Note: this is a guess that's almost certain to be wrong (unless square source)
					width: size.max,
					height: size.max
				};
			});
		}
	
		function checkResponse(o, key) {
	
			if (key in o) {
				o = o[key];
			}
			else if (!('error' in o)) {
				o.error = {
					code: 'invalid_request',
					message: o.message || 'Failed to get data from Flickr'
				};
			}
	
			return o;
		}
	
		function formatFriends(o) {
			formatError(o);
			if (o.contacts) {
				o = checkResponse(o, 'contacts');
				paging(o);
				o.data = o.contact;
				delete o.contact;
				for (var i = 0; i < o.data.length; i++) {
					var item = o.data[i];
					item.id = item.nsid;
					item.name = item.realname || item.username;
					item.thumbnail = getBuddyIcon(item, 'm');
				}
			}
	
			return o;
		}
	
		function paging(res) {
			if (res.page && res.pages && res.page !== res.pages) {
				res.paging = {
					next: '?page=' + (++res.page)
				};
			}
		}
	
	})(hello);
	
	(function(hello) {
	
		hello.init({
	
			foursquare: {
	
				name: 'Foursquare',
	
				oauth: {
					// See: https://developer.foursquare.com/overview/auth
					version: 2,
					auth: 'https://foursquare.com/oauth2/authenticate',
					grant: 'https://foursquare.com/oauth2/access_token'
				},
	
				// Refresh the access_token once expired
				refresh: true,
	
				base: 'https://api.foursquare.com/v2/',
	
				get: {
					me: 'users/self',
					'me/friends': 'users/self/friends',
					'me/followers': 'users/self/friends',
					'me/following': 'users/self/friends'
				},
	
				wrap: {
					me: function(o) {
						formatError(o);
						if (o && o.response) {
							o = o.response.user;
							formatUser(o);
						}
	
						return o;
					},
	
					'default': function(o) {
						formatError(o);
	
						// Format friends
						if (o && 'response' in o && 'friends' in o.response && 'items' in o.response.friends) {
							o.data = o.response.friends.items;
							o.data.forEach(formatUser);
							delete o.response;
						}
	
						return o;
					}
				},
	
				xhr: formatRequest,
				jsonp: formatRequest
			}
		});
	
		function formatError(o) {
			if (o.meta && (o.meta.code === 400 || o.meta.code === 401)) {
				o.error = {
					code: 'access_denied',
					message: o.meta.errorDetail
				};
			}
		}
	
		function formatUser(o) {
			if (o && o.id) {
				o.thumbnail = o.photo.prefix + '100x100' + o.photo.suffix;
				o.name = o.firstName + ' ' + o.lastName;
				o.first_name = o.firstName;
				o.last_name = o.lastName;
				if (o.contact) {
					if (o.contact.email) {
						o.email = o.contact.email;
					}
				}
			}
		}
	
		function formatRequest(p, qs) {
			var token = qs.access_token;
			delete qs.access_token;
			qs.oauth_token = token;
			qs.v = 20121125;
			return true;
		}
	
	})(hello);
	
	(function(hello) {
	
		hello.init({
	
			github: {
	
				name: 'GitHub',
	
				oauth: {
					version: 2,
					auth: 'https://github.com/login/oauth/authorize',
					grant: 'https://github.com/login/oauth/access_token',
					response_type: 'code'
				},
	
				scope: {
					email: 'user:email'
				},
	
				base: 'https://api.github.com/',
	
				get: {
					me: 'user',
					'me/friends': 'user/following?per_page=@{limit|100}',
					'me/following': 'user/following?per_page=@{limit|100}',
					'me/followers': 'user/followers?per_page=@{limit|100}',
					'me/like': 'user/starred?per_page=@{limit|100}'
				},
	
				wrap: {
					me: function(o, headers) {
	
						formatError(o, headers);
						formatUser(o);
	
						return o;
					},
	
					'default': function(o, headers, req) {
	
						formatError(o, headers);
	
						if (Array.isArray(o)) {
							o = {data:o};
						}
	
						if (o.data) {
							paging(o, headers, req);
							o.data.forEach(formatUser);
						}
	
						return o;
					}
				},
	
				xhr: function(p) {
	
					if (p.method !== 'get' && p.data) {
	
						// Serialize payload as JSON
						p.headers = p.headers || {};
						p.headers['Content-Type'] = 'application/json';
						if (typeof (p.data) === 'object') {
							p.data = JSON.stringify(p.data);
						}
					}
	
					return true;
				}
			}
		});
	
		function formatError(o, headers) {
			var code = headers ? headers.statusCode : (o && 'meta' in o && 'status' in o.meta && o.meta.status);
			if ((code === 401 || code === 403)) {
				o.error = {
					code: 'access_denied',
					message: o.message || (o.data ? o.data.message : 'Could not get response')
				};
				delete o.message;
			}
		}
	
		function formatUser(o) {
			if (o.id) {
				o.thumbnail = o.picture = o.avatar_url;
				o.name = o.login;
			}
		}
	
		function paging(res, headers, req) {
			if (res.data && res.data.length && headers && headers.Link) {
				var next = headers.Link.match(/<(.*?)>;\s*rel=\"next\"/);
				if (next) {
					res.paging = {
						next: next[1]
					};
				}
			}
		}
	
	})(hello);
	
	(function(hello) {
	
		var contactsUrl = 'https://www.google.com/m8/feeds/contacts/default/full?v=3.0&alt=json&max-results=@{limit|1000}&start-index=@{start|1}';
	
		hello.init({
	
			google: {
	
				name: 'Google Plus',
	
				// See: http://code.google.com/apis/accounts/docs/OAuth2UserAgent.html
				oauth: {
					version: 2,
					auth: 'https://accounts.google.com/o/oauth2/auth',
					grant: 'https://accounts.google.com/o/oauth2/token'
				},
	
				// Authorization scopes
				scope: {
					basic: 'https://www.googleapis.com/auth/plus.me profile',
					email: 'email',
					birthday: '',
					events: '',
					photos: 'https://picasaweb.google.com/data/',
					videos: 'http://gdata.youtube.com',
					friends: 'https://www.google.com/m8/feeds, https://www.googleapis.com/auth/plus.login',
					files: 'https://www.googleapis.com/auth/drive.readonly',
					publish: '',
					publish_files: 'https://www.googleapis.com/auth/drive',
					share: '',
					create_event: '',
					offline_access: ''
				},
	
				scope_delim: ' ',
	
				login: function(p) {
					if (p.qs.display === 'none') {
						// Google doesn't like display=none
						p.qs.display = '';
					}
	
					if (p.qs.response_type === 'code') {
	
						// Let's set this to an offline access to return a refresh_token
						p.qs.access_type = 'offline';
					}
	
					// Reauthenticate
					// https://developers.google.com/identity/protocols/
					if (p.options.force) {
						p.qs.approval_prompt = 'force';
					}
				},
	
				// API base URI
				base: 'https://www.googleapis.com/',
	
				// Map GET requests
				get: {
					me: 'plus/v1/people/me',
	
					// Deprecated Sept 1, 2014
					//'me': 'oauth2/v1/userinfo?alt=json',
	
					// See: https://developers.google.com/+/api/latest/people/list
					'me/friends': 'plus/v1/people/me/people/visible?maxResults=@{limit|100}',
					'me/following': contactsUrl,
					'me/followers': contactsUrl,
					'me/contacts': contactsUrl,
					'me/share': 'plus/v1/people/me/activities/public?maxResults=@{limit|100}',
					'me/feed': 'plus/v1/people/me/activities/public?maxResults=@{limit|100}',
					'me/albums': 'https://picasaweb.google.com/data/feed/api/user/default?alt=json&max-results=@{limit|100}&start-index=@{start|1}',
					'me/album': function(p, callback) {
						var key = p.query.id;
						delete p.query.id;
						callback(key.replace('/entry/', '/feed/'));
					},
	
					'me/photos': 'https://picasaweb.google.com/data/feed/api/user/default?alt=json&kind=photo&max-results=@{limit|100}&start-index=@{start|1}',
	
					// See: https://developers.google.com/drive/v2/reference/files/list
					'me/file': 'drive/v2/files/@{id}',
					'me/files': 'drive/v2/files?q=%22@{parent|root}%22+in+parents+and+trashed=false&maxResults=@{limit|100}',
	
					// See: https://developers.google.com/drive/v2/reference/files/list
					'me/folders': 'drive/v2/files?q=%22@{id|root}%22+in+parents+and+mimeType+=+%22application/vnd.google-apps.folder%22+and+trashed=false&maxResults=@{limit|100}',
	
					// See: https://developers.google.com/drive/v2/reference/files/list
					'me/folder': 'drive/v2/files?q=%22@{id|root}%22+in+parents+and+trashed=false&maxResults=@{limit|100}'
				},
	
				// Map POST requests
				post: {
	
					// Google Drive
					'me/files': uploadDrive,
					'me/folders': function(p, callback) {
						p.data = {
							title: p.data.name,
							parents: [{id: p.data.parent || 'root'}],
							mimeType: 'application/vnd.google-apps.folder'
						};
						callback('drive/v2/files');
					}
				},
	
				// Map PUT requests
				put: {
					'me/files': uploadDrive
				},
	
				// Map DELETE requests
				del: {
					'me/files': 'drive/v2/files/@{id}',
					'me/folder': 'drive/v2/files/@{id}'
				},
	
				// Map PATCH requests
				patch: {
					'me/file': 'drive/v2/files/@{id}'
				},
	
				wrap: {
					me: function(o) {
						if (o.id) {
							o.last_name = o.family_name || (o.name ? o.name.familyName : null);
							o.first_name = o.given_name || (o.name ? o.name.givenName : null);
	
							if (o.emails && o.emails.length) {
								o.email = o.emails[0].value;
							}
	
							formatPerson(o);
						}
	
						return o;
					},
	
					'me/friends': function(o) {
						if (o.items) {
							paging(o);
							o.data = o.items;
							o.data.forEach(formatPerson);
							delete o.items;
						}
	
						return o;
					},
	
					'me/contacts': formatFriends,
					'me/followers': formatFriends,
					'me/following': formatFriends,
					'me/share': formatFeed,
					'me/feed': formatFeed,
					'me/albums': gEntry,
					'me/photos': formatPhotos,
					'default': gEntry
				},
	
				xhr: function(p) {
	
					if (p.method === 'post' || p.method === 'put') {
						toJSON(p);
					}
					else if (p.method === 'patch') {
						hello.utils.extend(p.query, p.data);
						p.data = null;
					}
	
					return true;
				},
	
				// Don't even try submitting via form.
				// This means no POST operations in <=IE9
				form: false
			}
		});
	
		function toInt(s) {
			return parseInt(s, 10);
		}
	
		function formatFeed(o) {
			paging(o);
			o.data = o.items;
			delete o.items;
			return o;
		}
	
		// Format: ensure each record contains a name, id etc.
		function formatItem(o) {
			if (o.error) {
				return;
			}
	
			if (!o.name) {
				o.name = o.title || o.message;
			}
	
			if (!o.picture) {
				o.picture = o.thumbnailLink;
			}
	
			if (!o.thumbnail) {
				o.thumbnail = o.thumbnailLink;
			}
	
			if (o.mimeType === 'application/vnd.google-apps.folder') {
				o.type = 'folder';
				o.files = 'https://www.googleapis.com/drive/v2/files?q=%22' + o.id + '%22+in+parents';
			}
	
			return o;
		}
	
		function formatImage(image) {
			return {
				source: image.url,
				width: image.width,
				height: image.height
			};
		}
	
		function formatPhotos(o) {
			o.data = o.feed.entry.map(formatEntry);
			delete o.feed;
		}
	
		// Google has a horrible JSON API
		function gEntry(o) {
			paging(o);
	
			if ('feed' in o && 'entry' in o.feed) {
				o.data = o.feed.entry.map(formatEntry);
				delete o.feed;
			}
	
			// Old style: Picasa, etc.
			else if ('entry' in o) {
				return formatEntry(o.entry);
			}
	
			// New style: Google Drive & Plus
			else if ('items' in o) {
				o.data = o.items.map(formatItem);
				delete o.items;
			}
			else {
				formatItem(o);
			}
	
			return o;
		}
	
		function formatPerson(o) {
			o.name = o.displayName || o.name;
			o.picture = o.picture || (o.image ? o.image.url : null);
			o.thumbnail = o.picture;
		}
	
		function formatFriends(o, headers, req) {
			paging(o);
			var r = [];
			if ('feed' in o && 'entry' in o.feed) {
				var token = req.query.access_token;
				for (var i = 0; i < o.feed.entry.length; i++) {
					var a = o.feed.entry[i];
	
					a.id	= a.id.$t;
					a.name	= a.title.$t;
					delete a.title;
					if (a.gd$email) {
						a.email	= (a.gd$email && a.gd$email.length > 0) ? a.gd$email[0].address : null;
						a.emails = a.gd$email;
						delete a.gd$email;
					}
	
					if (a.updated) {
						a.updated = a.updated.$t;
					}
	
					if (a.link) {
	
						var pic = (a.link.length > 0) ? a.link[0].href : null;
						if (pic && a.link[0].gd$etag) {
							pic += (pic.indexOf('?') > -1 ? '&' : '?') + 'access_token=' + token;
							a.picture = pic;
							a.thumbnail = pic;
						}
	
						delete a.link;
					}
	
					if (a.category) {
						delete a.category;
					}
				}
	
				o.data = o.feed.entry;
				delete o.feed;
			}
	
			return o;
		}
	
		function formatEntry(a) {
	
			var group = a.media$group;
			var photo = group.media$content.length ? group.media$content[0] : {};
			var mediaContent = group.media$content || [];
			var mediaThumbnail = group.media$thumbnail || [];
	
			var pictures = mediaContent
				.concat(mediaThumbnail)
				.map(formatImage)
				.sort(function(a, b) {
					return a.width - b.width;
				});
	
			var i = 0;
			var _a;
			var p = {
				id: a.id.$t,
				name: a.title.$t,
				description: a.summary.$t,
				updated_time: a.updated.$t,
				created_time: a.published.$t,
				picture: photo ? photo.url : null,
				pictures: pictures,
				images: [],
				thumbnail: photo ? photo.url : null,
				width: photo.width,
				height: photo.height
			};
	
			// Get feed/children
			if ('link' in a) {
				for (i = 0; i < a.link.length; i++) {
					var d = a.link[i];
					if (d.rel.match(/\#feed$/)) {
						p.upload_location = p.files = p.photos = d.href;
						break;
					}
				}
			}
	
			// Get images of different scales
			if ('category' in a && a.category.length) {
				_a = a.category;
				for (i = 0; i < _a.length; i++) {
					if (_a[i].scheme && _a[i].scheme.match(/\#kind$/)) {
						p.type = _a[i].term.replace(/^.*?\#/, '');
					}
				}
			}
	
			// Get images of different scales
			if ('media$thumbnail' in group && group.media$thumbnail.length) {
				_a = group.media$thumbnail;
				p.thumbnail = _a[0].url;
				p.images = _a.map(formatImage);
			}
	
			_a = group.media$content;
	
			if (_a && _a.length) {
				p.images.push(formatImage(_a[0]));
			}
	
			return p;
		}
	
		function paging(res) {
	
			// Contacts V2
			if ('feed' in res && res.feed.openSearch$itemsPerPage) {
				var limit = toInt(res.feed.openSearch$itemsPerPage.$t);
				var start = toInt(res.feed.openSearch$startIndex.$t);
				var total = toInt(res.feed.openSearch$totalResults.$t);
	
				if ((start + limit) < total) {
					res.paging = {
						next: '?start=' + (start + limit)
					};
				}
			}
			else if ('nextPageToken' in res) {
				res.paging = {
					next: '?pageToken=' + res.nextPageToken
				};
			}
		}
	
		// Construct a multipart message
		function Multipart() {
	
			// Internal body
			var body = [];
			var boundary = (Math.random() * 1e10).toString(32);
			var counter = 0;
			var lineBreak = '\r\n';
			var delim = lineBreak + '--' + boundary;
			var ready = function() {};
	
			var dataUri = /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i;
	
			// Add file
			function addFile(item) {
				var fr = new FileReader();
				fr.onload = function(e) {
					addContent(btoa(e.target.result), item.type + lineBreak + 'Content-Transfer-Encoding: base64');
				};
	
				fr.readAsBinaryString(item);
			}
	
			// Add content
			function addContent(content, type) {
				body.push(lineBreak + 'Content-Type: ' + type + lineBreak + lineBreak + content);
				counter--;
				ready();
			}
	
			// Add new things to the object
			this.append = function(content, type) {
	
				// Does the content have an array
				if (typeof (content) === 'string' || !('length' in Object(content))) {
					// Converti to multiples
					content = [content];
				}
	
				for (var i = 0; i < content.length; i++) {
	
					counter++;
	
					var item = content[i];
	
					// Is this a file?
					// Files can be either Blobs or File types
					if (
						(typeof (File) !== 'undefined' && item instanceof File) ||
						(typeof (Blob) !== 'undefined' && item instanceof Blob)
					) {
						// Read the file in
						addFile(item);
					}
	
					// Data-URI?
					// Data:[<mime type>][;charset=<charset>][;base64],<encoded data>
					// /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i
					else if (typeof (item) === 'string' && item.match(dataUri)) {
						var m = item.match(dataUri);
						addContent(item.replace(dataUri, ''), m[1] + lineBreak + 'Content-Transfer-Encoding: base64');
					}
	
					// Regular string
					else {
						addContent(item, type);
					}
				}
			};
	
			this.onready = function(fn) {
				ready = function() {
					if (counter === 0) {
						// Trigger ready
						body.unshift('');
						body.push('--');
						fn(body.join(delim), boundary);
						body = [];
					}
				};
	
				ready();
			};
		}
	
		// Upload to Drive
		// If this is PUT then only augment the file uploaded
		// PUT https://developers.google.com/drive/v2/reference/files/update
		// POST https://developers.google.com/drive/manage-uploads
		function uploadDrive(p, callback) {
	
			var data = {};
	
			// Test for DOM element
			if (p.data &&
				(typeof (HTMLInputElement) !== 'undefined' && p.data instanceof HTMLInputElement)
			) {
				p.data = {file: p.data};
			}
	
			if (!p.data.name && Object(Object(p.data.file).files).length && p.method === 'post') {
				p.data.name = p.data.file.files[0].name;
			}
	
			if (p.method === 'post') {
				p.data = {
					title: p.data.name,
					parents: [{id: p.data.parent || 'root'}],
					file: p.data.file
				};
			}
			else {
	
				// Make a reference
				data = p.data;
				p.data = {};
	
				// Add the parts to change as required
				if (data.parent) {
					p.data.parents = [{id: p.data.parent || 'root'}];
				}
	
				if (data.file) {
					p.data.file = data.file;
				}
	
				if (data.name) {
					p.data.title = data.name;
				}
			}
	
			// Extract the file, if it exists from the data object
			// If the File is an INPUT element lets just concern ourselves with the NodeList
			var file;
			if ('file' in p.data) {
				file = p.data.file;
				delete p.data.file;
	
				if (typeof (file) === 'object' && 'files' in file) {
					// Assign the NodeList
					file = file.files;
				}
	
				if (!file || !file.length) {
					callback({
						error: {
							code: 'request_invalid',
							message: 'There were no files attached with this request to upload'
						}
					});
					return;
				}
			}
	
			// Set type p.data.mimeType = Object(file[0]).type || 'application/octet-stream';
	
			// Construct a multipart message
			var parts = new Multipart();
			parts.append(JSON.stringify(p.data), 'application/json');
	
			// Read the file into a  base64 string... yep a hassle, i know
			// FormData doesn't let us assign our own Multipart headers and HTTP Content-Type
			// Alas GoogleApi need these in a particular format
			if (file) {
				parts.append(file);
			}
	
			parts.onready(function(body, boundary) {
	
				p.headers['content-type'] = 'multipart/related; boundary="' + boundary + '"';
				p.data = body;
	
				callback('upload/drive/v2/files' + (data.id ? '/' + data.id : '') + '?uploadType=multipart');
			});
	
		}
	
		function toJSON(p) {
			if (typeof (p.data) === 'object') {
				// Convert the POST into a javascript object
				try {
					p.data = JSON.stringify(p.data);
					p.headers['content-type'] = 'application/json';
				}
				catch (e) {}
			}
		}
	
	})(hello);
	
	(function(hello) {
	
		hello.init({
	
			instagram: {
	
				name: 'Instagram',
	
				oauth: {
					// See: http://instagram.com/developer/authentication/
					version: 2,
					auth: 'https://instagram.com/oauth/authorize/',
					grant: 'https://api.instagram.com/oauth/access_token'
				},
	
				// Refresh the access_token once expired
				refresh: true,
	
				scope: {
					basic: 'basic',
					photos: '',
					friends: 'relationships',
					publish: 'likes comments',
					email: '',
					share: '',
					publish_files: '',
					files: '',
					videos: '',
					offline_access: ''
				},
	
				scope_delim: ' ',
	
				login: function(p) {
					// Instagram throws errors like 'JavaScript API is unsupported' if the display is 'popup'.
					// Make the display anything but 'popup'
					p.qs.display = '';
				},
	
				base: 'https://api.instagram.com/v1/',
	
				get: {
					me: 'users/self',
					'me/feed': 'users/self/feed?count=@{limit|100}',
					'me/photos': 'users/self/media/recent?min_id=0&count=@{limit|100}',
					'me/friends': 'users/self/follows?count=@{limit|100}',
					'me/following': 'users/self/follows?count=@{limit|100}',
					'me/followers': 'users/self/followed-by?count=@{limit|100}',
					'friend/photos': 'users/@{id}/media/recent?min_id=0&count=@{limit|100}'
				},
	
				post: {
					'me/like': function(p, callback) {
						var id = p.data.id;
						p.data = {};
						callback('media/' + id + '/likes');
					}
				},
	
				del: {
					'me/like': 'media/@{id}/likes'
				},
	
				wrap: {
					me: function(o) {
	
						formatError(o);
	
						if ('data' in o) {
							o.id = o.data.id;
							o.thumbnail = o.data.profile_picture;
							o.name = o.data.full_name || o.data.username;
						}
	
						return o;
					},
	
					'me/friends': formatFriends,
					'me/following': formatFriends,
					'me/followers': formatFriends,
					'me/photos': function(o) {
	
						formatError(o);
						paging(o);
	
						if ('data' in o) {
							o.data = o.data.filter(function(d) {
								return d.type === 'image';
							});
	
							o.data.forEach(function(d) {
								d.name = d.caption ? d.caption.text : null;
								d.thumbnail = d.images.thumbnail.url;
								d.picture = d.images.standard_resolution.url;
								d.pictures = Object.keys(d.images)
									.map(function(key) {
										var image = d.images[key];
										return formatImage(image);
									})
									.sort(function(a, b) {
										return a.width - b.width;
									});
							});
						}
	
						return o;
					},
	
					'default': function(o) {
						o = formatError(o);
						paging(o);
						return o;
					}
				},
	
				// Instagram does not return any CORS Headers
				// So besides JSONP we're stuck with proxy
				xhr: function(p, qs) {
	
					var method = p.method;
					var proxy = method !== 'get';
	
					if (proxy) {
	
						if ((method === 'post' || method === 'put') && p.query.access_token) {
							p.data.access_token = p.query.access_token;
							delete p.query.access_token;
						}
	
						// No access control headers
						// Use the proxy instead
						p.proxy = proxy;
					}
	
					return proxy;
				},
	
				// No form
				form: false
			}
		});
	
		function formatImage(image) {
			return {
				source: image.url,
				width: image.width,
				height: image.height
			};
		}
	
		function formatError(o) {
			if (typeof o === 'string') {
				return {
					error: {
						code: 'invalid_request',
						message: o
					}
				};
			}
	
			if (o && 'meta' in o && 'error_type' in o.meta) {
				o.error = {
					code: o.meta.error_type,
					message: o.meta.error_message
				};
			}
	
			return o;
		}
	
		function formatFriends(o) {
			paging(o);
			if (o && 'data' in o) {
				o.data.forEach(formatFriend);
			}
	
			return o;
		}
	
		function formatFriend(o) {
			if (o.id) {
				o.thumbnail = o.profile_picture;
				o.name = o.full_name || o.username;
			}
		}
	
		// See: http://instagram.com/developer/endpoints/
		function paging(res) {
			if ('pagination' in res) {
				res.paging = {
					next: res.pagination.next_url
				};
				delete res.pagination;
			}
		}
	
	})(hello);
	
	(function(hello) {
	
		hello.init({
	
			joinme: {
	
				name: 'join.me',
	
				oauth: {
					version: 2,
					auth: 'https://secure.join.me/api/public/v1/auth/oauth2',
					grant: 'https://secure.join.me/api/public/v1/auth/oauth2'
				},
	
				refresh: false,
	
				scope: {
					basic: 'user_info',
					user: 'user_info',
					scheduler: 'scheduler',
					start: 'start_meeting',
					email: '',
					friends: '',
					share: '',
					publish: '',
					photos: '',
					publish_files: '',
					files: '',
					videos: '',
					offline_access: ''
				},
	
				scope_delim: ' ',
	
				login: function(p) {
					p.options.popup.width = 400;
					p.options.popup.height = 700;
				},
	
				base: 'https://api.join.me/v1/',
	
				get: {
					me: 'user',
					meetings: 'meetings',
					'meetings/info': 'meetings/@{id}'
				},
	
				post: {
					'meetings/start/adhoc': function(p, callback) {
						callback('meetings/start');
					},
	
					'meetings/start/scheduled': function(p, callback) {
						var meetingId = p.data.meetingId;
						p.data = {};
						callback('meetings/' + meetingId + '/start');
					},
	
					'meetings/schedule': function(p, callback) {
						callback('meetings');
					}
				},
	
				patch: {
					'meetings/update': function(p, callback) {
						callback('meetings/' + p.data.meetingId);
					}
				},
	
				del: {
					'meetings/delete': 'meetings/@{id}'
				},
	
				wrap: {
					me: function(o, headers) {
						formatError(o, headers);
	
						if (!o.email) {
							return o;
						}
	
						o.name = o.fullName;
						o.first_name = o.name.split(' ')[0];
						o.last_name = o.name.split(' ')[1];
						o.id = o.email;
	
						return o;
					},
	
					'default': function(o, headers) {
						formatError(o, headers);
	
						return o;
					}
				},
	
				xhr: formatRequest
	
			}
		});
	
		function formatError(o, headers) {
			var errorCode;
			var message;
			var details;
	
			if (o && ('Message' in o)) {
				message = o.Message;
				delete o.Message;
	
				if ('ErrorCode' in o) {
					errorCode = o.ErrorCode;
					delete o.ErrorCode;
				}
				else {
					errorCode = getErrorCode(headers);
				}
	
				o.error = {
					code: errorCode,
					message: message,
					details: o
				};
			}
	
			return o;
		}
	
		function formatRequest(p, qs) {
			// Move the access token from the request body to the request header
			var token = qs.access_token;
			delete qs.access_token;
			p.headers.Authorization = 'Bearer ' + token;
	
			// Format non-get requests to indicate json body
			if (p.method !== 'get' && p.data) {
				p.headers['Content-Type'] = 'application/json';
				if (typeof (p.data) === 'object') {
					p.data = JSON.stringify(p.data);
				}
			}
	
			if (p.method === 'put') {
				p.method = 'patch';
			}
	
			return true;
		}
	
		function getErrorCode(headers) {
			switch (headers.statusCode) {
				case 400:
					return 'invalid_request';
				case 403:
					return 'stale_token';
				case 401:
					return 'invalid_token';
				case 500:
					return 'server_error';
				default:
					return 'server_error';
			}
		}
	
	}(hello));
	
	(function(hello) {
	
		hello.init({
	
			linkedin: {
	
				oauth: {
					version: 2,
					response_type: 'code',
					auth: 'https://www.linkedin.com/uas/oauth2/authorization',
					grant: 'https://www.linkedin.com/uas/oauth2/accessToken'
				},
	
				// Refresh the access_token once expired
				refresh: true,
	
				scope: {
					basic: 'r_basicprofile',
					email: 'r_emailaddress',
					files: '',
					friends: '',
					photos: '',
					publish: 'w_share',
					publish_files: 'w_share',
					share: '',
					videos: '',
					offline_access: ''
				},
				scope_delim: ' ',
	
				base: 'https://api.linkedin.com/v1/',
	
				get: {
					me: 'people/~:(picture-url,first-name,last-name,id,formatted-name,email-address)',
	
					// See: http://developer.linkedin.com/documents/get-network-updates-and-statistics-api
					'me/share': 'people/~/network/updates?count=@{limit|250}'
				},
	
				post: {
	
					// See: https://developer.linkedin.com/documents/api-requests-json
					'me/share': function(p, callback) {
						var data = {
							visibility: {
								code: 'anyone'
							}
						};
	
						if (p.data.id) {
	
							data.attribution = {
								share: {
									id: p.data.id
								}
							};
	
						}
						else {
							data.comment = p.data.message;
							if (p.data.picture && p.data.link) {
								data.content = {
									'submitted-url': p.data.link,
									'submitted-image-url': p.data.picture
								};
							}
						}
	
						p.data = JSON.stringify(data);
	
						callback('people/~/shares?format=json');
					},
	
					'me/like': like
				},
	
				del:{
					'me/like': like
				},
	
				wrap: {
					me: function(o) {
						formatError(o);
						formatUser(o);
						return o;
					},
	
					'me/friends': formatFriends,
					'me/following': formatFriends,
					'me/followers': formatFriends,
					'me/share': function(o) {
						formatError(o);
						paging(o);
						if (o.values) {
							o.data = o.values.map(formatUser);
							o.data.forEach(function(item) {
								item.message = item.headline;
							});
	
							delete o.values;
						}
	
						return o;
					},
	
					'default': function(o, headers) {
						formatError(o);
						empty(o, headers);
						paging(o);
					}
				},
	
				jsonp: function(p, qs) {
					formatQuery(qs);
					if (p.method === 'get') {
						qs.format = 'jsonp';
						qs['error-callback'] = p.callbackID;
					}
				},
	
				xhr: function(p, qs) {
					if (p.method !== 'get') {
						formatQuery(qs);
						p.headers['Content-Type'] = 'application/json';
	
						// Note: x-li-format ensures error responses are not returned in XML
						p.headers['x-li-format'] = 'json';
						p.proxy = true;
						return true;
					}
	
					return false;
				}
			}
		});
	
		function formatError(o) {
			if (o && 'errorCode' in o) {
				o.error = {
					code: o.status,
					message: o.message
				};
			}
		}
	
		function formatUser(o) {
			if (o.error) {
				return;
			}
	
			o.first_name = o.firstName;
			o.last_name = o.lastName;
			o.name = o.formattedName || (o.first_name + ' ' + o.last_name);
			o.thumbnail = o.pictureUrl;
			o.email = o.emailAddress;
			return o;
		}
	
		function formatFriends(o) {
			formatError(o);
			paging(o);
			if (o.values) {
				o.data = o.values.map(formatUser);
				delete o.values;
			}
	
			return o;
		}
	
		function paging(res) {
			if ('_count' in res && '_start' in res && (res._count + res._start) < res._total) {
				res.paging = {
					next: '?start=' + (res._start + res._count) + '&count=' + res._count
				};
			}
		}
	
		function empty(o, headers) {
			if (JSON.stringify(o) === '{}' && headers.statusCode === 200) {
				o.success = true;
			}
		}
	
		function formatQuery(qs) {
			// LinkedIn signs requests with the parameter 'oauth2_access_token'
			// ... yeah another one who thinks they should be different!
			if (qs.access_token) {
				qs.oauth2_access_token = qs.access_token;
				delete qs.access_token;
			}
		}
	
		function like(p, callback) {
			p.headers['x-li-format'] = 'json';
			var id = p.data.id;
			p.data = (p.method !== 'delete').toString();
			p.method = 'put';
			callback('people/~/network/updates/key=' + id + '/is-liked');
		}
	
	})(hello);
	
	// See: https://developers.soundcloud.com/docs/api/reference
	(function(hello) {
	
		hello.init({
	
			soundcloud: {
				name: 'SoundCloud',
	
				oauth: {
					version: 2,
					auth: 'https://soundcloud.com/connect',
					grant: 'https://soundcloud.com/oauth2/token'
				},
	
				// Request path translated
				base: 'https://api.soundcloud.com/',
				get: {
					me: 'me.json',
	
					// Http://developers.soundcloud.com/docs/api/reference#me
					'me/friends': 'me/followings.json',
					'me/followers': 'me/followers.json',
					'me/following': 'me/followings.json',
	
					// See: http://developers.soundcloud.com/docs/api/reference#activities
					'default': function(p, callback) {
	
						// Include '.json at the end of each request'
						callback(p.path + '.json');
					}
				},
	
				// Response handlers
				wrap: {
					me: function(o) {
						formatUser(o);
						return o;
					},
	
					'default': function(o) {
						if (Array.isArray(o)) {
							o = {
								data: o.map(formatUser)
							};
						}
	
						paging(o);
						return o;
					}
				},
	
				xhr: formatRequest,
				jsonp: formatRequest
			}
		});
	
		function formatRequest(p, qs) {
			// Alter the querystring
			var token = qs.access_token;
			delete qs.access_token;
			qs.oauth_token = token;
			qs['_status_code_map[302]'] = 200;
			return true;
		}
	
		function formatUser(o) {
			if (o.id) {
				o.picture = o.avatar_url;
				o.thumbnail = o.avatar_url;
				o.name = o.username || o.full_name;
			}
	
			return o;
		}
	
		// See: http://developers.soundcloud.com/docs/api/reference#activities
		function paging(res) {
			if ('next_href' in res) {
				res.paging = {
					next: res.next_href
				};
			}
		}
	
	})(hello);
	
	(function(hello) {
	
		var base = 'https://api.twitter.com/';
	
		hello.init({
	
			twitter: {
	
				// Ensure that you define an oauth_proxy
				oauth: {
					version: '1.0a',
					auth: base + 'oauth/authenticate',
					request: base + 'oauth/request_token',
					token: base + 'oauth/access_token'
				},
	
				login: function(p) {
					// Reauthenticate
					// https://dev.twitter.com/oauth/reference/get/oauth/authenticate
					var prefix = '?force_login=true';
					this.oauth.auth = this.oauth.auth.replace(prefix, '') + (p.options.force ? prefix : '');
				},
	
				base: base + '1.1/',
	
				get: {
					me: 'account/verify_credentials.json',
					'me/friends': 'friends/list.json?count=@{limit|200}',
					'me/following': 'friends/list.json?count=@{limit|200}',
					'me/followers': 'followers/list.json?count=@{limit|200}',
	
					// Https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
					'me/share': 'statuses/user_timeline.json?count=@{limit|200}',
	
					// Https://dev.twitter.com/rest/reference/get/favorites/list
					'me/like': 'favorites/list.json?count=@{limit|200}'
				},
	
				post: {
					'me/share': function(p, callback) {
	
						var data = p.data;
						p.data = null;
	
						var status = [];
	
						// Change message to status
						if (data.message) {
							status.push(data.message);
							delete data.message;
						}
	
						// If link is given
						if (data.link) {
							status.push(data.link);
							delete data.link;
						}
	
						if (data.picture) {
							status.push(data.picture);
							delete data.picture;
						}
	
						// Compound all the components
						if (status.length) {
							data.status = status.join(' ');
						}
	
						// Tweet media
						if (data.file) {
							data['media[]'] = data.file;
							delete data.file;
							p.data = data;
							callback('statuses/update_with_media.json');
						}
	
						// Retweet?
						else if ('id' in data) {
							callback('statuses/retweet/' + data.id + '.json');
						}
	
						// Tweet
						else {
							// Assign the post body to the query parameters
							hello.utils.extend(p.query, data);
							callback('statuses/update.json?include_entities=1');
						}
					},
	
					// See: https://dev.twitter.com/rest/reference/post/favorites/create
					'me/like': function(p, callback) {
						var id = p.data.id;
						p.data = null;
						callback('favorites/create.json?id=' + id);
					}
				},
	
				del: {
	
					// See: https://dev.twitter.com/rest/reference/post/favorites/destroy
					'me/like': function() {
						p.method = 'post';
						var id = p.data.id;
						p.data = null;
						callback('favorites/destroy.json?id=' + id);
					}
				},
	
				wrap: {
					me: function(res) {
						formatError(res);
						formatUser(res);
						return res;
					},
	
					'me/friends': formatFriends,
					'me/followers': formatFriends,
					'me/following': formatFriends,
	
					'me/share': function(res) {
						formatError(res);
						paging(res);
						if (!res.error && 'length' in res) {
							return {data: res};
						}
	
						return res;
					},
	
					'default': function(res) {
						res = arrayToDataResponse(res);
						paging(res);
						return res;
					}
				},
				xhr: function(p) {
	
					// Rely on the proxy for non-GET requests.
					return (p.method !== 'get');
				}
			}
		});
	
		function formatUser(o) {
			if (o.id) {
				if (o.name) {
					var m = o.name.split(' ');
					o.first_name = m.shift();
					o.last_name = m.join(' ');
				}
	
				// See: https://dev.twitter.com/overview/general/user-profile-images-and-banners
				o.thumbnail = o.profile_image_url_https || o.profile_image_url;
			}
	
			return o;
		}
	
		function formatFriends(o) {
			formatError(o);
			paging(o);
			if (o.users) {
				o.data = o.users.map(formatUser);
				delete o.users;
			}
	
			return o;
		}
	
		function formatError(o) {
			if (o.errors) {
				var e = o.errors[0];
				o.error = {
					code: 'request_failed',
					message: e.message
				};
			}
		}
	
		// Take a cursor and add it to the path
		function paging(res) {
			// Does the response include a 'next_cursor_string'
			if ('next_cursor_str' in res) {
				// See: https://dev.twitter.com/docs/misc/cursoring
				res.paging = {
					next: '?cursor=' + res.next_cursor_str
				};
			}
		}
	
		function arrayToDataResponse(res) {
			return Array.isArray(res) ? {data: res} : res;
		}
	
		/**
		// The documentation says to define user in the request
		// Although its not actually required.
	
		var user_id;
	
		function withUserId(callback){
			if(user_id){
				callback(user_id);
			}
			else{
				hello.api('twitter:/me', function(o){
					user_id = o.id;
					callback(o.id);
				});
			}
		}
	
		function sign(url){
			return function(p, callback){
				withUserId(function(user_id){
					callback(url+'?user_id='+user_id);
				});
			};
		}
		*/
	
	})(hello);
	
	// Vkontakte (vk.com)
	(function(hello) {
	
		hello.init({
	
			vk: {
				name: 'Vk',
	
				// See https://vk.com/dev/oauth_dialog
				oauth: {
					version: 2,
					auth: 'https://oauth.vk.com/authorize',
					grant: 'https://oauth.vk.com/access_token'
				},
	
				// Authorization scopes
				// See https://vk.com/dev/permissions
				scope: {
					email: 'email',
					friends: 'friends',
					photos: 'photos',
					videos: 'video',
					share: 'share',
					offline_access: 'offline'
				},
	
				// Refresh the access_token
				refresh: true,
	
				login: function(p) {
					p.qs.display = window.navigator &&
						window.navigator.userAgent &&
						/ipad|phone|phone|android/.test(window.navigator.userAgent.toLowerCase()) ? 'mobile' : 'popup';
				},
	
				// API Base URL
				base: 'https://api.vk.com/method/',
	
				// Map GET requests
				get: {
					me: function(p, callback) {
						p.query.fields = 'id,first_name,last_name,photo_max';
						callback('users.get');
					}
				},
	
				wrap: {
					me: function(res, headers, req) {
						formatError(res);
						return formatUser(res, req);
					}
				},
	
				// No XHR
				xhr: false,
	
				// All requests should be JSONP as of missing CORS headers in https://api.vk.com/method/*
				jsonp: true,
	
				// No form
				form: false
			}
		});
	
		function formatUser(o, req) {
	
			if (o !== null && 'response' in o && o.response !== null && o.response.length) {
				o = o.response[0];
				o.id = o.uid;
				o.thumbnail = o.picture = o.photo_max;
				o.name = o.first_name + ' ' + o.last_name;
	
				if (req.authResponse && req.authResponse.email !== null)
					o.email = req.authResponse.email;
			}
	
			return o;
		}
	
		function formatError(o) {
	
			if (o.error) {
				var e = o.error;
				o.error = {
					code: e.error_code,
					message: e.error_msg
				};
			}
		}
	
	})(hello);
	
	(function(hello) {
	
		hello.init({
			windows: {
				name: 'Windows live',
	
				// REF: http://msdn.microsoft.com/en-us/library/hh243641.aspx
				oauth: {
					version: 2,
					auth: 'https://login.live.com/oauth20_authorize.srf',
					grant: 'https://login.live.com/oauth20_token.srf'
				},
	
				// Refresh the access_token once expired
				refresh: true,
	
				logout: function() {
					return 'http://login.live.com/oauth20_logout.srf?ts=' + (new Date()).getTime();
				},
	
				// Authorization scopes
				scope: {
					basic: 'wl.signin,wl.basic',
					email: 'wl.emails',
					birthday: 'wl.birthday',
					events: 'wl.calendars',
					photos: 'wl.photos',
					videos: 'wl.photos',
					friends: 'wl.contacts_emails',
					files: 'wl.skydrive',
					publish: 'wl.share',
					publish_files: 'wl.skydrive_update',
					share: 'wl.share',
					create_event: 'wl.calendars_update,wl.events_create',
					offline_access: 'wl.offline_access'
				},
	
				// API base URL
				base: 'https://apis.live.net/v5.0/',
	
				// Map GET requests
				get: {
	
					// Friends
					me: 'me',
					'me/friends': 'me/friends',
					'me/following': 'me/contacts',
					'me/followers': 'me/friends',
					'me/contacts': 'me/contacts',
	
					'me/albums': 'me/albums',
	
					// Include the data[id] in the path
					'me/album': '@{id}/files',
					'me/photo': '@{id}',
	
					// Files
					'me/files': '@{parent|me/skydrive}/files',
					'me/folders': '@{id|me/skydrive}/files',
					'me/folder': '@{id|me/skydrive}/files'
				},
	
				// Map POST requests
				post: {
					'me/albums': 'me/albums',
					'me/album': '@{id}/files/',
	
					'me/folders': '@{id|me/skydrive/}',
					'me/files': '@{parent|me/skydrive}/files'
				},
	
				// Map DELETE requests
				del: {
					// Include the data[id] in the path
					'me/album': '@{id}',
					'me/photo': '@{id}',
					'me/folder': '@{id}',
					'me/files': '@{id}'
				},
	
				wrap: {
					me: formatUser,
	
					'me/friends': formatFriends,
					'me/contacts': formatFriends,
					'me/followers': formatFriends,
					'me/following': formatFriends,
					'me/albums': formatAlbums,
					'me/photos': formatDefault,
					'default': formatDefault
				},
	
				xhr: function(p) {
					if (p.method !== 'get' && p.method !== 'delete' && !hello.utils.hasBinary(p.data)) {
	
						// Does this have a data-uri to upload as a file?
						if (typeof (p.data.file) === 'string') {
							p.data.file = hello.utils.toBlob(p.data.file);
						}
						else {
							p.data = JSON.stringify(p.data);
							p.headers = {
								'Content-Type': 'application/json'
							};
						}
					}
	
					return true;
				},
	
				jsonp: function(p) {
					if (p.method !== 'get' && !hello.utils.hasBinary(p.data)) {
						p.data.method = p.method;
						p.method = 'get';
					}
				}
			}
		});
	
		function formatDefault(o) {
			if ('data' in o) {
				o.data.forEach(function(d) {
					if (d.picture) {
						d.thumbnail = d.picture;
					}
	
					if (d.images) {
						d.pictures = d.images
							.map(formatImage)
							.sort(function(a, b) {
								return a.width - b.width;
							});
					}
				});
			}
	
			return o;
		}
	
		function formatImage(image) {
			return {
				width: image.width,
				height: image.height,
				source: image.source
			};
		}
	
		function formatAlbums(o) {
			if ('data' in o) {
				o.data.forEach(function(d) {
					d.photos = d.files = 'https://apis.live.net/v5.0/' + d.id + '/photos';
				});
			}
	
			return o;
		}
	
		function formatUser(o, headers, req) {
			if (o.id) {
				var token = req.query.access_token;
				if (o.emails) {
					o.email = o.emails.preferred;
				}
	
				// If this is not an non-network friend
				if (o.is_friend !== false) {
					// Use the id of the user_id if available
					var id = (o.user_id || o.id);
					o.thumbnail = o.picture = 'https://apis.live.net/v5.0/' + id + '/picture?access_token=' + token;
				}
			}
	
			return o;
		}
	
		function formatFriends(o, headers, req) {
			if ('data' in o) {
				o.data.forEach(function(d) {
					formatUser(d, headers, req);
				});
			}
	
			return o;
		}
	
	})(hello);
	
	(function(hello) {
	
		hello.init({
	
			yahoo: {
	
				// Ensure that you define an oauth_proxy
				oauth: {
					version: '1.0a',
					auth: 'https://api.login.yahoo.com/oauth/v2/request_auth',
					request: 'https://api.login.yahoo.com/oauth/v2/get_request_token',
					token: 'https://api.login.yahoo.com/oauth/v2/get_token'
				},
	
				// Login handler
				login: function(p) {
					// Change the default popup window to be at least 560
					// Yahoo does dynamically change it on the fly for the signin screen (only, what if your already signed in)
					p.options.popup.width = 560;
	
					// Yahoo throws an parameter error if for whatever reason the state.scope contains a comma, so lets remove scope
					try {delete p.qs.state.scope;}
					catch (e) {}
				},
	
				base: 'https://social.yahooapis.com/v1/',
	
				get: {
					me: yql('select * from social.profile(0) where guid=me'),
					'me/friends': yql('select * from social.contacts(0) where guid=me'),
					'me/following': yql('select * from social.contacts(0) where guid=me')
				},
				wrap: {
					me: formatUser,
	
					// Can't get IDs
					// It might be better to loop through the social.relationship table with has unique IDs of users.
					'me/friends': formatFriends,
					'me/following': formatFriends,
					'default': paging
				}
			}
		});
	
		/*
			// Auto-refresh fix: bug in Yahoo can't get this to work with node-oauth-shim
			login : function(o){
				// Is the user already logged in
				var auth = hello('yahoo').getAuthResponse();
	
				// Is this a refresh token?
				if(o.options.display==='none'&&auth&&auth.access_token&&auth.refresh_token){
					// Add the old token and the refresh token, including path to the query
					// See http://developer.yahoo.com/oauth/guide/oauth-refreshaccesstoken.html
					o.qs.access_token = auth.access_token;
					o.qs.refresh_token = auth.refresh_token;
					o.qs.token_url = 'https://api.login.yahoo.com/oauth/v2/get_token';
				}
			},
		*/
	
		function formatError(o) {
			if (o && 'meta' in o && 'error_type' in o.meta) {
				o.error = {
					code: o.meta.error_type,
					message: o.meta.error_message
				};
			}
		}
	
		function formatUser(o) {
	
			formatError(o);
			if (o.query && o.query.results && o.query.results.profile) {
				o = o.query.results.profile;
				o.id = o.guid;
				o.last_name = o.familyName;
				o.first_name = o.givenName || o.nickname;
				var a = [];
				if (o.first_name) {
					a.push(o.first_name);
				}
	
				if (o.last_name) {
					a.push(o.last_name);
				}
	
				o.name = a.join(' ');
				o.email = (o.emails && o.emails[0]) ? o.emails[0].handle : null;
				o.thumbnail = o.image ? o.image.imageUrl : null;
			}
	
			return o;
		}
	
		function formatFriends(o, headers, request) {
			formatError(o);
			paging(o, headers, request);
			var contact;
			var field;
			if (o.query && o.query.results && o.query.results.contact) {
				o.data = o.query.results.contact;
				delete o.query;
	
				if (!Array.isArray(o.data)) {
					o.data = [o.data];
				}
	
				o.data.forEach(formatFriend);
			}
	
			return o;
		}
	
		function formatFriend(contact) {
			contact.id = null;
	
			// #362: Reports of responses returning a single item, rather than an Array of items.
			// Format the contact.fields to be an array.
			if (contact.fields && !(contact.fields instanceof Array)) {
				contact.fields = [contact.fields];
			}
	
			(contact.fields || []).forEach(function(field) {
				if (field.type === 'email') {
					contact.email = field.value;
				}
	
				if (field.type === 'name') {
					contact.first_name = field.value.givenName;
					contact.last_name = field.value.familyName;
					contact.name = field.value.givenName + ' ' + field.value.familyName;
				}
	
				if (field.type === 'yahooid') {
					contact.id = field.value;
				}
			});
		}
	
		function paging(res, headers, request) {
	
			// See: http://developer.yahoo.com/yql/guide/paging.html#local_limits
			if (res.query && res.query.count && request.options) {
				res.paging = {
					next: '?start=' + (res.query.count + (+request.options.start || 1))
				};
			}
	
			return res;
		}
	
		function yql(q) {
			return 'https://query.yahooapis.com/v1/yql?q=' + (q + ' limit @{limit|100} offset @{start|0}').replace(/\s/g, '%20') + '&format=json';
		}
	
	})(hello);
	
	// Register as anonymous AMD module
	if (true) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return hello;
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	// CommonJS module for browserify
	if (typeof module === 'object' && module.exports) {
		module.exports = hello;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(412).setImmediate))

/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(413).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(412).setImmediate, __webpack_require__(412).clearImmediate))

/***/ },
/* 413 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp2;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Subschema = __webpack_require__(160);
	
	var _github = __webpack_require__(415);
	
	var _github2 = _interopRequireDefault(_github);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Login = (_temp2 = _class = function (_Component) {
	    _inherits(Login, _Component);
	
	    function Login() {
	        var _Object$getPrototypeO;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Login);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Login)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.profile = function () {
	            return (0, _github2.default)().api({ path: 'me', formatResponse: false }).then(_this.handleGithubLoginSuccess);
	        }, _this.handleClick = function (e) {
	            _this.setState({ inprogress: true });
	            (0, _github2.default)().login({ scope: 'read:org, friends, photos, publish' }).then(_this.profile, _this.handleGithubLoginFailure);
	        }, _this.handleGithubLoginSuccess = function (me) {
	            console.log('success->me', me);
	            _this.setState({ inprogress: false, error: false });
	            _this.handleChange(me);
	        }, _this.handleGithubLoginFailure = function (error) {
	            console.log('fail->me', error);
	            _this.setState({ inprogress: false, error: error });
	            _this.handleChange(null);
	        }, _this.state = {
	            inprogress: false
	        }, _this.handleLogout = function (e) {
	            (0, _github2.default)().logout();
	            _this.props.onChange(null);
	            _this.setState({ error: false, inprogress: false });
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(Login, [{
	        key: 'handleChange',
	        value: function handleChange(me) {
	            if (typeof this.props.onChange === 'function') {
	                console.log('handleChange', me);
	                this.props.onChange(me);
	            }
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	
	            if (!this.props.value) {
	                var me = (0, _github.isAuth)();
	                if (me && me.error) {
	                    this.setState({ error: me.error, inprogress: false });
	                } else {
	                    this.profile();
	                }
	            }
	        }
	    }, {
	        key: 'renderMe',
	        value: function renderMe() {
	            var _props = this.props;
	            var _props$value = _props.value;
	            var _props$value$avatar_u = _props$value.avatar_url;
	            var avatar_url = _props$value$avatar_u === undefined ? '' : _props$value$avatar_u;
	            var login = _props$value.login;
	            var name = _props$value.name;
	            var labelClass = _props.labelClass;
	            var nameClass = _props.nameClass;
	            var loginClass = _props.loginClass;
	            var imgClass = _props.imgClass;
	
	            return _react2.default.createElement(
	                'button',
	                { onClick: this.handleLogout, className: 'clearfix ' + loginClass },
	                _react2.default.createElement('img', { className: imgClass, src: avatar_url }),
	                _react2.default.createElement(
	                    'strong',
	                    { className: labelClass },
	                    _react2.default.createElement('i', { className: 'fa fa-github' }),
	                    ' ',
	                    login
	                ),
	                _react2.default.createElement(
	                    'span',
	                    { className: nameClass },
	                    name
	                )
	            );
	        }
	    }, {
	        key: 'renderLogin',
	        value: function renderLogin() {
	            return _react2.default.createElement(
	                'button',
	                { className: this.props.buttonClass, onClick: this.handleClick },
	                _react2.default.createElement('i', {
	                    className: 'fa fa-github' }),
	                ' ',
	                this.props.loginText
	            );
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            if (this.state.inprogress) {
	                return _react2.default.createElement(
	                    'span',
	                    { className: this.props.inprogressClass },
	                    _react2.default.createElement('i', {
	                        className: 'fa fa-github' }),
	                    ' Logging Into Github...'
	                );
	            }
	            if (this.state.error) {
	                return _react2.default.createElement(
	                    'div',
	                    { className: this.props.hasErrorClass },
	                    _react2.default.createElement(
	                        'span',
	                        { className: this.props.errorMessageClass },
	                        this.state.error
	                    ),
	                    this.renderLogin()
	                );
	            }
	            return this.props.value ? this.renderMe() : this.renderLogin();
	        }
	    }]);
	
	    return Login;
	}(_react.Component), _class.defaultProps = {
	    buttonClass: "btn btn-primary",
	    loginText: 'Github Login',
	    logoutText: 'Github Logout',
	    imgClass: "thumbnail",
	    value: ".",
	    onChange: "."
	}, _class.propTypes = {
	    onChange: _Subschema.PropTypes.valueEvent,
	    value: _Subschema.PropTypes.value,
	    style: _Subschema.PropTypes.style
	}, _temp2);
	exports.default = Login;

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.settings = undefined;
	exports.default = github;
	exports.isAuth = isAuth;
	
	var _hellojs = __webpack_require__(411);
	
	var _hellojs2 = _interopRequireDefault(_hellojs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _window = window;
	var hostname = _window.location.hostname;
	
	
	var redirect_url = {
	    'localhost.subschema.com': '/redirect.hml',
	    'subschema.github.io': '/subschema-github/redirect.html'
	}[hostname];
	
	var hello = {
	    'localhost.subschema.com': { github: '627a431f51e3b60077a5' },
	    'subschema.github.io': { github: '56da255b6232790f0ffe' }
	}[hostname];
	
	var settings = exports.settings = {
	    hello: hello,
	    network: {
	        oauth_proxy: 'https://auth-server.herokuapp.com/proxy',
	        redirect_url: redirect_url
	    }
	};
	
	var _gh = void 0;
	
	function github() {
	    var _settings = arguments.length <= 0 || arguments[0] === undefined ? settings : arguments[0];
	
	    if (_gh) {
	        return _gh;
	    }
	    _hellojs2.default.init(_settings.hello);
	    window.github = _gh = (0, _hellojs2.default)('github', _settings.network);
	
	    return _gh;
	}
	
	function isAuth() {
	    var _settings = arguments.length <= 0 || arguments[0] === undefined ? settings : arguments[0];
	
	    return github(_settings).getAuthResponse('github');
	}

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(417);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(419)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../node_modules/less-loader/index.js!./Login.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!./../node_modules/less-loader/index.js!./Login.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(418)();
	// imports
	
	
	// module
	exports.push([module.id, ".Login__img___2c5gL {\n  height: 40px;\n  width: 40px;\n  border-radius: 8px;\n  float: left;\n  display: block;\n}\n.Login__login___3tCeb {\n  padding: 10px;\n  border-radius: 10px;\n  margin: 5px;\n  border: none;\n  background: transparent;\n}\n.Login__label___zIHhA {\n  box-sizing: border-box;\n  padding-left: 10px;\n  display: block;\n  float: left;\n}\n.Login__name___1fPA1 {\n  display: block;\n}\n", ""]);
	
	// exports
	exports.locals = {
		"img": "Login__img___2c5gL",
		"login": "Login__login___3tCeb",
		"label": "Login__label___zIHhA",
		"name": "Login__name___1fPA1"
	};

/***/ },
/* 418 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _github = __webpack_require__(415);
	
	var _github2 = _interopRequireDefault(_github);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*avatar_url: "https://avatars.githubusercontent.com/u/2218735?v=3"
	 description: null
	 events_url: "https://api.github.com/orgs/bobamo/events"
	 hooks_url: "https://api.github.com/orgs/bobamo/hooks"
	 id: 2218735
	 issues_url: "https://api.github.com/orgs/bobamo/issues"
	 login: "bobamo"
	 members_url: "https://api.github.com/orgs/bobamo/members{/member}"
	 name: "bobamo"
	 picture: "https://avatars.githubusercontent.com/u/2218735?v=3"
	 public_members_url: "https://api.github.com/orgs/bobamo/public_members{/member}"
	 repos_url: "https://api.github.com/orgs/bobamo/repos"
	 thumbnail: "https://avatars.githubusercontent.com/u/2218735?v=3"
	 url: "https://api.github.com/orgs/bobamo"*/
	
	var map = new WeakMap();
	
	function filter(orgs, value, cb) {
	    var result = orgs;
	    if (value) {
	        (function () {
	            var re = new RegExp(value, 'i');
	            result = orgs.filter(function (v) {
	                return re.test(v.name || v.full_name);
	            });
	        })();
	    }
	    cb(null, result);
	}
	
	var api = {
	    fetch: function fetch(url, value, component, cb) {
	        var data = map.get(component);
	        if (!data) {
	            (0, _github2.default)().api(url).then(function (resp) {
	                map.set(component, resp.data);
	                filter(resp.data, value, cb);
	            });
	        } else {
	            filter(data, value, cb);
	        }
	    },
	
	    /**Value returns the value of the object, not necessarily whats in the input box**/
	    value: function value(obj) {
	        return obj == null ? null : obj.name || obj.full_name || obj;
	    },
	
	    /**
	     * Format returns the format.
	     * @param v
	     * @returns {null}
	     */
	    format: function format(v) {
	        return v == null ? null : v.name || v.full_name || v;
	    }
	};
	
	exports.default = api;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjliYjdhMjE4OTg2ZmNiMjJjOTYiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzIiwid2VicGFjazovLy8uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EYW5nZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvdG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIva2V5TWlycm9yLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UGVyZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRDb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5IdWIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9WaWV3cG9ydE1ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvT2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZUhhbmRsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSb290SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2FkbGVyMzIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVmLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0T3duZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFVwZGF0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ2FsbGJhY2tRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9UcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaXNUZXh0Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2lzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TmF0aXZlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3ZhbGlkYXRlRE9NTmVzdGluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2tleU9mLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DbGllbnRSZWFjdFJvb3RJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljTW91c2VFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZmluZERPTU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0xpbmtlZFZhbHVlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZmxhdHRlbkNoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TZXJ2ZXJSZWFjdFJvb3RJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudEtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljVG91Y2hFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJc29tb3JwaGljLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL21hcE9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9vbmx5Q2hpbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZGVwcmVjYXRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvQXBwLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHJhbnNpdGlvbi9SZWFjdENTU1JlcGxhY2VUcmFuc2l0aW9uLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vcmVhY3QtZG9tL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9DU1NDb3JlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VHJhbnNpdGlvbkV2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9kZWNvcmF0b3JzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL2RlY29yYXRvcnMvZGVjb3JhdG9yLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC91dGlsaXR5L25vb3AuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHV0aWxzLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvb2JqZWN0L2V4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9hc3NpZ25XaXRoLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvb2JqZWN0L2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9sYW5nL2lzTmF0aXZlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvZ2V0TGVuZ3RoLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9zaGltS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2xhbmcvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9sYW5nL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9pc0luZGV4LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvb2JqZWN0L2tleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlQ29weS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmluZENhbGxiYWNrLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvdXRpbGl0eS9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvZnVuY3Rpb24vcmVzdFBhcmFtLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2xhbmcvaXNSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9sYW5nL2lzRGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2xhbmcvaXNCb29sZWFuLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc051bWJlci5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2NvbGxlY3Rpb24vZmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VFYWNoLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZUZvck93bi5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvdG9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9jcmVhdGVCYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZUZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlQ2FsbGJhY2suanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlTWF0Y2hlcy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VJc01hdGNoLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZUlzRXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlSXNFcXVhbERlZXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9lcXVhbEFycmF5cy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2FycmF5U29tZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2VxdWFsQnlUYWcuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9lcXVhbE9iamVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9sYW5nL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2dldE1hdGNoRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL29iamVjdC9wYWlycy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlR2V0LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZVNsaWNlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvaXNLZXkuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9hcnJheS9sYXN0LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvdG9QYXRoLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvdXRpbGl0eS9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlRmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VGaW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9hcnJheS91bmlxdWUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9hcnJheS91bmlxLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZVVuaXEuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2luZGV4T2ZOYU4uanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9jYWNoZUluZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9jcmVhdGVDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL1NldENhY2hlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvY2FjaGVQdXNoLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvc29ydGVkVW5pcS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2NvbGxlY3Rpb24vZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2NvbGxlY3Rpb24vZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2FycmF5RWFjaC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZUZvckVhY2guanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9vYmplY3QvdmFsdWVzLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZVZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9kZWNvcmF0b3JzL2xpZmVjeWNsZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9EZWZhdWx0TG9hZGVyLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL2xvYWRlckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvY29sbGVjdGlvbi9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L3N1YnNjaGVtYS1pbmplY3Rpb24vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9zdWJzY2hlbWEtaW5qZWN0aW9uL3NyYy9pbmplY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vc3Vic2NoZW1hLWluamVjdGlvbi9zcmMvaW5qZWN0b3JGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9zdWJzY2hlbWEtaW5qZWN0aW9uL3NyYy91dGlsLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90ZW1wbGF0ZXMgbm9ucmVjdXJzaXZlIFRlbXBsYXRlLmpzKHgpIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9BdXRvY29tcGxldGVJdGVtVGVtcGxhdGUuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9CdXR0b25UZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0J1dHRvbnNUZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0NoZWNrYm94VGVtcGxhdGUuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9DaGVja2JveGVzR3JvdXBUZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0NoZWNrYm94ZXNUZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0NvbGxlY3Rpb25DcmVhdGVUZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvQ29udGVudC5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9vYmplY3QvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9hc3NpZ25EZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZURlZmF1bHRzLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3R5cGVzL0NvbnRlbnRXcmFwcGVyLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90ZW1wbGF0ZXMvQ29udGVudEl0ZW1UZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9vYmplY3QvZ2V0LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9FZGl0b3JUZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0ZpZWxkU2V0VGVtcGxhdGUuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9Gb3JtVGVtcGxhdGUuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9MaXN0SXRlbVRlbXBsYXRlLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90ZW1wbGF0ZXMvTW9kYWxUZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvVmFsdWVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL2V2ZW50YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9jb21wb25lbnRzL05ld0NoaWxkQ29udGV4dC5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9sYW5nL2Nsb25lRGVlcC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VDbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2FycmF5Q29weS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2luaXRDbG9uZUFycmF5LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvaW5pdENsb25lQnlUYWcuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9idWZmZXJDbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2luaXRDbG9uZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9jb21wb25lbnRzL1JlbmRlckNvbnRlbnQuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9PYmplY3RUZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL1JhZGlvSXRlbVRlbXBsYXRlLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90ZW1wbGF0ZXMvV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL1dpemFyZFRlbXBsYXRlLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9PYmplY3QuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL2NvbXBvbmVudHMvRmllbGQuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL2NvbXBvbmVudHMvRmllbGRTZXQuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9XaXphcmRNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90eXBlcyBub25yZWN1cnNpdmUgXFwuanMoeCkiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvQXV0b2NvbXBsZXRlLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9Eb20uanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvQ2hlY2tib3guanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3R5cGVzL0NoZWNrYm94ZXMuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3R5cGVzL0NvbGxlY3Rpb25NaXhpbi5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvRGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvSGlkZGVuLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9MYXp5VHlwZS5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvTGlzdC5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L3JlYWN0LWFkZG9ucy1jc3MtdHJhbnNpdGlvbi1ncm91cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvTWl4ZWQuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3R5cGVzL051bWJlci5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvUGFzc3dvcmQuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3R5cGVzL1JhZGlvLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9SZXN0cmljdGVkLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9SZXN0cmljdGVkTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvU2VsZWN0LmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9TdWJzdGl0dXRlTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2xvZGFzaC9zdHJpbmcvZXNjYXBlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvZXNjYXBlSHRtbENoYXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvVGV4dC5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvVGV4dEFyZWEuanN4Iiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Byb2Nlc3NvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcHJvY2Vzc29ycyBub25yZWN1cnNpdmUgXFwuanMoeCkiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcHJvY2Vzc29ycy9BcnJheVByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9wcm9jZXNzb3JzL09wdGlvbnNQcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdmFsaWRhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzIG5vbnJlY3Vyc2l2ZSBeLiotc3R5bGVcXC5qcyQiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL0F1dG9jb21wbGV0ZUl0ZW1UZW1wbGF0ZS1zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvQnV0dG9uc1RlbXBsYXRlLXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9DaGVja2JveFRlbXBsYXRlLXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9DaGVja2JveGVzR3JvdXBUZW1wbGF0ZS1zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvQ29sbGVjdGlvbkNyZWF0ZVRlbXBsYXRlLXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9Db2xsZWN0aW9uTWl4aW4tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL0VkaXRvclRlbXBsYXRlLXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9Gb3JtVGVtcGxhdGUtc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL0l0ZW1Ub1N0cmluZ1RlbXBsYXRlLXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9MaXN0LXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9MaXN0SXRlbVRlbXBsYXRlLXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9NaXhlZC1zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvTW9kYWxUZW1wbGF0ZS1zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvUmFkaW9JdGVtVGVtcGxhdGUtc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzIG5vbnJlY3Vyc2l2ZSBeLipcXC4obGVzc3xjc3MpJCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvQXV0b2NvbXBsZXRlLmxlc3M/NzdlOCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvQXV0b2NvbXBsZXRlLmxlc3MiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9MaXN0SXRlbVRlbXBsYXRlLmxlc3M/ZWUwYSIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvTGlzdEl0ZW1UZW1wbGF0ZS5sZXNzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9XaXphcmRQcm9ncmVzc1RlbXBsYXRlLmxlc3M/YzBjMSIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZS5sZXNzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9XaXphcmRUZW1wbGF0ZS5sZXNzPzkxYjYiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL1dpemFyZFRlbXBsYXRlLmxlc3MiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90cmFuc2l0aW9uIG5vbnJlY3Vyc2l2ZSBeLiotc3R5bGVcXC5qcyQiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9ucy1zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90cmFuc2l0aW9uIG5vbnJlY3Vyc2l2ZSBeLipcXC4obGVzc3xjc3MpJCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90cmFuc2l0aW9uL3RyYW5zaXRpb25zLmxlc3M/ZDZmMiIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy90cmFuc2l0aW9uL3RyYW5zaXRpb25zLmxlc3MiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzLmpzIiwid2VicGFjazovLy8uKmluZGV4LmpzJClcXC5qc3giLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2JsdXJWYWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvdmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2NoYW5nZVZhbGlkYXRlLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9jb25kaXRpb25hbC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9jb21wb25lbnRzL0NvbmRpdGlvbmFsLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvY29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvZGF0YVR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2RvbVR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2Vycm9yLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9lcnJvckV2ZW50LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2V2ZW50LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9leHByZXNzaW9uLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9maWVsZC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvdGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2ZpZWxkQXR0cnMuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2ZpZWxkcy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvZmllbGRzZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2h0bWxGb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2lkLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9pbmplY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvaW5qZWN0ZWRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvbGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL29wZXJhdG9yLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9vcHRpb25zLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9wcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL3NjaGVtYS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL3RhcmdldEV2ZW50LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy90aXRsZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvdHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvdHlwZUNsYXNzLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy92YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2xhbmcvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VGb3JJbi5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvdmFsdWVFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL3NyYy9kZWNvcmF0b3JzL3Byb3ZpZGVGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL2NhY2hlZEluamVjdG9yLmpzIiwid2VicGFjazovLy8uLi9zdWJzY2hlbWEvc3JjL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvY29tcG9uZW50cy9Gb3JtLmpzeCIsIndlYnBhY2s6Ly8vLi4vc3Vic2NoZW1hL34vbG9kYXNoL29iamVjdC9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL3N1YnNjaGVtYS9zcmMvY3NzLmpzIiwid2VicGFjazovLy8uL34vaGVsbG9qcy9kaXN0L2hlbGxvLmFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi90aW1lcnMtYnJvd3NlcmlmeS9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvTG9naW4uanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9naXRodWIuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL0xvZ2luLmxlc3M/NzI2MyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvTG9naW4ubGVzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvR2l0aHViUHJvY2Vzc29yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOzs7Ozs7Ozs7Ozs7OztBQUtBLHVCQUFPLGtEQUFQLEVBQWUsU0FBUyxjQUFULENBQXdCLFNBQXhCLENBQWYsRTs7Ozs7O0FDTEE7O0FBRUE7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBLHdCOzs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0hBQThIOztBQUU5SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCOzs7Ozs7O0FDM0ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUMxRnRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELHdDOzs7Ozs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsNkI7Ozs7Ozs7QUNqMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELDJDOzs7Ozs7QUNuVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW1DLGdDQUFnQzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7OztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUEsZ0M7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCOzs7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLDBEQUEwRDtBQUN2RSxlQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7Ozs7QUMxV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRzs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBbUM7QUFDbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLHNCQUFzQjtBQUM1Qyx3QkFBdUIsNkJBQTZCO0FBQ3BELE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLHlCQUF5QjtBQUMvQyx3QkFBdUIsZ0NBQWdDO0FBQ3ZELE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLDJCQUEyQjtBQUNqRCx3QkFBdUIsa0NBQWtDO0FBQ3pELE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLDRCQUE0QjtBQUNsRCx3QkFBdUIsbUNBQW1DO0FBQzFELE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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SUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLGVBQWU7QUFDNUIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQixlQUFjLEVBQUU7QUFDaEIsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDOzs7Ozs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkM7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLDBCQUEwQjtBQUNyQyxhQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCOzs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0M7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCOztBQUVyQix1QkFBc0IsaUJBQWlCO0FBQ3ZDLG9CQUFtQixjQUFjO0FBQ2pDLG1CQUFrQixlQUFlOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBc0g7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwSEFBeUg7QUFDekg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHlCQUF5QjtBQUN4QztBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFOQUFvTixZQUFZO0FBQ2hPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxT0FBb08sK0JBQStCO0FBQ25ROztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEscURBQW9EO0FBQ3BEO0FBQ0EseUJBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQSxvQzs7Ozs7OztBQ2o4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQSw0Qjs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBRUEsbUM7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUiw0QkFBMkI7QUFDM0IsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCwyQkFBMEI7QUFDMUIsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBLG9CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQzs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkI7Ozs7Ozs7QUNsd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFlBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QixjQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLDBEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDOzs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Qzs7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDBCQUF5QjtBQUN6QixJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQzs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsV0FBVztBQUN0QixhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLHVCQUF1QjtBQUNsQyxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHVCQUF1QjtBQUNsQyxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGNBQWEsdUJBQXVCO0FBQ3BDLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7OztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHVCQUF1QjtBQUNsQyxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHVCQUF1QjtBQUNsQyxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDOzs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixpQkFBaUI7QUFDdkMsd0JBQXVCLHdCQUF3QjtBQUMvQyxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsV0FBVztBQUN0QixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLGVBQWU7QUFDNUIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQixlQUFjLEVBQUU7QUFDaEIsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUM7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0IsZ0JBQWdCO0FBQ3RDLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixlQUFlO0FBQ3JDLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixrQkFBa0I7QUFDeEMsd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLHlCQUF5QjtBQUMvQyx3QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsZ0JBQWdCO0FBQ3RDLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixzQkFBc0I7QUFDNUMsd0JBQXVCLDZCQUE2QjtBQUNwRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLGVBQWU7QUFDckMsd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLGNBQWM7QUFDcEMsd0JBQXVCLHFCQUFxQjtBQUM1QztBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLHNCQUFzQjtBQUM1Qyx3QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsZUFBZTtBQUNyQyx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0Isa0JBQWtCO0FBQ3hDLHdCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixvQkFBb0I7QUFDMUMsd0JBQXVCLDJCQUEyQjtBQUNsRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLG1CQUFtQjtBQUN6Qyx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0Isb0JBQW9CO0FBQzFDLHdCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixtQkFBbUI7QUFDekMsd0JBQXVCLDBCQUEwQjtBQUNqRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLG9CQUFvQjtBQUMxQyx3QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsZUFBZTtBQUNyQyx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IseUJBQXlCO0FBQy9DLHdCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixrQkFBa0I7QUFDeEMsd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLG9CQUFvQjtBQUMxQyx3QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsZ0JBQWdCO0FBQ3RDLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixnQkFBZ0I7QUFDdEMsd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLGdCQUFnQjtBQUN0Qyx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsZ0JBQWdCO0FBQ3RDLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixrQkFBa0I7QUFDeEMsd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLG1CQUFtQjtBQUN6Qyx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsZ0JBQWdCO0FBQ3RDLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixlQUFlO0FBQ3JDLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixxQkFBcUI7QUFDM0Msd0JBQXVCLDRCQUE0QjtBQUNuRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLHlCQUF5QjtBQUMvQyx3QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0Isb0JBQW9CO0FBQzFDLHdCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0Isb0JBQW9CO0FBQzFDLHdCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixvQkFBb0I7QUFDMUMsd0JBQXVCLDJCQUEyQjtBQUNsRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLG1CQUFtQjtBQUN6Qyx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0Isb0JBQW9CO0FBQzFDLHdCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixrQkFBa0I7QUFDeEMsd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLGdCQUFnQjtBQUN0Qyx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsZ0JBQWdCO0FBQ3RDLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixlQUFlO0FBQ3JDLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixrQkFBa0I7QUFDeEMsd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLG1CQUFtQjtBQUN6Qyx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IscUJBQXFCO0FBQzNDLHdCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixnQkFBZ0I7QUFDdEMsd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLGlCQUFpQjtBQUN2Qyx3QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsaUJBQWlCO0FBQ3ZDLHdCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixrQkFBa0I7QUFDeEMsd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLGtCQUFrQjtBQUN4Qyx3QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsaUJBQWlCO0FBQ3ZDLHdCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixrQkFBa0I7QUFDeEMsd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLHFCQUFxQjtBQUMzQyx3QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0Isc0JBQXNCO0FBQzVDLHdCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQixtQkFBbUI7QUFDekMsd0JBQXVCLDBCQUEwQjtBQUNqRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLG9CQUFvQjtBQUMxQyx3QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IscUJBQXFCO0FBQzNDLHdCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUFzQix1QkFBdUI7QUFDN0Msd0JBQXVCLDhCQUE4QjtBQUNyRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXNCLGtCQUFrQjtBQUN4Qyx3QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSx1QkFBc0IsZ0JBQWdCO0FBQ3RDLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEwQixnQkFBZ0I7QUFDMUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxlQUFlO0FBQzVCLGNBQWEsT0FBTztBQUNwQixjQUFhLE9BQU87QUFDcEIsZUFBYyxFQUFFO0FBQ2hCLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DOzs7Ozs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0M7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Qzs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQzs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Qjs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUM7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0M7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDOzs7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEM7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrRDs7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0I7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQsb0M7Ozs7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O0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekRBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbENBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbENBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbENBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBLCtEQUE4RCxlQUFlLGdDQUFnQztBQUM3RztBQUNBLEVBQUM7O0FBRUQsMEM7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXNCLDBDQUEwQzs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUVBQW9FOztBQUVwRTtBQUNBLHVFQUFzRTs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQThCOztBQUU5Qiw0QkFBMkI7QUFDM0IsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBc0Isc0NBQXNDOztBQUU1RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF1QyxlQUFlLFlBQVk7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckMscUJBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixrQkFBa0IsOEVBQThFO0FBQ3pILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjs7QUFFaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQixXQUFXOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCLDJCQUEwQjtBQUMxQiwyQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFxQztBQUNyQyxrQ0FBaUM7QUFDakMsa0NBQWlDO0FBQ2pDLDJCQUEwQjtBQUMxQiwyQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4Qiw4REFBOEQsRUFBRTtBQUM5RiwrQkFBOEIsOERBQThELEVBQUU7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBLDhDQUE2QztBQUM3QztBQUNBLDhDQUE2QztBQUM3QztBQUNBLHVCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2Qix3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBLG9CQUFtQixxQkFBcUI7QUFDeEMseUJBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLFdBQVUsb0JBQW9CLEVBQUU7QUFDaEM7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTLGVBQWUsRUFBRTtBQUMxQjtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLDZCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFrQzs7QUFFbEM7O0FBRUEscUJBQW9CLDhCQUE4Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EscUNBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLDhCQUE4Qjs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUYsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQiw0RUFBNEU7O0FBRWpHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0IsZ0JBQWdCOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQW9DLGFBQWE7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLHNCQUFzQjs7QUFFekQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrRkFBOEY7QUFDOUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBcUU7QUFDckUsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSSxrQkFBa0I7QUFDdEIsS0FBSSxrQkFBa0I7QUFDdEIsS0FBSSxrQkFBa0I7QUFDdEIsS0FBSSxpQkFBaUI7QUFDckIsS0FBSSxrQkFBa0I7QUFDdEIsS0FBSSxrQkFBa0I7QUFDdEIsS0FBSSxtQkFBbUI7QUFDdkIsS0FBSSxtQkFBbUI7QUFDdkIsS0FBSSxtQkFBbUI7QUFDdkIsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0EsOENBQTZDLFVBQVU7QUFDdkQsZ0RBQStDLFVBQVU7QUFDekQsZ0RBQStDLFVBQVU7QUFDekQseUNBQXdDLFVBQVU7QUFDbEQsS0FBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQSx3R0FBdUcsV0FBVyxlQUFlLFFBQVE7O0FBRXpJOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtFQUFpRSxVQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLG1FQUFrRSxVQUFVO0FBQzVFLGtFQUFpRSxVQUFVO0FBQzNFLGtHQUFpRyxVQUFVLGVBQWUsUUFBUTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUwsNkdBQTRHLFVBQVUsZUFBZSxRQUFROztBQUU3STtBQUNBLGtDQUFpQyxHQUFHO0FBQ3BDLHdDQUF1QyxZQUFZLDhDQUE4QyxVQUFVOztBQUUzRztBQUNBLDBDQUF5QyxRQUFRLHNHQUFzRyxVQUFVOztBQUVqSztBQUNBLHlDQUF3QyxRQUFRLDhDQUE4QyxVQUFVO0FBQ3hHLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0EsbUNBQWtDLEdBQUc7QUFDckMsb0NBQW1DLEdBQUc7QUFDdEMsS0FBSTs7QUFFSjtBQUNBO0FBQ0Esa0NBQWlDLEdBQUc7QUFDcEMsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQix5QkFBeUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtB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O0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsR0FBRztBQUNwQyxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0Esb0NBQW1DLEdBQUc7QUFDdEMsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBa0QsVUFBVTtBQUM1RCxLQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQSw4Q0FBNkMsVUFBVTtBQUN2RCxnREFBK0MsVUFBVTtBQUN6RCxrREFBaUQsVUFBVTs7QUFFM0Q7QUFDQSxzREFBcUQsVUFBVTs7QUFFL0Q7QUFDQSw2Q0FBNEMsVUFBVTtBQUN0RCxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQStCLFVBQVU7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW1CLEdBQUc7QUFDdEIsb0JBQW1CLEdBQUc7O0FBRXRCO0FBQ0Esb0JBQW1CLG1CQUFtQjtBQUN0QyxzQkFBcUIsZUFBZTtBQUNwQyxxQkFBb0IsZUFBZTtBQUNuQyxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixHQUFHOztBQUV0QixzQkFBcUIsZ0JBQWdCO0FBQ3JDLG9CQUFtQixtQkFBbUI7QUFDdEMsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsR0FBRztBQUN0QixvQkFBbUIsR0FBRztBQUN0QixxQkFBb0IsR0FBRztBQUN2QixvQkFBbUIsR0FBRztBQUN0QixLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUVBQWtFLFVBQVUsVUFBVSxRQUFRO0FBQzlGOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcHNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLGlCQUFpQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHOzs7Ozs7O0FDM0VBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Rjs7Ozs7OztBQXFCUiw2QkFBTyxHQUFFO0FBQ0wsZ0JBQU8sS0FBSyxJQUFMLEdBQVksSUFBWixHQUFtQixFQUFFLElBQUYsSUFBVSxFQUFFLFNBQUYsSUFBZSxDQUF6QixDQURyQjtNQXJCRDtFQUFOOzttQkEwQlMsSSIsImZpbGUiOiJhcHAuYjliYjdhMjE4OTg2ZmNiMjJjOTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGI5YmI3YTIxODk4NmZjYjIyYzk2XG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtyZW5kZXJ9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwLmpzeCc7XG5cbnJlbmRlcig8QXBwLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250ZW50JykpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9wdWJsaWMvaW5kZXguanN4XG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9yZWFjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgnLi9SZWFjdERPTScpO1xudmFyIFJlYWN0RE9NU2VydmVyID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlcnZlcicpO1xudmFyIFJlYWN0SXNvbW9ycGhpYyA9IHJlcXVpcmUoJy4vUmVhY3RJc29tb3JwaGljJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBkZXByZWNhdGVkID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkJyk7XG5cbi8vIGB2ZXJzaW9uYCB3aWxsIGJlIGFkZGVkIGhlcmUgYnkgUmVhY3RJc29tb3JwaGljLlxudmFyIFJlYWN0ID0ge307XG5cbmFzc2lnbihSZWFjdCwgUmVhY3RJc29tb3JwaGljKTtcblxuYXNzaWduKFJlYWN0LCB7XG4gIC8vIFJlYWN0RE9NXG4gIGZpbmRET01Ob2RlOiBkZXByZWNhdGVkKCdmaW5kRE9NTm9kZScsICdSZWFjdERPTScsICdyZWFjdC1kb20nLCBSZWFjdERPTSwgUmVhY3RET00uZmluZERPTU5vZGUpLFxuICByZW5kZXI6IGRlcHJlY2F0ZWQoJ3JlbmRlcicsICdSZWFjdERPTScsICdyZWFjdC1kb20nLCBSZWFjdERPTSwgUmVhY3RET00ucmVuZGVyKSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZGVwcmVjYXRlZCgndW5tb3VudENvbXBvbmVudEF0Tm9kZScsICdSZWFjdERPTScsICdyZWFjdC1kb20nLCBSZWFjdERPTSwgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSksXG5cbiAgLy8gUmVhY3RET01TZXJ2ZXJcbiAgcmVuZGVyVG9TdHJpbmc6IGRlcHJlY2F0ZWQoJ3JlbmRlclRvU3RyaW5nJywgJ1JlYWN0RE9NU2VydmVyJywgJ3JlYWN0LWRvbS9zZXJ2ZXInLCBSZWFjdERPTVNlcnZlciwgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcpLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogZGVwcmVjYXRlZCgncmVuZGVyVG9TdGF0aWNNYXJrdXAnLCAnUmVhY3RET01TZXJ2ZXInLCAncmVhY3QtZG9tL3NlcnZlcicsIFJlYWN0RE9NU2VydmVyLCBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY01hcmt1cClcbn0pO1xuXG5SZWFjdC5fX1NFQ1JFVF9ET01fRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0RE9NO1xuUmVhY3QuX19TRUNSRVRfRE9NX1NFUlZFUl9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RET01TZXJ2ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NXG4gKi9cblxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vcmVuZGVyU3VidHJlZUludG9Db250YWluZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciByZW5kZXIgPSBSZWFjdFBlcmYubWVhc3VyZSgnUmVhY3QnLCAncmVuZGVyJywgUmVhY3RNb3VudC5yZW5kZXIpO1xuXG52YXIgUmVhY3QgPSB7XG4gIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcbiAgcmVuZGVyOiByZW5kZXIsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbn07XG5cbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxuLy8gQWxsb3dzIGZvciBkZWJ1Z2dpbmcgd2hlbiB0aGUgaG9vayBpcyBpbmplY3RlZCBvbiB0aGUgcGFnZS5cbi8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5pZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCh7XG4gICAgQ3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgICBJbnN0YW5jZUhhbmRsZXM6IFJlYWN0SW5zdGFuY2VIYW5kbGVzLFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlcixcbiAgICBUZXh0Q29tcG9uZW50OiBSZWFjdERPTVRleHRDb21wb25lbnRcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcblxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRldnRvb2xzIGlzIG5vdCBpbnN0YWxsZWRcbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGluIElFOCwgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgYW5kIHByb3ZpZGVcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgLy8gc2hpbXNcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgU3RyaW5nLnByb3RvdHlwZS50cmltLFxuXG4gICAgLy8gc2hhbXNcbiAgICBPYmplY3QuY3JlYXRlLCBPYmplY3QuZnJlZXplXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ09uZSBvciBtb3JlIEVTNSBzaGltL3NoYW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG5cbi8qKlxuICogVGV4dCBub2RlcyB2aW9sYXRlIGEgY291cGxlIGFzc3VtcHRpb25zIHRoYXQgUmVhY3QgbWFrZXMgYWJvdXQgY29tcG9uZW50czpcbiAqXG4gKiAgLSBXaGVuIG1vdW50aW5nIHRleHQgaW50byB0aGUgRE9NLCBhZGphY2VudCB0ZXh0IG5vZGVzIGFyZSBtZXJnZWQuXG4gKiAgLSBUZXh0IG5vZGVzIGNhbm5vdCBiZSBhc3NpZ25lZCBhIFJlYWN0IHJvb3QgSUQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byB3cmFwIHN0cmluZ3MgaW4gZWxlbWVudHMgc28gdGhhdCB0aGV5IGNhbiB1bmRlcmdvXG4gKiB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXG4gKlxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXG4gKlxuICogQGNsYXNzIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIC8vIFRoaXMgY29uc3RydWN0b3IgYW5kIGl0cyBhcmd1bWVudCBpcyBjdXJyZW50bHkgdXNlZCBieSBtb2Nrcy5cbn07XG5cbmFzc2lnbihSZWFjdERPTVRleHRDb21wb25lbnQucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgcmVhbGx5IGEgUmVhY3RUZXh0IChSZWFjdE5vZGUpLCBub3QgYSBSZWFjdEVsZW1lbnRcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IHRleHQ7XG4gICAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcblxuICAgIC8vIFByb3BlcnRpZXNcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudEluZGV4ID0gMDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pIHtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKCdzcGFuJywgbnVsbCwgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gY29udGV4dFtSZWFjdE1vdW50Lm93bmVyRG9jdW1lbnRDb250ZXh0S2V5XTtcbiAgICAgIHZhciBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldEF0dHJpYnV0ZUZvcklEKGVsLCByb290SUQpO1xuICAgICAgLy8gUG9wdWxhdGUgbm9kZSBjYWNoZVxuICAgICAgUmVhY3RNb3VudC5nZXRJRChlbCk7XG4gICAgICBzZXRUZXh0Q29udGVudChlbCwgdGhpcy5fc3RyaW5nVGV4dCk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlc2NhcGVkVGV4dCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0aGlzLl9zdHJpbmdUZXh0KTtcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgd3JhcCB0aGlzIGluIGEgYHNwYW5gIGZvciB0aGUgcmVhc29ucyBzdGF0ZWQgYWJvdmUsIGJ1dFxuICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlciAoc3RhdGljIHBhZ2VzKSxcbiAgICAgICAgLy8gd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8c3BhbiAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHJvb3RJRCkgKyAnPicgKyBlc2NhcGVkVGV4dCArICc8L3NwYW4+JztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMudXBkYXRlVGV4dENvbnRlbnQobm9kZSwgbmV4dFN0cmluZ1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50KHRoaXMuX3Jvb3ROb2RlSUQpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTUNoaWxkcmVuT3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEYW5nZXIgPSByZXF1aXJlKCcuL0RhbmdlcicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluc2VydHMgYGNoaWxkTm9kZWAgYXMgYSBjaGlsZCBvZiBgcGFyZW50Tm9kZWAgYXQgdGhlIGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBwYXJlbnROb2RlIFBhcmVudCBub2RlIGluIHdoaWNoIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY2hpbGROb2RlIENoaWxkIG5vZGUgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGluZGV4KSB7XG4gIC8vIEJ5IGV4cGxvaXRpbmcgYXJyYXlzIHJldHVybmluZyBgdW5kZWZpbmVkYCBmb3IgYW4gdW5kZWZpbmVkIGluZGV4LCB3ZSBjYW5cbiAgLy8gcmVseSBleGNsdXNpdmVseSBvbiBgaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpYCBpbnN0ZWFkIG9mIGFsc28gdXNpbmdcbiAgLy8gYGFwcGVuZENoaWxkKG5vZGUpYC4gSG93ZXZlciwgdXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsXG4gIC8vIGJyb3dzZXJzIHNvIHdlIG11c3QgcmVwbGFjZSBpdCB3aXRoIGBudWxsYC5cblxuICAvLyBmaXggcmVuZGVyIG9yZGVyIGVycm9yIGluIHNhZmFyaVxuICAvLyBJRTggd2lsbCB0aHJvdyBlcnJvciB3aGVuIGluZGV4IG91dCBvZiBsaXN0IHNpemUuXG4gIHZhciBiZWZvcmVDaGlsZCA9IGluZGV4ID49IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBudWxsIDogcGFyZW50Tm9kZS5jaGlsZE5vZGVzLml0ZW0oaW5kZXgpO1xuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgYmVmb3JlQ2hpbGQpO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgdXBkYXRlVGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uICh1cGRhdGVzLCBtYXJrdXBMaXN0KSB7XG4gICAgdmFyIHVwZGF0ZTtcbiAgICAvLyBNYXBwaW5nIGZyb20gcGFyZW50IElEcyB0byBpbml0aWFsIGNoaWxkIG9yZGVyaW5ncy5cbiAgICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcbiAgICAvLyBMaXN0IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBiZSBtb3ZlZCBvciByZW1vdmVkLlxuICAgIHZhciB1cGRhdGVkQ2hpbGRyZW4gPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuICAgICAgaWYgKHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HIHx8IHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSkge1xuICAgICAgICB2YXIgdXBkYXRlZEluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgdmFyIHVwZGF0ZWRDaGlsZCA9IHVwZGF0ZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNbdXBkYXRlZEluZGV4XTtcbiAgICAgICAgdmFyIHBhcmVudElEID0gdXBkYXRlLnBhcmVudElEO1xuXG4gICAgICAgICF1cGRhdGVkQ2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc1VwZGF0ZXMoKTogVW5hYmxlIHRvIGZpbmQgY2hpbGQgJXMgb2YgZWxlbWVudC4gVGhpcyAnICsgJ3Byb2JhYmx5IG1lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgJyArICdicm93c2VyKSwgdXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsICcgKyAnbmVzdGluZyB0YWdzIGxpa2UgPGZvcm0+LCA8cD4sIG9yIDxhPiwgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyAnICsgJ2luIGFuIDxzdmc+IHBhcmVudC4gVHJ5IGluc3BlY3RpbmcgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBlbGVtZW50ICcgKyAnd2l0aCBSZWFjdCBJRCBgJXNgLicsIHVwZGF0ZWRJbmRleCwgcGFyZW50SUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4gPSBpbml0aWFsQ2hpbGRyZW4gfHwge307XG4gICAgICAgIGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF0gPSBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdIHx8IFtdO1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdW3VwZGF0ZWRJbmRleF0gPSB1cGRhdGVkQ2hpbGQ7XG5cbiAgICAgICAgdXBkYXRlZENoaWxkcmVuID0gdXBkYXRlZENoaWxkcmVuIHx8IFtdO1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW4ucHVzaCh1cGRhdGVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW5kZXJlZE1hcmt1cDtcbiAgICAvLyBtYXJrdXBMaXN0IGlzIGVpdGhlciBhIGxpc3Qgb2YgbWFya3VwIG9yIGp1c3QgYSBsaXN0IG9mIGVsZW1lbnRzXG4gICAgaWYgKG1hcmt1cExpc3QubGVuZ3RoICYmIHR5cGVvZiBtYXJrdXBMaXN0WzBdID09PSAnc3RyaW5nJykge1xuICAgICAgcmVuZGVyZWRNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAobWFya3VwTGlzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkTWFya3VwID0gbWFya3VwTGlzdDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdXBkYXRlZCBjaGlsZHJlbiBmaXJzdCBzbyB0aGF0IGB0b0luZGV4YCBpcyBjb25zaXN0ZW50LlxuICAgIGlmICh1cGRhdGVkQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdXBkYXRlZENoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbltqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVwZGF0ZWRDaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVA6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgcmVuZGVyZWRNYXJrdXBbdXBkYXRlLm1hcmt1cEluZGV4XSwgdXBkYXRlLnRvSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkc6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgaW5pdGlhbENoaWxkcmVuW3VwZGF0ZS5wYXJlbnRJRF1bdXBkYXRlLmZyb21JbmRleF0sIHVwZGF0ZS50b0luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQOlxuICAgICAgICAgIHNldElubmVySFRNTCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFOlxuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZCBieSB0aGUgZm9yLWxvb3AgYWJvdmUuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhET01DaGlsZHJlbk9wZXJhdGlvbnMsICdET01DaGlsZHJlbk9wZXJhdGlvbnMnLCB7XG4gIHVwZGF0ZVRleHRDb250ZW50OiAndXBkYXRlVGV4dENvbnRlbnQnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEYW5nZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlTm9kZXNGcm9tTWFya3VwID0gcmVxdWlyZSgnZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgT1BFTl9UQUdfTkFNRV9FWFAgPSAvXig8W14gXFwvPl0rKS87XG52YXIgUkVTVUxUX0lOREVYX0FUVFIgPSAnZGF0YS1kYW5nZXItaW5kZXgnO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIGZyb20gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIE5PVEU6IEV4dHJhY3RpbmcgdGhlIGBub2RlTmFtZWAgZG9lcyBub3QgcmVxdWlyZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaFxuICogYmVjYXVzZSB3ZSBtYWtlIGFzc3VtcHRpb25zIGFib3V0IFJlYWN0LWdlbmVyYXRlZCBtYXJrdXAgKGkuZS4gdGhlcmUgYXJlIG5vXG4gKiBzcGFjZXMgc3Vycm91bmRpbmcgdGhlIG9wZW5pbmcgdGFnIGFuZCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgYXR0cmlidXRlKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9leHRyYWN0LW5vZGVuYW1lXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICByZXR1cm4gbWFya3VwLnN1YnN0cmluZygxLCBtYXJrdXAuaW5kZXhPZignICcpKTtcbn1cblxudmFyIERhbmdlciA9IHtcblxuICAvKipcbiAgICogUmVuZGVycyBtYXJrdXAgaW50byBhbiBhcnJheSBvZiBub2Rlcy4gVGhlIG1hcmt1cCBpcyBleHBlY3RlZCB0byByZW5kZXJcbiAgICogaW50byBhIGxpc3Qgb2Ygcm9vdCBub2Rlcy4gQWxzbywgdGhlIGxlbmd0aCBvZiBgcmVzdWx0TGlzdGAgYW5kXG4gICAqIGBtYXJrdXBMaXN0YCBzaG91bGQgYmUgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwTGlzdCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzIHRvIHJlbmRlci5cbiAgICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudD59IExpc3Qgb2YgcmVuZGVyZWQgbm9kZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXBMaXN0KSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhIHdvcmtlciAnICsgJ3RocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgZ2xvYmFsbHkgJyArICdiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSAnICsgJ1JlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbm9kZU5hbWU7XG4gICAgdmFyIG1hcmt1cEJ5Tm9kZU5hbWUgPSB7fTtcbiAgICAvLyBHcm91cCBtYXJrdXAgYnkgYG5vZGVOYW1lYCBpZiBhIHdyYXAgaXMgbmVjZXNzYXJ5LCBlbHNlIGJ5ICcqJy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmt1cExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICFtYXJrdXBMaXN0W2ldID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVuZGVyTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwTGlzdFtpXSk7XG4gICAgICBub2RlTmFtZSA9IGdldE1hcmt1cFdyYXAobm9kZU5hbWUpID8gbm9kZU5hbWUgOiAnKic7XG4gICAgICBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSA9IG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdIHx8IFtdO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV1baV0gPSBtYXJrdXBMaXN0W2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0TGlzdCA9IFtdO1xuICAgIHZhciByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ID0gMDtcbiAgICBmb3IgKG5vZGVOYW1lIGluIG1hcmt1cEJ5Tm9kZU5hbWUpIHtcbiAgICAgIGlmICghbWFya3VwQnlOb2RlTmFtZS5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbWFya3VwTGlzdEJ5Tm9kZU5hbWUgPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXTtcblxuICAgICAgLy8gVGhpcyBmb3ItaW4gbG9vcCBza2lwcyB0aGUgaG9sZXMgb2YgdGhlIHNwYXJzZSBhcnJheS4gVGhlIG9yZGVyIG9mXG4gICAgICAvLyBpdGVyYXRpb24gc2hvdWxkIGZvbGxvdyB0aGUgb3JkZXIgb2YgYXNzaWdubWVudCwgd2hpY2ggaGFwcGVucyB0byBtYXRjaFxuICAgICAgLy8gbnVtZXJpY2FsIGluZGV4IG9yZGVyLCBidXQgd2UgZG9uJ3QgcmVseSBvbiB0aGF0LlxuICAgICAgdmFyIHJlc3VsdEluZGV4O1xuICAgICAgZm9yIChyZXN1bHRJbmRleCBpbiBtYXJrdXBMaXN0QnlOb2RlTmFtZSkge1xuICAgICAgICBpZiAobWFya3VwTGlzdEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpKSB7XG4gICAgICAgICAgdmFyIG1hcmt1cCA9IG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XTtcblxuICAgICAgICAgIC8vIFB1c2ggdGhlIHJlcXVlc3RlZCBtYXJrdXAgd2l0aCBhbiBhZGRpdGlvbmFsIFJFU1VMVF9JTkRFWF9BVFRSXG4gICAgICAgICAgLy8gYXR0cmlidXRlLiAgSWYgdGhlIG1hcmt1cCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgPCBjaGFyYWN0ZXIsIGl0XG4gICAgICAgICAgLy8gd2lsbCBiZSBkaXNjYXJkZWQgYmVsb3cgKHdpdGggYW4gYXBwcm9wcmlhdGUgY29uc29sZS5lcnJvcikuXG4gICAgICAgICAgbWFya3VwTGlzdEJ5Tm9kZU5hbWVbcmVzdWx0SW5kZXhdID0gbWFya3VwLnJlcGxhY2UoT1BFTl9UQUdfTkFNRV9FWFAsXG4gICAgICAgICAgLy8gVGhpcyBpbmRleCB3aWxsIGJlIHBhcnNlZCBiYWNrIG91dCBiZWxvdy5cbiAgICAgICAgICAnJDEgJyArIFJFU1VMVF9JTkRFWF9BVFRSICsgJz1cIicgKyByZXN1bHRJbmRleCArICdcIiAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW5kZXIgZWFjaCBncm91cCBvZiBtYXJrdXAgd2l0aCBzaW1pbGFyIHdyYXBwaW5nIGBub2RlTmFtZWAuXG4gICAgICB2YXIgcmVuZGVyTm9kZXMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwTGlzdEJ5Tm9kZU5hbWUuam9pbignJyksIGVtcHR5RnVuY3Rpb24gLy8gRG8gbm90aGluZyBzcGVjaWFsIHdpdGggPHNjcmlwdD4gdGFncy5cbiAgICAgICk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVuZGVyTm9kZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIHJlbmRlck5vZGUgPSByZW5kZXJOb2Rlc1tqXTtcbiAgICAgICAgaWYgKHJlbmRlck5vZGUuaGFzQXR0cmlidXRlICYmIHJlbmRlck5vZGUuaGFzQXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKSkge1xuXG4gICAgICAgICAgcmVzdWx0SW5kZXggPSArcmVuZGVyTm9kZS5nZXRBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpO1xuICAgICAgICAgIHJlbmRlck5vZGUucmVtb3ZlQXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcblxuICAgICAgICAgICEhcmVzdWx0TGlzdC5oYXNPd25Qcm9wZXJ0eShyZXN1bHRJbmRleCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGFuZ2VyOiBBc3NpZ25pbmcgdG8gYW4gYWxyZWFkeS1vY2N1cGllZCByZXN1bHQgaW5kZXguJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgcmVzdWx0TGlzdFtyZXN1bHRJbmRleF0gPSByZW5kZXJOb2RlO1xuXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbWF0Y2ggcmVzdWx0TGlzdC5sZW5ndGggYW5kIG1hcmt1cExpc3QubGVuZ3RoIHdoZW5cbiAgICAgICAgICAvLyB3ZSdyZSBkb25lLlxuICAgICAgICAgIHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRGFuZ2VyOiBEaXNjYXJkaW5nIHVuZXhwZWN0ZWQgbm9kZTonLCByZW5kZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsdGhvdWdoIHJlc3VsdExpc3Qgd2FzIHBvcHVsYXRlZCBvdXQgb2Ygb3JkZXIsIGl0IHNob3VsZCBub3cgYmUgYSBkZW5zZVxuICAgIC8vIGFycmF5LlxuICAgICEocmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9PT0gcmVzdWx0TGlzdC5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogRGlkIG5vdCBhc3NpZ24gdG8gZXZlcnkgaW5kZXggb2YgcmVzdWx0TGlzdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAhKHJlc3VsdExpc3QubGVuZ3RoID09PSBtYXJrdXBMaXN0Lmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGFuZ2VyOiBFeHBlY3RlZCBtYXJrdXAgdG8gcmVuZGVyICVzIG5vZGVzLCBidXQgcmVuZGVyZWQgJXMuJywgbWFya3VwTGlzdC5sZW5ndGgsIHJlc3VsdExpc3QubGVuZ3RoKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gcmVzdWx0TGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSAnICsgJ3dvcmtlciB0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlICcgKyAnZ2xvYmFsbHkgYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgJyArICdSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhbWFya3VwID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKG9sZENoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVwbGFjZSBtYXJrdXAgb2YgdGhlICcgKyAnPGh0bWw+IG5vZGUuIFRoaXMgaXMgYmVjYXVzZSBicm93c2VyIHF1aXJrcyBtYWtlIHRoaXMgdW5yZWxpYWJsZSAnICsgJ2FuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlICcgKyAnc2VydmVyIHJlbmRlcmluZy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIG5ld0NoaWxkO1xuICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykge1xuICAgICAgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q2hpbGQgPSBtYXJrdXA7XG4gICAgfVxuICAgIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYW5nZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0Rhbmdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFeGVjdXRpb25FbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXBcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnLi9jcmVhdGVBcnJheUZyb21NaXhlZCcpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCcuL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIHJlbmRlciBhbGwgbWFya3VwLlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFBhdHRlcm4gdXNlZCBieSBgZ2V0Tm9kZU5hbWVgLlxuICovXG52YXIgbm9kZU5hbWVQYXR0ZXJuID0gL15cXHMqPChcXHcrKS87XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgdmFyIG5vZGVOYW1lTWF0Y2ggPSBtYXJrdXAubWF0Y2gobm9kZU5hbWVQYXR0ZXJuKTtcbiAgcmV0dXJuIG5vZGVOYW1lTWF0Y2ggJiYgbm9kZU5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbm9kZXMgcmVuZGVyZWQgZnJvbSB0aGUgc3VwcGxpZWQgbWFya3VwLiBUaGVcbiAqIG9wdGlvbmFsbHkgc3VwcGxpZWQgYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uY2UgZm9yIGVhY2hcbiAqIDxzY3JpcHQ+IGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZC4gSWYgbm8gYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gaXMgc3VwcGxpZWQsXG4gKiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGFueSA8c2NyaXB0PiBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBBIHN0cmluZyBvZiB2YWxpZCBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBoYW5kbGVTY3JpcHQgSW52b2tlZCBvbmNlIGZvciBlYWNoIHJlbmRlcmVkIDxzY3JpcHQ+LlxuICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudHxET01UZXh0Tm9kZT59IEFuIGFycmF5IG9mIHJlbmRlcmVkIG5vZGVzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBoYW5kbGVTY3JpcHQpIHtcbiAgdmFyIG5vZGUgPSBkdW1teU5vZGU7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgZHVtbXkgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXApO1xuXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XG4gIGlmICh3cmFwKSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSB3cmFwWzFdICsgbWFya3VwICsgd3JhcFsyXTtcblxuICAgIHZhciB3cmFwRGVwdGggPSB3cmFwWzBdO1xuICAgIHdoaWxlICh3cmFwRGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgfVxuXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gIGlmIChzY3JpcHRzLmxlbmd0aCkge1xuICAgICFoYW5kbGVTY3JpcHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwKC4uLik6IFVuZXhwZWN0ZWQgPHNjcmlwdD4gZWxlbWVudCByZW5kZXJlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgY3JlYXRlQXJyYXlGcm9tTWl4ZWQoc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xuICB9XG5cbiAgdmFyIG5vZGVzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQobm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZUFycmF5RnJvbU1peGVkXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvQXJyYXkgPSByZXF1aXJlKCcuL3RvQXJyYXknKTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybihcbiAgICAvLyBub3QgbnVsbC9mYWxzZVxuICAgICEhb2JqICYmIChcbiAgICAvLyBhcnJheXMgYXJlIG9iamVjdHMsIE5vZGVMaXN0cyBhcmUgZnVuY3Rpb25zIGluIFNhZmFyaVxuICAgIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJlxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG4gICAgJ2xlbmd0aCcgaW4gb2JqICYmXG4gICAgLy8gbm90IHdpbmRvd1xuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmXG4gICAgLy8gbm8gRE9NIG5vZGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gYXJyYXktbGlrZVxuICAgIC8vIGEgJ3NlbGVjdCcgZWxlbWVudCBoYXMgJ2xlbmd0aCcgYW5kICdpdGVtJyBwcm9wZXJ0aWVzIG9uIElFOFxuICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxuICAgIC8vIGEgcmVhbCBhcnJheVxuICAgIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgIC8vIGFyZ3VtZW50c1xuICAgICdjYWxsZWUnIGluIG9iaiB8fFxuICAgIC8vIEhUTUxDb2xsZWN0aW9uL05vZGVMaXN0XG4gICAgJ2l0ZW0nIGluIG9iailcbiAgKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgYnkgd3JhcHBpbmcgaXQgaW4gYW4gYXJyYXkgaWYgaXQgaXMgbm90LlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50IGlmIGl0IGlzIGFscmVhZHkgYW4gYXJyYXkuXG4gKlxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGlkaW9tYXRpY2FsbHk6XG4gKlxuICogICB2YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCdjcmVhdGVBcnJheUZyb21NaXhlZCcpO1xuICpcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XG4gKiAgICAgdGhpbmdzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQodGhpbmdzKTtcbiAqICAgICAuLi5cbiAqICAgfVxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmVhdCBgdGhpbmdzJyBhcyBhbiBhcnJheSwgYnV0IGFjY2VwdCBzY2FsYXJzIGluIHRoZSBBUEkuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gY29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCwgbGlrZSBgYXJndW1lbnRzYCwgaW50byBhbiBhcnJheVxuICogdXNlIHRvQXJyYXkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1peGVkKG9iaikge1xuICBpZiAoIWhhc0FycmF5TmF0dXJlKG9iaikpIHtcbiAgICByZXR1cm4gW29ial07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0FycmF5KG9iaik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcnJheUZyb21NaXhlZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdG9BcnJheVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2UgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3QgaW5cbiAgLy8gb2xkIHZlcnNpb25zIG9mIFNhZmFyaSkuXG4gICEoIUFycmF5LmlzQXJyYXkob2JqKSAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IEFycmF5LWxpa2Ugb2JqZWN0IGV4cGVjdGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICEodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBuZWVkcyBhIGxlbmd0aCBwcm9wZXJ0eScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9BcnJheTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi90b0FycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnZhcmlhbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE1hcmt1cFdyYXBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG5cbnZhciBzaG91bGRXcmFwID0ge307XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcFxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnRzIHNpbmNlIHdlIGtub3cgdGhleSdsbCBhbHdheXMgbmVlZCB0byBiZSB3cmFwcGVkXG4vLyBjb25zaXN0ZW50bHkuIElmIHRoZXkgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG52YXIgc3ZnRWxlbWVudHMgPSBbJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3RleHQnLCAndHNwYW4nXTtcbnN2Z0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcbiAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSB0cnVlO1xufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGBub2RlTmFtZWAuXG4gKlxuICogTk9URTogVGhpcyBsYXppbHkgZGV0ZWN0cyB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cbiAqIEByZXR1cm4gez9hcnJheX0gTWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWFya3VwIHdyYXBwaW5nIG5vZGUgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcmt1cFdyYXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZW1wdHlGdW5jdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgU0VUX01BUktVUDogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU1pcnJvclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5O1xuICAhKG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBrZXk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5TWlycm9yO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL2tleU1pcnJvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZWFjdFBlcmYgaXMgYSBnZW5lcmFsIEFPUCBzeXN0ZW0gZGVzaWduZWQgdG8gbWVhc3VyZSBwZXJmb3JtYW5jZS4gVGhpc1xuICogbW9kdWxlIG9ubHkgaGFzIHRoZSBob29rczogc2VlIFJlYWN0RGVmYXVsdFBlcmYgZm9yIHRoZSBhbmFseXNpcyB0b29sLlxuICovXG52YXIgUmVhY3RQZXJmID0ge1xuICAvKipcbiAgICogQm9vbGVhbiB0byBlbmFibGUvZGlzYWJsZSBtZWFzdXJlbWVudC4gU2V0IHRvIGZhbHNlIGJ5IGRlZmF1bHQgdG8gcHJldmVudFxuICAgKiBhY2NpZGVudGFsIGxvZ2dpbmcgYW5kIHBlcmYgbG9zcy5cbiAgICovXG4gIGVuYWJsZU1lYXN1cmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBIb2xkcyBvbnRvIHRoZSBtZWFzdXJlIGZ1bmN0aW9uIGluIHVzZS4gQnkgZGVmYXVsdCwgZG9uJ3QgbWVhc3VyZVxuICAgKiBhbnl0aGluZywgYnV0IHdlJ2xsIG92ZXJyaWRlIHRoaXMgaWYgd2UgaW5qZWN0IGEgbWVhc3VyZSBmdW5jdGlvbi5cbiAgICovXG4gIHN0b3JlZE1lYXN1cmU6IF9ub01lYXN1cmUsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iamVjdE5hbWVcbiAgICogQHBhcmFtIHtvYmplY3Q8c3RyaW5nPn0gbWV0aG9kTmFtZXNcbiAgICovXG4gIG1lYXN1cmVNZXRob2RzOiBmdW5jdGlvbiAob2JqZWN0LCBvYmplY3ROYW1lLCBtZXRob2ROYW1lcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kTmFtZXMpIHtcbiAgICAgICAgaWYgKCFtZXRob2ROYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSBSZWFjdFBlcmYubWVhc3VyZShvYmplY3ROYW1lLCBtZXRob2ROYW1lc1trZXldLCBvYmplY3Rba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyB0byB3cmFwIG1ldGhvZHMgeW91IHdhbnQgdG8gbWVhc3VyZS4gWmVybyBvdmVyaGVhZCBpbiBwcm9kdWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAqL1xuICBtZWFzdXJlOiBmdW5jdGlvbiAob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtZWFzdXJlZEZ1bmMgPSBudWxsO1xuICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSkge1xuICAgICAgICAgIGlmICghbWVhc3VyZWRGdW5jKSB7XG4gICAgICAgICAgICBtZWFzdXJlZEZ1bmMgPSBSZWFjdFBlcmYuc3RvcmVkTWVhc3VyZShvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVhc3VyZWRGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICB3cmFwcGVyLmRpc3BsYXlOYW1lID0gb2JqTmFtZSArICdfJyArIGZuTmFtZTtcbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYztcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZWFzdXJlXG4gICAgICovXG4gICAgaW5qZWN0TWVhc3VyZTogZnVuY3Rpb24gKG1lYXN1cmUpIHtcbiAgICAgIFJlYWN0UGVyZi5zdG9yZWRNZWFzdXJlID0gbWVhc3VyZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2ltcGx5IHBhc3NlcyB0aHJvdWdoIHRoZSBtZWFzdXJlZCBmdW5jdGlvbiwgd2l0aG91dCBtZWFzdXJpbmcgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBfbm9NZWFzdXJlKG9iak5hbWUsIGZuTmFtZSwgZnVuYykge1xuICByZXR1cm4gZnVuYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFBlcmY7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UGVyZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0SW5uZXJIVE1MXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbn07XG5cbi8vIFdpbjggYXBwczogQWxsb3cgYWxsIGh0bWwgdG8gYmUgaW5zZXJ0ZWRcbmlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0pO1xuICB9O1xufVxuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldElubmVySFRNTDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRUZXh0Q29udGVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRleHRDb250ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9zZXRUZXh0Q29udGVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVNDQVBFX0xPT0tVUCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJzwnOiAnJmx0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjeDI3Oydcbn07XG5cbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFwiJ10vZztcblxuZnVuY3Rpb24gZXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gRVNDQVBFX0xPT0tVUFttYXRjaF07XG59XG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBlc2NhcGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gL15bYS16QS1aX11bXFx3XFwuXFwtXSokLztcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlXG4gIH07XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG5cbiAgdmFyIHdhcm5Vbmtub3duUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgLy8gRm9yIG5vdywgb25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIHN1Z2dlc3RlZCBjb3JyZWN0aW9uLiBUaGlzIHByZXZlbnRzXG4gICAgLy8gbG9nZ2luZyB0b28gbXVjaCB3aGVuIHVzaW5nIHRyYW5zZmVyUHJvcHNUby5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzdGFuZGFyZE5hbWUgPT0gbnVsbCwgJ1Vua25vd24gRE9NIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgc3RhbmRhcmROYW1lKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBjdXN0b20gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlQXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICAvLyBNdXN0IGV4cGxpY2l0bHkgY2FzdCB2YWx1ZXMgZm9yIEhBU19TSURFX0VGRkVDVFMtcHJvcGVydGllcyB0byB0aGVcbiAgICAgICAgLy8gcHJvcGVydHkgdHlwZSBiZWZvcmUgY29tcGFyaW5nOyBvbmx5IGB2YWx1ZWAgZG9lcyBhbmQgaXMgc3RyaW5nLlxuICAgICAgICBpZiAoIXByb3BlcnR5SW5mby5oYXNTaWRlRWZmZWN0cyB8fCAnJyArIG5vZGVbcHJvcE5hbWVdICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlQXR0cmlidXRlKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBET01Qcm9wZXJ0eS5nZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eShub2RlLm5vZGVOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvLmhhc1NpZGVFZmZlY3RzIHx8ICcnICsgbm9kZVtwcm9wTmFtZV0gIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoRE9NUHJvcGVydHlPcGVyYXRpb25zLCAnRE9NUHJvcGVydHlPcGVyYXRpb25zJywge1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiAnc2V0VmFsdWVGb3JQcm9wZXJ0eScsXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiAnc2V0VmFsdWVGb3JBdHRyaWJ1dGUnLFxuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiAnZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfQVRUUklCVVRFOiAweDEsXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDIsXG4gIEhBU19TSURFX0VGRkVDVFM6IDB4NCxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4OCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4MTAsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDIwIHwgMHgxMCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHg0MCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxuICAgKiBhdHRyaWJ1dGVzIHdoZXJlIGl0J3MgaW1wb3NzaWJsZSB0byBlbnVtZXJhdGUgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NUHJvcGVydHlOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTVByb3BlcnR5TmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGlmIChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgICAgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLnB1c2goZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgJyArICdcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSAnICsgJ2luamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlICcgKyAnaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBsb3dlckNhc2VkLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXG4gICAgICAgIG11dGF0aW9uTWV0aG9kOiBudWxsLFxuXG4gICAgICAgIG11c3RVc2VBdHRyaWJ1dGU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFKSxcbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzU2lkZUVmZmVjdHM6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUyksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKVxuICAgICAgfTtcblxuICAgICAgISghcHJvcGVydHlJbmZvLm11c3RVc2VBdHRyaWJ1dGUgfHwgIXByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBDYW5ub3QgcmVxdWlyZSB1c2luZyBib3RoIGF0dHJpYnV0ZSBhbmQgcHJvcGVydHk6ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICEocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSB8fCAhcHJvcGVydHlJbmZvLmhhc1NpZGVFZmZlY3RzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogUHJvcGVydGllcyB0aGF0IGhhdmUgc2lkZSBlZmZlY3RzIG11c3QgdXNlIHByb3BlcnR5OiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciAnICsgJ251bWVyaWMgdmFsdWUsIGJ1dCBub3QgYSBjb21iaW5hdGlvbjogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG52YXIgZGVmYXVsdFZhbHVlQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBET01Qcm9wZXJ0eSBleHBvcnRzIGxvb2t1cCBvYmplY3RzIHRoYXQgY2FuIGJlIHVzZWQgbGlrZSBmdW5jdGlvbnM6XG4gKlxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2lkJ11cbiAqICAgdHJ1ZVxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2Zvb2JhciddXG4gKiAgIHVuZGVmaW5lZFxuICpcbiAqIEFsdGhvdWdoIHRoaXMgbWF5IGJlIGNvbmZ1c2luZywgaXQgcGVyZm9ybXMgYmV0dGVyIGluIGdlbmVyYWwuXG4gKlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktZXhpc3RzXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1taXNzaW5nXG4gKi9cbnZhciBET01Qcm9wZXJ0eSA9IHtcblxuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG5cbiAgLyoqXG4gICAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICAgKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gICAqXG4gICAqIGF0dHJpYnV0ZU5hbWU6XG4gICAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAgICogYXR0cmlidXRlTmFtZXNwYWNlXG4gICAqIHByb3BlcnR5TmFtZTpcbiAgICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAgICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogbXV0YXRpb25NZXRob2Q6XG4gICAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICAgKiAgIGluaXRpYWwgcmVuZGVyLlxuICAgKiBtdXN0VXNlQXR0cmlidXRlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgdXNpbmcgYCpBdHRyaWJ1dGUoKWAuXG4gICAqICAgKFRoaXMgaW5jbHVkZXMgYW55dGhpbmcgdGhhdCBmYWlscyBgPHByb3BOYW1lPiBpbiA8ZWxlbWVudD5gLilcbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNTaWRlRWZmZWN0czpcbiAgICogICBXaGV0aGVyIG9yIG5vdCBzZXR0aW5nIGEgdmFsdWUgY2F1c2VzIHNpZGUgZWZmZWN0cyBzdWNoIGFzIHRyaWdnZXJpbmdcbiAgICogICByZXNvdXJjZXMgdG8gYmUgbG9hZGVkIG9yIHRleHQgc2VsZWN0aW9uIGNoYW5nZXMuIElmIHRydWUsIHdlIHJlYWQgZnJvbVxuICAgKiAgIHRoZSBET00gYmVmb3JlIHVwZGF0aW5nIHRvIGVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBpZiBpdCBoYXNcbiAgICogICBjaGFuZ2VkLlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBET00gcHJvcGVydHkgKGkuZS4sIG5vdCBhblxuICAgKiBhdHRyaWJ1dGUpLiBNb3N0IGRlZmF1bHQgdmFsdWVzIGFyZSAnJyBvciBmYWxzZSwgYnV0IG5vdCBhbGwuIFdvcnNlIHlldCxcbiAgICogc29tZSAoaW4gcGFydGljdWxhciwgYHR5cGVgKSB2YXJ5IGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBlbGVtZW50LlxuICAgKlxuICAgKiBUT0RPOiBJcyBpdCBiZXR0ZXIgdG8gZ3JhYiBhbGwgdGhlIHBvc3NpYmxlIHByb3BlcnRpZXMgd2hlbiBjcmVhdGluZyBhblxuICAgKiBlbGVtZW50IHRvIGF2b2lkIGhhdmluZyB0byBjcmVhdGUgdGhlIHNhbWUgZWxlbWVudCB0d2ljZT9cbiAgICovXG4gIGdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZU5hbWUsIHByb3ApIHtcbiAgICB2YXIgbm9kZURlZmF1bHRzID0gZGVmYXVsdFZhbHVlQ2FjaGVbbm9kZU5hbWVdO1xuICAgIHZhciB0ZXN0RWxlbWVudDtcbiAgICBpZiAoIW5vZGVEZWZhdWx0cykge1xuICAgICAgZGVmYXVsdFZhbHVlQ2FjaGVbbm9kZU5hbWVdID0gbm9kZURlZmF1bHRzID0ge307XG4gICAgfVxuICAgIGlmICghKHByb3AgaW4gbm9kZURlZmF1bHRzKSkge1xuICAgICAgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgIG5vZGVEZWZhdWx0c1twcm9wXSA9IHRlc3RFbGVtZW50W3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZURlZmF1bHRzW3Byb3BdO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTVByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB3YXJuaW5nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL3dhcm5pbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGFsbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSByZWNvbmNpbGVyIHRoYXQgcmVxdWlyZXMga25vd2xlZGdlIG9mXG4gKiB0aGUgYnJvd3NlciBjb250ZXh0LiBUT0RPOiBUaGVzZSBjYWxsZXJzIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIGF2b2lkIHRoZVxuICogbmVlZCBmb3IgdGhpcyBpbmplY3Rpb24uXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHtcblxuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMsXG5cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlELFxuXG4gIC8qKlxuICAgKiBJZiBhIHBhcnRpY3VsYXIgZW52aXJvbm1lbnQgcmVxdWlyZXMgdGhhdCBzb21lIHJlc291cmNlcyBiZSBjbGVhbmVkIHVwLFxuICAgKiBzcGVjaWZ5IHRoaXMgaW4gdGhlIGluamVjdGVkIE1peGluLiBJbiB0aGUgRE9NLCB3ZSB3b3VsZCBsaWtlbHkgd2FudCB0b1xuICAgKiBwdXJnZSBhbnkgY2FjaGVkIG5vZGUgSUQgbG9va3Vwcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVubW91bnRJREZyb21FbnZpcm9ubWVudDogZnVuY3Rpb24gKHJvb3ROb2RlSUQpIHtcbiAgICBSZWFjdE1vdW50LnB1cmdlSUQocm9vdE5vZGVJRCk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSURPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEVycm9ycyBmb3IgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3QgYmUgdXBkYXRlZCB3aXRoIGB1cGRhdGVQcm9wZXJ0eUJ5SUQoKWAuXG4gKlxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJTlZBTElEX1BST1BFUlRZX0VSUk9SUyA9IHtcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6ICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgc2V0IHVzaW5nIGB1cGRhdGVJbm5lckhUTUxCeUlEKClgLicsXG4gIHN0eWxlOiAnYHN0eWxlYCBtdXN0IGJlIHNldCB1c2luZyBgdXBkYXRlU3R5bGVzQnlJRCgpYC4nXG59O1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSB3aXRoIG5ldyBwcm9wZXJ0eSB2YWx1ZXMuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB0b1xuICAgKiB1cGRhdGUgRE9NIHByb3BlcnRpZXMgaW4gYERPTVByb3BlcnR5YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSB2YWxpZCBwcm9wZXJ0eSBuYW1lLCBzZWUgYERPTVByb3BlcnR5YC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZVByb3BlcnR5QnlJRDogZnVuY3Rpb24gKGlkLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAhIUlOVkFMSURfUFJPUEVSVFlfRVJST1JTLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVByb3BlcnR5QnlJRCguLi4pOiAlcycsIElOVkFMSURfUFJPUEVSVFlfRVJST1JTW25hbWVdKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0YW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgRE9NIG5vZGUgdGhhdCBleGlzdHMgaW4gdGhlIGRvY3VtZW50IHdpdGggbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgY2hpbGQgdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgRGFuZ2Vyb3VzIG1hcmt1cCB0byBpbmplY3QgaW4gcGxhY2Ugb2YgY2hpbGQuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXB9XG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uIChpZCwgbWFya3VwKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChub2RlLCBtYXJrdXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwIExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAodXBkYXRlcywgbWFya3VwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1cGRhdGVzW2ldLnBhcmVudE5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodXBkYXRlc1tpXS5wYXJlbnRJRCk7XG4gICAgfVxuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyh1cGRhdGVzLCBtYXJrdXApO1xuICB9XG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RET01JRE9wZXJhdGlvbnMsICdSZWFjdERPTUlET3BlcmF0aW9ucycsIHtcbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEJyxcbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiAnZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JRE9wZXJhdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1vdW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgbm9kZUNhY2hlID0ge307XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbnZhciBvd25lckRvY3VtZW50Q29udGV4dEtleSA9ICdfX1JlYWN0TW91bnRfb3duZXJEb2N1bWVudCQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbi8qKiBNYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLiAqL1xudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqIE1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byBgY29udGFpbmVyYCBub2Rlcy4gKi9cbnZhciBjb250YWluZXJzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKiogX19ERVZfXy1vbmx5IG1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byByb290IGVsZW1lbnRzLiAqL1xuICB2YXIgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRCA9IHt9O1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGJyZWFkdGgtZmlyc3Qgc2VhcmNoIHN0YXRlIGluIGZpbmRDb21wb25lbnRSb290LlxudmFyIGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSA9IFtdO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gKiB0aGF0J3Mgbm90IGNvbW1vbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5ncy5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHdoZXJlIHRoZSBzdHJpbmdzIGRpdmVyZ2VcbiAqL1xuZnVuY3Rpb24gZmlyc3REaWZmZXJlbmNlSW5kZXgoc3RyaW5nMSwgc3RyaW5nMikge1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4oc3RyaW5nMS5sZW5ndGgsIHN0cmluZzIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5MZW47IGkrKykge1xuICAgIGlmIChzdHJpbmcxLmNoYXJBdChpKSAhPT0gc3RyaW5nMi5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nMS5sZW5ndGggPT09IHN0cmluZzIubGVuZ3RoID8gLTEgOiBtaW5MZW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTURvY3VtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpblxuICogYSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4gez8qfSBET00gZWxlbWVudCB0aGF0IG1heSBoYXZlIHRoZSByZWFjdFJvb3QgSUQsIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluIGEgUmVhY3QgY29tcG9uZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gQSBcInJlYWN0Um9vdFwiIElELCBpZiBhIFJlYWN0IGNvbXBvbmVudCBpcyByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gcm9vdEVsZW1lbnQgJiYgUmVhY3RNb3VudC5nZXRJRChyb290RWxlbWVudCk7XG59XG5cbi8qKlxuICogQWNjZXNzaW5nIG5vZGVbQVRUUl9OQU1FXSBvciBjYWxsaW5nIGdldEF0dHJpYnV0ZShBVFRSX05BTUUpIG9uIGEgZm9ybVxuICogZWxlbWVudCBjYW4gcmV0dXJuIGl0cyBjb250cm9sIHdob3NlIG5hbWUgb3IgSUQgZXF1YWxzIEFUVFJfTkFNRS4gQWxsXG4gKiBET00gbm9kZXMgc3VwcG9ydCBgZ2V0QXR0cmlidXRlTm9kZWAgYnV0IHRoaXMgY2FuIGFsc28gZ2V0IGNhbGxlZCBvblxuICogb3RoZXIgb2JqZWN0cyBzbyBqdXN0IHJldHVybiAnJyBpZiB3ZSdyZSBnaXZlbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBhXG4gKiBET00gbm9kZSAoc3VjaCBhcyB3aW5kb3cpLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR8RE9NV2luZG93fERPTURvY3VtZW50fERPTVRleHROb2RlfSBub2RlIERPTSBub2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBJRCBvZiB0aGUgc3VwcGxpZWQgYGRvbU5vZGVgLlxuICovXG5mdW5jdGlvbiBnZXRJRChub2RlKSB7XG4gIHZhciBpZCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChpZCkge1xuICAgIGlmIChub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICB2YXIgY2FjaGVkID0gbm9kZUNhY2hlW2lkXTtcbiAgICAgIGlmIChjYWNoZWQgIT09IG5vZGUpIHtcbiAgICAgICAgISFpc1ZhbGlkKGNhY2hlZCwgaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0TW91bnQ6IFR3byB2YWxpZCBidXQgdW5lcXVhbCBub2RlcyB3aXRoIHRoZSBzYW1lIGAlc2A6ICVzJywgQVRUUl9OQU1FLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSB8fCAnJztcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBSZWFjdC1zcGVjaWZpYyBJRCBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgVGhlIERPTSBub2RlIHdob3NlIElEIHdpbGwgYmUgc2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB2YWx1ZSBvZiB0aGUgSUQgYXR0cmlidXRlLlxuICovXG5mdW5jdGlvbiBzZXRJRChub2RlLCBpZCkge1xuICB2YXIgb2xkSUQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICBpZiAob2xkSUQgIT09IGlkKSB7XG4gICAgZGVsZXRlIG5vZGVDYWNoZVtvbGRJRF07XG4gIH1cbiAgbm9kZS5zZXRBdHRyaWJ1dGUoQVRUUl9OQU1FLCBpZCk7XG4gIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIFJlYWN0LWdlbmVyYXRlZCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsZWQgYGlkYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXROb2RlKGlkKSB7XG4gIGlmICghbm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSB8fCAhaXNWYWxpZChub2RlQ2FjaGVbaWRdLCBpZCkpIHtcbiAgICBub2RlQ2FjaGVbaWRdID0gUmVhY3RNb3VudC5maW5kUmVhY3ROb2RlQnlJRChpZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVDYWNoZVtpZF07XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgcHVibGljIFJlYWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gaW5zdGFuY2UgQSBwdWJsaWMgUmVhY3QgaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdGFuY2UpLl9yb290Tm9kZUlEO1xuICBpZiAoUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmlzTnVsbENvbXBvbmVudElEKGlkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghbm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSB8fCAhaXNWYWxpZChub2RlQ2FjaGVbaWRdLCBpZCkpIHtcbiAgICBub2RlQ2FjaGVbaWRdID0gUmVhY3RNb3VudC5maW5kUmVhY3ROb2RlQnlJRChpZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVDYWNoZVtpZF07XG59XG5cbi8qKlxuICogQSBub2RlIGlzIFwidmFsaWRcIiBpZiBpdCBpcyBjb250YWluZWQgYnkgYSBjdXJyZW50bHkgbW91bnRlZCBjb250YWluZXIuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IHRoZSBub2RlIGRvZXMgbm90IGhhdmUgdG8gYmUgY29udGFpbmVkIGJ5IGEgZG9jdW1lbnQgaW5cbiAqIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBleHBlY3RlZCBJRCBvZiB0aGUgbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5vZGUgaXMgY29udGFpbmVkIGJ5IGEgbW91bnRlZCBjb250YWluZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWQobm9kZSwgaWQpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICAhKGludGVybmFsR2V0SUQobm9kZSkgPT09IGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdE1vdW50OiBVbmV4cGVjdGVkIG1vZGlmaWNhdGlvbiBvZiBgJXNgJywgQVRUUl9OQU1FKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluc05vZGUoY29udGFpbmVyLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENhdXNlcyB0aGUgY2FjaGUgdG8gZm9yZ2V0IGFib3V0IG9uZSBSZWFjdC1zcGVjaWZpYyBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIHRvIGZvcmdldC5cbiAqL1xuZnVuY3Rpb24gcHVyZ2VJRChpZCkge1xuICBkZWxldGUgbm9kZUNhY2hlW2lkXTtcbn1cblxudmFyIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuZnVuY3Rpb24gZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwoYW5jZXN0b3JJRCkge1xuICB2YXIgYW5jZXN0b3IgPSBub2RlQ2FjaGVbYW5jZXN0b3JJRF07XG4gIGlmIChhbmNlc3RvciAmJiBpc1ZhbGlkKGFuY2VzdG9yLCBhbmNlc3RvcklEKSkge1xuICAgIGRlZXBlc3ROb2RlU29GYXIgPSBhbmNlc3RvcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIG5vZGUgaXNuJ3QgcG9wdWxhdGVkIGluIHRoZSBjYWNoZSwgc28gcHJlc3VtYWJseSBub25lIG9mIGl0c1xuICAgIC8vIGRlc2NlbmRhbnRzIGFyZS4gQnJlYWsgb3V0IG9mIHRoZSBsb29wLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZGVlcGVzdCBjYWNoZWQgbm9kZSB3aG9zZSBJRCBpcyBhIHByZWZpeCBvZiBgdGFyZ2V0SURgLlxuICovXG5mdW5jdGlvbiBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yKHRhcmdldElEKSB7XG4gIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuICBSZWFjdEluc3RhbmNlSGFuZGxlcy50cmF2ZXJzZUFuY2VzdG9ycyh0YXJnZXRJRCwgZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwpO1xuXG4gIHZhciBmb3VuZE5vZGUgPSBkZWVwZXN0Tm9kZVNvRmFyO1xuICBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbiAgcmV0dXJuIGZvdW5kTm9kZTtcbn1cblxuLyoqXG4gKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIGlmIChSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgY29udGV4dCA9IGFzc2lnbih7fSwgY29udGV4dCk7XG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgICAgY29udGV4dFtvd25lckRvY3VtZW50Q29udGV4dEtleV0gPSBjb250YWluZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHRbb3duZXJEb2N1bWVudENvbnRleHRLZXldID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGNvbnRleHQgPT09IGVtcHR5T2JqZWN0KSB7XG4gICAgICBjb250ZXh0ID0ge307XG4gICAgfVxuICAgIHZhciB0YWcgPSBjb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHRhZywgbnVsbCk7XG4gIH1cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gIGNvbXBvbmVudEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5fdG9wTGV2ZWxXcmFwcGVyID0gY29tcG9uZW50SW5zdGFuY2U7XG4gIFJlYWN0TW91bnQuX21vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBCYXRjaGVkIG1vdW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcbiAgLyogZm9yY2VIVE1MICovc2hvdWxkUmV1c2VNYXJrdXApO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGluc3RhbmNlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHVubW91bnQgZnJvbS5cbiAqIEBmaW5hbFxuICogQGludGVybmFsXG4gKiBAc2VlIHtSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGV9XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRGcm9tTm9kZShpbnN0YW5jZSwgY29udGFpbmVyKSB7XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlKTtcblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKG5vZGUpIHtcbiAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQobm9kZSk7XG4gIHJldHVybiByZWFjdFJvb3RJRCA/IHJlYWN0Um9vdElEICE9PSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQocmVhY3RSb290SUQpIDogZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgKGRlZXBlc3QpIGFuY2VzdG9yIG9mIGEgbm9kZSB3aGljaCBpcyByZW5kZXJlZCBieSB0aGlzIGNvcHlcbiAqIG9mIFJlYWN0LlxuICovXG5mdW5jdGlvbiBmaW5kRmlyc3RSZWFjdERPTUltcGwobm9kZSkge1xuICAvLyBUaGlzIG5vZGUgbWlnaHQgYmUgZnJvbSBhbm90aGVyIFJlYWN0IGluc3RhbmNlLCBzbyB3ZSBtYWtlIHN1cmUgbm90IHRvXG4gIC8vIGV4YW1pbmUgdGhlIG5vZGUgY2FjaGUgaGVyZVxuICBmb3IgKDsgbm9kZSAmJiBub2RlLnBhcmVudE5vZGUgIT09IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgLy8gTm90IGEgRE9NRWxlbWVudCwgdGhlcmVmb3JlIG5vdCBhIFJlYWN0IGNvbXBvbmVudFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBub2RlSUQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICAgIGlmICghbm9kZUlEKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG5cbiAgICAvLyBJZiBjb250YWluZXJzQnlSZWFjdFJvb3RJRCBjb250YWlucyB0aGUgY29udGFpbmVyIHdlIGZpbmQgYnkgY3Jhd2xpbmcgdXBcbiAgICAvLyB0aGUgdHJlZSwgd2Uga25vdyB0aGF0IHRoaXMgaW5zdGFuY2Ugb2YgUmVhY3QgcmVuZGVyZWQgdGhlIG5vZGUuXG4gICAgLy8gbmIuIGlzVmFsaWQncyBzdHJhdGVneSAod2l0aCBjb250YWluc05vZGUpIGRvZXMgbm90IHdvcmsgYmVjYXVzZSByZW5kZXJcbiAgICAvLyB0cmVlcyBtYXkgYmUgbmVzdGVkIGFuZCB3ZSBkb24ndCB3YW50IGEgZmFsc2UgcG9zaXRpdmUgaW4gdGhhdCBjYXNlLlxuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcbiAgICB2YXIgbGFzdElEO1xuICAgIGRvIHtcbiAgICAgIGxhc3RJRCA9IGludGVybmFsR2V0SUQoY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGFzc2VkLWluIG5vZGUgaGFzIGJlZW4gZGV0YWNoZWQgZnJvbSB0aGUgY29udGFpbmVyIGl0IHdhc1xuICAgICAgICAvLyBvcmlnaW5hbGx5IHJlbmRlcmVkIGludG8uXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGxhc3RJRCAhPT0gcmVhY3RSb290SUQpO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRlbXBvcmFyeSAoPykgaGFjayBzbyB0aGF0IHdlIGNhbiBzdG9yZSBhbGwgdG9wLWxldmVsIHBlbmRpbmcgdXBkYXRlcyBvblxuICogY29tcG9zaXRlcyBpbnN0ZWFkIG9mIGhhdmluZyB0byB3b3JyeSBhYm91dCBkaWZmZXJlbnQgdHlwZXMgb2YgY29tcG9uZW50c1xuICogaGVyZS5cbiAqL1xudmFyIFRvcExldmVsV3JhcHBlciA9IGZ1bmN0aW9uICgpIHt9O1xuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUb3BMZXZlbFdyYXBwZXIuZGlzcGxheU5hbWUgPSAnVG9wTGV2ZWxXcmFwcGVyJztcbn1cblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyB0aGlzLnByb3BzIGlzIGFjdHVhbGx5IGEgUmVhY3RFbGVtZW50XG4gIHJldHVybiB0aGlzLnByb3BzO1xufTtcblxuLyoqXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuXG4gIFRvcExldmVsV3JhcHBlcjogVG9wTGV2ZWxXcmFwcGVyLFxuXG4gIC8qKiBFeHBvc2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgKiovXG4gIF9pbnN0YW5jZXNCeVJlYWN0Um9vdElEOiBpbnN0YW5jZXNCeVJlYWN0Um9vdElELFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaG9vayBwcm92aWRlZCB0byBzdXBwb3J0IHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIHdoaWxlXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFwcGFyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiBpdHMgYGNvbnRhaW5lcmAgZG9lcyBub3RcbiAgICogY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgYGNvbnRhaW5lcmAgYmVpbmcgcmVuZGVyZWQgaW50by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVuZGVyQ2FsbGJhY2sgVGhpcyBtdXN0IGJlIGNhbGxlZCBvbmNlIHRvIGRvIHRoZSByZW5kZXIuXG4gICAqL1xuICBzY3JvbGxNb25pdG9yOiBmdW5jdGlvbiAoY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xuICAgIHJlbmRlckNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqL1xuICBfdXBkYXRlUm9vdENvbXBvbmVudDogZnVuY3Rpb24gKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50KTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKHByZXZDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXSA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNvbXBvbmVudCBpbnRvIHRoZSBpbnN0YW5jZSBtYXAgYW5kIHN0YXJ0cyBzY3JvbGwgdmFsdWVcbiAgICogbW9uaXRvcmluZ1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcmVhY3RSb290IElEIHByZWZpeFxuICAgKi9cbiAgX3JlZ2lzdGVyQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dENvbXBvbmVudCwgY29udGFpbmVyKSB7XG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuXG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5yZWdpc3RlckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gbmV4dENvbXBvbmVudDtcbiAgICByZXR1cm4gcmVhY3RSb290SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgZWxlbWVudCB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgaWYgd2Ugc2hvdWxkIHNraXAgdGhlIG1hcmt1cCBpbnNlcnRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcbiAgICovXG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgbnVsbCk7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5fcmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lcik7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCByZWFjdFJvb3RJRCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gUmVjb3JkIHRoZSByb290IGVsZW1lbnQgaW4gY2FzZSBpdCBsYXRlciBnZXRzIHRyYW5zcGxhbnRlZC5cbiAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIF9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhbiBlbGVtZW50IHN0cmluZywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgKyAnaXQgYnkgcGFzc2luZyBpdCB0byBSZWFjdC5jcmVhdGVFbGVtZW50LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNvbXBvbmVudCBjbGFzcywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgKyAnaXQgYnkgcGFzc2luZyBpdCB0byBSZWFjdC5jcmVhdGVFbGVtZW50LicgOlxuICAgIC8vIENoZWNrIGlmIGl0IHF1YWNrcyBsaWtlIGFuIGVsZW1lbnRcbiAgICBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IG5ldyBSZWFjdEVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBuZXh0RWxlbWVudCk7XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKV07XG5cbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xuICAgICAgdmFyIHByZXZXcmFwcGVkRWxlbWVudCA9IHByZXZDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldldyYXBwZWRFbGVtZW50LnByb3BzO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgdmFyIHB1YmxpY0luc3QgPSBwcmV2Q29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgdXBkYXRlZENhbGxiYWNrID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocHVibGljSW5zdCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0TW91bnQuX3VwZGF0ZVJvb3RDb21wb25lbnQocHJldkNvbXBvbmVudCwgbmV4dFdyYXBwZWRFbGVtZW50LCBjb250YWluZXIsIHVwZGF0ZWRDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwdWJsaWNJbnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0Um9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmICEhaW50ZXJuYWxHZXRJRChyZWFjdFJvb3RFbGVtZW50KTtcbiAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHJvb3RFbGVtZW50U2libGluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3RFbGVtZW50U2libGluZyA9IHJvb3RFbGVtZW50U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50ICYmICFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZDtcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHBhcmVudENvbXBvbmVudCAhPSBudWxsID8gcGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIDogZW1wdHlPYmplY3QpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNvbnRhaW5lciBub2RlIGludG8gd2hpY2ggUmVhY3QgY29tcG9uZW50cyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBUaGlzIGFsc28gY3JlYXRlcyB0aGUgXCJyZWFjdFJvb3RcIiBJRCB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGVsZW1lbnRcbiAgICogcmVuZGVyZWQgd2l0aGluLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZWdpc3RlciBhcyBhIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgXCJyZWFjdFJvb3RcIiBJRCBvZiBlbGVtZW50cyByZW5kZXJlZCB3aXRoaW4uXG4gICAqL1xuICByZWdpc3RlckNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgaWYgKHJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBJZiBvbmUgZXhpc3RzLCBtYWtlIHN1cmUgaXQgaXMgYSB2YWxpZCBcInJlYWN0Um9vdFwiIElELlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQocmVhY3RSb290SUQpO1xuICAgIH1cbiAgICBpZiAoIXJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBObyB2YWxpZCBcInJlYWN0Um9vdFwiIElEIGZvdW5kLCBjcmVhdGUgb25lLlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIH1cbiAgICBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBjb250YWluZXI7XG4gICAgcmV0dXJuIHJlYWN0Um9vdElEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbmQgZGVzdHJveXMgdGhlIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBpbiB0aGUgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBjb21wb25lbnQgd2FzIGZvdW5kIGluIGFuZCB1bm1vdW50ZWQgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICBgY29udGFpbmVyYFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFN0cmljdGx5IHNwZWFraW5nLCB1bm1vdW50aW5nIHdvbid0IGNhdXNlIGFcbiAgICAvLyByZW5kZXIgYnV0IHdlIHN0aWxsIGRvbid0IGV4cGVjdCB0byBiZSBpbiBhIHJlbmRlciBjYWxsIGhlcmUuKVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgJyArICdpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuXG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBiZWluZyB1bm1vdW50ZWQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgaXNuJ3QgYVxuICAgICAgLy8gcm9vdCBub2RlLlxuICAgICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySUQgPSBpbnRlcm5hbEdldElEKGNvbnRhaW5lcik7XG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXJJRCAmJiBjb250YWluZXJJRCA9PT0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKGNvbnRhaW5lcklEKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyh1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUsIGNvbXBvbmVudCwgY29udGFpbmVyKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgZGVsZXRlIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVsZXRlIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIFJlYWN0IGNvbXBvbmVudCB0byB3aGljaCB0aGVcbiAgICogc3VwcGxpZWQgRE9NIGBpZGAgYmVsb25ncy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgYGlkYC5cbiAgICovXG4gIGZpbmRSZWFjdENvbnRhaW5lckZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoaWQpO1xuICAgIHZhciBjb250YWluZXIgPSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgICBpZiAocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgICAvLyBDYWxsIGludGVybmFsR2V0SUQgaGVyZSBiZWNhdXNlIGdldElEIGNhbGxzIGlzVmFsaWQgd2hpY2ggY2FsbHNcbiAgICAgICAgLy8gZmluZFJlYWN0Q29udGFpbmVyRm9ySUQgKHRoaXMgZnVuY3Rpb24pLlxuICAgICAgICBpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50KSA9PT0gcmVhY3RSb290SUQsICdSZWFjdE1vdW50OiBSb290IGVsZW1lbnQgSUQgZGlmZmVyZWQgZnJvbSByZWFjdFJvb3RJRC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGNvbnRhaW5lckNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjb250YWluZXJDaGlsZCAmJiByZWFjdFJvb3RJRCA9PT0gaW50ZXJuYWxHZXRJRChjb250YWluZXJDaGlsZCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY29udGFpbmVyIGhhcyBhIG5ldyBjaGlsZCB3aXRoIHRoZSBzYW1lIElEIGFzIHRoZSBvbGRcbiAgICAgICAgICAvLyByb290IGVsZW1lbnQsIHRoZW4gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gaXNcbiAgICAgICAgICAvLyBqdXN0IHN0YWxlIGFuZCBuZWVkcyB0byBiZSB1cGRhdGVkLiBUaGUgY2FzZSB0aGF0IGRlc2VydmVzIGFcbiAgICAgICAgICAvLyB3YXJuaW5nIGlzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBlbXB0eS5cbiAgICAgICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGNvbnRhaW5lckNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RNb3VudDogUm9vdCBlbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgJyArICdjb250YWluZXIuIE5ldyBjb250YWluZXI6ICVzJywgcm9vdEVsZW1lbnQucGFyZW50Tm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IFJlYWN0IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBET00gbm9kZSBpbiB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSBSb290IERPTSBub2RlIG9mIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqL1xuICBmaW5kUmVhY3ROb2RlQnlJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHJlYWN0Um9vdCA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICAgIHJldHVybiBSZWFjdE1vdW50LmZpbmRDb21wb25lbnRSb290KHJlYWN0Um9vdCwgaWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdXAgdGhlIGFuY2VzdG9ycyBvZiB0aGUgc3VwcGxpZWQgbm9kZSB0byBmaW5kIGEgbm9kZSB0aGF0IGlzIGFcbiAgICogRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGJ5IHRoaXMgY29weSBvZiBSZWFjdC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBub2RlXG4gICAqIEByZXR1cm4gez9ET01FdmVudFRhcmdldH1cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRGaXJzdFJlYWN0RE9NOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBmaW5kRmlyc3RSZWFjdERPTUltcGwobm9kZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGEgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBgdGFyZ2V0SURgIGluc2lkZSBvZiB0aGUgc3VwcGxpZWRcbiAgICogYGFuY2VzdG9yTm9kZWAuICBFeHBsb2l0cyB0aGUgSUQgbmFtaW5nIHNjaGVtZSB0byBwZXJmb3JtIHRoZSBzZWFyY2hcbiAgICogcXVpY2tseS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gYW5jZXN0b3JOb2RlIFNlYXJjaCBmcm9tIHRoaXMgcm9vdC5cbiAgICogQHBhcmFybSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBgdGFyZ2V0SURgLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZpbmRDb21wb25lbnRSb290OiBmdW5jdGlvbiAoYW5jZXN0b3JOb2RlLCB0YXJnZXRJRCkge1xuICAgIHZhciBmaXJzdENoaWxkcmVuID0gZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5O1xuICAgIHZhciBjaGlsZEluZGV4ID0gMDtcblxuICAgIHZhciBkZWVwZXN0QW5jZXN0b3IgPSBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yKHRhcmdldElEKSB8fCBhbmNlc3Rvck5vZGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IG9uIHRoZSBuZXh0IGxpbmU7IGdpdmUgYW4gZWFybHkgd2FybmluZ1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGVlcGVzdEFuY2VzdG9yICE9IG51bGwsICdSZWFjdCBjYW5cXCd0IGZpbmQgdGhlIHJvb3QgY29tcG9uZW50IG5vZGUgZm9yIGRhdGEtcmVhY3RpZCB2YWx1ZSAnICsgJ2Alc2AuIElmIHlvdVxcJ3JlIHNlZWluZyB0aGlzIG1lc3NhZ2UsIGl0IHByb2JhYmx5IG1lYW5zIHRoYXQgJyArICd5b3VcXCd2ZSBsb2FkZWQgdHdvIGNvcGllcyBvZiBSZWFjdCBvbiB0aGUgcGFnZS4gQXQgdGhpcyB0aW1lLCBvbmx5ICcgKyAnYSBzaW5nbGUgY29weSBvZiBSZWFjdCBjYW4gYmUgbG9hZGVkIGF0IGEgdGltZS4nLCB0YXJnZXRJRCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZmlyc3RDaGlsZHJlblswXSA9IGRlZXBlc3RBbmNlc3Rvci5maXJzdENoaWxkO1xuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMTtcblxuICAgIHdoaWxlIChjaGlsZEluZGV4IDwgZmlyc3RDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpcnN0Q2hpbGRyZW5bY2hpbGRJbmRleCsrXTtcbiAgICAgIHZhciB0YXJnZXRDaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZElEID0gUmVhY3RNb3VudC5nZXRJRChjaGlsZCk7XG4gICAgICAgIGlmIChjaGlsZElEKSB7XG4gICAgICAgICAgLy8gRXZlbiBpZiB3ZSBmaW5kIHRoZSBub2RlIHdlJ3JlIGxvb2tpbmcgZm9yLCB3ZSBmaW5pc2ggbG9vcGluZ1xuICAgICAgICAgIC8vIHRocm91Z2ggaXRzIHNpYmxpbmdzIHRvIGVuc3VyZSB0aGV5J3JlIGNhY2hlZCBzbyB0aGF0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyB0byByZXZpc2l0IHRoaXMgbm9kZSBhZ2Fpbi4gT3RoZXJ3aXNlLCB3ZSBtYWtlIG5eMiBjYWxscyB0byBnZXRJRFxuICAgICAgICAgIC8vIHdoZW4gdmlzaXRpbmcgdGhlIG1hbnkgY2hpbGRyZW4gb2YgYSBzaW5nbGUgbm9kZSBpbiBvcmRlci5cblxuICAgICAgICAgIGlmICh0YXJnZXRJRCA9PT0gY2hpbGRJRCkge1xuICAgICAgICAgICAgdGFyZ2V0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJlYWN0SW5zdGFuY2VIYW5kbGVzLmlzQW5jZXN0b3JJRE9mKGNoaWxkSUQsIHRhcmdldElEKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBhIGNoaWxkIHdob3NlIElEIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBJRCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIGJlIHN1cmUgdGhhdCB3ZSBvbmx5IHdhbnQgdG8gc2VhcmNoIHRoZSBzdWJ0cmVlXG4gICAgICAgICAgICAvLyByb290ZWQgYXQgdGhpcyBjaGlsZCwgc28gd2UgY2FuIHRocm93IG91dCB0aGUgcmVzdCBvZiB0aGVcbiAgICAgICAgICAgIC8vIHNlYXJjaCBzdGF0ZS5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRJbmRleCA9IDA7XG4gICAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoaXMgY2hpbGQgaGFkIG5vIElELCB0aGVuIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBpdCB3YXNcbiAgICAgICAgICAvLyBpbmplY3RlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBicm93c2VyLCBhcyB3aGVuIGEgYDx0YWJsZT5gXG4gICAgICAgICAgLy8gZWxlbWVudCBzcHJvdXRzIGFuIGV4dHJhIGA8dGJvZHk+YCBjaGlsZCBhcyBhIHNpZGUgZWZmZWN0IG9mXG4gICAgICAgICAgLy8gYC5pbm5lckhUTUxgIHBhcnNpbmcuIE9wdGltaXN0aWNhbGx5IGNvbnRpbnVlIGRvd24gdGhpc1xuICAgICAgICAgIC8vIGJyYW5jaCwgYnV0IG5vdCBiZWZvcmUgZXhhbWluaW5nIHRoZSBvdGhlciBzaWJsaW5ncy5cbiAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0Q2hpbGQpIHtcbiAgICAgICAgLy8gRW1wdHlpbmcgZmlyc3RDaGlsZHJlbi9maW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXkgaXNcbiAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSBmb3IgY29ycmVjdG5lc3MsIGJ1dCBpdCBoZWxwcyB0aGUgR0MgcmVjbGFpbVxuICAgICAgICAvLyBhbnkgbm9kZXMgdGhhdCB3ZXJlIGxlZnQgYXQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoLlxuICAgICAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENoaWxkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kQ29tcG9uZW50Um9vdCguLi4sICVzKTogVW5hYmxlIHRvIGZpbmQgZWxlbWVudC4gVGhpcyBwcm9iYWJseSAnICsgJ21lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgYnJvd3NlciksICcgKyAndXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsIG5lc3RpbmcgdGFncyAnICsgJ2xpa2UgPGZvcm0+LCA8cD4sIG9yIDxhPiwgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyBpbiBhbiA8c3ZnPiAnICsgJ3BhcmVudC4gJyArICdUcnkgaW5zcGVjdGluZyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGVsZW1lbnQgd2l0aCBSZWFjdCBJRCBgJXNgLicsIHRhcmdldElELCBSZWFjdE1vdW50LmdldElEKGFuY2VzdG9yTm9kZSkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbikge1xuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKG1hcmt1cCwgcm9vdEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgJyArICdzZXJ2ZXIgcmVuZGVyaW5nIGJ1dCB0aGUgY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgdXN1YWxseSAnICsgJ21lYW5zIHlvdSByZW5kZXJlZCBhIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZSBvciBwcm9wcyBvbiAnICsgJ3RoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgJyArICdtZXRob2RzIGFyZSBpbXB1cmUuIFJlYWN0IGNhbm5vdCBoYW5kbGUgdGhpcyBjYXNlIGR1ZSB0byAnICsgJ2Nyb3NzLWJyb3dzZXIgcXVpcmtzIGJ5IHJlbmRlcmluZyBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gWW91ICcgKyAnc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyAnICsgJ2FuZCBlbnN1cmUgdGhlIHByb3BzIGFyZSB0aGUgc2FtZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlOlxcbiVzJywgZGlmZmVyZW5jZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdCBhdHRlbXB0ZWQgdG8gcmV1c2UgbWFya3VwIGluIGEgY29udGFpbmVyIGJ1dCB0aGUgJyArICdjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCB5b3UgYXJlICcgKyAndXNpbmcgc2VydmVyIHJlbmRlcmluZyBhbmQgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlICcgKyAnc2VydmVyIHdhcyBub3Qgd2hhdCB0aGUgY2xpZW50IHdhcyBleHBlY3RpbmcuIFJlYWN0IGluamVjdGVkICcgKyAnbmV3IG1hcmt1cCB0byBjb21wZW5zYXRlIHdoaWNoIHdvcmtzIGJ1dCB5b3UgaGF2ZSBsb3N0IG1hbnkgJyArICdvZiB0aGUgYmVuZWZpdHMgb2Ygc2VydmVyIHJlbmRlcmluZy4gSW5zdGVhZCwgZmlndXJlIG91dCAnICsgJ3doeSB0aGUgbWFya3VwIGJlaW5nIGdlbmVyYXRlZCBpcyBkaWZmZXJlbnQgb24gdGhlIGNsaWVudCAnICsgJ29yIHNlcnZlcjpcXG4lcycsIGRpZmZlcmVuY2UpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCAnICsgJ3lvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzICcgKyAnd2l0aG91dCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcy4gJyArICdTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcmt1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgfVxuICB9LFxuXG4gIG93bmVyRG9jdW1lbnRDb250ZXh0S2V5OiBvd25lckRvY3VtZW50Q29udGV4dEtleSxcblxuICAvKipcbiAgICogUmVhY3QgSUQgdXRpbGl0aWVzLlxuICAgKi9cblxuICBnZXRSZWFjdFJvb3RJRDogZ2V0UmVhY3RSb290SUQsXG5cbiAgZ2V0SUQ6IGdldElELFxuXG4gIHNldElEOiBzZXRJRCxcblxuICBnZXROb2RlOiBnZXROb2RlLFxuXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG5cbiAgaXNWYWxpZDogaXNWYWxpZCxcblxuICBwdXJnZUlEOiBwdXJnZUlEXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RNb3VudCwgJ1JlYWN0TW91bnQnLCB7XG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQnLFxuICBfbW91bnRJbWFnZUludG9Ob2RlOiAnX21vdW50SW1hZ2VJbnRvTm9kZSdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudEVtaXR0ZXJNaXhpbicpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydCBwbHVnZ2FibGVcbiAqICAgIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IGZhbHNlO1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8vIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZSB0cmFwIGF0IGFcbi8vIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkIGNhdXNlIGR1cGxpY2F0ZVxuLy8gZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlXG52YXIgdG9wRXZlbnRNYXBwaW5nID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucHV0TGlzdGVuZXIoJ215SUQnLCAnb25DbGljaycsIG15RnVuY3Rpb24pO1xuICpcbiAqIFRoaXMgd291bGQgYWxsb2NhdGUgYSBcInJlZ2lzdHJhdGlvblwiIG9mIGAoJ29uQ2xpY2snLCBteUZ1bmN0aW9uKWAgb24gJ215SUQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICB2YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsKSB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3doZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnd2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ21vdXNld2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdtb3VzZXdoZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggbmVlZHMgdG8gY2FwdHVyZSBhIGRpZmZlcmVudCBtb3VzZSBzY3JvbGwgZXZlbnQuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy90ZXN0cy9zY3JvbGwuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdET01Nb3VzZVNjcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCkge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuV0lORE9XX0hBTkRMRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMgfHwgZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXMnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXMnLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BCbHVyLCAnYmx1cicsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXNpbicpKSB7XG4gICAgICAgICAgICAvLyBJRSBoYXMgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50cyB3aGljaCBidWJibGUuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXNpbicsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2ZvY3Vzb3V0JywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BCbHVyXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BGb2N1c10gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcEV2ZW50TWFwcGluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChkZXBlbmRlbmN5LCB0b3BFdmVudE1hcHBpbmdbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gd2luZG93IHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50cy4gV2UgY2FjaGUgc2Nyb2xsIHZhbHVlcyBzbyB0aGF0XG4gICAqIGFwcGxpY2F0aW9uIGNvZGUgY2FuIGFjY2VzcyB0aGVtIHdpdGhvdXQgdHJpZ2dlcmluZyByZWZsb3dzLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlKSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XG4gICAgICBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogRXZlbnRQbHVnaW5IdWIuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiBFdmVudFBsdWdpbkh1Yi5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICBwdXRMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIsXG5cbiAgZ2V0TGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyLFxuXG4gIGRlbGV0ZUxpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5kZWxldGVMaXN0ZW5lcixcblxuICBkZWxldGVBbGxMaXN0ZW5lcnM6IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVyc1xuXG59KTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciwgJ1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicsIHtcbiAgcHV0TGlzdGVuZXI6ICdwdXRMaXN0ZW5lcicsXG4gIGRlbGV0ZUxpc3RlbmVyOiAnZGVsZXRlTGlzdGVuZXInXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRDb25zdGFudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0ga2V5TWlycm9yKHsgYnViYmxlZDogbnVsbCwgY2FwdHVyZWQ6IG51bGwgfSk7XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICB0b3BBYm9ydDogbnVsbCxcbiAgdG9wQmx1cjogbnVsbCxcbiAgdG9wQ2FuUGxheTogbnVsbCxcbiAgdG9wQ2FuUGxheVRocm91Z2g6IG51bGwsXG4gIHRvcENoYW5nZTogbnVsbCxcbiAgdG9wQ2xpY2s6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiBudWxsLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiBudWxsLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogbnVsbCxcbiAgdG9wQ29udGV4dE1lbnU6IG51bGwsXG4gIHRvcENvcHk6IG51bGwsXG4gIHRvcEN1dDogbnVsbCxcbiAgdG9wRG91YmxlQ2xpY2s6IG51bGwsXG4gIHRvcERyYWc6IG51bGwsXG4gIHRvcERyYWdFbmQ6IG51bGwsXG4gIHRvcERyYWdFbnRlcjogbnVsbCxcbiAgdG9wRHJhZ0V4aXQ6IG51bGwsXG4gIHRvcERyYWdMZWF2ZTogbnVsbCxcbiAgdG9wRHJhZ092ZXI6IG51bGwsXG4gIHRvcERyYWdTdGFydDogbnVsbCxcbiAgdG9wRHJvcDogbnVsbCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IG51bGwsXG4gIHRvcEVtcHRpZWQ6IG51bGwsXG4gIHRvcEVuY3J5cHRlZDogbnVsbCxcbiAgdG9wRW5kZWQ6IG51bGwsXG4gIHRvcEVycm9yOiBudWxsLFxuICB0b3BGb2N1czogbnVsbCxcbiAgdG9wSW5wdXQ6IG51bGwsXG4gIHRvcEtleURvd246IG51bGwsXG4gIHRvcEtleVByZXNzOiBudWxsLFxuICB0b3BLZXlVcDogbnVsbCxcbiAgdG9wTG9hZDogbnVsbCxcbiAgdG9wTG9hZGVkRGF0YTogbnVsbCxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IG51bGwsXG4gIHRvcExvYWRTdGFydDogbnVsbCxcbiAgdG9wTW91c2VEb3duOiBudWxsLFxuICB0b3BNb3VzZU1vdmU6IG51bGwsXG4gIHRvcE1vdXNlT3V0OiBudWxsLFxuICB0b3BNb3VzZU92ZXI6IG51bGwsXG4gIHRvcE1vdXNlVXA6IG51bGwsXG4gIHRvcFBhc3RlOiBudWxsLFxuICB0b3BQYXVzZTogbnVsbCxcbiAgdG9wUGxheTogbnVsbCxcbiAgdG9wUGxheWluZzogbnVsbCxcbiAgdG9wUHJvZ3Jlc3M6IG51bGwsXG4gIHRvcFJhdGVDaGFuZ2U6IG51bGwsXG4gIHRvcFJlc2V0OiBudWxsLFxuICB0b3BTY3JvbGw6IG51bGwsXG4gIHRvcFNlZWtlZDogbnVsbCxcbiAgdG9wU2Vla2luZzogbnVsbCxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BTdGFsbGVkOiBudWxsLFxuICB0b3BTdWJtaXQ6IG51bGwsXG4gIHRvcFN1c3BlbmQ6IG51bGwsXG4gIHRvcFRleHRJbnB1dDogbnVsbCxcbiAgdG9wVGltZVVwZGF0ZTogbnVsbCxcbiAgdG9wVG91Y2hDYW5jZWw6IG51bGwsXG4gIHRvcFRvdWNoRW5kOiBudWxsLFxuICB0b3BUb3VjaE1vdmU6IG51bGwsXG4gIHRvcFRvdWNoU3RhcnQ6IG51bGwsXG4gIHRvcFZvbHVtZUNoYW5nZTogbnVsbCxcbiAgdG9wV2FpdGluZzogbnVsbCxcbiAgdG9wV2hlZWw6IG51bGxcbn0pO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMsXG4gIFByb3BhZ2F0aW9uUGhhc2VzOiBQcm9wYWdhdGlvblBoYXNlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvbnN0YW50cztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRDb25zdGFudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIC0gYEluc3RhbmNlSGFuZGxlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBwZXJmb3JtcyBsb2dpY2FsIHRyYXZlcnNhbHMgb2YgRE9NXG4gKiAgIGhpZXJhcmNoeSBnaXZlbiBpZHMgb2YgdGhlIGxvZ2ljYWwgRE9NIGVsZW1lbnRzIGludm9sdmVkLlxuICovXG52YXIgSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCkge1xuICB2YXIgdmFsaWQgPSBJbnN0YW5jZUhhbmRsZSAmJiBJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZVR3b1BoYXNlICYmIEluc3RhbmNlSGFuZGxlLnRyYXZlcnNlRW50ZXJMZWF2ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodmFsaWQsICdJbnN0YW5jZUhhbmRsZSBub3QgaW5qZWN0ZWQgYmVmb3JlIHVzZSEnKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZE1vdW50XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdE1vdW50OiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZEluc3RhbmNlSGFuZGxlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbiAoSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgSW5zdGFuY2VIYW5kbGUgPSBJbmplY3RlZEluc3RhbmNlSGFuZGxlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEluc3RhbmNlSGFuZGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpZCkge1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nICcgKyAnYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpbkh1Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5SZWdpc3RyeVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgRXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gRXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluICcgKyAndGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAhUGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgJyArICdtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gUGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICsgJ2V2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzIGFuZFxuICogY2FuIGJlIHVzZWQgd2l0aCBgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXJgIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHtcblxuICAvKipcbiAgICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gICAqL1xuICBwbHVnaW5zOiBbXSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gICAqL1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAgICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gICAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogZnVuY3Rpb24gKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAgICEhRXZlbnRQbHVnaW5PcmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gJyArICdvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgICBFdmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogZnVuY3Rpb24gKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IFBsdWdpbk1vZHVsZSkge1xuICAgICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zICcgKyAndXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQSBzeW50aGV0aWMgZXZlbnQuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gZXZlbnQuZGlzcGF0Y2hDb25maWc7XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVdIHx8IG51bGw7XG4gICAgfVxuICAgIGZvciAodmFyIHBoYXNlIGluIGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAoIWRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlXV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW5Nb2R1bGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRFdmVudFBsdWdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAobmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnMubGVuZ3RoID0gMDtcblxuICAgIHZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcykge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgTW91bnRgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgZG9tIElEcyBhbmRcbiAqICAgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIGluamVjdGlvbiA9IHtcbiAgTW91bnQ6IG51bGwsXG4gIGluamVjdE1vdW50OiBmdW5jdGlvbiAoSW5qZWN0ZWRNb3VudCkge1xuICAgIGluamVjdGlvbi5Nb3VudCA9IEluamVjdGVkTW91bnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkTW91bnQgJiYgSW5qZWN0ZWRNb3VudC5nZXROb2RlICYmIEluamVjdGVkTW91bnQuZ2V0SUQsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCguLi4pOiBJbmplY3RlZCBNb3VudCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGUgb3IgZ2V0SUQuJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbmZ1bmN0aW9uIGlzRW5kaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDtcbn1cblxuZnVuY3Rpb24gaXNNb3ZlaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZSB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlO1xufVxuZnVuY3Rpb24gaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24gfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ7XG59XG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBpZHNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJRHMpO1xuICAgIHZhciBJRHNMZW4gPSBpZHNJc0FyciA/IGRpc3BhdGNoSURzLmxlbmd0aCA6IGRpc3BhdGNoSURzID8gMSA6IDA7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGlkc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBJRHNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tSUQgRE9NIGlkIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGRvbUlEKSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBpbmplY3Rpb24uTW91bnQuZ2V0Tm9kZShkb21JRCk7XG4gIGlmIChzaW11bGF0ZWQpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoKHR5cGUsIGxpc3RlbmVyLCBldmVudCwgZG9tSUQpO1xuICB9IGVsc2Uge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sodHlwZSwgbGlzdGVuZXIsIGV2ZW50LCBkb21JRCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaElEc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaElEcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIElEcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJRHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaElEc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSURzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSURzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciByZXMgPSBkaXNwYXRjaExpc3RlbmVyID8gZGlzcGF0Y2hMaXN0ZW5lcihldmVudCwgZGlzcGF0Y2hJRCkgOiBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogR2VuZXJhbCB1dGlsaXRpZXMgdGhhdCBhcmUgdXNlZnVsIGluIGNyZWF0aW5nIGN1c3RvbSBFdmVudCBQbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHtcbiAgaXNFbmRpc2g6IGlzRW5kaXNoLFxuICBpc01vdmVpc2g6IGlzTW92ZWlzaCxcbiAgaXNTdGFydGlzaDogaXNTdGFydGlzaCxcblxuICBleGVjdXRlRGlyZWN0RGlzcGF0Y2g6IGV4ZWN1dGVEaXJlY3REaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWU6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUsXG4gIGhhc0Rpc3BhdGNoZXM6IGhhc0Rpc3BhdGNoZXMsXG5cbiAgZ2V0Tm9kZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGluamVjdGlvbi5Nb3VudC5nZXROb2RlKGlkKTtcbiAgfSxcbiAgZ2V0SUQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGluamVjdGlvbi5Nb3VudC5nZXRJRChub2RlKTtcbiAgfSxcblxuICBpbmplY3Rpb246IGluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblV0aWxzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblV0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVycm9yVXRpbHNcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICpcbiAqIEBwYXJhbSB7P1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGEgRmlyc3QgYXJndW1lbnRcbiAqIEBwYXJhbSB7Kn0gYiBTZWNvbmQgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYyhhLCBiKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgY2F1Z2h0RXJyb3IgPSB4O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHNvIHRoYXQgYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIGV2ZW50XG4gICAqIGhhbmRsZXIgYXJlIHN1cmUgdG8gYmUgcmV0aHJvd24gYnkgcmV0aHJvd0NhdWdodEVycm9yLlxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKipcbiAgICogVG8gaGVscCBkZXZlbG9wbWVudCB3ZSBjYW4gZ2V0IGJldHRlciBkZXZ0b29scyBpbnRlZ3JhdGlvbiBieSBzaW11bGF0aW5nIGFcbiAgICogcmVhbCBicm93c2VyIGV2ZW50LlxuICAgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBhLCBiKSB7XG4gICAgICB2YXIgYm91bmRGdW5jID0gZnVuYy5iaW5kKG51bGwsIGEsIGIpO1xuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIG5hbWU7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVycm9yVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFjY3VtdWxhdGVJbnRvXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICpcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgdmFyIGN1cnJlbnRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjdXJyZW50KTtcbiAgdmFyIG5leHRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXh0KTtcblxuICBpZiAoY3VycmVudElzQXJyYXkgJiYgbmV4dElzQXJyYXkpIHtcbiAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoY3VycmVudElzQXJyYXkpIHtcbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAobmV4dElzQXJyYXkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGVJbnRvO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9yRWFjaEFjY3VtdWxhdGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gZnVuY3Rpb24gKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGVudmlyb25tZW50IGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVmlld3BvcnRNZXRyaWNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmlld3BvcnRNZXRyaWNzID0ge1xuXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24gKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb24ueDtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcCA9IHNjcm9sbFBvc2l0aW9uLnk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1ldHJpY3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgT2JqZWN0LmFzc2lnblxuICovXG5cbi8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QuYXNzaWduXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlcykge1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIHRhcmdldCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIG5leHRJbmRleCA9IDE7IG5leHRJbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IG5leHRJbmRleCsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbbmV4dEluZGV4XTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IE9iamVjdChuZXh0U291cmNlKTtcblxuICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IGFjY2Vzc29ycyBub3IgcHJveGllcy4gVGhlcmVmb3JlIHRoaXNcbiAgICAvLyBjb3B5IGNhbm5vdCB0aHJvdy4gSWYgd2UgZXZlciBzdXBwb3J0ZWQgdGhpcyB0aGVuIHdlIG11c3QgaGFuZGxlXG4gICAgLy8gZXhjZXB0aW9ucyBhbmQgc2lkZS1lZmZlY3RzLiBXZSBkb24ndCBzdXBwb3J0IHN5bWJvbHMgc28gdGhleSB3b24ndFxuICAgIC8vIGJlIHRyYW5zZmVycmVkLlxuXG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9PYmplY3QuYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc0V2ZW50U3VwcG9ydGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IChldmVudE5hbWUgaW4gZG9jdW1lbnQpO1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmVhdHVyZUZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSB7XG4gIHVzZUNyZWF0ZUVsZW1lbnQ6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmVhdHVyZUZsYWdzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgUmVhY3QgZWxlbWVudHMuIFRoaXMgaXMgb25seSB1c2VkIHRvIG1ha2UgdGhpc1xuICogd29yayB3aXRoIGEgZHluYW1pYyBpbnN0YW5jZW9mIGNoZWNrLiBOb3RoaW5nIHNob3VsZCBsaXZlIG9uIHRoaXMgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICByZWYgPSBjb25maWcucmVmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLnJlZjtcbiAgICBrZXkgPSBjb25maWcua2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBjb25maWcua2V5O1xuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzW3Byb3BOYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn07XG5cblJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIGZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gZWFzaWx5IGFjY2Vzc2VkIG9uIGVsZW1lbnRzLiBFLmcuIGA8Rm9vIC8+LnR5cGUgPT09IEZvb2AuXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBuYW1lZCBgY29uc3RydWN0b3JgIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICBmYWN0b3J5LnR5cGUgPSB0eXBlO1xuICByZXR1cm4gZmFjdG9yeTtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3UHJvcHMpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBvbGRFbGVtZW50LmtleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG5ld1Byb3BzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElmIHRoZSBrZXkgb24gdGhlIG9yaWdpbmFsIGlzIHZhbGlkLCB0aGVuIHRoZSBjbG9uZSBpcyB2YWxpZFxuICAgIG5ld0VsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IG9sZEVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZDtcbiAgfVxuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChjb25maWcucmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbkRlZmluZVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIHJlZ2lzdHJ5IGtlZXBzIHRyYWNrIG9mIHRoZSBSZWFjdCBJRHMgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCByZW5kZXJlZCB0b1xuLy8gYG51bGxgIChpbiByZWFsaXR5IGEgcGxhY2Vob2xkZXIgc3VjaCBhcyBgbm9zY3JpcHRgKVxudmFyIG51bGxDb21wb25lbnRJRHNSZWdpc3RyeSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkIHRvIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIHJldHVybiAhIW51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF07XG59XG5cbi8qKlxuICogTWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIG51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF0gPSB0cnVlO1xufVxuXG4vKipcbiAqIFVubWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsOiBpdCByZW5kZXJzIHRvIHNvbWV0aGluZyBub3cuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqL1xuZnVuY3Rpb24gZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRChpZCkge1xuICBkZWxldGUgbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5W2lkXTtcbn1cblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHtcbiAgaXNOdWxsQ29tcG9uZW50SUQ6IGlzTnVsbENvbXBvbmVudElELFxuICByZWdpc3Rlck51bGxDb21wb25lbnRJRDogcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQsXG4gIGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQ6IGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SURcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5zdGFuY2VIYW5kbGVzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZSgnLi9SZWFjdFJvb3RJbmRleCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU0VQQVJBVE9SX0xFTkdUSCA9IFNFUEFSQVRPUi5sZW5ndGg7XG5cbi8qKlxuICogTWF4aW11bSBkZXB0aCBvZiB0cmF2ZXJzYWxzIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgcG9zc2liaWxpdHkgb2YgYSBiYWQgSUQuXG4gKi9cbnZhciBNQVhfVFJFRV9ERVBUSCA9IDEwMDAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBET00gSUQgcHJlZml4IHRvIHVzZSB3aGVuIG1vdW50aW5nIFJlYWN0IGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEEgdW5pcXVlIGludGVnZXJcbiAqIEByZXR1cm4ge3N0cmluZ30gUmVhY3Qgcm9vdCBJRC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RJRFN0cmluZyhpbmRleCkge1xuICByZXR1cm4gU0VQQVJBVE9SICsgaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNoYXJhY3RlciBpbiB0aGUgc3VwcGxpZWQgSUQgaXMgYSBzZXBhcmF0b3Igb3IgdGhlIGVuZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdCBET00gSUQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGNoYXJhY3RlciB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNoYXJhY3RlciBpcyBhIHNlcGFyYXRvciBvciBlbmQgb2YgdGhlIElELlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCb3VuZGFyeShpZCwgaW5kZXgpIHtcbiAgcmV0dXJuIGlkLmNoYXJBdChpbmRleCkgPT09IFNFUEFSQVRPUiB8fCBpbmRleCA9PT0gaWQubGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc3VwcGxpZWQgc3RyaW5nIGlzIGEgdmFsaWQgUmVhY3QgRE9NIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0IERPTSBJRCwgbWF5YmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBSZWFjdCBET00gSUQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSUQoaWQpIHtcbiAgcmV0dXJuIGlkID09PSAnJyB8fCBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiAmJiBpZC5jaGFyQXQoaWQubGVuZ3RoIC0gMSkgIT09IFNFUEFSQVRPUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGZpcnN0IElEIGlzIGFuIGFuY2VzdG9yIG9mIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQgSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFuY2VzdG9ySURcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjZW5kYW50SURcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYGFuY2VzdG9ySURgIGlzIGFuIGFuY2VzdG9yIG9mIGBkZXNjZW5kYW50SURgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzQW5jZXN0b3JJRE9mKGFuY2VzdG9ySUQsIGRlc2NlbmRhbnRJRCkge1xuICByZXR1cm4gZGVzY2VuZGFudElELmluZGV4T2YoYW5jZXN0b3JJRCkgPT09IDAgJiYgaXNCb3VuZGFyeShkZXNjZW5kYW50SUQsIGFuY2VzdG9ySUQubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgSUQgb2YgdGhlIHN1cHBsaWVkIFJlYWN0IERPTSBJRCwgYGlkYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBwYXJlbnQsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudElEKGlkKSB7XG4gIHJldHVybiBpZCA/IGlkLnN1YnN0cigwLCBpZC5sYXN0SW5kZXhPZihTRVBBUkFUT1IpKSA6ICcnO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5leHQgRE9NIElEIG9uIHRoZSB0cmVlIHBhdGggZnJvbSB0aGUgc3VwcGxpZWQgYGFuY2VzdG9ySURgIHRvIHRoZVxuICogc3VwcGxpZWQgYGRlc3RpbmF0aW9uSURgLiBJZiB0aGV5IGFyZSBlcXVhbCwgdGhlIElEIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvcklEIElEIG9mIGFuIGFuY2VzdG9yIG5vZGUgb2YgYGRlc3RpbmF0aW9uSURgLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uSUQgSUQgb2YgdGhlIGRlc3RpbmF0aW9uIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5leHQgSUQgb24gdGhlIHBhdGggZnJvbSBgYW5jZXN0b3JJRGAgdG8gYGRlc3RpbmF0aW9uSURgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dERlc2NlbmRhbnRJRChhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSB7XG4gICEoaXNWYWxpZElEKGFuY2VzdG9ySUQpICYmIGlzVmFsaWRJRChkZXN0aW5hdGlvbklEKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0TmV4dERlc2NlbmRhbnRJRCglcywgJXMpOiBSZWNlaXZlZCBhbiBpbnZhbGlkIFJlYWN0IERPTSBJRC4nLCBhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICFpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROZXh0RGVzY2VuZGFudElEKC4uLik6IFJlYWN0IGhhcyBtYWRlIGFuIGludmFsaWQgYXNzdW1wdGlvbiBhYm91dCAnICsgJ3RoZSBET00gaGllcmFyY2h5LiBFeHBlY3RlZCBgJXNgIHRvIGJlIGFuIGFuY2VzdG9yIG9mIGAlc2AuJywgYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoYW5jZXN0b3JJRCA9PT0gZGVzdGluYXRpb25JRCkge1xuICAgIHJldHVybiBhbmNlc3RvcklEO1xuICB9XG4gIC8vIFNraXAgb3ZlciB0aGUgYW5jZXN0b3IgYW5kIHRoZSBpbW1lZGlhdGUgc2VwYXJhdG9yLiBUcmF2ZXJzZSB1bnRpbCB3ZSBoaXRcbiAgLy8gYW5vdGhlciBzZXBhcmF0b3Igb3Igd2UgcmVhY2ggdGhlIGVuZCBvZiBgZGVzdGluYXRpb25JRGAuXG4gIHZhciBzdGFydCA9IGFuY2VzdG9ySUQubGVuZ3RoICsgU0VQQVJBVE9SX0xFTkdUSDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgZGVzdGluYXRpb25JRC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KGRlc3RpbmF0aW9uSUQsIGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uSUQuc3Vic3RyKDAsIGkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIG9mIHR3byBJRHMuXG4gKlxuICogVXNpbmcgdGhpcyBJRCBzY2hlbWUsIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCBpcyB0aGUgbG9uZ2VzdCBjb21tb25cbiAqIHByZWZpeCBvZiB0aGUgdHdvIElEcyB0aGF0IGltbWVkaWF0ZWx5IHByZWNlZGVkIGEgXCJtYXJrZXJcIiBpbiBib3RoIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9uZUlEXG4gKiBAcGFyYW0ge3N0cmluZ30gdHdvSURcbiAqIEByZXR1cm4ge3N0cmluZ30gTmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQsIG9yIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm9uZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChvbmVJRCwgdHdvSUQpIHtcbiAgdmFyIG1pbkxlbmd0aCA9IE1hdGgubWluKG9uZUlELmxlbmd0aCwgdHdvSUQubGVuZ3RoKTtcbiAgaWYgKG1pbkxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICB2YXIgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gMDtcbiAgLy8gVXNlIGA8PWAgdG8gdHJhdmVyc2UgdW50aWwgdGhlIFwiRU9MXCIgb2YgdGhlIHNob3J0ZXIgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8PSBtaW5MZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KG9uZUlELCBpKSAmJiBpc0JvdW5kYXJ5KHR3b0lELCBpKSkge1xuICAgICAgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gaTtcbiAgICB9IGVsc2UgaWYgKG9uZUlELmNoYXJBdChpKSAhPT0gdHdvSUQuY2hhckF0KGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGxvbmdlc3RDb21tb25JRCA9IG9uZUlELnN1YnN0cigwLCBsYXN0Q29tbW9uTWFya2VySW5kZXgpO1xuICAhaXNWYWxpZElEKGxvbmdlc3RDb21tb25JRCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKCVzLCAlcyk6IEV4cGVjdGVkIGEgdmFsaWQgUmVhY3QgRE9NIElEOiAlcycsIG9uZUlELCB0d29JRCwgbG9uZ2VzdENvbW1vbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBsb25nZXN0Q29tbW9uSUQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBwYXJlbnQgcGF0aCBiZXR3ZWVuIHR3byBJRHMgKGVpdGhlciB1cCBvciBkb3duKS4gVGhlIElEcyBtdXN0XG4gKiBub3QgYmUgdGhlIHNhbWUsIGFuZCB0aGVyZSBtdXN0IGV4aXN0IGEgcGFyZW50IHBhdGggYmV0d2VlbiB0aGVtLiBJZiB0aGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgdHJhdmVyc2FsIGlzIHN0b3BwZWQuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBzdGFydCBJRCBhdCB3aGljaCB0byBzdGFydCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9zdHJpbmd9IHN0b3AgSUQgYXQgd2hpY2ggdG8gZW5kIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBlYWNoIElEIHdpdGguXG4gKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gKiBAcGFyYW0gez9ib29sZWFufSBza2lwRmlyc3QgV2hldGhlciBvciBub3QgdG8gc2tpcCB0aGUgZmlyc3Qgbm9kZS5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNraXBMYXN0IFdoZXRoZXIgb3Igbm90IHRvIHNraXAgdGhlIGxhc3Qgbm9kZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlUGFyZW50UGF0aChzdGFydCwgc3RvcCwgY2IsIGFyZywgc2tpcEZpcnN0LCBza2lwTGFzdCkge1xuICBzdGFydCA9IHN0YXJ0IHx8ICcnO1xuICBzdG9wID0gc3RvcCB8fCAnJztcbiAgIShzdGFydCAhPT0gc3RvcCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKC4uLik6IENhbm5vdCB0cmF2ZXJzZSBmcm9tIGFuZCB0byB0aGUgc2FtZSBJRCwgYCVzYC4nLCBzdGFydCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgdHJhdmVyc2VVcCA9IGlzQW5jZXN0b3JJRE9mKHN0b3AsIHN0YXJ0KTtcbiAgISh0cmF2ZXJzZVVwIHx8IGlzQW5jZXN0b3JJRE9mKHN0YXJ0LCBzdG9wKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKCVzLCAlcywgLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gdHdvIElEcyB0aGF0IGRvICcgKyAnbm90IGhhdmUgYSBwYXJlbnQgcGF0aC4nLCBzdGFydCwgc3RvcCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAvLyBUcmF2ZXJzZSBmcm9tIGBzdGFydGAgdG8gYHN0b3BgIG9uZSBkZXB0aCBhdCBhIHRpbWUuXG4gIHZhciBkZXB0aCA9IDA7XG4gIHZhciB0cmF2ZXJzZSA9IHRyYXZlcnNlVXAgPyBnZXRQYXJlbnRJRCA6IGdldE5leHREZXNjZW5kYW50SUQ7XG4gIGZvciAodmFyIGlkID0gc3RhcnQ7OyAvKiB1bnRpbCBicmVhayAqL2lkID0gdHJhdmVyc2UoaWQsIHN0b3ApKSB7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoKCFza2lwRmlyc3QgfHwgaWQgIT09IHN0YXJ0KSAmJiAoIXNraXBMYXN0IHx8IGlkICE9PSBzdG9wKSkge1xuICAgICAgcmV0ID0gY2IoaWQsIHRyYXZlcnNlVXAsIGFyZyk7XG4gICAgfVxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IGlkID09PSBzdG9wKSB7XG4gICAgICAvLyBPbmx5IGJyZWFrIC8vYWZ0ZXIvLyB2aXNpdGluZyBgc3RvcGAuXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgIShkZXB0aCsrIDwgTUFYX1RSRUVfREVQVEgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXZlcnNlUGFyZW50UGF0aCglcywgJXMsIC4uLik6IERldGVjdGVkIGFuIGluZmluaXRlIGxvb3Agd2hpbGUgJyArICd0cmF2ZXJzaW5nIHRoZSBSZWFjdCBET00gSUQgdHJlZS4gVGhpcyBtYXkgYmUgZHVlIHRvIG1hbGZvcm1lZCBJRHM6ICVzJywgc3RhcnQsIHN0b3AsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBJRHMgYXNzaWduZWQgdG8gRE9NIHJlcHJlc2VudGF0aW9ucyBvZiBSZWFjdCBjb21wb25lbnRzLiBUaGlzXG4gKiB1c2VzIGEgc3BlY2lmaWMgc2NoZW1lIGluIG9yZGVyIHRvIHRyYXZlcnNlIHRoZSBET00gZWZmaWNpZW50bHkgKGUuZy4gaW5cbiAqIG9yZGVyIHRvIHNpbXVsYXRlIGV2ZW50cykuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIFJlYWN0IHJvb3QgSURcbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IHJvb3QgSUQuXG4gICAqL1xuICBjcmVhdGVSZWFjdFJvb3RJRDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRSZWFjdFJvb3RJRFN0cmluZyhSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIFJlYWN0IElEIGJ5IGpvaW5pbmcgYSByb290IElEIHdpdGggYSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIFJvb3QgSUQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIGNvbXBvbmVudCdzIG5hbWUgKGFzIGZsYXR0ZW5lZCBjaGlsZHJlbikuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWFjdCBJRC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBjcmVhdGVSZWFjdElEOiBmdW5jdGlvbiAocm9vdElELCBuYW1lKSB7XG4gICAgcmV0dXJuIHJvb3RJRCArIG5hbWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIERPTSBJRCBvZiB0aGUgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgdGhlIHJvb3Qgb2YgdGhlIHRyZWUgdGhhdFxuICAgKiBjb250YWlucyB0aGUgUmVhY3QgY29tcG9uZW50IHdpdGggdGhlIHN1cHBsaWVkIERPTSBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIERPTSBJRCBvZiBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7P3N0cmluZ30gRE9NIElEIG9mIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB0aGUgcm9vdC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIGlmIChpZCAmJiBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiAmJiBpZC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKFNFUEFSQVRPUiwgMSk7XG4gICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGlkLnN1YnN0cigwLCBpbmRleCkgOiBpZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICAgKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gICAqXG4gICAqIE5PVEU6IERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2VcbiAgICogbm90aGluZyBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZWF2ZUlEIElEIGJlaW5nIGxlZnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRlcklEIElEIGJlaW5nIGVudGVyZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBlYWNoIGVudGVyZWQvbGVmdCBJRC5cbiAgICogQHBhcmFtIHsqfSB1cEFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gbGVmdCBJRHMuXG4gICAqIEBwYXJhbSB7Kn0gZG93bkFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gZW50ZXJlZCBJRHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbiAobGVhdmVJRCwgZW50ZXJJRCwgY2IsIHVwQXJnLCBkb3duQXJnKSB7XG4gICAgdmFyIGFuY2VzdG9ySUQgPSBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQobGVhdmVJRCwgZW50ZXJJRCk7XG4gICAgaWYgKGFuY2VzdG9ySUQgIT09IGxlYXZlSUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aChsZWF2ZUlELCBhbmNlc3RvcklELCBjYiwgdXBBcmcsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGFuY2VzdG9ySUQgIT09IGVudGVySUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aChhbmNlc3RvcklELCBlbnRlcklELCBjYiwgZG93bkFyZywgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIHRyYXZlcnNhbCBoYXBwZW5zIG9uIElEcyB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXRJRCwgY2IsIGFyZykge1xuICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKHRhcmdldElELCAnJywgY2IsIGFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgdHJhdmVyc2VUd29QaGFzZWAgYnV0IHNraXBzIHRoZSBgdGFyZ2V0SURgLlxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZVNraXBUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRJRCwgY2IsIGFyZykge1xuICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgodGFyZ2V0SUQsICcnLCBjYiwgYXJnLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlIGEgbm9kZSBJRCwgY2FsbGluZyB0aGUgc3VwcGxpZWQgYGNiYCBmb3IgZWFjaCBhbmNlc3RvciBJRC4gRm9yXG4gICAqIGV4YW1wbGUsIHBhc3NpbmcgYC4wLiRyb3ctMC4xYCB3b3VsZCByZXN1bHQgaW4gYGNiYCBnZXR0aW5nIGNhbGxlZFxuICAgKiB3aXRoIGAuMGAsIGAuMC4kcm93LTBgLCBhbmQgYC4wLiRyb3ctMC4xYC5cbiAgICpcbiAgICogTk9URTogVGhpcyB0cmF2ZXJzYWwgaGFwcGVucyBvbiBJRHMgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgZmFsc2UpO1xuICB9LFxuXG4gIGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRDogZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklELFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TmV4dERlc2NlbmRhbnRJRDogZ2V0TmV4dERlc2NlbmRhbnRJRCxcblxuICBpc0FuY2VzdG9ySURPZjogaXNBbmNlc3RvcklET2YsXG5cbiAgU0VQQVJBVE9SOiBTRVBBUkFUT1JcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlSGFuZGxlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZUhhbmRsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4XG4gICAqL1xuICBpbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKF9jcmVhdGVSZWFjdFJvb3RJbmRleCkge1xuICAgIFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4ID0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4O1xuICB9XG59O1xuXG52YXIgUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBudWxsLFxuICBpbmplY3Rpb246IFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Um9vdEluZGV4O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJvb3RJbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZU1hcFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqL1xuXG4vLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBFUzY6IHZhciBSZWFjdEluc3RhbmNlTWFwID0gbmV3IE1hcCgpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gICAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XG4gICAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHZhbHVlO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnN0YW5jZU1hcDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNYXJrdXBDaGVja3N1bVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcblxudmFyIFRBR19FTkQgPSAvXFwvPz4vO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgY2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG5cbiAgICAvLyBBZGQgY2hlY2tzdW0gKGhhbmRsZSBib3RoIHBhcmVudCB0YWdzIGFuZCBzZWxmLWNsb3NpbmcgdGFncylcbiAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoVEFHX0VORCwgJyAnICsgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUgKyAnPVwiJyArIGNoZWNrc3VtICsgJ1wiJCYnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXBDaGVja3N1bSA9PT0gZXhpc3RpbmdDaGVja3N1bTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTU9EID0gNjU1MjE7XG5cbi8vIGFkbGVyMzIgaXMgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZywgYW5kIGlzIG9ubHkgdXNlZCB0byBzYW5pdHkgY2hlY2sgdGhhdFxuLy8gbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIG1hdGNoZXMgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIGNsaWVudC5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gKGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgU2hlZXRKUyB2ZXJzaW9uKSBoYXMgYmVlbiBvcHRpbWl6ZWRcbi8vIGZvciBvdXIgdXNlIGNhc2UsIGF0IHRoZSBleHBlbnNlIG9mIGNvbmZvcm1pbmcgdG8gdGhlIGFkbGVyMzIgc3BlY2lmaWNhdGlvblxuLy8gZm9yIG5vbi1hc2NpaSBpbnB1dHMuXG5mdW5jdGlvbiBhZGxlcjMyKGRhdGEpIHtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcbiAgdmFyIG0gPSBsICYgfjB4MztcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgZm9yICg7IGkgPCBNYXRoLm1pbihpICsgNDA5NiwgbSk7IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvYWRsZXIzMi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNhbGwgUmVhY3RSZWYuYXR0YWNoUmVmcyB3aXRoIHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCwgc3BsaXQgb3V0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFJlZnMoKSB7XG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtYXJrdXAgPSBpbnRlcm5hbEluc3RhbmNlLm1vdW50Q29tcG9uZW50KHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGEgY29tcG9uZW50IHVzaW5nIGEgbmV3IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG5cbiAgICBpZiAobmV4dEVsZW1lbnQgPT09IHByZXZFbGVtZW50ICYmIGNvbnRleHQgPT09IGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIHtcbiAgICAgIC8vIFNpbmNlIGVsZW1lbnRzIGFyZSBpbW11dGFibGUgYWZ0ZXIgdGhlIG93bmVyIGlzIHJlbmRlcmVkLFxuICAgICAgLy8gd2UgY2FuIGRvIGEgY2hlYXAgaWRlbnRpdHkgY29tcGFyZSBoZXJlIHRvIGRldGVybWluZSBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIHN1cGVyZmx1b3VzIHJlY29uY2lsZS4gSXQncyBwb3NzaWJsZSBmb3Igc3RhdGUgdG8gYmUgbXV0YWJsZSBidXQgc3VjaFxuICAgICAgLy8gY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiB0aGUgb3duZXIgd2hpY2ggd291bGQgcmVjcmVhdGVcbiAgICAgIC8vIHRoZSBlbGVtZW50LiBXZSBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIG93bmVyIHNpbmNlXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciBhbiBlbGVtZW50IGNyZWF0ZWQgb3V0c2lkZSBhIGNvbXBvc2l0ZSB0byBiZVxuICAgICAgLy8gZGVlcGx5IG11dGF0ZWQgYW5kIHJldXNlZC5cblxuICAgICAgLy8gVE9ETzogQmFpbGluZyBvdXQgZWFybHkgaXMganVzdCBhIHBlcmYgb3B0aW1pemF0aW9uIHJpZ2h0P1xuICAgICAgLy8gVE9ETzogUmVtb3ZpbmcgdGhlIHJldHVybiBzdGF0ZW1lbnQgc2hvdWxkIGFmZmVjdCBjb3JyZWN0bmVzcz9cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVmc0NoYW5nZWQgPSBSZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQpIHtcbiAgICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgcHJldkVsZW1lbnQpO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uKSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24pO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVmXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGF0dGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cblJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMgPSBmdW5jdGlvbiAocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIC8vIElmIGVpdGhlciB0aGUgb3duZXIgb3IgYSBgcmVmYCBoYXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRoZSBuZXdlc3Qgb3duZXJcbiAgLy8gaGFzIHN0b3JlZCBhIHJlZmVyZW5jZSB0byBgdGhpc2AsIGFuZCB0aGUgcHJldmlvdXMgb3duZXIgKGlmIGRpZmZlcmVudClcbiAgLy8gaGFzIGZvcmdvdHRlbiB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYC4gV2UgdXNlIHRoZSBlbGVtZW50IGluc3RlYWRcbiAgLy8gb2YgdGhlIHB1YmxpYyB0aGlzLnByb3BzIGJlY2F1c2UgdGhlIHBvc3QgcHJvY2Vzc2luZyBjYW5ub3QgZGV0ZXJtaW5lXG4gIC8vIGEgcmVmLiBUaGUgcmVmIGNvbmNlcHR1YWxseSBsaXZlcyBvbiB0aGUgZWxlbWVudC5cblxuICAvLyBUT0RPOiBTaG91bGQgdGhpcyBldmVuIGJlIHBvc3NpYmxlPyBUaGUgb3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlXG4gIC8vIGl0J3MgZm9yYmlkZGVuIGJ5IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LiBUaGUgcmVmIGNhbiBjaGFuZ2VcbiAgLy8gaWYgeW91IHN3YXAgdGhlIGtleXMgb2YgYnV0IG5vdCB0aGUgcmVmcy4gUmVjb25zaWRlciB3aGVyZSB0aGlzIGNoZWNrXG4gIC8vIGlzIG1hZGUuIEl0IHByb2JhYmx5IGJlbG9uZ3Mgd2hlcmUgdGhlIGtleSBjaGVja2luZyBhbmRcbiAgLy8gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCBpcyBkb25lLlxuXG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG5cbiAgcmV0dXJuKFxuICAgIC8vIFRoaXMgaGFzIGEgZmV3IGZhbHNlIHBvc2l0aXZlcyB3L3IvdCBlbXB0eSBjb21wb25lbnRzLlxuICAgIHByZXZFbXB0eSB8fCBuZXh0RW1wdHkgfHwgbmV4dEVsZW1lbnQuX293bmVyICE9PSBwcmV2RWxlbWVudC5fb3duZXIgfHwgbmV4dEVsZW1lbnQucmVmICE9PSBwcmV2RWxlbWVudC5yZWZcbiAgKTtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzVmFsaWRPd25lcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0ICcgKyAnYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCAnICsgJ2JlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAvLyBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJyVzKC4uLik6IENhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gJyArICcoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlLicsIGNhbGxlck5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGludGVybmFsSW5zdGFuY2U7XG59XG5cbi8qKlxuICogUmVhY3RVcGRhdGVRdWV1ZSBhbGxvd3MgZm9yIHN0YXRlIHVwZGF0ZXMgdG8gYmUgc2NoZWR1bGVkIGludG8gYSBsYXRlclxuICogcmVjb25jaWxpYXRpb24gc3RlcC5cbiAqL1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSB7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgLy8gRHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyIHRoaXMgd2lsbCBzdGlsbCBiZSBudWxsIGJ1dCBhZnRlclxuICAgICAgLy8gdGhhdCB3aWxsIGFsd2F5cyByZW5kZXIgdG8gc29tZXRoaW5nLiBBdCBsZWFzdCBmb3Igbm93LiBTbyB3ZSBjYW4gdXNlXG4gICAgICAvLyB0aGlzIGhhY2suXG4gICAgICByZXR1cm4gISFpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2VucXVldWVDYWxsYmFjayguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICsgJ2BzZXRTdGF0ZWAsIGByZXBsYWNlU3RhdGVgLCBvciBgZm9yY2VVcGRhdGVgIHdpdGggYSBjYWxsYmFjayB0aGF0ICcgKyAnaXNuXFwndCBjYWxsYWJsZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICEodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdlbnF1ZXVlQ2FsbGJhY2soLi4uKTogWW91IGNhbGxlZCBgc2V0UHJvcHNgLCBgcmVwbGFjZVByb3BzYCwgJyArICdgc2V0U3RhdGVgLCBgcmVwbGFjZVN0YXRlYCwgb3IgYGZvcmNlVXBkYXRlYCB3aXRoIGEgY2FsbGJhY2sgdGhhdCAnICsgJ2lzblxcJ3QgY2FsbGFibGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSB8fCAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbXSk7XG4gICAgcXVldWUucHVzaChwYXJ0aWFsU3RhdGUpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0UHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFByb3BzKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRQcm9wcycpO1xuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRQcm9wc0ludGVybmFsKGludGVybmFsSW5zdGFuY2UsIHBhcnRpYWxQcm9wcyk7XG4gIH0sXG5cbiAgZW5xdWV1ZVNldFByb3BzSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB2YXIgdG9wTGV2ZWxXcmFwcGVyID0gaW50ZXJuYWxJbnN0YW5jZS5fdG9wTGV2ZWxXcmFwcGVyO1xuICAgICF0b3BMZXZlbFdyYXBwZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0UHJvcHMoLi4uKTogWW91IGNhbGxlZCBgc2V0UHJvcHNgIG9uIGEgJyArICdjb21wb25lbnQgd2l0aCBhIHBhcmVudC4gVGhpcyBpcyBhbiBhbnRpLXBhdHRlcm4gc2luY2UgcHJvcHMgd2lsbCAnICsgJ2dldCByZWFjdGl2ZWx5IHVwZGF0ZWQgd2hlbiByZW5kZXJlZC4gSW5zdGVhZCwgY2hhbmdlIHRoZSBvd25lclxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QgdG8gcGFzcyB0aGUgY29ycmVjdCB2YWx1ZSBhcyBwcm9wcyB0byB0aGUgY29tcG9uZW50ICcgKyAnd2hlcmUgaXQgaXMgY3JlYXRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBNZXJnZSB3aXRoIHRoZSBwZW5kaW5nIGVsZW1lbnQgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2Ugd2l0aCBleGlzdGluZ1xuICAgIC8vIGVsZW1lbnQgcHJvcHMuXG4gICAgdmFyIHdyYXBFbGVtZW50ID0gdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCB8fCB0b3BMZXZlbFdyYXBwZXIuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBlbGVtZW50ID0gd3JhcEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzLCBwYXJ0aWFsUHJvcHMpO1xuICAgIHRvcExldmVsV3JhcHBlci5fcGVuZGluZ0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMod3JhcEVsZW1lbnQsIFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyhlbGVtZW50LCBwcm9wcykpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZSh0b3BMZXZlbFdyYXBwZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIE5ldyBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVByb3BzOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHByb3BzKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlUHJvcHMnKTtcbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVByb3BzSW50ZXJuYWwoaW50ZXJuYWxJbnN0YW5jZSwgcHJvcHMpO1xuICB9LFxuXG4gIGVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHByb3BzKSB7XG4gICAgdmFyIHRvcExldmVsV3JhcHBlciA9IGludGVybmFsSW5zdGFuY2UuX3RvcExldmVsV3JhcHBlcjtcbiAgICAhdG9wTGV2ZWxXcmFwcGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlcGxhY2VQcm9wcyguLi4pOiBZb3UgY2FsbGVkIGByZXBsYWNlUHJvcHNgIG9uIGEgJyArICdjb21wb25lbnQgd2l0aCBhIHBhcmVudC4gVGhpcyBpcyBhbiBhbnRpLXBhdHRlcm4gc2luY2UgcHJvcHMgd2lsbCAnICsgJ2dldCByZWFjdGl2ZWx5IHVwZGF0ZWQgd2hlbiByZW5kZXJlZC4gSW5zdGVhZCwgY2hhbmdlIHRoZSBvd25lclxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QgdG8gcGFzcyB0aGUgY29ycmVjdCB2YWx1ZSBhcyBwcm9wcyB0byB0aGUgY29tcG9uZW50ICcgKyAnd2hlcmUgaXQgaXMgY3JlYXRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBNZXJnZSB3aXRoIHRoZSBwZW5kaW5nIGVsZW1lbnQgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2Ugd2l0aCBleGlzdGluZ1xuICAgIC8vIGVsZW1lbnQgcHJvcHMuXG4gICAgdmFyIHdyYXBFbGVtZW50ID0gdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCB8fCB0b3BMZXZlbFdyYXBwZXIuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBlbGVtZW50ID0gd3JhcEVsZW1lbnQucHJvcHM7XG4gICAgdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyh3cmFwRWxlbWVudCwgUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKGVsZW1lbnQsIHByb3BzKSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKHRvcExldmVsV3JhcHBlcik7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5ld0VsZW1lbnQpIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5ld0VsZW1lbnQ7XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGRpcnR5Q29tcG9uZW50cyA9IFtdO1xudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyAnICsgJ3N0cmF0ZWd5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCAvKiBmb3JjZUhUTUwgKi9mYWxzZSk7XG59XG5cbmFzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5NaXhpbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XG59XG5cbi8qKlxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudE9yZGVyIC0gYzIuX21vdW50T3JkZXI7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gJyArICdtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpdCB3aWxsIHN0aWxsXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcblxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxuICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XG4gICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXG4gIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAvLyBjb21wb25lbnREaWRVcGRhdGUpIGJ1dCB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUgdG9vIGluIG9yZGVyIHRvIGNhdGNoXG4gIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCBhc2FwIGNhbGxzLlxuICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCB8fCBhc2FwRW5xdWV1ZWQpIHtcbiAgICBpZiAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xuICAgICAgYXNhcEVucXVldWVkID0gZmFsc2U7XG4gICAgICB2YXIgcXVldWUgPSBhc2FwQ2FsbGJhY2tRdWV1ZTtcbiAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgICAgIHF1ZXVlLm5vdGlmeUFsbCgpO1xuICAgICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbn07XG5mbHVzaEJhdGNoZWRVcGRhdGVzID0gUmVhY3RQZXJmLm1lYXN1cmUoJ1JlYWN0VXBkYXRlcycsICdmbHVzaEJhdGNoZWRVcGRhdGVzJywgZmx1c2hCYXRjaGVkVXBkYXRlcyk7XG5cbi8qKlxuICogTWFyayBhIGNvbXBvbmVudCBhcyBuZWVkaW5nIGEgcmVyZW5kZXIsIGFkZGluZyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBhXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShjb21wb25lbnQpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcblxuICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFRoaXMgaXMgY2FsbGVkIGJ5IGVhY2ggdG9wLWxldmVsIHVwZGF0ZVxuICAvLyBmdW5jdGlvbiwgbGlrZSBzZXRQcm9wcywgc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcblxuICBpZiAoIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGVucXVldWVVcGRhdGUsIGNvbXBvbmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdG8gYmUgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmF0Y2hpbmcgY3ljbGUuIFRocm93c1xuICogaWYgbm8gdXBkYXRlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBlcmZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgY29udGV4dCkge1xuICAhYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJlJyArICd1cGRhdGVzIGFyZSBub3QgYmVpbmcgYmF0Y2hlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGFzYXBDYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xufVxuXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XG4gICAgIVJlY29uY2lsZVRyYW5zYWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XG4gICAgIV9iYXRjaGluZ1N0cmF0ZWd5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hlZFVwZGF0ZXMoKSBmdW5jdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5ID0gX2JhdGNoaW5nU3RyYXRlZ3k7XG4gIH1cbn07XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSB7XG4gIC8qKlxuICAgKiBSZWFjdCByZWZlcmVuY2VzIGBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uYCB1c2luZyB0aGlzIHByb3BlcnR5IGluIG9yZGVyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXG5cbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxuICBmbHVzaEJhdGNoZWRVcGRhdGVzOiBmbHVzaEJhdGNoZWRVcGRhdGVzLFxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvbixcbiAgYXNhcDogYXNhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2FsbGJhY2tRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIENhbGxiYWNrUXVldWUoKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbn1cblxuYXNzaWduKENhbGxiYWNrUXVldWUucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgQ29udGV4dCB0byBjYWxsIGBjYWxsYmFja2Agd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAhKGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzbWF0Y2hlZCBsaXN0IG9mIGNvbnRleHRzIGluIGNhbGxiYWNrIHF1ZXVlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKGNvbnRleHRzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcyAob3B0aW9uYWwpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvcHlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXG4gKi9cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiAoQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogYFRyYW5zYWN0aW9uYCBjcmVhdGVzIGEgYmxhY2sgYm94IHRoYXQgaXMgYWJsZSB0byB3cmFwIGFueSBtZXRob2Qgc3VjaCB0aGF0XG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxuICogaW5zdGFudGlhdGVzIGEgdHJhbnNhY3Rpb24gY2FuIHByb3ZpZGUgZW5mb3JjZXJzIG9mIHRoZSBpbnZhcmlhbnRzIGF0XG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAqIHNob3VsZCBub3QgYmUgcnVuIHdoaWxlIGl0IGlzIGFscmVhZHkgYmVpbmcgcnVuLiBZb3Ugd291bGQgdHlwaWNhbGx5IGNyZWF0ZSBhXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cbiAqIHRoZXkgb25seSByZXF1aXJlIGltcGxlbWVudGluZyB0d28gbWV0aG9kcy5cbiAqXG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJzIChpbmplY3RlZCBhdCBjcmVhdGlvbiB0aW1lKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICstLXwgICAgd3JhcHBlcjEgICB8LS0tfC0tLS0rICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICstLS0tfCAgIHdyYXBwZXIyICB8LS0tLS0tLS0rICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICB2ICAgICB2ICAgfCB3cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0+fC18LS0tfC18LS0tfC0tPnxhbnlNZXRob2R8LS0tfC0tLXwtfC0tLXwtfC0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogPC9wcmU+XG4gKlxuICogVXNlIGNhc2VzOlxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICogLSBEZWFjdGl2YXRpbmcgZXZlbnRzIHdoaWxlIHJlYXJyYW5naW5nIHRoZSBET00sIHByZXZlbnRpbmcgYmx1cnMvZm9jdXNlcyxcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxuICogICByZWNvbmNpbGlhdGlvbiB0YWtlcyBwbGFjZSBpbiBhIHdvcmtlciB0aHJlYWQuXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcbiAqICAgY29udGVudC5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IFdyYXBwaW5nIHBhcnRpY3VsYXIgZmx1c2hlcyBvZiB0aGUgYFJlYWN0V29ya2VyYCBxdWV1ZVxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIE1peGluID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxuICAgKiB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGMgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGYgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cbiAgICovXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlICcgKyAnaXMgYWxyZWFkeSBhbiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxuICAgICAgICAvLyBPQlNFUlZFRF9FUlJPUiBzdGF0ZSBiZWZvcmUgb3ZlcndyaXRpbmcgaXQgd2l0aCB0aGUgcmVhbCByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SO1xuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XG4gICAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBpZiAoaW5pdERhdGEgIT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SICYmIHdyYXBwZXIuY2xvc2UpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBUaGUgY2xvc2VyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGNsb3NlIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgfVxufTtcblxudmFyIFRyYW5zYWN0aW9uID0ge1xuXG4gIE1peGluOiBNaXhpbixcblxuICAvKipcbiAgICogVG9rZW4gdG8gbG9vayBmb3IgdG8gZGV0ZXJtaW5lIGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eU9iamVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjb250YWluc05vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICpcbiAqIEBwYXJhbSB7P0RPTU5vZGV9IG91dGVyTm9kZSBPdXRlciBET00gbm9kZS5cbiAqIEBwYXJhbSB7P0RPTU5vZGV9IGlubmVyTm9kZSBJbm5lciBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG91dGVyTm9kZWAgY29udGFpbnMgb3IgaXMgYGlubmVyTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShfeCwgX3gyKSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIHZhciBvdXRlck5vZGUgPSBfeCxcbiAgICAgICAgaW5uZXJOb2RlID0gX3gyO1xuICAgIF9hZ2FpbiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICAgIF94ID0gb3V0ZXJOb2RlO1xuICAgICAgX3gyID0gaW5uZXJOb2RlLnBhcmVudE5vZGU7XG4gICAgICBfYWdhaW4gPSB0cnVlO1xuICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbnRhaW5zKSB7XG4gICAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gICAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzVGV4dE5vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzTm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9pc05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdE5hdGl2ZUNvbXBvbmVudCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uICgpIHt9O1xuYXNzaWduKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUsIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50Lk1peGluLCB7XG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG59KTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHR5cGUgcmVmZXJlbmNlIGlzIGEga25vd24gaW50ZXJuYWwgdHlwZS4gSS5lLiBub3QgYSB1c2VyXG4gKiBwcm92aWRlZCBjb21wb3NpdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGludGVybmFsIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3ROb2RlLCBjcmVhdGUgYW4gaW5zdGFuY2UgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIG1vdW50ZWQuXG4gKlxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3Rvci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChub2RlKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gbmV3IFJlYWN0RW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpICcgKyAnb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5jb25zdHJ1Y3QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gU2V0cyB1cCB0aGUgaW5zdGFuY2UuIFRoaXMgY2FuIHByb2JhYmx5IGp1c3QgbW92ZSBpbnRvIHRoZSBjb25zdHJ1Y3RvciBub3cuXG4gIGluc3RhbmNlLmNvbnN0cnVjdChub2RlKTtcblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuX2lzT3duZXJOZWNlc3NhcnkgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb3NpdGVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkge1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KSB7fVxuU3RhdGVsZXNzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBDb21wb25lbnQgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgcmV0dXJuIENvbXBvbmVudCh0aGlzLnByb3BzLCB0aGlzLmNvbnRleHQsIHRoaXMudXBkYXRlcik7XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLSBUaGUgTGlmZS1DeWNsZSBvZiBhIENvbXBvc2l0ZSBDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXG4gKiAgIC0gY29tcG9uZW50V2lsbE1vdW50XG4gKiAgIC0gcmVuZGVyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXJdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XG4gKlxuICogICAgICAgVXBkYXRlIFBoYXNlczpcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXG4gKiAgICAgICAtIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcbiAqICAgICAgICAgICAtIHJlbmRlclxuICogICAgICAgICAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzIG9yIHJlY2VpdmUgcHJvcHMgcGhhc2VzXVxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxuICpcbiAqICAgICAtIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxuICogLSAoZGVzdHJveWVkKTogVGhlIGluc3RhbmNlIGlzIG5vdyBibGFuaywgcmVsZWFzZWQgYnkgUmVhY3QgYW5kIHJlYWR5IGZvciBHQy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQW4gaW5jcmVtZW50aW5nIElEIGFzc2lnbmVkIHRvIGVhY2ggY29tcG9uZW50IHdoZW4gaXQgaXMgbW91bnRlZC4gVGhpcyBpc1xuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG5leHRNb3VudElEID0gMTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBjb21wb3NpdGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlcyBhbmQgUmVhY3RVcGRhdGVRdWV1ZS5cbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyh0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgdmFyIHB1YmxpY0NvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChjb250ZXh0KTtcblxuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGluc3Q7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIC8vIFRoaXMgaXMgYSB3YXkgdG8gZGV0ZWN0IGlmIENvbXBvbmVudCBpcyBhIHN0YXRlbGVzcyBhcnJvdyBmdW5jdGlvblxuICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggaXMgbm90IG5ld2FibGUuIEl0IG1pZ2h0IG5vdCBiZSAxMDAlIHJlbGlhYmxlIGJ1dCBpc1xuICAgIC8vIHNvbWV0aGluZyB3ZSBjYW4gZG8gdW50aWwgd2Ugc3RhcnQgZGV0ZWN0aW5nIHRoYXQgQ29tcG9uZW50IGV4dGVuZHNcbiAgICAvLyBSZWFjdC5Db21wb25lbnQuIFdlIGFscmVhZHkgYXNzdW1lIHRoYXQgdHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJy5cbiAgICB2YXIgY2FuSW5zdGFudGlhdGUgPSAoJ3Byb3RvdHlwZScgaW4gQ29tcG9uZW50KTtcblxuICAgIGlmIChjYW5JbnN0YW50aWF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIFJlYWN0VXBkYXRlUXVldWUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0ID0gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgUmVhY3RVcGRhdGVRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjYW5JbnN0YW50aWF0ZSB8fCBpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChpbnN0KSkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gaW5zdDtcbiAgICAgIGluc3QgPSBuZXcgU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBsYXRlciBpbiBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50LCBidXQgYWRkIGFuIGVhcmx5XG4gICAgICAvLyB3YXJuaW5nIG5vdyB0byBoZWxwIGRlYnVnZ2luZ1xuICAgICAgaWYgKGluc3QucmVuZGVyID09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYCwgcmV0dXJuZWQgJyArICdudWxsL2ZhbHNlIGZyb20gYSBzdGF0ZWxlc3MgY29tcG9uZW50LCBvciB0cmllZCB0byByZW5kZXIgYW4gJyArICdlbGVtZW50IHdob3NlIHR5cGUgaXMgYSBmdW5jdGlvbiB0aGF0IGlzblxcJ3QgYSBSZWFjdCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHN1cHBvcnQgRVM2IGluaGVyaXRpbmcgZnJvbSBSZWFjdC5Db21wb25lbnQsIHRoZSBtb2R1bGUgcGF0dGVybixcbiAgICAgICAgLy8gYW5kIHN0YXRlbGVzcyBjb21wb25lbnRzLCBidXQgbm90IEVTNiBjbGFzc2VzIHRoYXQgZG9uJ3QgZXh0ZW5kXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50IHx8ICFjYW5JbnN0YW50aWF0ZSB8fCAhKGluc3QgaW5zdGFuY2VvZiBDb21wb25lbnQpLCAnJXMoLi4uKTogUmVhY3QgY29tcG9uZW50IGNsYXNzZXMgbXVzdCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2Ugc2hvdWxkIGJlIHNldCB1cCBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgIC8vIHNpbXBsZXIgY2xhc3MgYWJzdHJhY3Rpb25zLCB3ZSBzZXQgdGhlbSB1cCBhZnRlciB0aGUgZmFjdC5cbiAgICBpbnN0LnByb3BzID0gcHVibGljUHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0LnVwZGF0ZXIgPSBSZWFjdFVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5wcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcbiAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZWAgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgd2Ugbm93IHJlbmRlclxuICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KHJlbmRlcmVkRWxlbWVudCk7XG5cbiAgICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCByb290SUQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZE1vdW50LCBpbnN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfVxuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXG4gICAgLy8gaXQgd291bGQgc3RpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgcmVzZXQuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFza0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSBudWxsO1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY29udGV4dFR5cGVzO1xuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuICAgIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCAmJiBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICEodHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICEobmFtZSBpbiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NpZ24oe30sIGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBwcm9wcyBieSBzZXR0aW5nIGRlZmF1bHQgdmFsdWVzIGZvciB1bnNwZWNpZmllZCBwcm9wcyBhbmRcbiAgICogYXNzZXJ0aW5nIHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZC4gRG9lcyBub3QgbXV0YXRlIGl0cyBhcmd1bWVudDsgcmV0dXJuc1xuICAgKiBhIG5ldyBwcm9wcyBvYmplY3Qgd2l0aCBkZWZhdWx0cyBtZXJnZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc1Byb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LnByb3BUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQucHJvcFR5cGVzLCBuZXdQcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1Byb3BzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCB0aGUgcHJvcHMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wVHlwZXMgTWFwIG9mIHByb3AgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gICAgLy8gVE9ETzogU3RvcCB2YWxpZGF0aW5nIHByb3AgdHlwZXMgaGVyZSBhbmQgb25seSB1c2UgdGhlIGVsZW1lbnRcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHZhciBjb21wb25lbnROYW1lID0gdGhpcy5nZXROYW1lKCk7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgICEodHlwZW9mIHByb3BUeXBlc1twcm9wTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5ICcgKyAnZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAvLyBXZSBtYXkgd2FudCB0byBleHRlbmQgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBlcnJvcnMgaW5cbiAgICAgICAgICAvLyB0b3AtbGV2ZWwgcmVuZGVyIGNhbGxzLCBzbyBJJ20gYWJzdHJhY3RpbmcgaXQgYXdheSBpbnRvXG4gICAgICAgICAgLy8gYSBmdW5jdGlvbiB0byBtaW5pbWl6ZSByZWZhY3RvcmluZyBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKHRoaXMpO1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uID09PSBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApIHtcbiAgICAgICAgICAgIC8vIFByZWZhY2UgZ2l2ZXMgdXMgc29tZXRoaW5nIHRvIGJsYWNrbGlzdCBpbiB3YXJuaW5nIG1vZHVsZVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBDb250ZXh0IFR5cGVzOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50IHx8IHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlICE9PSBudWxsIHx8IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIHVwZGF0ZSB0byBhIG1vdW50ZWQgY29tcG9uZW50LiBUaGUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBhbmRcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXG4gICAqIHJlcHJlc2VudGF0aW9uIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldlBhcmVudEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIG5leHRDb250ZXh0ID0gdGhpcy5fY29udGV4dCA9PT0gbmV4dFVubWFza2VkQ29udGV4dCA/IGluc3QuY29udGV4dCA6IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIHZhciBuZXh0UHJvcHM7XG5cbiAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGEgcHJvcHMgdXBkYXRlIHZlcnN1cyBhIHNpbXBsZSBzdGF0ZSB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgPT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICAvLyBTa2lwIGNoZWNraW5nIHByb3AgdHlwZXMgYWdhaW4gLS0gd2UgZG9uJ3QgcmVhZCBpbnN0LnByb3BzIHRvIGF2b2lkXG4gICAgICAvLyB3YXJuaW5nIGZvciBET00gY29tcG9uZW50IHByb3BzIGluIHRoaXMgdXBncmFkZVxuICAgICAgbmV4dFByb3BzID0gbmV4dFBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyhuZXh0UGFyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XG4gICAgICAvLyBfcGVuZGluZ1N0YXRlUXVldWUgd2hpY2ggd2lsbCBlbnN1cmUgdGhhdCBhbnkgc3RhdGUgdXBkYXRlcyBnZXRzXG4gICAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG5cbiAgICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSB8fCAhaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUgfHwgaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2Ygc2hvdWxkVXBkYXRlICE9PSAndW5kZWZpbmVkJywgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgLy8gV2lsbCBzZXQgYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgLlxuICAgICAgdGhpcy5fcGVyZm9ybUNvbXBvbmVudFVwZGF0ZShuZXh0UGFyZW50RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3MgZGV0ZXJtaW5lZCB0aGF0IGEgY29tcG9uZW50IHNob3VsZCBub3QgdXBkYXRlLCB3ZSBzdGlsbCB3YW50XG4gICAgICAvLyB0byBzZXQgcHJvcHMgYW5kIHN0YXRlIGJ1dCB3ZSBzaG9ydGN1dCB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlLlxuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0UGFyZW50RWxlbWVudDtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBuZXh0VW5tYXNrZWRDb250ZXh0O1xuICAgICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICB9XG4gIH0sXG5cbiAgX3Byb2Nlc3NQZW5kaW5nU3RhdGU6IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcGVuZGluZ1N0YXRlUXVldWU7XG4gICAgdmFyIHJlcGxhY2UgPSB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICByZXR1cm4gaW5zdC5zdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZSAmJiBxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBxdWV1ZVswXTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gYXNzaWduKHt9LCByZXBsYWNlID8gcXVldWVbMF0gOiBpbnN0LnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICBhc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgaW5zdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjb21wb25lbnQncyBgcmVuZGVyYCBtZXRob2QgYW5kIHVwZGF0ZSB0aGUgRE9NIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgdmFyIHByZXZSZW5kZXJlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBuZXh0UmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIG5leHRSZW5kZXJlZEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlc2UgdHdvIElEcyBhcmUgYWN0dWFsbHkgdGhlIHNhbWUhIEJ1dCBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoYXQuXG4gICAgICB2YXIgdGhpc0lEID0gdGhpcy5fcm9vdE5vZGVJRDtcbiAgICAgIHZhciBwcmV2Q29tcG9uZW50SUQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX3Jvb3ROb2RlSUQ7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCk7XG4gICAgICB2YXIgbmV4dE1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgdGhpc0lELCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEKHByZXZDb21wb25lbnRJRCwgbmV4dE1hcmt1cCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogZnVuY3Rpb24gKHByZXZDb21wb25lbnRJRCwgbmV4dE1hcmt1cCkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZWRDb21wb25lbnQgPT09ICd1bmRlZmluZWQnICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZENvbXBvbmVudDtcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgICEoXG4gICAgLy8gVE9ETzogQW4gYGlzVmFsaWROb2RlYCBmdW5jdGlvbiB3b3VsZCBwcm9iYWJseSBiZSBtb3JlIGFwcHJvcHJpYXRlXG4gICAgcmVuZGVyZWRDb21wb25lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRDb21wb25lbnQgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChyZW5kZXJlZENvbXBvbmVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0Q29tcG9uZW50IG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgcHVibGljQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQgJiYgY29tcG9uZW50LmdldE5hbWUgPyBjb21wb25lbnQuZ2V0TmFtZSgpIDogJ2EgY29tcG9uZW50JztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHB1YmxpY0NvbXBvbmVudEluc3RhbmNlICE9IG51bGwsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcyAnICsgJyhTZWUgcmVmIFwiJXNcIiBpbiAlcyBjcmVhdGVkIGJ5ICVzKS4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLicsIHJlZiwgY29tcG9uZW50TmFtZSwgdGhpcy5nZXROYW1lKCkpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBwdWJsaWNDb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmIChpbnN0IGluc3RhbmNlb2YgU3RhdGVsZXNzQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbiwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jywge1xuICBtb3VudENvbXBvbmVudDogJ21vdW50Q29tcG9uZW50JyxcbiAgdXBkYXRlQ29tcG9uZW50OiAndXBkYXRlQ29tcG9uZW50JyxcbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnXG59KTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIE1peGluOiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGVudmlyb25tZW50IGRlcGVuZGVudCBjbGVhbnVwIGhvb2suIChzZXJ2ZXIgdnMuXG4gICAqIGJyb3dzZXIgZXRjKS4gRXhhbXBsZTogQSBicm93c2VyIHN5c3RlbSBjYWNoZXMgRE9NIG5vZGVzIGJhc2VkIG9uIGNvbXBvbmVudFxuICAgKiBJRCBhbmQgbXVzdCByZW1vdmUgdGhhdCBjYWNoZSBlbnRyeSB3aGVuIHRoaXMgaW5zdGFuY2UgaXMgdW5tb3VudGVkLlxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXG4gICAqIHRoZSB0cmVlLlxuICAgKi9cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCA9IGVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSBrZXlNaXJyb3Ioe1xuICBwcm9wOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBjaGlsZENvbnRleHQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcbiAqIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkIGFzIG9wcG9zZWQgdG8gYmVpbmcgZGVzdHJveWVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3XG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG4gIGlmIChwcmV2RW1wdHkgfHwgbmV4dEVtcHR5KSB7XG4gICAgcmV0dXJuIHByZXZFbXB0eSA9PT0gbmV4dEVtcHR5O1xuICB9XG5cbiAgdmFyIHByZXZUeXBlID0gdHlwZW9mIHByZXZFbGVtZW50O1xuICB2YXIgbmV4dFR5cGUgPSB0eXBlb2YgbmV4dEVsZW1lbnQ7XG4gIGlmIChwcmV2VHlwZSA9PT0gJ3N0cmluZycgfHwgcHJldlR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnc3RyaW5nJyB8fCBuZXh0VHlwZSA9PT0gJ251bWJlcic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBwcmV2RWxlbWVudC50eXBlID09PSBuZXh0RWxlbWVudC50eXBlICYmIHByZXZFbGVtZW50LmtleSA9PT0gbmV4dEVsZW1lbnQua2V5O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG52YXIgcGxhY2Vob2xkZXJFbGVtZW50O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBwbGFjZWhvbGRlckVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudChjb21wb25lbnQpO1xuICB9XG59O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGluc3RhbnRpYXRlKHBsYWNlaG9sZGVyRWxlbWVudCk7XG59O1xuYXNzaWduKFJlYWN0RW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHt9LFxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQocm9vdElEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gICAgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICB9XG59KTtcblxuUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24gPSBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TmF0aXZlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBhdXRvR2VuZXJhdGVXcmFwcGVyQ2xhc3MgPSBudWxsO1xudmFyIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IG51bGw7XG4vLyBUaGlzIHJlZ2lzdHJ5IGtlZXBzIHRyYWNrIG9mIHdyYXBwZXIgY2xhc3NlcyBhcm91bmQgbmF0aXZlIHRhZ3MuXG52YXIgdGFnVG9Db21wb25lbnRDbGFzcyA9IHt9O1xudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XG5cbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEga2V5ZWQgb2JqZWN0IHdpdGggY2xhc3NlcyBhcyB2YWx1ZXMuIEVhY2gga2V5IHJlcHJlc2VudHMgYVxuICAvLyB0YWcuIFRoYXQgcGFydGljdWxhciB0YWcgd2lsbCB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIHRoZSBnZW5lcmljIG9uZS5cbiAgaW5qZWN0Q29tcG9uZW50Q2xhc3NlczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzZXMpIHtcbiAgICBhc3NpZ24odGFnVG9Db21wb25lbnRDbGFzcywgY29tcG9uZW50Q2xhc3Nlcyk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGEgY29tcG9zaXRlIGNvbXBvbmVudCB3cmFwcGVyIGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgdGFnIGZvciB3aGljaCB0byBnZXQgdGhlIGNsYXNzLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBSZWFjdCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9XG4gIHZhciB0YWcgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IHRhZ1RvQ29tcG9uZW50Q2xhc3NbdGFnXTtcbiAgaWYgKGNvbXBvbmVudENsYXNzID09IG51bGwpIHtcbiAgICB0YWdUb0NvbXBvbmVudENsYXNzW3RhZ10gPSBjb21wb25lbnRDbGFzcyA9IGF1dG9HZW5lcmF0ZVdyYXBwZXJDbGFzcyh0YWcpO1xuICB9XG4gIHJldHVybiBjb21wb25lbnRDbGFzcztcbn1cblxuLyoqXG4gKiBHZXQgYSBuYXRpdmUgaW50ZXJuYWwgY29tcG9uZW50IGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGludGVybmFsIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KSB7XG4gICFnZW5lcmljQ29tcG9uZW50Q2xhc3MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjb21wb25lbnQgZm9yIHRoZSB0YWcgJXMnLCBlbGVtZW50LnR5cGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBnZW5lcmljQ29tcG9uZW50Q2xhc3MoZWxlbWVudC50eXBlLCBlbGVtZW50LnByb3BzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSB7XG4gIGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudDogZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50LFxuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdE5hdGl2ZUNvbXBvbmVudEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROYXRpdmVDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB2YWxpZGF0ZURPTU5lc3RpbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIHBhcmVudFRhZzogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IGFzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLnBhcmVudFRhZyA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcblxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuXG4gICAgICBjYXNlICd0YWJsZSc6XG5cbiAgICAgIGNhc2UgJ2hyJzpcblxuICAgICAgY2FzZSAneG1wJzpcblxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgaW5zdGFuY2UsIHJldHVybiBhIGxpc3Qgb2YgaXRzIHJlY3Vyc2l2ZVxuICAgKiBvd25lcnMsIHN0YXJ0aW5nIGF0IHRoZSByb290IGFuZCBlbmRpbmcgd2l0aCB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgdmFyIGZpbmRPd25lclN0YWNrID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIC8qZXNsaW50LWRpc2FibGUgc3BhY2UtYWZ0ZXIta2V5d29yZHMgKi9cbiAgICBkbyB7XG4gICAgICAvKmVzbGludC1lbmFibGUgc3BhY2UtYWZ0ZXIta2V5d29yZHMgKi9cbiAgICAgIHN0YWNrLnB1c2goaW5zdGFuY2UpO1xuICAgIH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgc3RhY2sucmV2ZXJzZSgpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLnBhcmVudFRhZztcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBwcm9ibGVtYXRpYyA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuXG4gICAgaWYgKHByb2JsZW1hdGljKSB7XG4gICAgICB2YXIgYW5jZXN0b3JUYWcgPSBwcm9ibGVtYXRpYy50YWc7XG4gICAgICB2YXIgYW5jZXN0b3JJbnN0YW5jZSA9IHByb2JsZW1hdGljLmluc3RhbmNlO1xuXG4gICAgICB2YXIgY2hpbGRPd25lciA9IGNoaWxkSW5zdGFuY2UgJiYgY2hpbGRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXIgPSBhbmNlc3Rvckluc3RhbmNlICYmIGFuY2VzdG9ySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgdmFyIGNoaWxkT3duZXJzID0gZmluZE93bmVyU3RhY2soY2hpbGRPd25lcik7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lcnMgPSBmaW5kT3duZXJTdGFjayhhbmNlc3Rvck93bmVyKTtcblxuICAgICAgdmFyIG1pblN0YWNrTGVuID0gTWF0aC5taW4oY2hpbGRPd25lcnMubGVuZ3RoLCBhbmNlc3Rvck93bmVycy5sZW5ndGgpO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIHZhciBkZWVwZXN0Q29tbW9uID0gLTE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWluU3RhY2tMZW47IGkrKykge1xuICAgICAgICBpZiAoY2hpbGRPd25lcnNbaV0gPT09IGFuY2VzdG9yT3duZXJzW2ldKSB7XG4gICAgICAgICAgZGVlcGVzdENvbW1vbiA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFVOS05PV04gPSAnKHVua25vd24pJztcbiAgICAgIHZhciBjaGlsZE93bmVyTmFtZXMgPSBjaGlsZE93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lck5hbWVzID0gYW5jZXN0b3JPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIG93bmVySW5mbyA9IFtdLmNvbmNhdChcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgYW5kIGNoaWxkIGluc3RhbmNlcyBoYXZlIGEgY29tbW9uIG93bmVyIGFuY2VzdG9yLCBzdGFydFxuICAgICAgLy8gd2l0aCB0aGF0IC0tIG90aGVyd2lzZSB3ZSBqdXN0IHN0YXJ0IHdpdGggdGhlIHBhcmVudCdzIG93bmVycy5cbiAgICAgIGRlZXBlc3RDb21tb24gIT09IC0xID8gY2hpbGRPd25lcnNbZGVlcGVzdENvbW1vbl0uZ2V0TmFtZSgpIHx8IFVOS05PV04gOiBbXSwgYW5jZXN0b3JPd25lck5hbWVzLCBhbmNlc3RvclRhZyxcbiAgICAgIC8vIElmIHdlJ3JlIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCAobm9uLXBhcmVudCkgYW5jZXN0cnksIGFkZCAnLi4uJ1xuICAgICAgaW52YWxpZEFuY2VzdG9yID8gWycuLi4nXSA6IFtdLCBjaGlsZE93bmVyTmFtZXMsIGNoaWxkVGFnKS5qb2luKCcgPiAnKTtcblxuICAgICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgb3duZXJJbmZvO1xuICAgICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiA8JXM+IGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiAnICsgJ1NlZSAlcy4lcycsIGNoaWxkVGFnLCBhbmNlc3RvclRhZywgb3duZXJJbmZvLCBpbmZvKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6IDwlcz4gY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgY2hpbGRUYWcsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleSA9ICdfX3ZhbGlkYXRlRE9NTmVzdGluZ19hbmNlc3RvckluZm8kJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbztcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5wYXJlbnRUYWc7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vQ2xpZW50UmVhY3RSb290SW5kZXgnKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbicpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vU2VydmVyUmVhY3RSb290SW5kZXgnKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0SW5zdGFuY2VIYW5kbGUoUmVhY3RJbnN0YW5jZUhhbmRsZXMpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RNb3VudChSZWFjdE1vdW50KTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5DbGFzcy5pbmplY3RNaXhpbihSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbik7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50KCdub3NjcmlwdCcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Sb290SW5kZXguaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXgoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gQ2xpZW50UmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggOiBTZXJ2ZXJSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG4gICAgaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gICAgICB2YXIgUmVhY3REZWZhdWx0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0UGVyZicpO1xuICAgICAgUmVhY3REZWZhdWx0UGVyZi5zdGFydCgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljSW5wdXRFdmVudCcpO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQsIHRvcExldmVsVHlwZXMudG9wUGFzdGVdXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZSwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBmYWxsYmFjayBvYmplY3QsIGlmIGFueS5cbnZhciBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghY3VycmVudENvbXBvc2l0aW9uICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuZ2V0UG9vbGVkKHRvcExldmVsVGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0OlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kIHx8IGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5yZWxlYXNlKGN1cnJlbnRDb21wb3NpdGlvbik7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoICYmICFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlZm9yZUlucHV0RXZlbnRQbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBFdmVudENvbnN0YW50cy5Qcm9wYWdhdGlvblBoYXNlcztcbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpZCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoZG9tSUQsIHVwd2FyZHMsIGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZG9tSUQsICdEaXNwYXRjaGluZyBpZCBtdXN0IG5vdCBiZSBudWxsJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHBoYXNlID0gdXB3YXJkcyA/IFByb3BhZ2F0aW9uUGhhc2VzLmJ1YmJsZWQgOiBQcm9wYWdhdGlvblBoYXNlcy5jYXB0dXJlZDtcbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGRvbUlELCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGRvbUlEKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlKGV2ZW50LmRpc3BhdGNoTWFya2VyLCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldChldmVudC5kaXNwYXRjaE1hcmtlciwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaWQsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSURzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSURzLCBpZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5kaXNwYXRjaE1hcmtlciwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VFbnRlckxlYXZlKGZyb21JRCwgdG9JRCwgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9zdGFydFRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFRleHRDb250ZW50QWNjZXNzb3JcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRleHRDb250ZW50QWNjZXNzb3I7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IGRpc3BhdGNoTWFya2VyO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG59XG5cbmFzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBvbiBhICcgKyAncmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gVGhpcyBpcyBhIG5vLW9wLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHN0b3BQcm9wYWdhdGlvbmAgb24gYSAnICsgJ3JlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuIFRoaXMgaXMgYSBuby1vcC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoTWFya2VyID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBhc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0lucHV0RXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU9mXG4gKi9cblxuLyoqXG4gKiBBbGxvd3MgZXh0cmFjdGlvbiBvZiBhIG1pbmlmaWVkIGtleS4gTGV0J3MgdGhlIGJ1aWxkIHN5c3RlbSBtaW5pZnkga2V5c1xuICogd2l0aG91dCBsb3NpbmcgdGhlIGFiaWxpdHkgdG8gZHluYW1pY2FsbHkgdXNlIGtleSBzdHJpbmdzIGFzIHZhbHVlc1xuICogdGhlbXNlbHZlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkvdmFsIHBhaXIgYW5kIGl0IHdpbGwgcmV0dXJuXG4gKiB5b3UgdGhlIHN0cmluZyBrZXkgb2YgdGhhdCBzaW5nbGUgcmVjb3JkLiBTdXBwb3NlIHlvdSB3YW50IHRvIGdyYWIgdGhlXG4gKiB2YWx1ZSBmb3IgYSBrZXkgJ2NsYXNzTmFtZScgaW5zaWRlIG9mIGFuIG9iamVjdC4gS2V5L3ZhbCBtaW5pZmljYXRpb24gbWF5XG4gKiBoYXZlIGFsaWFzZWQgdGhhdCBrZXkgdG8gYmUgJ3hhMTInLiBrZXlPZih7Y2xhc3NOYW1lOiBudWxsfSkgd2lsbCByZXR1cm5cbiAqICd4YTEyJyBpbiB0aGF0IGNhc2UuIFJlc29sdmUga2V5cyB5b3Ugd2FudCB0byB1c2Ugb25jZSBhdCBzdGFydHVwIHRpbWUsIHRoZW5cbiAqIHJldXNlIHRob3NlIHJlc29sdXRpb25zLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleU9mID0gZnVuY3Rpb24gKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIva2V5T2YuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENoYW5nZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNoYW5nZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2hhbmdlQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENoYW5nZSwgdG9wTGV2ZWxUeXBlcy50b3BDbGljaywgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCk7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBhY3RpdmVFbGVtZW50SUQsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJRCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SUQgPSB0YXJnZXRJRDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRvcExldmVsVGFyZ2V0SUQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0ge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gQ2FzdCB0byBhIHN0cmluZyBzbyB3ZSBjYW4gZG8gZXF1YWxpdHkgY2hlY2tzLlxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgfVxufTtcblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICd2YWx1ZScpO1xuXG4gIC8vIE5vdCBndWFyZGVkIGluIGEgY2FuRGVmaW5lUHJvcGVydHkgY2hlY2s6IElFOCBzdXBwb3J0cyBkZWZpbmVQcm9wZXJ0eSBvbmx5XG4gIC8vIG9uIERPTSBlbGVtZW50c1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbmV3VmFsdWVQcm9wKTtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGRlbGV0ZSByZXN0b3JlcyB0aGUgb3JpZ2luYWwgcHJvcGVydHkgZGVmaW5pdGlvblxuICBkZWxldGUgYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcblxuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmFsdWUgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LnZhbHVlO1xuICBpZiAodmFsdWUgPT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB2YWx1ZTtcblxuICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbn1cblxuLyoqXG4gKiBJZiBhIGBjaGFuZ2VgIGV2ZW50IHNob3VsZCBiZSBmaXJlZCwgcmV0dXJucyB0aGUgdGFyZ2V0J3MgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldElERm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wSW5wdXQpIHtcbiAgICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMgKGkuZS4sIG5vdCBJRTggb3IgSUU5KSwgdGhlIGlucHV0IGV2ZW50IGlzIGV4YWN0bHlcbiAgICAvLyB3aGF0IHdlIHdhbnQgc28gZmFsbCB0aHJvdWdoIGhlcmUgYW5kIHRyaWdnZXIgYW4gYWJzdHJhY3QgZXZlbnRcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93bikge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQudmFsdWUgIT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgICAgYWN0aXZlRWxlbWVudFZhbHVlID0gYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50SUQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENsaWNrKSB7XG4gICAgcmV0dXJuIHRvcExldmVsVGFyZ2V0SUQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuXG4gICAgdmFyIGdldFRhcmdldElERnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGlmIChkb2VzQ2hhbmdlRXZlbnRCdWJibGUpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRTtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SURGdW5jKSB7XG4gICAgICB2YXIgdGFyZ2V0SUQgPSBnZXRUYXJnZXRJREZ1bmModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gICAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCB0YXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRUYXJnZXRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHRJbnB1dEVsZW1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIHN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXSB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENsaWVudFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5leHRSZWFjdFJvb3RJbmRleCA9IDA7XG5cbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV4dFJlYWN0Um9vdEluZGV4Kys7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50UmVhY3RSb290SW5kZXg7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0NsaWVudFJlYWN0Um9vdEluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gW2tleU9mKHsgUmVzcG9uZGVyRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2ltcGxlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgVGFwRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IENoYW5nZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNlbGVjdEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IG51bGwgfSldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG52YXIgZ2V0Rmlyc3RSZWFjdERPTSA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7IG9uTW91c2VFbnRlcjogbnVsbCB9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0LCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcl1cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUxlYXZlOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9XG59O1xuXG52YXIgZXh0cmFjdGVkRXZlbnRzID0gW251bGwsIG51bGxdO1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCAmJiB0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAodG9wTGV2ZWxUYXJnZXQud2luZG93ID09PSB0b3BMZXZlbFRhcmdldCkge1xuICAgICAgLy8gYHRvcExldmVsVGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSB0b3BMZXZlbFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IHRvcExldmVsVGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICB2YXIgZnJvbUlEID0gJyc7XG4gICAgdmFyIHRvSUQgPSAnJztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0KSB7XG4gICAgICBmcm9tID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICBmcm9tSUQgPSB0b3BMZXZlbFRhcmdldElEO1xuICAgICAgdG8gPSBnZXRGaXJzdFJlYWN0RE9NKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50KTtcbiAgICAgIGlmICh0bykge1xuICAgICAgICB0b0lEID0gUmVhY3RNb3VudC5nZXRJRCh0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0byA9IHdpbjtcbiAgICAgIH1cbiAgICAgIHRvID0gdG8gfHwgd2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tID0gd2luO1xuICAgICAgdG8gPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgIHRvSUQgPSB0b3BMZXZlbFRhcmdldElEO1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUxlYXZlLCBmcm9tSUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgbGVhdmUudHlwZSA9ICdtb3VzZWxlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0bztcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VFbnRlciwgdG9JRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpO1xuXG4gICAgZXh0cmFjdGVkRXZlbnRzWzBdID0gbGVhdmU7XG4gICAgZXh0cmFjdGVkRXZlbnRzWzFdID0gZW50ZXI7XG5cbiAgICByZXR1cm4gZXh0cmFjdGVkRXZlbnRzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY01vdXNlRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xuICAgIC8vIGJ1dHRvbjogMCAxIDIgKHN0YW5kYXJkKVxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIElFPDlcbiAgICAvLyB3aGljaDogIHVuZGVmaW5lZFxuICAgIC8vIGJ1dHRvbjogMCAwIDBcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMiA/IDIgOiBidXR0b24gPT09IDQgPyAxIDogMDtcbiAgfSxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcbiAgdmlldzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnZpZXcpIHtcbiAgICAgIHJldHVybiBldmVudC52aWV3O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldC53aW5kb3cgPT09IHRhcmdldCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGEgd2luZG93IG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgIGlmIChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gIH0sXG4gIGRldGFpbDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgSFRNTERPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfU0lERV9FRkZFQ1RTID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19TSURFX0VGRkVDVFM7XG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFO1xuXG52YXIgaGFzU1ZHO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgaW1wbGVtZW50YXRpb24gPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbjtcbiAgaGFzU1ZHID0gaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJiBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlJywgJzEuMScpO1xufVxuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oZGF0YXxhcmlhKS1bYS16X11bYS16XFxkXy5cXC1dKiQvKSxcbiAgUHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhY2NlcHQ6IG51bGwsXG4gICAgYWNjZXB0Q2hhcnNldDogbnVsbCxcbiAgICBhY2Nlc3NLZXk6IG51bGwsXG4gICAgYWN0aW9uOiBudWxsLFxuICAgIGFsbG93RnVsbFNjcmVlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBhbHQ6IG51bGwsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogbnVsbCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IG51bGwsXG4gICAgY2VsbFNwYWNpbmc6IG51bGwsXG4gICAgY2hhclNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNoYWxsZW5nZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2xhc3NJRDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIFRvIHNldCBjbGFzc05hbWUgb24gU1ZHIGVsZW1lbnRzLCBpdCdzIG5lY2Vzc2FyeSB0byB1c2UgLnNldEF0dHJpYnV0ZTtcbiAgICAvLyB0aGlzIHdvcmtzIG9uIEhUTUwgZWxlbWVudHMgdG9vIGluIGFsbCBicm93c2VycyBleGNlcHQgSUU4LiBDb252ZW5pZW50bHksXG4gICAgLy8gSUU4IGRvZXNuJ3Qgc3VwcG9ydCBTVkcgYW5kIHNvIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSBhdHRyaWJ1dGUgaW5cbiAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgU1ZHIGFuZCB0aGUgcHJvcGVydHkgaW4gYnJvd3NlcnMgdGhhdCBkb24ndCxcbiAgICAvLyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgSFRNTCBvciBTVkcuXG4gICAgY2xhc3NOYW1lOiBoYXNTVkcgPyBNVVNUX1VTRV9BVFRSSUJVVEUgOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBjb2xzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb2xTcGFuOiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgY29udGVudEVkaXRhYmxlOiBudWxsLFxuICAgIGNvbnRleHRNZW51OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY29udHJvbHM6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29vcmRzOiBudWxsLFxuICAgIGNyb3NzT3JpZ2luOiBudWxsLFxuICAgIGRhdGE6IG51bGwsIC8vIEZvciBgPG9iamVjdCAvPmAgYWN0cyBhcyBgc3JjYC5cbiAgICBkYXRlVGltZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogbnVsbCxcbiAgICBkaXNhYmxlZDogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiBudWxsLFxuICAgIGVuY1R5cGU6IG51bGwsXG4gICAgZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1BY3Rpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtRW5jVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1NZXRob2Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZyYW1lQm9yZGVyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaGVhZGVyczogbnVsbCxcbiAgICBoZWlnaHQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoaWRkZW46IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IG51bGwsXG4gICAgaHJlZjogbnVsbCxcbiAgICBocmVmTGFuZzogbnVsbCxcbiAgICBodG1sRm9yOiBudWxsLFxuICAgIGh0dHBFcXVpdjogbnVsbCxcbiAgICBpY29uOiBudWxsLFxuICAgIGlkOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBpbnB1dE1vZGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpbnRlZ3JpdHk6IG51bGwsXG4gICAgaXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBrZXlQYXJhbXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBrZXlUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAga2luZDogbnVsbCxcbiAgICBsYWJlbDogbnVsbCxcbiAgICBsYW5nOiBudWxsLFxuICAgIGxpc3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBsb29wOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvdzogbnVsbCxcbiAgICBtYW5pZmVzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmdpbkhlaWdodDogbnVsbCxcbiAgICBtYXJnaW5XaWR0aDogbnVsbCxcbiAgICBtYXg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWVkaWE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYUdyb3VwOiBudWxsLFxuICAgIG1ldGhvZDogbnVsbCxcbiAgICBtaW46IG51bGwsXG4gICAgbWluTGVuZ3RoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbmFtZTogbnVsbCxcbiAgICBub25jZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wdGltdW06IG51bGwsXG4gICAgcGF0dGVybjogbnVsbCxcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBwb3N0ZXI6IG51bGwsXG4gICAgcHJlbG9hZDogbnVsbCxcbiAgICByYWRpb0dyb3VwOiBudWxsLFxuICAgIHJlYWRPbmx5OiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlbDogbnVsbCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByb3dzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBudWxsLFxuICAgIHNhbmRib3g6IG51bGwsXG4gICAgc2NvcGU6IG51bGwsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzY3JvbGxpbmc6IG51bGwsXG4gICAgc2VhbWxlc3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiBudWxsLFxuICAgIHNpemU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogbnVsbCxcbiAgICBzcmM6IG51bGwsXG4gICAgc3JjRG9jOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBzcmNMYW5nOiBudWxsLFxuICAgIHNyY1NldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIHN1bW1hcnk6IG51bGwsXG4gICAgdGFiSW5kZXg6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHR5cGU6IG51bGwsXG4gICAgdXNlTWFwOiBudWxsLFxuICAgIHZhbHVlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19TSURFX0VGRkVDVFMsXG4gICAgd2lkdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB3bW9kZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdyYXA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSREZhIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhYm91dDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGRhdGF0eXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaW5saXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlZml4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByZXNvdXJjZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgICd0eXBlb2YnOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdm9jYWI6IE1VU1RfVVNFX0FUVFJJQlVURSxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGF1dG9Db3JyZWN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gYXV0b1NhdmUgYWxsb3dzIFdlYktpdC9CbGluayB0byBwZXJzaXN0IHZhbHVlcyBvZiBpbnB1dCBmaWVsZHMgb24gcGFnZSByZWxvYWRzXG4gICAgYXV0b1NhdmU6IG51bGwsXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xuICAgIGNvbG9yOiBudWxsLFxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1Qcm9wOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaXRlbVNjb3BlOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBpdGVtVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIGl0ZW1JRCBhbmQgaXRlbVJlZiBhcmUgZm9yIE1pY3JvZGF0YSBzdXBwb3J0IGFzIHdlbGwgYnV0XG4gICAgLy8gb25seSBzcGVjaWZpZWQgaW4gdGhlIHRoZSBXSEFUV0cgc3BlYyBkb2N1bWVudC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcbiAgICBpdGVtSUQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpdGVtUmVmOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XG4gICAgLy8gc2VhcmNoIGZpZWxkcyBpbiBXZWJLaXQvQmxpbmtcbiAgICByZXN1bHRzOiBudWxsLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcbiAgICAvLyBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgb24gSUU8MTBcbiAgICBzZWN1cml0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcbiAgICB1bnNlbGVjdGFibGU6IE1VU1RfVVNFX0FUVFJJQlVURVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTVByb3BlcnR5TmFtZXM6IHtcbiAgICBhdXRvQ29tcGxldGU6ICdhdXRvY29tcGxldGUnLFxuICAgIGF1dG9Gb2N1czogJ2F1dG9mb2N1cycsXG4gICAgYXV0b1BsYXk6ICdhdXRvcGxheScsXG4gICAgYXV0b1NhdmU6ICdhdXRvc2F2ZScsXG4gICAgLy8gYGVuY29kaW5nYCBpcyBlcXVpdmFsZW50IHRvIGBlbmN0eXBlYCwgSUU4IGxhY2tzIGFuIGBlbmN0eXBlYCBzZXR0ZXIuXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNkb20tZnMtZW5jb2RpbmdcbiAgICBlbmNUeXBlOiAnZW5jb2RpbmcnLFxuICAgIGhyZWZMYW5nOiAnaHJlZmxhbmcnLFxuICAgIHJhZGlvR3JvdXA6ICdyYWRpb2dyb3VwJyxcbiAgICBzcGVsbENoZWNrOiAnc3BlbGxjaGVjaycsXG4gICAgc3JjRG9jOiAnc3JjZG9jJyxcbiAgICBzcmNTZXQ6ICdzcmNzZXQnXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5LZXkgPSAnX2dldERPTU5vZGVEaWRXYXJuJztcblxudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBjb21wb25lbnQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRET01Ob2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcy5jb25zdHJ1Y3RvcltkaWRXYXJuS2V5XSwgJyVzLmdldERPTU5vZGUoLi4uKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICcgKyAnUmVhY3RET00uZmluZERPTU5vZGUoaW5zdGFuY2UpIGluc3RlYWQuJywgUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuZ2V0TmFtZSgpIHx8IHRoaXMudGFnTmFtZSB8fCAnVW5rbm93bicpIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuY29uc3RydWN0b3JbZGlkV2FybktleV0gPSB0cnVlO1xuICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZpbmRET01Ob2RlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGdldERPTU5vZGUgb3IgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG4gIGlmIChSZWFjdEluc3RhbmNlTWFwLmhhcyhjb21wb25lbnRPckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZ2V0Tm9kZUZyb21JbnN0YW5jZShjb21wb25lbnRPckVsZW1lbnQpO1xuICB9XG4gICEoY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PSBudWxsIHx8IHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kRE9NTm9kZSB3YXMgY2FsbGVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZmluZERPTU5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcblxudmFyIFJFU0VUX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBGTFVTSF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBSZWFjdFVwZGF0ZXMuZmx1c2hCYXRjaGVkVXBkYXRlcy5iaW5kKFJlYWN0VXBkYXRlcylcbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtGTFVTSF9CQVRDSEVEX1VQREFURVMsIFJFU0VUX0JBVENIRURfVVBEQVRFU107XG5cbmZ1bmN0aW9uIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xufVxuXG5hc3NpZ24oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfVxufSk7XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXG4gICAqIGFuZCBmcmllbmRzIGFyZSBiYXRjaGVkIHN1Y2ggdGhhdCBjb21wb25lbnRzIGFyZW4ndCB1cGRhdGVkIHVubmVjZXNzYXJpbHkuXG4gICAqL1xuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzO1xuXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKGNhbGxiYWNrLCBudWxsLCBhLCBiLCBjLCBkLCBlKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01CdXR0b24gPSByZXF1aXJlKCcuL1JlYWN0RE9NQnV0dG9uJyk7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnB1dCcpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTU9wdGlvbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dGFyZWEnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRlbGV0ZUxpc3RlbmVyID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBDSElMRFJFTiA9IGtleU9mKHsgY2hpbGRyZW46IG51bGwgfSk7XG52YXIgU1RZTEUgPSBrZXlPZih7IHN0eWxlOiBudWxsIH0pO1xudmFyIEhUTUwgPSBrZXlPZih7IF9faHRtbDogbnVsbCB9KTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbGVnYWN5UHJvcHNEZXNjcmlwdG9yO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgbGVnYWN5UHJvcHNEZXNjcmlwdG9yID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAucHJvcHMgb2YgYSBET00gbm9kZTsgaW5zdGVhZCwgJyArICdyZWNyZWF0ZSB0aGUgcHJvcHMgYXMgYHJlbmRlcmAgZGlkIG9yaWdpbmFsbHkgb3IgcmVhZCB0aGUgRE9NICcgKyAncHJvcGVydGllcy9hdHRyaWJ1dGVzIGRpcmVjdGx5IGZyb20gdGhpcyBub2RlIChlLmcuLCAnICsgJ3RoaXMucmVmcy5ib3guY2xhc3NOYW1lKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBsZWdhY3lHZXRET01Ob2RlKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLmdldERPTU5vZGUoKSBvZiBhIERPTSBub2RlOyAnICsgJ2luc3RlYWQsIHVzZSB0aGUgbm9kZSBkaXJlY3RseS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbGVnYWN5SXNNb3VudGVkKCkge1xuICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5pc01vdW50ZWQoKSBvZiBhIERPTSBub2RlLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAhIWNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gbGVnYWN5U2V0U3RhdGVFdGMoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuc2V0U3RhdGUoKSwgLnJlcGxhY2VTdGF0ZSgpLCBvciAnICsgJy5mb3JjZVVwZGF0ZSgpIG9mIGEgRE9NIG5vZGUuIFRoaXMgaXMgYSBuby1vcC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdhY3lTZXRQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnNldFByb3BzKCkgb2YgYSBET00gbm9kZS4gJyArICdJbnN0ZWFkLCBjYWxsIFJlYWN0RE9NLnJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmICghY29tcG9uZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwoY29tcG9uZW50LCBwYXJ0aWFsUHJvcHMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKGNvbXBvbmVudCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVJlcGxhY2VQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnJlcGxhY2VQcm9wcygpIG9mIGEgRE9NIG5vZGUuICcgKyAnSW5zdGVhZCwgY2FsbCBSZWFjdERPTS5yZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWNvbXBvbmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbChjb21wb25lbnQsIHBhcnRpYWxQcm9wcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwoY29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZXMgdW5kZWZpbmVkIGFuZCB0aGF0XG4gIC8vIGluZiBhbmQgbmFuIGRvbid0IGJlY29tZSBudWxsXG4gIHJldHVybiBTdHJpbmcob2JqKTtcbn1cblxudmFyIHN0eWxlTXV0YXRpb25XYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZShzdHlsZTEsIHN0eWxlMiwgY29tcG9uZW50KSB7XG4gIGlmIChzdHlsZTEgPT0gbnVsbCB8fCBzdHlsZTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hhbGxvd0VxdWFsKHN0eWxlMSwgc3R5bGUyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50Ll90YWc7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXIpIHtcbiAgICBvd25lck5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gIH1cblxuICB2YXIgaGFzaCA9IG93bmVyTmFtZSArICd8JyArIGNvbXBvbmVudE5hbWU7XG5cbiAgaWYgKHN0eWxlTXV0YXRpb25XYXJuaW5nLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3R5bGVNdXRhdGlvbldhcm5pbmdbaGFzaF0gPSB0cnVlO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYCVzYCB3YXMgcGFzc2VkIGEgc3R5bGUgb2JqZWN0IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBtdXRhdGVkLiAnICsgJ011dGF0aW5nIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgY2xvbmluZyBpdCBiZWZvcmVoYW5kLiBDaGVjayAnICsgJ3RoZSBgcmVuZGVyYCAlcy4gUHJldmlvdXMgc3R5bGU6ICVzLiBNdXRhdGVkIHN0eWxlOiAlcy4nLCBjb21wb25lbnROYW1lLCBvd25lciA/ICdvZiBgJyArIG93bmVyTmFtZSArICdgJyA6ICd1c2luZyA8JyArIGNvbXBvbmVudE5hbWUgKyAnPicsIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMSksIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMikpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5vdCBoYXZlIGBjaGlsZHJlbmAgb3IgJyArICd1c2UgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHVuZGVmaW5lZDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArICdub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuICcgKyAndXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJRTggaGFzIG5vIEFQSSBmb3IgZXZlbnQgY2FwdHVyaW5nIGFuZCB0aGUgYG9uU2Nyb2xsYCBldmVudCBkb2Vzbid0XG4gICAgLy8gYnViYmxlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHJlZ2lzdHJhdGlvbk5hbWUgIT09ICdvblNjcm9sbCcgfHwgaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSksICdUaGlzIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgdGhlIGBvblNjcm9sbGAgZXZlbnQnKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICB2YXIgZG9jID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSA/IGNvbnRhaW5lci5vd25lckRvY3VtZW50IDogY29udGFpbmVyO1xuICAgIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIH1cbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGlkOiBpZCxcbiAgICByZWdpc3RyYXRpb25OYW1lOiByZWdpc3RyYXRpb25OYW1lLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHV0TGlzdGVuZXIoKSB7XG4gIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcztcbiAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaWQsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50c0xvY2FsKCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpbnN0Ll9yb290Tm9kZUlEKTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBjcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc1tldmVudF0sIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wUmVzZXQsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdCwgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVhZHlJbnB1dFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NSW5wdXQubW91bnRSZWFkeVdyYXBwZXIodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsIGNhc2VkIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxuLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gYXNzaWduKHtcbiAgJ21lbnVpdGVtJzogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9ICh7fSkuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkVGFnQ2FjaGUsIHRhZykpIHtcbiAgICAhVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHRhZzogJXMnLCB0YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIGluc3QpIHtcbiAgLy8gUGFzcyBkb3duIG91ciB0YWcgbmFtZSB0byBjaGlsZCBjb21wb25lbnRzIGZvciB2YWxpZGF0aW9uIHB1cnBvc2VzXG4gIGNvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICB2YXIgaW5mbyA9IGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldO1xuICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKGluZm8sIGluc3QuX3RhZywgaW5zdCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPj0gMCB8fCBwcm9wcy5pcyAhPSBudWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KHRhZykge1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gICAgdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBUaGUgcm9vdCBET00gSUQgZm9yIHRoaXMgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAgICAgbGlzdGVuZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgUmVhY3RET01PcHRpb24ubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01TZWxlY3QubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQgPSBSZWFjdERPTVNlbGVjdC5wcm9jZXNzQ2hpbGRDb250ZXh0KHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSkge1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCB0aGlzLCBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2ID0gcHJvY2Vzc0NoaWxkQ29udGV4dERldihjb250ZXh0LCB0aGlzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2O1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNvbnRleHRbUmVhY3RNb3VudC5vd25lckRvY3VtZW50Q29udGV4dEtleV07XG4gICAgICB2YXIgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9ySUQoZWwsIHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgLy8gUG9wdWxhdGUgbm9kZSBjYWNoZVxuICAgICAgUmVhY3RNb3VudC5nZXRJRChlbCk7XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKHt9LCBwcm9wcywgdHJhbnNhY3Rpb24sIGVsKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUluaXRpYWxDaGlsZHJlbih0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGVsKTtcbiAgICAgIG1vdW50SW1hZ2UgPSBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZ09wZW4gPSB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBwcm9wcyk7XG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShtb3VudFJlYWR5SW5wdXRXcmFwcGVyLCB0aGlzKTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XG4gICAgdmFyIHJldCA9ICc8JyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAocHJvcEtleSAhPT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cEZvcklEID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHJldHVybiByZXQgKyAnICcgKyBtYXJrdXBGb3JJRDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgZWwpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChlbCwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHNldFRleHRDb250ZW50KGVsLCBjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgbmF0aXZlIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gSWYgdGhlIGNvbnRleHQgaXMgcmVmZXJlbmNlLWVxdWFsIHRvIHRoZSBvbGQgb25lLCBwYXNzIGRvd24gdGhlIHNhbWVcbiAgICAgIC8vIHByb2Nlc3NlZCBvYmplY3Qgc28gdGhlIHVwZGF0ZSBiYWlsb3V0IGluIFJlYWN0UmVjb25jaWxlciBiZWhhdmVzXG4gICAgICAvLyBjb3JyZWN0bHkgKGFuZCBpZGVudGljYWxseSBpbiBkZXYgYW5kIHByb2QpLiBTZWUgIzUwMDUuXG4gICAgICBpZiAodGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXYgPSBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIHRoaXMpO1xuICAgICAgfVxuICAgICAgY29udGV4dCA9IHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXY7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBudWxsKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKCFjYW5EZWZpbmVQcm9wZXJ0eSAmJiB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgbm9kZSkge1xuICAgIHZhciBwcm9wS2V5O1xuICAgIHZhciBzdHlsZU5hbWU7XG4gICAgdmFyIHN0eWxlVXBkYXRlcztcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXG4gICAgICAgICAgLy8gZWxzZSB3aWxsRGVsZXRlTGlzdGVuZXIgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSB3YXNuJ3QgYWN0dWFsbHkgYVxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgbmV4dFByb3AgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGFudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgIH1cbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZVVwZGF0ZXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZVxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbGFzdFByb3BzLmNoaWxkcmVuXSA/IGxhc3RQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgdmFyIG5leHRDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcblxuICAgIC8vIE5vdGUgdGhlIHVzZSBvZiBgIT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgdmFyIGxhc3RDaGlsZHJlbiA9IGxhc3RDb250ZW50ICE9IG51bGwgPyBudWxsIDogbGFzdFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGNoaWxkcmVuIHRvIGNvbnRlbnQvaHRtbCBvciB2aWNlIHZlcnNhLCByZW1vdmVcbiAgICAvLyB0aGUgb2xkIGNvbnRlbnRcbiAgICB2YXIgbGFzdEhhc0NvbnRlbnRPckh0bWwgPSBsYXN0Q29udGVudCAhPSBudWxsIHx8IGxhc3RIdG1sICE9IG51bGw7XG4gICAgdmFyIG5leHRIYXNDb250ZW50T3JIdG1sID0gbmV4dENvbnRlbnQgIT0gbnVsbCB8fCBuZXh0SHRtbCAhPSBudWxsO1xuICAgIGlmIChsYXN0Q2hpbGRyZW4gIT0gbnVsbCAmJiBuZXh0Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihudWxsLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChsYXN0SGFzQ29udGVudE9ySHRtbCAmJiAhbmV4dEhhc0NvbnRlbnRPckh0bWwpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycpO1xuICAgIH1cblxuICAgIGlmIChuZXh0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdENvbnRlbnQgIT09IG5leHRDb250ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycgKyBuZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQudW5tb3VudFdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgJyArICdpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCAnICsgJzxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhICcgKyAnc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgJyArICdlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcblxuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IHRoaXM7XG4gICAgICBub2RlLmdldERPTU5vZGUgPSBsZWdhY3lHZXRET01Ob2RlO1xuICAgICAgbm9kZS5pc01vdW50ZWQgPSBsZWdhY3lJc01vdW50ZWQ7XG4gICAgICBub2RlLnNldFN0YXRlID0gbGVnYWN5U2V0U3RhdGVFdGM7XG4gICAgICBub2RlLnJlcGxhY2VTdGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5mb3JjZVVwZGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5zZXRQcm9wcyA9IGxlZ2FjeVNldFByb3BzO1xuICAgICAgbm9kZS5yZXBsYWNlUHJvcHMgPSBsZWdhY3lSZXBsYWNlUHJvcHM7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIGxlZ2FjeVByb3BzRGVzY3JpcHRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50IHdpbGwgdXBkYXRlIHRoaXMgcHJvcGVydHkgb24gc3Vic2VxdWVudCByZW5kZXJzXG4gICAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGVDb21wb25lbnQgd2lsbCB1cGRhdGUgdGhpcyBwcm9wZXJ0eSBvbiBzdWJzZXF1ZW50IHJlbmRlcnNcbiAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdERPTUNvbXBvbmVudCwgJ1JlYWN0RE9NQ29tcG9uZW50Jywge1xuICBtb3VudENvbXBvbmVudDogJ21vdW50Q29tcG9uZW50JyxcbiAgdXBkYXRlQ29tcG9uZW50OiAndXBkYXRlQ29tcG9uZW50J1xufSk7XG5cbmFzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQXV0b0ZvY3VzVXRpbHNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG5cbnZhciBNaXhpbiA9IHtcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgIGZvY3VzTm9kZShmaW5kRE9NTm9kZSh0aGlzKSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIE1peGluOiBNaXhpbixcblxuICBmb2N1c0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIGZvY3VzTm9kZShSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9Gb2N1c1V0aWxzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9jdXNOb2RlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL2ZvY3VzTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xudmFyIGRhbmdlcm91c1N0eWxlVmFsdWUgPSByZXF1aXJlKCcuL2Rhbmdlcm91c1N0eWxlVmFsdWUnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBtZW1vaXplU3RyaW5nT25seSA9IHJlcXVpcmUoJ2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbn0pO1xuXG52YXIgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSBmYWxzZTtcbnZhciBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnY3NzRmxvYXQnO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgdGVtcFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHRyeSB7XG4gICAgLy8gSUU4IHRocm93cyBcIkludmFsaWQgYXJndW1lbnQuXCIgaWYgcmVzZXR0aW5nIHNob3J0aGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgIHRlbXBTdHlsZS5mb250ID0gJyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IHRydWU7XG4gIH1cbiAgLy8gSUU4IG9ubHkgc3VwcG9ydHMgYWNjZXNzaW5nIGNzc0Zsb2F0IChzdGFuZGFyZCkgYXMgc3R5bGVGbG9hdFxuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmNzc0Zsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnc3R5bGVGbG9hdCc7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSkgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiAnICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSkgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWFsaXplZCArPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKi9cbiAgc2V0VmFsdWVGb3JTdHlsZXM6IGZ1bmN0aW9uIChub2RlLCBzdHlsZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVGbG9hdEFjY2Vzc29yO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgJiYgQ1NTUHJvcGVydHkuc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zW3N0eWxlTmFtZV07XG4gICAgICAgIGlmIChleHBhbnNpb24pIHtcbiAgICAgICAgICAvLyBTaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBJRTggd29uJ3QgbGlrZSB1bnNldHRpbmcsIHNvIHVuc2V0IGVhY2hcbiAgICAgICAgICAvLyBjb21wb25lbnQgdG8gcGxhY2F0ZSBpdFxuICAgICAgICAgIGZvciAodmFyIGluZGl2aWR1YWxTdHlsZU5hbWUgaW4gZXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBzdHlsZVtpbmRpdmlkdWFsU3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKENTU1Byb3BlcnR5T3BlcmF0aW9ucywgJ0NTU1Byb3BlcnR5T3BlcmF0aW9ucycsIHtcbiAgc2V0VmFsdWVGb3JTdHlsZXM6ICdzZXRWYWx1ZUZvclN0eWxlcydcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWVcbiAgfSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXG4gICAgb3V0bGluZUNvbG9yOiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW1lbGl6ZVN0eWxlTmFtZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbWVsaXplXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9jYW1lbGl6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGFuZ2Vyb3VzU3R5bGVWYWx1ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBoeXBoZW5hdGVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIvaHlwaGVuYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWVtb2l6ZVN0cmluZ09ubHlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUJ1dHRvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vdXNlTGlzdGVuZXJOYW1lcyA9IHtcbiAgb25DbGljazogdHJ1ZSxcbiAgb25Eb3VibGVDbGljazogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VNb3ZlOiB0cnVlLFxuICBvbk1vdXNlVXA6IHRydWUsXG5cbiAgb25DbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPGJ1dHRvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01CdXR0b24gPSB7XG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgcHJvcHMsIGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzXG4gICAgdmFyIG5hdGl2ZVByb3BzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhbW91c2VMaXN0ZW5lck5hbWVzW2tleV0pIHtcbiAgICAgICAgbmF0aXZlUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQnV0dG9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW5wdXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RJRCA9IHt9O1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cbnZhciBSZWFjdERPTUlucHV0ID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgdmFyIGNoZWNrZWQgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldENoZWNrZWQocHJvcHMpO1xuXG4gICAgdmFyIG5hdGl2ZVByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuZGVmYXVsdENoZWNrZWQgfHwgZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IGRlZmF1bHRWYWx1ZSAhPSBudWxsID8gZGVmYXVsdFZhbHVlIDogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuICB9LFxuXG4gIG1vdW50UmVhZHlXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIENhbid0IGJlIGluIG1vdW50V3JhcHBlciBvciBlbHNlIHNlcnZlciByZW5kZXJpbmcgbGVha3MuXG4gICAgaW5zdGFuY2VzQnlSZWFjdElEW2luc3QuX3Jvb3ROb2RlSURdID0gaW5zdDtcbiAgfSxcblxuICB1bm1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdElEW2luc3QuX3Jvb3ROb2RlSURdO1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBSZWFjdERPTUlET3BlcmF0aW9ucy51cGRhdGVQcm9wZXJ0eUJ5SUQoaW5zdC5fcm9vdE5vZGVJRCwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3Qgd2l0aCBub24tUmVhY3QuXG4gICAgICB2YXIgb3RoZXJJRCA9IFJlYWN0TW91bnQuZ2V0SUQob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlcklEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSAnICsgJ3NhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBpbnN0YW5jZXNCeVJlYWN0SURbb3RoZXJJRF07XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBVbmtub3duIHJhZGlvIGJ1dHRvbiBJRCAlcy4nLCBvdGhlcklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCBvdGhlckluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnY2hlY2tib3gnOiB0cnVlLFxuICAnaW1hZ2UnOiB0cnVlLFxuICAnaGlkZGVuJzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSAnICsgJ2NoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMudmFsdWUgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCAnICsgJ3RvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuICcgKyAnSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWQgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gJyArICd1c2UgY2hlY2tlZExpbmsnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBvbkNoYW5nZTogUmVhY3RQcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvTGlua2VkVmFsdWVVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcblxuICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdSZXF1aXJlZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHdhcyBub3Qgc3BlY2lmaWVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJyk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gZXhwZWN0ZWRWYWx1ZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbi8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHJldHVybiAnPDxhbm9ueW1vdXM+Pic7XG4gIH1cbiAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEl0ZXJhdG9yRm5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzXG4gKiogbW9kdWxlIGlkID0gMTA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01PcHRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsdWVDb250ZXh0S2V5ID0gUmVhY3RET01TZWxlY3QudmFsdWVDb250ZXh0S2V5O1xuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnIHZpYSBjb250ZXh0XG4gICAgdmFyIHNlbGVjdFZhbHVlID0gY29udGV4dFt2YWx1ZUNvbnRleHRLZXldO1xuXG4gICAgLy8gSWYgY29udGV4dCBrZXkgaXMgbnVsbCAoZS5nLiwgbm8gc3BlY2lmaWVkIHZhbHVlIG9yIGFmdGVyIGluaXRpYWwgbW91bnQpXG4gICAgLy8gb3IgbWlzc2luZyAoZS5nLiwgZm9yIDxkYXRhbGlzdD4pLCB3ZSBkb24ndCBjaGFuZ2UgcHJvcHMuc2VsZWN0ZWRcbiAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtpXSA9PT0gJycgKyBwcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09ICcnICsgcHJvcHMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0geyBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcbiAgfSxcblxuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIG5hdGl2ZVByb3BzID0gYXNzaWduKHsgc2VsZWN0ZWQ6IHVuZGVmaW5lZCwgY2hpbGRyZW46IHVuZGVmaW5lZCB9LCBwcm9wcyk7XG5cbiAgICAvLyBSZWFkIHN0YXRlIG9ubHkgZnJvbSBpbml0aWFsIG1vdW50IGJlY2F1c2UgPHNlbGVjdD4gdXBkYXRlcyB2YWx1ZVxuICAgIC8vIG1hbnVhbGx5OyB3ZSBuZWVkIHRoZSBpbml0aWFsIHN0YXRlIG9ubHkgZm9yIHNlcnZlciByZW5kZXJpbmdcbiAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgIG5hdGl2ZVByb3BzLnNlbGVjdGVkID0gaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gJyc7XG5cbiAgICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAgIFJlYWN0Q2hpbGRyZW4uZm9yRWFjaChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIG5hdGl2ZVByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlUHJvcHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8oPyFcXC8pL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJy8vJyk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdDtcbiAgdmFyIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeDtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZCAhPT0gY2hpbGQgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5IHx8ICcnKSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdHJhdmVyc2VBbGxDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLlNFUEFSQVRPUjtcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyTG9va3VwID0ge1xuICAnPSc6ICc9MCcsXG4gICcuJzogJz0xJyxcbiAgJzonOiAnPTInXG59O1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvWz0uOl0vZztcblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXNlclByb3ZpZGVkS2V5RXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cFttYXRjaF07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gd3JhcFVzZXJQcm92aWRlZEtleShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEVzY2FwZSBhIGNvbXBvbmVudCBrZXkgc28gdGhhdCBpdCBpcyBzYWZlIHRvIHVzZSBpbiBhIHJlYWN0aWQuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IENvbXBvbmVudCBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyKTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgYGtleWAgdmFsdWUgZXhwbGljaXRseSBwcm92aWRlZCBieSB0aGUgdXNlciB0byBkaXN0aW5ndWlzaCBpdCBmcm9tXG4gKiBpbXBsaWNpdGx5LWdlbmVyYXRlZCBrZXlzIGdlbmVyYXRlZCBieSBhIGNvbXBvbmVudCdzIGluZGV4IGluIGl0cyBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBWYWx1ZSBvZiBhIHVzZXItcHJvdmlkZWQgYGtleWAgYXR0cmlidXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHdyYXBVc2VyUHJvdmlkZWRLZXkoa2V5KSB7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoa2V5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIHdyYXBVc2VyUHJvdmlkZWRLZXkoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEl0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50ICcgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbHVlQ29udGV4dEtleSA9ICdfX1JlYWN0RE9NU2VsZWN0X3ZhbHVlJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEICYmIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcykge1xuICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBvd25lcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBpbnN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlXG4gKiBAcGFyYW0geyp9IHByb3BWYWx1ZSBBIHN0cmluZ2FibGUgKHdpdGggYG11bHRpcGxlYCwgYSBsaXN0IG9mIHN0cmluZ2FibGVzKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoaW5zdCwgbXVsdGlwbGUsIHByb3BWYWx1ZSkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaTtcbiAgdmFyIG9wdGlvbnMgPSBSZWFjdE1vdW50LmdldE5vZGUoaW5zdC5fcm9vdE5vZGVJRCkub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHByb3BWYWx1ZVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcHRpb25zW2ldLnZhbHVlID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xuICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cbnZhciBSZWFjdERPTVNlbGVjdCA9IHtcbiAgdmFsdWVDb250ZXh0S2V5OiB2YWx1ZUNvbnRleHRLZXksXG5cbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHJldHVybiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBwZW5kaW5nVXBkYXRlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIHdhc011bHRpcGxlOiBCb29sZWFuKHByb3BzLm11bHRpcGxlKVxuICAgIH07XG4gIH0sXG5cbiAgcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gUGFzcyBkb3duIGluaXRpYWwgdmFsdWUgc28gaW5pdGlhbCBnZW5lcmF0ZWQgbWFya3VwIGhhcyBjb3JyZWN0XG4gICAgLy8gYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGFzc2lnbih7fSwgY29udGV4dCk7XG4gICAgY2hpbGRDb250ZXh0W3ZhbHVlQ29udGV4dEtleV0gPSBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICAgIHJldHVybiBjaGlsZENvbnRleHQ7XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGUgY29udGV4dCB2YWx1ZSBkb3duXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciB3YXNNdWx0aXBsZSA9IGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSBCb29sZWFuKHByb3BzLm11bHRpcGxlKTtcblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpKSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRhcmVhXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLlxuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIC8vIFdlIHNhdmUgdGhlIGluaXRpYWwgdmFsdWUgc28gdGhhdCBgUmVhY3RET01Db21wb25lbnRgIGRvZXNuJ3QgdXBkYXRlXG4gICAgICAvLyBgdGV4dENvbnRlbnRgICh1bm5lY2Vzc2FyeSBzaW5jZSB3ZSB1cGRhdGUgdmFsdWUpLlxuICAgICAgLy8gVGhlIGluaXRpYWwgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzXG4gICAgICAvLyBmb3JjZWQgdG8gYmUgYSBzdHJpbmcuXG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgKHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZSksXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkUmVjb25jaWxlcicpO1xuXG52YXIgZmxhdHRlbkNoaWxkcmVuID0gcmVxdWlyZSgnLi9mbGF0dGVuQ2hpbGRyZW4nKTtcblxuLyoqXG4gKiBVcGRhdGluZyBjaGlsZHJlbiBvZiBhIGNvbXBvbmVudCBtYXkgdHJpZ2dlciByZWN1cnNpdmUgdXBkYXRlcy4gVGhlIGRlcHRoIGlzXG4gKiB1c2VkIHRvIGJhdGNoIHJlY3Vyc2l2ZSB1cGRhdGVzIHRvIHJlbmRlciBtYXJrdXAgbW9yZSBlZmZpY2llbnRseS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVwZGF0ZURlcHRoID0gMDtcblxuLyoqXG4gKiBRdWV1ZSBvZiB1cGRhdGUgY29uZmlndXJhdGlvbiBvYmplY3RzLlxuICpcbiAqIEVhY2ggb2JqZWN0IGhhcyBhIGB0eXBlYCBwcm9wZXJ0eSB0aGF0IGlzIGluIGBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc2AuXG4gKlxuICogQHR5cGUge2FycmF5PG9iamVjdD59XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXBkYXRlUXVldWUgPSBbXTtcblxuLyoqXG4gKiBRdWV1ZSBvZiBtYXJrdXAgdG8gYmUgcmVuZGVyZWQuXG4gKlxuICogQHR5cGUge2FycmF5PHN0cmluZz59XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbWFya3VwUXVldWUgPSBbXTtcblxuLyoqXG4gKiBFbnF1ZXVlcyBtYXJrdXAgdG8gYmUgcmVuZGVyZWQgYW5kIGluc2VydGVkIGF0IGEgc3VwcGxpZWQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZUluc2VydE1hcmt1cChwYXJlbnRJRCwgbWFya3VwLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUCxcbiAgICBtYXJrdXBJbmRleDogbWFya3VwUXVldWUucHVzaChtYXJrdXApIC0gMSxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4XG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVNb3ZlKHBhcmVudElELCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogdG9JbmRleFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVJlbW92ZShwYXJlbnRJRCwgZnJvbUluZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREUsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGZyb21JbmRleCxcbiAgICB0b0luZGV4OiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIHNldHRpbmcgdGhlIG1hcmt1cCBvZiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVTZXRNYXJrdXAocGFyZW50SUQsIG1hcmt1cCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlNFVF9NQVJLVVAsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVUZXh0Q29udGVudChwYXJlbnRJRCwgdGV4dENvbnRlbnQpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgY29udGVudDogdGV4dENvbnRlbnQsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgaWYgKHVwZGF0ZVF1ZXVlLmxlbmd0aCkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyh1cGRhdGVRdWV1ZSwgbWFya3VwUXVldWUpO1xuICAgIGNsZWFyUXVldWUoKTtcbiAgfVxufVxuXG4vKipcbiAqIENsZWFycyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICB1cGRhdGVRdWV1ZS5sZW5ndGggPSAwO1xuICBtYXJrdXBRdWV1ZS5sZW5ndGggPSAwO1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcblxuICAvKipcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxuICAgKiBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIGJ5IGBSZWFjdERPTUNvbXBvbmVudGAgdG8gbW91bnQsIHVwZGF0ZSwgYW5kXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE11bHRpQ2hpbGQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIF9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIF9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIG5leHRDaGlsZHJlbjtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMpO1xuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICAvLyBJbmxpbmVkIGZvciBwZXJmb3JtYW5jZSwgc2VlIGBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdElEYC5cbiAgICAgICAgICB2YXIgcm9vdElEID0gdGhpcy5fcm9vdE5vZGVJRCArIG5hbWU7XG4gICAgICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24gKG5leHRDb250ZW50KSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuKTtcbiAgICAgICAgLy8gVE9ETzogVGhlIHNldFRleHRDb250ZW50IG9wZXJhdGlvbiBzaG91bGQgYmUgZW5vdWdoXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBuZXcgdGV4dCBjb250ZW50LlxuICAgICAgICB0aGlzLnNldFRleHRDb250ZW50KG5leHRDb250ZW50KTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbWFya3VwIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0TWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlTWFya3VwOiBmdW5jdGlvbiAobmV4dE1hcmt1cCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbik7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkQnlOYW1lKHByZXZDaGlsZHJlbltuYW1lXSwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0TWFya3VwKG5leHRNYXJrdXApO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBuZXcgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbXByb3ZlIHBlcmZvcm1hbmNlIGJ5IGlzb2xhdGluZyB0aGlzIGhvdCBjb2RlIHBhdGggZnJvbSB0aGUgdHJ5L2NhdGNoXG4gICAgICogYmxvY2sgaW4gYHVwZGF0ZUNoaWxkcmVuYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW47XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XG4gICAgICAgICAgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBuZXh0SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIHByZXZDaGlsZC5fbW91bnRJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGBfbW91bnRJbmRleGAgZ2V0cyB1bnNldCBieSB1bm1vdW50aW5nLlxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHRoaXMuX21vdW50Q2hpbGRCeU5hbWVBdEluZGV4KG5leHRDaGlsZCwgbmFtZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocmVuZGVyZWRDaGlsZHJlbik7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhlIHN1cHBsaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgZW5xdWV1ZU1vdmUodGhpcy5fcm9vdE5vZGVJRCwgY2hpbGQuX21vdW50SW5kZXgsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBtb3VudEltYWdlKSB7XG4gICAgICBlbnF1ZXVlSW5zZXJ0TWFya3VwKHRoaXMuX3Jvb3ROb2RlSUQsIG1vdW50SW1hZ2UsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENoaWxkIHRvIHJlbW92ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgZW5xdWV1ZVJlbW92ZSh0aGlzLl9yb290Tm9kZUlELCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodGV4dENvbnRlbnQpIHtcbiAgICAgIGVucXVldWVUZXh0Q29udGVudCh0aGlzLl9yb290Tm9kZUlELCB0ZXh0Q29udGVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gc2V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICAgIGVucXVldWVTZXRNYXJrdXAodGhpcy5fcm9vdE5vZGVJRCwgbWFya3VwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGEgY2hpbGQgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91bnRDaGlsZEJ5TmFtZUF0SW5kZXg6IGZ1bmN0aW9uIChjaGlsZCwgbmFtZSwgaW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAvLyBJbmxpbmVkIGZvciBwZXJmb3JtYW5jZSwgc2VlIGBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdElEYC5cbiAgICAgIHZhciByb290SUQgPSB0aGlzLl9yb290Tm9kZUlEICsgbmFtZTtcbiAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICB0aGlzLmNyZWF0ZUNoaWxkKGNoaWxkLCBtb3VudEltYWdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYSByZW5kZXJlZCBjaGlsZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byB1bm1vdW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VubW91bnRDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gbnVsbDtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZFJlY29uY2lsZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RhbmNlcywgY2hpbGQsIG5hbWUpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciBrZXlVbmlxdWUgPSBjaGlsZEluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGtleVVuaXF1ZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsIG5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmIChjaGlsZCAhPSBudWxsICYmIGtleVVuaXF1ZSkge1xuICAgIGNoaWxkSW5zdGFuY2VzW25hbWVdID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjaGlsZCwgbnVsbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFjdENoaWxkUmVjb25jaWxlciBwcm92aWRlcyBoZWxwZXJzIGZvciBpbml0aWFsaXppbmcgb3IgdXBkYXRpbmcgYSBzZXQgb2ZcbiAqIGNoaWxkcmVuLiBJdHMgb3V0cHV0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIGl0IG9udG8gUmVhY3RNdWx0aUNoaWxkIHdoaWNoXG4gKiBkb2VzIGRpZmZlZCByZW9yZGVyaW5nIGFuZCBpbnNlcnRpb24uXG4gKi9cbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkTm9kZXMgTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBpbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBpbnN0YW50aWF0ZUNoaWxkLCBjaGlsZEluc3RhbmNlcyk7XG4gICAgcmV0dXJuIGNoaWxkSW5zdGFuY2VzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiBhbmQgcmV0dXJucyBhIG5ldyBzZXQgb2YgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDaGlsZHJlbiBGbGF0IGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIG5ldyBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgLy8gV2UgY3VycmVudGx5IGRvbid0IGhhdmUgYSB3YXkgdG8gdHJhY2sgbW92ZXMgaGVyZSBidXQgaWYgd2UgdXNlIGl0ZXJhdG9yc1xuICAgIC8vIGluc3RlYWQgb2YgZm9yLi5pbiB3ZSBjYW4gemlwIHRoZSBpdGVyYXRvcnMgYW5kIGNoZWNrIGlmIGFuIGl0ZW0gaGFzXG4gICAgLy8gbW92ZWQuXG4gICAgLy8gVE9ETzogSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgcmV0dXJuIHRoZSBwcmV2Q2hpbGRyZW4gb2JqZWN0IHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcXVpY2tseSBiYWlsb3V0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q2hpbGQgJiYgcHJldkNoaWxkLl9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgIGlmIChwcmV2Q2hpbGQgIT0gbnVsbCAmJiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDaGlsZCwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gcHJldkNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIG51bGwpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBuZXh0Q2hpbGRJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5tb3VudCBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkcmVuW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHJlbmRlcmVkQ2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAocmVuZGVyZWRDaGlsZHJlbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkUmVjb25jaWxlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmbGF0dGVuQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9SZWFjdENvbXBvbmVudH0gY2hpbGQgUmVhY3QgY2hpbGQgY29tcG9uZW50LlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xuICB2YXIga2V5VW5pcXVlID0gcmVzdWx0W25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoa2V5VW5pcXVlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJywgbmFtZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XG4gICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNoYWxsb3dFcXVhbFxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIHZhciBiSGFzT3duUHJvcGVydHkgPSBoYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFiSGFzT3duUHJvcGVydHkoa2V5c0FbaV0pIHx8IG9iakFba2V5c0FbaV1dICE9PSBvYmpCW2tleXNBW2ldXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uJyk7XG5cbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcGFyZW50IFJlYWN0IGNvbXBvbmVudCBvZiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9IFBhcmVudCBjb250YWluZXIsIG9yIGBudWxsYCBpZiB0aGUgc3BlY2lmaWVkIG5vZGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IG5lc3RlZC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChub2RlKSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHZhciBub2RlSUQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICB2YXIgcm9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKHJvb3RJRCk7XG4gIHZhciBwYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY29udGFpbmVyKTtcbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIC8vIFRPRE86IFJlLWVuYWJsZSBldmVudC5wYXRoIGhhbmRsaW5nXG4gIC8vXG4gIC8vIGlmIChib29rS2VlcGluZy5uYXRpdmVFdmVudC5wYXRoICYmIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGgubGVuZ3RoID4gMSkge1xuICAvLyAgIC8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9IGVsc2Uge1xuICAvLyAgIC8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9XG5cbiAgdm9pZCBoYW5kbGVUb3BMZXZlbFdpdGhQYXRoOyAvLyB0ZW1wb3JhcmlseSB1bnVzZWRcbiAgaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZyk7XG59XG5cbi8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZykge1xuICB2YXIgdG9wTGV2ZWxUYXJnZXQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKSB8fCB3aW5kb3c7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRvcExldmVsVGFyZ2V0O1xuICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9wTGV2ZWxUYXJnZXQgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgdmFyIHRvcExldmVsVGFyZ2V0SUQgPSBSZWFjdE1vdW50LmdldElEKHRvcExldmVsVGFyZ2V0KSB8fCAnJztcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aChib29rS2VlcGluZykge1xuICB2YXIgcGF0aCA9IGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGg7XG4gIHZhciBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFswXTtcbiAgdmFyIGV2ZW50c0ZpcmVkID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudCA9IHBhdGhbaV07XG4gICAgaWYgKGN1cnJlbnRQYXRoRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSB7XG4gICAgICBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFtpICsgMV07XG4gICAgfVxuICAgIC8vIFRPRE86IHNsb3dcbiAgICB2YXIgcmVhY3RQYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICBpZiAocmVhY3RQYXJlbnQgPT09IGN1cnJlbnRQYXRoRWxlbWVudCkge1xuICAgICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudElEID0gUmVhY3RNb3VudC5nZXRJRChjdXJyZW50UGF0aEVsZW1lbnQpO1xuICAgICAgdmFyIG5ld1Jvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChjdXJyZW50UGF0aEVsZW1lbnRJRCk7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChjdXJyZW50UGF0aEVsZW1lbnQpO1xuXG4gICAgICB2YXIgdG9wTGV2ZWxUYXJnZXRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KSB8fCAnJztcbiAgICAgIGV2ZW50c0ZpcmVkKys7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgY3VycmVudFBhdGhFbGVtZW50LCB0b3BMZXZlbFRhcmdldElELCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgY3VycmVudE5hdGl2ZVRhcmdldCk7XG5cbiAgICAgIC8vIEp1bXAgdG8gdGhlIHJvb3Qgb2YgdGhpcyBSZWFjdCByZW5kZXIgdHJlZVxuICAgICAgd2hpbGUgKGN1cnJlbnRQYXRoRWxlbWVudElEICE9PSBuZXdSb290SUQpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnQgPSBwYXRoW2ldO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50c0ZpcmVkID09PSAwKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHdpbmRvdywgJycsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Njcm9sbCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDExOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudExpc3RlbmVyXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiAodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiAoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdE5hdGl2ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL1JlYWN0Um9vdEluZGV4Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuaW5qZWN0aW9uLFxuICBDbGFzczogUmVhY3RDbGFzcy5pbmplY3Rpb24sXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBOYXRpdmVDb21wb25lbnQ6IFJlYWN0TmF0aXZlQ29tcG9uZW50LmluamVjdGlvbixcbiAgUGVyZjogUmVhY3RQZXJmLmluamVjdGlvbixcbiAgUm9vdEluZGV4OiBSZWFjdFJvb3RJbmRleC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5qZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgTUlYSU5TX0tFWSA9IGtleU9mKHsgbWl4aW5zOiBudWxsIH0pO1xuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gKi9cbnZhciBTcGVjUG9saWN5ID0ga2V5TWlycm9yKHtcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgb25seSBvbmNlIGJ5IHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIG9yIG1peGluLlxuICAgKi9cbiAgREVGSU5FX09OQ0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIGJ5IGJvdGggdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gYW5kIG1peGlucy5cbiAgICogU3Vic2VxdWVudCBkZWZpbml0aW9ucyB3aWxsIGJlIGNoYWluZWQuIFRoZXNlIG1ldGhvZHMgbXVzdCByZXR1cm4gdm9pZC5cbiAgICovXG4gIERFRklORV9NQU5ZOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgb3ZlcnJpZGluZyB0aGUgYmFzZSBjbGFzcy5cbiAgICovXG4gIE9WRVJSSURFX0JBU0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBzaW1pbGFyIHRvIERFRklORV9NQU5ZLCBleGNlcHQgd2UgYXNzdW1lIHRoZXkgcmV0dXJuXG4gICAqIG9iamVjdHMuIFdlIHRyeSB0byBtZXJnZSB0aGUga2V5cyBvZiB0aGUgcmV0dXJuIHZhbHVlcyBvZiBhbGwgdGhlIG1peGVkIGluXG4gICAqIGZ1bmN0aW9ucy4gSWYgdGhlcmUgaXMgYSBrZXkgY29uZmxpY3Qgd2UgdGhyb3cuXG4gICAqL1xuICBERUZJTkVfTUFOWV9NRVJHRUQ6IG51bGxcbn0pO1xuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxudmFyIHdhcm5lZFNldFByb3BzID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuU2V0UHJvcHMoKSB7XG4gIGlmICghd2FybmVkU2V0UHJvcHMpIHtcbiAgICB3YXJuZWRTZXRQcm9wcyA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdzZXRQcm9wcyguLi4pIGFuZCByZXBsYWNlUHJvcHMoLi4uKSBhcmUgZGVwcmVjYXRlZC4gJyArICdJbnN0ZWFkLCBjYWxsIHJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLicpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAqIG9yIG5hdGl2ZSBjb21wb25lbnRzLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEBub3NpZGVlZmZlY3RzXG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAqXG4gICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAqICAgICB9KTtcbiAgICogICB9XG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgKiB1cGRhdGUuXG4gICAqXG4gICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAqXG4gICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogU3BlY1BvbGljeS5PVkVSUklERV9CQVNFXG5cbn07XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICovXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIH0sXG4gIG1peGluczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLCBjb250ZXh0VHlwZXMpO1xuICB9LFxuICAvKipcbiAgICogU3BlY2lhbCBjYXNlIGdldERlZmF1bHRQcm9wcyB3aGljaCBzaG91bGQgbW92ZSBpbnRvIHN0YXRpY3MgYnV0IHJlcXVpcmVzXG4gICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgIH1cbiAgfSxcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHByb3BUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gIH0sXG4gIHN0YXRpY3M6IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgfSxcbiAgYXV0b2JpbmQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cbi8vIG5vb3BcbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIGludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG5vdCBpbiBfX0RFVl9fXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUocHJvdG8sIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5PVkVSUklERV9CQVNFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArICdgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyAnICsgJ2RvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICsgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSAnICsgJ3RvIGEgbWl4aW4uJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgISh0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICsgJ3VzZSBhIGNvbXBvbmVudCBjbGFzcyBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgISFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3BlYykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICsgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUocHJvdG8sIG5hbWUpO1xuXG4gICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID0gaXNGdW5jdGlvbiAmJiAhaXNSZWFjdENsYXNzTWV0aG9kICYmICFpc0FscmVhZHlEZWZpbmVkICYmIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgaWYgKCFwcm90by5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXBbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgIShpc1JlYWN0Q2xhc3NNZXRob2QgJiYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgJyArICd3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJywgc3BlY1BvbGljeSwgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICBpZiAoIXN0YXRpY3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gKG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTKTtcbiAgICAhIWlzUmVzZXJ2ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkICcgKyAncHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0ICcgKyAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICsgJ2NvbnN0cnVjdG9yLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBpc0luaGVyaXRlZCA9IChuYW1lIGluIENvbnN0cnVjdG9yKTtcbiAgICAhIWlzSW5oZXJpdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSAnICsgJ2R1ZSB0byBhIG1peGluLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAhKG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAhKG9uZVtrZXldID09PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogJyArICdUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCAnICsgJ21heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byAnICsgJ2dldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgJyArICd3aXRoIGNsYXNoaW5nIGtleXMuJywga2V5KSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb25lO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIGMgPSB7fTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyLCBuby11bmRlZiAqL1xuICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICsgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgIH1cbiAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG4vKipcbiAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICBmb3IgKHZhciBhdXRvQmluZEtleSBpbiBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgaWYgKGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXAuaGFzT3duUHJvcGVydHkoYXV0b0JpbmRLZXkpKSB7XG4gICAgICB2YXIgbWV0aG9kID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcFthdXRvQmluZEtleV07XG4gICAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gKi9cbnZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAqL1xuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVyLmlzTW91bnRlZCh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQHB1YmxpY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc2V0UHJvcHM6IGZ1bmN0aW9uIChwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5TZXRQcm9wcygpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFByb3BzKHRoaXMsIHBhcnRpYWxQcm9wcyk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYWxsIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBwdWJsaWNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHJlcGxhY2VQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzLCBjYWxsYmFjaykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuU2V0UHJvcHMoKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlUHJvcHModGhpcywgbmV3UHJvcHMpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDbGFzc1xuICovXG52YXIgUmVhY3RDbGFzcyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbiAoc3BlYykge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBpcyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9O1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICBpbmplY3RlZE1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENsYXNzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSAnICsgJ2Z1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocGFydGlhbFN0YXRlICE9IG51bGwsICdzZXRTdGF0ZSguLi4pOiBZb3UgcGFzc2VkIGFuIHVuZGVmaW5lZCBvciBudWxsIHN0YXRlIG9iamVjdDsgJyArICdpbnN0ZWFkLCB1c2UgZm9yY2VVcGRhdGUoKS4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGdldERPTU5vZGU6IFsnZ2V0RE9NTm9kZScsICdVc2UgUmVhY3RET00uZmluZERPTU5vZGUoY29tcG9uZW50KSBpbnN0ZWFkLiddLFxuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlUHJvcHM6IFsncmVwbGFjZVByb3BzJywgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ10sXG4gICAgc2V0UHJvcHM6IFsnc2V0UHJvcHMnLCAnSW5zdGVhZCwgY2FsbCByZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5URFoocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvciAmJiBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnc2V0UHJvcHMnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBOZXcgcHJvcHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwcm9wcykge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdyZXBsYWNlUHJvcHMnKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbihmb3JjZUhUTUwpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICAvLyBPbmx5IHNlcnZlci1zaWRlIHJlbmRlcmluZyByZWFsbHkgbmVlZHMgdGhpcyBvcHRpb24gKHNlZVxuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdgKSwgYnV0IHNlcnZlci1zaWRlIHVzZXNcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25gIGluc3RlYWQuIFRoaXMgb3B0aW9uIGlzIGhlcmUgc28gdGhhdCBpdCdzXG4gIC8vIGFjY2Vzc2libGUgYW5kIGRlZmF1bHRzIHRvIGZhbHNlIHdoZW4gYFJlYWN0RE9NQ29tcG9uZW50YCBhbmRcbiAgLy8gYFJlYWN0VGV4dENvbXBvbmVudGAgY2hlY2tzIGl0IGluIGBtb3VudENvbXBvbmVudGAuYFxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gZmFsc2U7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9ICFmb3JjZUhUTUwgJiYgUmVhY3RET01GZWF0dXJlRmxhZ3MudXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbmFzc2lnbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElucHV0U2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiAoaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JykpIHtcbiAgICAgIC8vIElFOCBpbnB1dC5cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIHNlbGVjdGlvbiBwZXIgZG9jdW1lbnQgaW4gSUUsIHNvIGl0IG11c3RcbiAgICAgIC8vIGJlIGluIG91ciBlbGVtZW50LlxuICAgICAgaWYgKHJhbmdlLnBhcmVudEVsZW1lbnQoKSA9PT0gaW5wdXQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiAtcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICBlbmQ6IC1yYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IFJlYWN0RE9NU2VsZWN0aW9uLmdldE9mZnNldHMoaW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICAgKiB0aGUgaW5wdXQuXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldHMpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIChpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSkge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Jyk7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSW4gRmlyZWZveCwgcmFuZ2Uuc3RhcnRDb250YWluZXIgYW5kIHJhbmdlLmVuZENvbnRhaW5lciBjYW4gYmUgXCJhbm9ueW1vdXNcbiAgLy8gZGl2c1wiLCBlLmcuIHRoZSB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91c1xuICAvLyBkaXZzIGRvIG5vdCBzZWVtIHRvIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZFxuICAvLyBlcnJvclwiIGlmIGFueSBvZiBpdHMgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZVxuICAvLyB3YXkgdG8gYXZvaWQgZXJyb3JpbmcgaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yXG4gIC8vIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmQgY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICBjdXJyZW50UmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXG4gIC8vIHRoaXMgdmFsdWUgd3JvbmcuXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQodGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0ZW1wUmFuZ2Uuc3RhcnRPZmZzZXQsIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQpO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc0JhY2t3YXJkID8gZW5kIDogc3RhcnQsXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldElFT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xuICB2YXIgc3RhcnQsIGVuZDtcblxuICBpZiAodHlwZW9mIG9mZnNldHMuZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBzdGFydDtcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xuICAgIGVuZCA9IG9mZnNldHMuc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuICB9XG5cbiAgcmFuZ2UubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcbiAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICByYW5nZS5zZWxlY3QoKTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gdHlwZW9mIG9mZnNldHMuZW5kID09PSAndW5kZWZpbmVkJyA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCove1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VsZWN0RXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2VsZWN0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51LCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4vLyBub3QgZXh0cmFjdCBldmVudHMuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcbnZhciBPTl9TRUxFQ1RfS0VZID0ga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkgfHwgdG9wTGV2ZWxUYXJnZXQuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudElEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9TRUxFQ1RfS0VZKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlcnZlclJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaXplIG9mIHRoZSByZWFjdFJvb3QgSUQgc3BhY2UuIFdlIGdlbmVyYXRlIHJhbmRvbSBudW1iZXJzIGZvciBSZWFjdCByb290XG4gKiBJRHMgYW5kIGlmIHRoZXJlJ3MgYSBjb2xsaXNpb24gdGhlIGV2ZW50cyBhbmQgRE9NIHVwZGF0ZSBzeXN0ZW0gd2lsbFxuICogZ2V0IGNvbmZ1c2VkLiBJbiB0aGUgZnV0dXJlIHdlIG5lZWQgYSB3YXkgdG8gZ2VuZXJhdGUgR1VJRHMgYnV0IGZvclxuICogbm93IHRoaXMgd2lsbCB3b3JrIG9uIGEgc21hbGxlciBzY2FsZS5cbiAqL1xudmFyIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVggPSBNYXRoLnBvdygyLCA1Myk7XG5cbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiBHTE9CQUxfTU9VTlRfUE9JTlRfTUFYKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJSZWFjdFJvb3RJbmRleDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU2VydmVyUmVhY3RSb290SW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTaW1wbGVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBhYm9ydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQWJvcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFib3J0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYmx1cjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmx1cjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmx1ckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5VGhyb3VnaDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2g6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db3B5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db3B5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkN1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRvdWJsZUNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Eb3VibGVDbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VudGVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW50ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0V4aXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0xlYXZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnTGVhdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ092ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJvcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJvcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJvcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGR1cmF0aW9uQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbXB0aWVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbXB0aWVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbXB0aWVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5jcnlwdGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuY3J5cHRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuZGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5kZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRXJyb3I6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVycm9yQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZm9jdXM6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkZvY3VzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Gb2N1c0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25JbnB1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW5wdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlEb3duOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5UHJlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVByZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlQcmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5VXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkRGF0YToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRlZE1ldGFkYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgLy8gTm90ZTogV2UgZG8gbm90IGFsbG93IGxpc3RlbmluZyB0byBtb3VzZU92ZXIgZXZlbnRzLiBJbnN0ZWFkLCB1c2UgdGhlXG4gIC8vIG9uTW91c2VFbnRlci9vbk1vdXNlTGVhdmUgY3JlYXRlZCBieSBgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luYC5cbiAgbW91c2VEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU91dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlVXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXN0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGFzdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhc3RlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGF1c2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBhdXNlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QYXVzZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwbGF5aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QbGF5aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QbGF5aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblByb2dyZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Qcm9ncmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJhdGVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmVzZXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJlc2V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TY3JvbGw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNjcm9sbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Vla2VkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVrZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzZWVraW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVraW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVraW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3RhbGxlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3RhbGxlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3RhbGxlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VibWl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdWJtaXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdXNwZW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdXNwZW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdXNwZW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdGltZVVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoQ2FuY2VsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB2b2x1bWVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2FpdGluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2FpdGluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BBYm9ydDogZXZlbnRUeXBlcy5hYm9ydCxcbiAgdG9wQmx1cjogZXZlbnRUeXBlcy5ibHVyLFxuICB0b3BDYW5QbGF5OiBldmVudFR5cGVzLmNhblBsYXksXG4gIHRvcENhblBsYXlUaHJvdWdoOiBldmVudFR5cGVzLmNhblBsYXlUaHJvdWdoLFxuICB0b3BDbGljazogZXZlbnRUeXBlcy5jbGljayxcbiAgdG9wQ29udGV4dE1lbnU6IGV2ZW50VHlwZXMuY29udGV4dE1lbnUsXG4gIHRvcENvcHk6IGV2ZW50VHlwZXMuY29weSxcbiAgdG9wQ3V0OiBldmVudFR5cGVzLmN1dCxcbiAgdG9wRG91YmxlQ2xpY2s6IGV2ZW50VHlwZXMuZG91YmxlQ2xpY2ssXG4gIHRvcERyYWc6IGV2ZW50VHlwZXMuZHJhZyxcbiAgdG9wRHJhZ0VuZDogZXZlbnRUeXBlcy5kcmFnRW5kLFxuICB0b3BEcmFnRW50ZXI6IGV2ZW50VHlwZXMuZHJhZ0VudGVyLFxuICB0b3BEcmFnRXhpdDogZXZlbnRUeXBlcy5kcmFnRXhpdCxcbiAgdG9wRHJhZ0xlYXZlOiBldmVudFR5cGVzLmRyYWdMZWF2ZSxcbiAgdG9wRHJhZ092ZXI6IGV2ZW50VHlwZXMuZHJhZ092ZXIsXG4gIHRvcERyYWdTdGFydDogZXZlbnRUeXBlcy5kcmFnU3RhcnQsXG4gIHRvcERyb3A6IGV2ZW50VHlwZXMuZHJvcCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IGV2ZW50VHlwZXMuZHVyYXRpb25DaGFuZ2UsXG4gIHRvcEVtcHRpZWQ6IGV2ZW50VHlwZXMuZW1wdGllZCxcbiAgdG9wRW5jcnlwdGVkOiBldmVudFR5cGVzLmVuY3J5cHRlZCxcbiAgdG9wRW5kZWQ6IGV2ZW50VHlwZXMuZW5kZWQsXG4gIHRvcEVycm9yOiBldmVudFR5cGVzLmVycm9yLFxuICB0b3BGb2N1czogZXZlbnRUeXBlcy5mb2N1cyxcbiAgdG9wSW5wdXQ6IGV2ZW50VHlwZXMuaW5wdXQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcExvYWRlZERhdGE6IGV2ZW50VHlwZXMubG9hZGVkRGF0YSxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IGV2ZW50VHlwZXMubG9hZGVkTWV0YWRhdGEsXG4gIHRvcExvYWRTdGFydDogZXZlbnRUeXBlcy5sb2FkU3RhcnQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BQYXVzZTogZXZlbnRUeXBlcy5wYXVzZSxcbiAgdG9wUGxheTogZXZlbnRUeXBlcy5wbGF5LFxuICB0b3BQbGF5aW5nOiBldmVudFR5cGVzLnBsYXlpbmcsXG4gIHRvcFByb2dyZXNzOiBldmVudFR5cGVzLnByb2dyZXNzLFxuICB0b3BSYXRlQ2hhbmdlOiBldmVudFR5cGVzLnJhdGVDaGFuZ2UsXG4gIHRvcFJlc2V0OiBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6IGV2ZW50VHlwZXMuc2Nyb2xsLFxuICB0b3BTZWVrZWQ6IGV2ZW50VHlwZXMuc2Vla2VkLFxuICB0b3BTZWVraW5nOiBldmVudFR5cGVzLnNlZWtpbmcsXG4gIHRvcFN0YWxsZWQ6IGV2ZW50VHlwZXMuc3RhbGxlZCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wU3VzcGVuZDogZXZlbnRUeXBlcy5zdXNwZW5kLFxuICB0b3BUaW1lVXBkYXRlOiBldmVudFR5cGVzLnRpbWVVcGRhdGUsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BWb2x1bWVDaGFuZ2U6IGV2ZW50VHlwZXMudm9sdW1lQ2hhbmdlLFxuICB0b3BXYWl0aW5nOiBldmVudFR5cGVzLndhaXRpbmcsXG4gIHRvcFdoZWVsOiBldmVudFR5cGVzLndoZWVsXG59O1xuXG5mb3IgKHZhciB0eXBlIGluIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZykge1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdHlwZV0uZGVwZW5kZW5jaWVzID0gW3R5cGVdO1xufVxuXG52YXIgT05fQ0xJQ0tfS0VZID0ga2V5T2YoeyBvbkNsaWNrOiBudWxsIH0pO1xudmFyIG9uQ2xpY2tMaXN0ZW5lcnMgPSB7fTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFib3J0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheVRocm91Z2g6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHVyYXRpb25DaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW1wdGllZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmNyeXB0ZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5kZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW5wdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWREYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZE1ldGFkYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXVzZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXlpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUHJvZ3Jlc3M6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmF0ZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSZXNldDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVrZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2luZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdGFsbGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdXNwZW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRpbWVVcGRhdGU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVm9sdW1lQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdhaXRpbmc6XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgICAvLyBGaXJlRm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2xpY2s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERvdWJsZUNsaWNrOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VudGVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFeGl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdMZWF2ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJvcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvcHk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1tpZF0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1tpZF0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2lkXS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2lkXTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNGb2N1c0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljS2V5Ym9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudENoYXJDb2RlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50S2V5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRLZXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNEcmFnRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVG91Y2hFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTVkdET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBjbGlwUGF0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGN4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGw6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRGYW1pbHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250U2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJFbmQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJNaWQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJTdGFydDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9mZnNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVyblVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcG9pbnRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3ByZWFkTWV0aG9kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcENvbG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VEYXNoYXJyYXk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VMaW5lY2FwOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZVdpZHRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdGV4dEFuY2hvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZlcnNpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2aWV3Qm94OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FjdHVhdGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FyY3JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0hyZWY6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1Nob3c6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1RpdGxlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sQmFzZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbExhbmc6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxTcGFjZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkxOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5OiBNVVNUX1VTRV9BVFRSSUJVVEVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gICAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gICAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICAgIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICAgIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICAgIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gICAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gICAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICAgIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICAgIHZpZXdCb3g6ICd2aWV3Qm94JyxcbiAgICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcbiAgICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxuICAgIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICAgIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gICAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgICB4bWxTcGFjZTogJ3htbDpzcGFjZSdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG5cbmZ1bmN0aW9uIHJvdW5kRmxvYXQodmFsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHZhbCAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKG9iaiwga2V5LCB2YWwpIHtcbiAgb2JqW2tleV0gPSAob2JqW2tleV0gfHwgMCkgKyB2YWw7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmID0ge1xuICBfYWxsTWVhc3VyZW1lbnRzOiBbXSwgLy8gbGFzdCBpdGVtIGluIHRoZSBsaXN0IGlzIHRoZSBjdXJyZW50IG9uZVxuICBfbW91bnRTdGFjazogWzBdLFxuICBfaW5qZWN0ZWQ6IGZhbHNlLFxuXG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFSZWFjdERlZmF1bHRQZXJmLl9pbmplY3RlZCkge1xuICAgICAgUmVhY3RQZXJmLmluamVjdGlvbi5pbmplY3RNZWFzdXJlKFJlYWN0RGVmYXVsdFBlcmYubWVhc3VyZSk7XG4gICAgfVxuXG4gICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUgPSB0cnVlO1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IGZhbHNlO1xuICB9LFxuXG4gIGdldExhc3RNZWFzdXJlbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICB9LFxuXG4gIHByaW50RXhjbHVzaXZlOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0NvbXBvbmVudCBjbGFzcyBuYW1lJzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnVG90YWwgaW5jbHVzaXZlIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5pbmNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIG1vdW50IHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIHJlbmRlciB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0ucmVuZGVyKSxcbiAgICAgICAgJ01vdW50IHRpbWUgcGVyIGluc3RhbmNlIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uZXhjbHVzaXZlIC8gaXRlbS5jb3VudCksXG4gICAgICAgICdSZW5kZXIgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIC8vIFRPRE86IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUoKSBkb2VzIG5vdCByZXR1cm4gdGhlIGNvcnJlY3RcbiAgICAvLyBudW1iZXIuXG4gIH0sXG5cbiAgcHJpbnRJbmNsdXNpdmU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnT3duZXIgPiBjb21wb25lbnQnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdJbmNsdXNpdmUgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnRpbWUpLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgY29uc29sZS5sb2coJ1RvdGFsIHRpbWU6JywgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpLnRvRml4ZWQoMikgKyAnIG1zJyk7XG4gIH0sXG5cbiAgZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcDogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCB0cnVlKTtcbiAgICByZXR1cm4gc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1dhc3RlZCB0aW1lIChtcyknOiBpdGVtLnRpbWUsXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIHByaW50V2FzdGVkOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICBjb25zb2xlLnRhYmxlKFJlYWN0RGVmYXVsdFBlcmYuZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcChtZWFzdXJlbWVudHMpKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBwcmludERPTTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdFtET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRV0gPSBpdGVtLmlkO1xuICAgICAgcmVzdWx0LnR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICByZXN1bHQuYXJncyA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uYXJncyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBfcmVjb3JkV3JpdGU6IGZ1bmN0aW9uIChpZCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3MpIHtcbiAgICAvLyBUT0RPOiB0b3RhbFRpbWUgaXNuJ3QgdGhhdCB1c2VmdWwgc2luY2UgaXQgZG9lc24ndCBjb3VudCBwYWludHMvcmVmbG93c1xuICAgIHZhciB3cml0ZXMgPSBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLndyaXRlcztcbiAgICB3cml0ZXNbaWRdID0gd3JpdGVzW2lkXSB8fCBbXTtcbiAgICB3cml0ZXNbaWRdLnB1c2goe1xuICAgICAgdHlwZTogZm5OYW1lLFxuICAgICAgdGltZTogdG90YWxUaW1lLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICB9LFxuXG4gIG1lYXN1cmU6IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsVGltZTtcbiAgICAgIHZhciBydjtcbiAgICAgIHZhciBzdGFydDtcblxuICAgICAgaWYgKGZuTmFtZSA9PT0gJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyB8fCBmbk5hbWUgPT09ICdmbHVzaEJhdGNoZWRVcGRhdGVzJykge1xuICAgICAgICAvLyBBIFwibWVhc3VyZW1lbnRcIiBpcyBhIHNldCBvZiBtZXRyaWNzIHJlY29yZGVkIGZvciBlYWNoIGZsdXNoLiBXZSB3YW50XG4gICAgICAgIC8vIHRvIGdyb3VwIHRoZSBtZXRyaWNzIGZvciBhIGdpdmVuIGZsdXNoIHRvZ2V0aGVyIHNvIHdlIGNhbiBsb29rIGF0IHRoZVxuICAgICAgICAvLyBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgYW5kIHRoZSBET00gb3BlcmF0aW9ucyB0aGF0IGFjdHVhbGx5XG4gICAgICAgIC8vIGhhcHBlbmVkIHRvIGRldGVybWluZSB0aGUgYW1vdW50IG9mIFwid2FzdGVkIHdvcmtcIiBwZXJmb3JtZWQuXG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5wdXNoKHtcbiAgICAgICAgICBleGNsdXNpdmU6IHt9LFxuICAgICAgICAgIGluY2x1c2l2ZToge30sXG4gICAgICAgICAgcmVuZGVyOiB7fSxcbiAgICAgICAgICBjb3VudHM6IHt9LFxuICAgICAgICAgIHdyaXRlczoge30sXG4gICAgICAgICAgZGlzcGxheU5hbWVzOiB7fSxcbiAgICAgICAgICB0b3RhbFRpbWU6IDAsXG4gICAgICAgICAgY3JlYXRlZDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLnRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdfbW91bnRJbWFnZUludG9Ob2RlJyB8fCBtb2R1bGVOYW1lID09PSAnUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyB8fCBtb2R1bGVOYW1lID09PSAnUmVhY3RET01JRE9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdDU1NQcm9wZXJ0eU9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdET01DaGlsZHJlbk9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKSB7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGZuTmFtZSA9PT0gJ19tb3VudEltYWdlSW50b05vZGUnKSB7XG4gICAgICAgICAgdmFyIG1vdW50SUQgPSBSZWFjdE1vdW50LmdldElEKGFyZ3NbMV0pO1xuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKG1vdW50SUQsIGZuTmFtZSwgdG90YWxUaW1lLCBhcmdzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMnKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBmb3JtYXRcbiAgICAgICAgICBhcmdzWzBdLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlQXJncyA9IHt9O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5mcm9tSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLmZyb21JbmRleCA9IHVwZGF0ZS5mcm9tSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRvSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRvSW5kZXggPSB1cGRhdGUudG9JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRleHRDb250ZW50ID0gdXBkYXRlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5tYXJrdXBJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MubWFya3VwID0gYXJnc1sxXVt1cGRhdGUubWFya3VwSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUodXBkYXRlLnBhcmVudElELCB1cGRhdGUudHlwZSwgdG90YWxUaW1lLCB3cml0ZUFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJhc2ljIGZvcm1hdFxuICAgICAgICAgIHZhciBpZCA9IGFyZ3NbMF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlkID0gUmVhY3RNb3VudC5nZXRJRChhcmdzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUoaWQsIGZuTmFtZSwgdG90YWxUaW1lLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChtb2R1bGVOYW1lID09PSAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnICYmIChmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgfHwgZm5OYW1lID09PSAndXBkYXRlQ29tcG9uZW50JyB8fCAvLyBUT0RPOiByZWNlaXZlQ29tcG9uZW50KCk/XG4gICAgICBmbk5hbWUgPT09ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JykpIHtcblxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSA9PT0gUmVhY3RNb3VudC5Ub3BMZXZlbFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb290Tm9kZUlEID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnID8gYXJnc1swXSA6IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICAgIHZhciBpc1JlbmRlciA9IGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnO1xuICAgICAgICB2YXIgaXNNb3VudCA9IGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JztcblxuICAgICAgICB2YXIgbW91bnRTdGFjayA9IFJlYWN0RGVmYXVsdFBlcmYuX21vdW50U3RhY2s7XG4gICAgICAgIHZhciBlbnRyeSA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyKSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuY291bnRzLCByb290Tm9kZUlELCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgZW50cnkuY3JlYXRlZFtyb290Tm9kZUlEXSA9IHRydWU7XG4gICAgICAgICAgbW91bnRTdGFjay5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5yZW5kZXIsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VudCkge1xuICAgICAgICAgIHZhciBzdWJNb3VudFRpbWUgPSBtb3VudFN0YWNrLnBvcCgpO1xuICAgICAgICAgIG1vdW50U3RhY2tbbW91bnRTdGFjay5sZW5ndGggLSAxXSArPSB0b3RhbFRpbWU7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuZXhjbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUgLSBzdWJNb3VudFRpbWUpO1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5pbmNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeS5kaXNwbGF5TmFtZXNbcm9vdE5vZGVJRF0gPSB7XG4gICAgICAgICAgY3VycmVudDogdGhpcy5nZXROYW1lKCksXG4gICAgICAgICAgb3duZXI6IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgOiAnPHJvb3Q+J1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG4vLyBEb24ndCB0cnkgdG8gc2F2ZSB1c2VycyBsZXNzIHRoYW4gMS4ybXMgKGEgbnVtYmVyIEkgbWFkZSB1cClcbnZhciBET05UX0NBUkVfVEhSRVNIT0xEID0gMS4yO1xudmFyIERPTV9PUEVSQVRJT05fVFlQRVMgPSB7XG4gICdfbW91bnRJbWFnZUludG9Ob2RlJzogJ3NldCBpbm5lckhUTUwnLFxuICBJTlNFUlRfTUFSS1VQOiAnc2V0IGlubmVySFRNTCcsXG4gIE1PVkVfRVhJU1RJTkc6ICdtb3ZlJyxcbiAgUkVNT1ZFX05PREU6ICdyZW1vdmUnLFxuICBTRVRfTUFSS1VQOiAnc2V0IGlubmVySFRNTCcsXG4gIFRFWFRfQ09OVEVOVDogJ3NldCB0ZXh0Q29udGVudCcsXG4gICdzZXRWYWx1ZUZvclByb3BlcnR5JzogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAnc2V0VmFsdWVGb3JBdHRyaWJ1dGUnOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICdkZWxldGVWYWx1ZUZvclByb3BlcnR5JzogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAnc2V0VmFsdWVGb3JTdHlsZXMnOiAndXBkYXRlIHN0eWxlcycsXG4gICdyZXBsYWNlTm9kZVdpdGhNYXJrdXAnOiAncmVwbGFjZScsXG4gICd1cGRhdGVUZXh0Q29udGVudCc6ICdzZXQgdGV4dENvbnRlbnQnXG59O1xuXG5mdW5jdGlvbiBnZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKSB7XG4gIC8vIFRPRE86IHJldHVybiBudW1iZXIgb2YgRE9NIG9wcz8gY291bGQgYmUgbWlzbGVhZGluZy5cbiAgLy8gVE9ETzogbWVhc3VyZSBkcm9wcGVkIGZyYW1lcyBhZnRlciByZWNvbmNpbGU/XG4gIC8vIFRPRE86IGxvZyB0b3RhbCB0aW1lIG9mIGVhY2ggcmVjb25jaWxlIGFuZCB0aGUgdG9wLWxldmVsIGNvbXBvbmVudFxuICAvLyBjbGFzcyB0aGF0IHRyaWdnZXJlZCBpdC5cbiAgdmFyIHRvdGFsVGltZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHRvdGFsVGltZSArPSBtZWFzdXJlbWVudC50b3RhbFRpbWU7XG4gIH1cbiAgcmV0dXJuIHRvdGFsVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpIHtcbiAgdmFyIGl0ZW1zID0gW107XG4gIG1lYXN1cmVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtZWFzdXJlbWVudCkge1xuICAgIE9iamVjdC5rZXlzKG1lYXN1cmVtZW50LndyaXRlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIG1lYXN1cmVtZW50LndyaXRlc1tpZF0uZm9yRWFjaChmdW5jdGlvbiAod3JpdGUpIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHR5cGU6IERPTV9PUEVSQVRJT05fVFlQRVNbd3JpdGUudHlwZV0gfHwgd3JpdGUudHlwZSxcbiAgICAgICAgICBhcmdzOiB3cml0ZS5hcmdzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBkaXNwbGF5TmFtZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSA9IGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgIGluY2x1c2l2ZTogMCxcbiAgICAgICAgZXhjbHVzaXZlOiAwLFxuICAgICAgICByZW5kZXI6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuICAgICAgaWYgKG1lYXN1cmVtZW50LnJlbmRlcltpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0ucmVuZGVyICs9IG1lYXN1cmVtZW50LnJlbmRlcltpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmluY2x1c2l2ZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uY291bnQgKz0gbWVhc3VyZW1lbnQuY291bnRzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgbWFrZSBhIHNvcnRlZCBhcnJheSB3aXRoIHRoZSByZXN1bHRzLlxuICB2YXIgYXJyID0gW107XG4gIGZvciAoZGlzcGxheU5hbWUgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgPj0gRE9OVF9DQVJFX1RIUkVTSE9MRCkge1xuICAgICAgYXJyLnB1c2goY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuZXhjbHVzaXZlIC0gYS5leGNsdXNpdmU7XG4gIH0pO1xuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCBvbmx5Q2xlYW4pIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSB7fTtcbiAgdmFyIGluY2x1c2l2ZUtleTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG4gICAgdmFyIGNsZWFuQ29tcG9uZW50cztcblxuICAgIGlmIChvbmx5Q2xlYW4pIHtcbiAgICAgIGNsZWFuQ29tcG9uZW50cyA9IGdldFVuY2hhbmdlZENvbXBvbmVudHMobWVhc3VyZW1lbnQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgICAgaWYgKG9ubHlDbGVhbiAmJiAhY2xlYW5Db21wb25lbnRzW2lkXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXTtcblxuICAgICAgLy8gSW5jbHVzaXZlIHRpbWUgaXMgbm90IHVzZWZ1bCBmb3IgbWFueSBjb21wb25lbnRzIHdpdGhvdXQga25vd2luZyB3aGVyZVxuICAgICAgLy8gdGhleSBhcmUgaW5zdGFudGlhdGVkLiBTbyB3ZSBhZ2dyZWdhdGUgaW5jbHVzaXZlIHRpbWUgd2l0aCBib3RoIHRoZVxuICAgICAgLy8gb3duZXIgYW5kIGN1cnJlbnQgZGlzcGxheU5hbWUgYXMgdGhlIGtleS5cbiAgICAgIGluY2x1c2l2ZUtleSA9IGRpc3BsYXlOYW1lLm93bmVyICsgJyA+ICcgKyBkaXNwbGF5TmFtZS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gPSBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gfHwge1xuICAgICAgICBjb21wb25lbnROYW1lOiBpbmNsdXNpdmVLZXksXG4gICAgICAgIHRpbWU6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGluY2x1c2l2ZUtleSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgaWYgKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS50aW1lID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSk7XG4gICAgfVxuICB9XG5cbiAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi50aW1lIC0gYS50aW1lO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KSB7XG4gIC8vIEZvciBhIGdpdmVuIHJlY29uY2lsZSwgbG9vayBhdCB3aGljaCBjb21wb25lbnRzIGRpZCBub3QgYWN0dWFsbHlcbiAgLy8gcmVuZGVyIGFueXRoaW5nIHRvIHRoZSBET00gYW5kIHJldHVybiBhIG1hcHBpbmcgb2YgdGhlaXIgSUQgdG9cbiAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIHRoZSBlbnRpcmUgc3VidHJlZS5cbiAgdmFyIGNsZWFuQ29tcG9uZW50cyA9IHt9O1xuICB2YXIgZGlydHlMZWFmSURzID0gT2JqZWN0LmtleXMobWVhc3VyZW1lbnQud3JpdGVzKTtcbiAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgIHZhciBpc0RpcnR5ID0gZmFsc2U7XG4gICAgLy8gRm9yIGVhY2ggY29tcG9uZW50IHRoYXQgcmVuZGVyZWQsIHNlZSBpZiBhIGNvbXBvbmVudCB0aGF0IHRyaWdnZXJlZFxuICAgIC8vIGEgRE9NIG9wIGlzIGluIGl0cyBzdWJ0cmVlLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlydHlMZWFmSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZGlydHlMZWFmSURzW2ldLmluZGV4T2YoaWQpID09PSAwKSB7XG4gICAgICAgIGlzRGlydHkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgY29tcG9uZW50IG5ld2x5IGNyZWF0ZWRcbiAgICBpZiAobWVhc3VyZW1lbnQuY3JlYXRlZFtpZF0pIHtcbiAgICAgIGlzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWlzRGlydHkgJiYgbWVhc3VyZW1lbnQuY291bnRzW2lkXSA+IDApIHtcbiAgICAgIGNsZWFuQ29tcG9uZW50c1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xlYW5Db21wb25lbnRzO1xufVxuXG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0ge1xuICBnZXRFeGNsdXNpdmVTdW1tYXJ5OiBnZXRFeGNsdXNpdmVTdW1tYXJ5LFxuICBnZXRJbmNsdXNpdmVTdW1tYXJ5OiBnZXRJbmNsdXNpdmVTdW1tYXJ5LFxuICBnZXRET01TdW1tYXJ5OiBnZXRET01TdW1tYXJ5LFxuICBnZXRUb3RhbFRpbWU6IGdldFRvdGFsVGltZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlTm93XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZSgnLi9wZXJmb3JtYW5jZScpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3c7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAocGVyZm9ybWFuY2Uubm93KSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzXG4gKiogbW9kdWxlIGlkID0gMTQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcGVyZm9ybWFuY2VcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFZlcnNpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzAuMTQuNyc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDE0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VydmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRJbmplY3Rpb24nKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZyA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmcnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciBSZWFjdERPTVNlcnZlciA9IHtcbiAgcmVuZGVyVG9TdHJpbmc6IFJlYWN0U2VydmVyUmVuZGVyaW5nLnJlbmRlclRvU3RyaW5nLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogUmVhY3RTZXJ2ZXJSZW5kZXJpbmcucmVuZGVyVG9TdGF0aWNNYXJrdXAsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlcnZlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZXJ2ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBIVE1MIG1hcmt1cFxuICovXG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZyhlbGVtZW50KSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyVG9TdHJpbmcoKTogWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0RWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gICAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB0cmFuc2FjdGlvbiA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKGZhbHNlKTtcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5wZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgbnVsbCk7XG4gICAgICB2YXIgbWFya3VwID0gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCBlbXB0eU9iamVjdCk7XG4gICAgICByZXR1cm4gUmVhY3RNYXJrdXBDaGVja3N1bS5hZGRDaGVja3N1bVRvTWFya3VwKG1hcmt1cCk7XG4gICAgfSwgbnVsbCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICAvLyBSZXZlcnQgdG8gdGhlIERPTSBiYXRjaGluZyBzdHJhdGVneSBzaW5jZSB0aGVzZSB0d28gcmVuZGVyZXJzXG4gICAgLy8gY3VycmVudGx5IHNoYXJlIHRoZXNlIHN0YXRlZnVsIG1vZHVsZXMuXG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwLCB3aXRob3V0IHRoZSBleHRyYSBSZWFjdCBJRCBhbmQgY2hlY2tzdW1cbiAqIChmb3IgZ2VuZXJhdGluZyBzdGF0aWMgcGFnZXMpXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTWFya3VwKGVsZW1lbnQpIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJUb1N0YXRpY01hcmt1cCgpOiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3RFbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgdHJhbnNhY3Rpb247XG4gIHRyeSB7XG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIHRyYW5zYWN0aW9uID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5nZXRQb29sZWQodHJ1ZSk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGVsZW1lbnQsIG51bGwpO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlLm1vdW50Q29tcG9uZW50KGlkLCB0cmFuc2FjdGlvbiwgZW1wdHlPYmplY3QpO1xuICAgIH0sIG51bGwpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgLy8gUmV2ZXJ0IHRvIHRoZSBET00gYmF0Y2hpbmcgc3RyYXRlZ3kgc2luY2UgdGhlc2UgdHdvIHJlbmRlcmVyc1xuICAgIC8vIGN1cnJlbnRseSBzaGFyZSB0aGVzZSBzdGF0ZWZ1bCBtb2R1bGVzLlxuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVuZGVyVG9TdHJpbmc6IHJlbmRlclRvU3RyaW5nLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogcmVuZGVyVG9TdGF0aWNNYXJrdXBcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaGVyZS4gRHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIHdlIGRvbid0IHdhbnQgdG9cbiAgICAvLyBzY2hlZHVsZSBhbnkgdXBkYXRlcy4gV2Ugd2lsbCBzaW1wbHkgaWdub3JlIHRoZW0uXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBgQ2FsbGJhY2tRdWV1ZWAgcXVldWUgZm9yIGNvbGxlY3RpbmcgYG9uRE9NUmVhZHlgIGNhbGxiYWNrc1xuICogZHVyaW5nIHRoZSBwZXJmb3JtaW5nIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICBjbG9zZTogZW1wdHlGdW5jdGlvblxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW09OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcbiAgfVxufTtcblxuYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SXNvbW9ycGhpY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmFjdG9yaWVzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuXG4gIC8vIE1vZGVyblxuXG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgdG9BcnJheTogUmVhY3RDaGlsZHJlbi50b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgLy8gQ3VycmVudGx5IGEgbm9vcC4gV2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0cmFjZSBtaXhpbnMuXG4gICAgcmV0dXJuIG1peGluO1xuICB9LFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTUZhY3RvcmllcyxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLy8gSG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nIGVsc2UuXG4gIF9fc3ByZWFkOiBhc3NpZ25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SXNvbW9ycGhpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmFjdG9yaWVzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcblxudmFyIG1hcE9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL21hcE9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgKGUuZy4gYGRpdmApLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NRmFjdG9yeSh0YWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3RvcnkodGFnKTtcbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkodGFnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gbWFwT2JqZWN0KHtcbiAgYTogJ2EnLFxuICBhYmJyOiAnYWJicicsXG4gIGFkZHJlc3M6ICdhZGRyZXNzJyxcbiAgYXJlYTogJ2FyZWEnLFxuICBhcnRpY2xlOiAnYXJ0aWNsZScsXG4gIGFzaWRlOiAnYXNpZGUnLFxuICBhdWRpbzogJ2F1ZGlvJyxcbiAgYjogJ2InLFxuICBiYXNlOiAnYmFzZScsXG4gIGJkaTogJ2JkaScsXG4gIGJkbzogJ2JkbycsXG4gIGJpZzogJ2JpZycsXG4gIGJsb2NrcXVvdGU6ICdibG9ja3F1b3RlJyxcbiAgYm9keTogJ2JvZHknLFxuICBicjogJ2JyJyxcbiAgYnV0dG9uOiAnYnV0dG9uJyxcbiAgY2FudmFzOiAnY2FudmFzJyxcbiAgY2FwdGlvbjogJ2NhcHRpb24nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNvZGU6ICdjb2RlJyxcbiAgY29sOiAnY29sJyxcbiAgY29sZ3JvdXA6ICdjb2xncm91cCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0YWxpc3Q6ICdkYXRhbGlzdCcsXG4gIGRkOiAnZGQnLFxuICBkZWw6ICdkZWwnLFxuICBkZXRhaWxzOiAnZGV0YWlscycsXG4gIGRmbjogJ2RmbicsXG4gIGRpYWxvZzogJ2RpYWxvZycsXG4gIGRpdjogJ2RpdicsXG4gIGRsOiAnZGwnLFxuICBkdDogJ2R0JyxcbiAgZW06ICdlbScsXG4gIGVtYmVkOiAnZW1iZWQnLFxuICBmaWVsZHNldDogJ2ZpZWxkc2V0JyxcbiAgZmlnY2FwdGlvbjogJ2ZpZ2NhcHRpb24nLFxuICBmaWd1cmU6ICdmaWd1cmUnLFxuICBmb290ZXI6ICdmb290ZXInLFxuICBmb3JtOiAnZm9ybScsXG4gIGgxOiAnaDEnLFxuICBoMjogJ2gyJyxcbiAgaDM6ICdoMycsXG4gIGg0OiAnaDQnLFxuICBoNTogJ2g1JyxcbiAgaDY6ICdoNicsXG4gIGhlYWQ6ICdoZWFkJyxcbiAgaGVhZGVyOiAnaGVhZGVyJyxcbiAgaGdyb3VwOiAnaGdyb3VwJyxcbiAgaHI6ICdocicsXG4gIGh0bWw6ICdodG1sJyxcbiAgaTogJ2knLFxuICBpZnJhbWU6ICdpZnJhbWUnLFxuICBpbWc6ICdpbWcnLFxuICBpbnB1dDogJ2lucHV0JyxcbiAgaW5zOiAnaW5zJyxcbiAga2JkOiAna2JkJyxcbiAga2V5Z2VuOiAna2V5Z2VuJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxlZ2VuZDogJ2xlZ2VuZCcsXG4gIGxpOiAnbGknLFxuICBsaW5rOiAnbGluaycsXG4gIG1haW46ICdtYWluJyxcbiAgbWFwOiAnbWFwJyxcbiAgbWFyazogJ21hcmsnLFxuICBtZW51OiAnbWVudScsXG4gIG1lbnVpdGVtOiAnbWVudWl0ZW0nLFxuICBtZXRhOiAnbWV0YScsXG4gIG1ldGVyOiAnbWV0ZXInLFxuICBuYXY6ICduYXYnLFxuICBub3NjcmlwdDogJ25vc2NyaXB0JyxcbiAgb2JqZWN0OiAnb2JqZWN0JyxcbiAgb2w6ICdvbCcsXG4gIG9wdGdyb3VwOiAnb3B0Z3JvdXAnLFxuICBvcHRpb246ICdvcHRpb24nLFxuICBvdXRwdXQ6ICdvdXRwdXQnLFxuICBwOiAncCcsXG4gIHBhcmFtOiAncGFyYW0nLFxuICBwaWN0dXJlOiAncGljdHVyZScsXG4gIHByZTogJ3ByZScsXG4gIHByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICBxOiAncScsXG4gIHJwOiAncnAnLFxuICBydDogJ3J0JyxcbiAgcnVieTogJ3J1YnknLFxuICBzOiAncycsXG4gIHNhbXA6ICdzYW1wJyxcbiAgc2NyaXB0OiAnc2NyaXB0JyxcbiAgc2VjdGlvbjogJ3NlY3Rpb24nLFxuICBzZWxlY3Q6ICdzZWxlY3QnLFxuICBzbWFsbDogJ3NtYWxsJyxcbiAgc291cmNlOiAnc291cmNlJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzdHJvbmc6ICdzdHJvbmcnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3ViOiAnc3ViJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICBzdXA6ICdzdXAnLFxuICB0YWJsZTogJ3RhYmxlJyxcbiAgdGJvZHk6ICd0Ym9keScsXG4gIHRkOiAndGQnLFxuICB0ZXh0YXJlYTogJ3RleHRhcmVhJyxcbiAgdGZvb3Q6ICd0Zm9vdCcsXG4gIHRoOiAndGgnLFxuICB0aGVhZDogJ3RoZWFkJyxcbiAgdGltZTogJ3RpbWUnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHI6ICd0cicsXG4gIHRyYWNrOiAndHJhY2snLFxuICB1OiAndScsXG4gIHVsOiAndWwnLFxuICAndmFyJzogJ3ZhcicsXG4gIHZpZGVvOiAndmlkZW8nLFxuICB3YnI6ICd3YnInLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6ICdjaXJjbGUnLFxuICBjbGlwUGF0aDogJ2NsaXBQYXRoJyxcbiAgZGVmczogJ2RlZnMnLFxuICBlbGxpcHNlOiAnZWxsaXBzZScsXG4gIGc6ICdnJyxcbiAgaW1hZ2U6ICdpbWFnZScsXG4gIGxpbmU6ICdsaW5lJyxcbiAgbGluZWFyR3JhZGllbnQ6ICdsaW5lYXJHcmFkaWVudCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgcGF0aDogJ3BhdGgnLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBvbHlnb246ICdwb2x5Z29uJyxcbiAgcG9seWxpbmU6ICdwb2x5bGluZScsXG4gIHJhZGlhbEdyYWRpZW50OiAncmFkaWFsR3JhZGllbnQnLFxuICByZWN0OiAncmVjdCcsXG4gIHN0b3A6ICdzdG9wJyxcbiAgc3ZnOiAnc3ZnJyxcbiAgdGV4dDogJ3RleHQnLFxuICB0c3BhbjogJ3RzcGFuJ1xuXG59LCBjcmVhdGVET01GYWN0b3J5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRWYWxpZGF0b3JcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBhZGRlbmRhID0gZ2V0QWRkZW5kYUZvcktleVVzZSgndW5pcXVlS2V5JywgZWxlbWVudCwgcGFyZW50VHlwZSk7XG4gIGlmIChhZGRlbmRhID09PSBudWxsKSB7XG4gICAgLy8gd2UgYWxyZWFkeSBzaG93ZWQgdGhlIHdhcm5pbmdcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMlcycsIGFkZGVuZGEucGFyZW50T3JPd25lciB8fCAnJywgYWRkZW5kYS5jaGlsZE93bmVyIHx8ICcnLCBhZGRlbmRhLnVybCB8fCAnJykgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogU2hhcmVkIHdhcm5pbmcgYW5kIG1vbml0b3JpbmcgY29kZSBmb3IgdGhlIGtleSB3YXJuaW5ncy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlVHlwZSBBIGtleSB1c2VkIGZvciBkZS1kdXBpbmcgd2FybmluZ3MuXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBDb21wb25lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqIEByZXR1cm5zIHs/b2JqZWN0fSBBIHNldCBvZiBhZGRlbmRhIHRvIHVzZSBpbiB0aGUgd2FybmluZyBtZXNzYWdlLCBvciBudWxsXG4gKiBpZiB0aGUgd2FybmluZyBoYXMgYWxyZWFkeSBiZWVuIHNob3duIGJlZm9yZSAoYW5kIHNob3VsZG4ndCBiZSBzaG93biBhZ2FpbikuXG4gKi9cbmZ1bmN0aW9uIGdldEFkZGVuZGFGb3JLZXlVc2UobWVzc2FnZVR5cGUsIGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gIGlmICghYWRkZW5kdW0pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgYWRkZW5kdW0gPSAnIENoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmdbbWVzc2FnZVR5cGVdIHx8IChvd25lckhhc0tleVVzZVdhcm5pbmdbbWVzc2FnZVR5cGVdID0ge30pO1xuICBpZiAobWVtb2l6ZXJbYWRkZW5kdW1dKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbWVtb2l6ZXJbYWRkZW5kdW1dID0gdHJ1ZTtcblxuICB2YXIgYWRkZW5kYSA9IHtcbiAgICBwYXJlbnRPck93bmVyOiBhZGRlbmR1bSxcbiAgICB1cmw6ICcgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgY2hpbGRPd25lcjogbnVsbFxuICB9O1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGFkZGVuZGEuY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJztcbiAgfVxuXG4gIHJldHVybiBhZGRlbmRhO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyBwcm92aWRlIGltcGxpY2l0IGtleXMuXG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKGNvbXBvbmVudE5hbWUsIHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgcHJvcFR5cGVzW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lLCB0eXBlb2YgZXJyb3IpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1Byb3BUeXBlcyhuYW1lLCBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHtcblxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodmFsaWRUeXBlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBzaG91bGQgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgYm9vbGVhbiwgb3IgJyArICdudW1iZXIuIEl0IHNob3VsZCBiZSBhIHN0cmluZyAoZm9yIERPTSBlbGVtZW50cykgb3IgYSBSZWFjdENsYXNzICcgKyAnKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtYXBPYmplY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGBjYWxsYmFja2Agb25jZSBmb3IgZWFjaCBlbnVtZXJhYmxlIG93biBwcm9wZXJ0eSBpbiB0aGVcbiAqIG9iamVjdCBhbmQgY29uc3RydWN0cyBhIG5ldyBvYmplY3QgZnJvbSB0aGUgcmVzdWx0cy4gVGhlIGBjYWxsYmFja2AgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKlxuICogIC0gdGhlIHByb3BlcnR5IHZhbHVlXG4gKiAgLSB0aGUgcHJvcGVydHkgbmFtZVxuICogIC0gdGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGFkZGVkIGFmdGVyIHRoZSBjYWxsIHRvIGBtYXBPYmplY3RgIHdpbGwgbm90IGJlIHZpc2l0ZWRcbiAqIGJ5IGBjYWxsYmFja2AuIElmIHRoZSB2YWx1ZXMgb2YgZXhpc3RpbmcgcHJvcGVydGllcyBhcmUgY2hhbmdlZCwgdGhlIHZhbHVlXG4gKiBwYXNzZWQgdG8gYGNhbGxiYWNrYCB3aWxsIGJlIHRoZSB2YWx1ZSBhdCB0aGUgdGltZSBgbWFwT2JqZWN0YCB2aXNpdHMgdGhlbS5cbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgZGVsZXRlZCBiZWZvcmUgYmVpbmcgdmlzaXRlZCBhcmUgbm90IHZpc2l0ZWQuXG4gKlxuICogQGdyZXAgZnVuY3Rpb24gb2JqZWN0TWFwKClcbiAqIEBncmVwIGZ1bmN0aW9uIG9iak1hcCgpXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0W25hbWVdLCBuYW1lLCBvYmplY3QpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcE9iamVjdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mYmpzL2xpYi9tYXBPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBvbmx5Q2hpbGRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXNcbiAqIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZVxuICogcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0byBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZVxuICogb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0Q29tcG9uZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdvbmx5Q2hpbGQgbXVzdCBiZSBwYXNzZWQgYSBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgb25lIGNoaWxkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ubHlDaGlsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMTU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGVwcmVjYXRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogVGhpcyB3aWxsIGxvZyBhIHNpbmdsZSBkZXByZWNhdGlvbiBub3RpY2UgcGVyIGZ1bmN0aW9uIGFuZCBmb3J3YXJkIHRoZSBjYWxsXG4gKiBvbiB0byB0aGUgbmV3IEFQSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5ld01vZHVsZSBUaGUgbW9kdWxlIHRoYXQgZm4gd2lsbCBleGlzdCBpblxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1BhY2thZ2UgVGhlIG1vZHVsZSB0aGF0IGZuIHdpbGwgZXhpc3QgaW5cbiAqIEBwYXJhbSB7Kn0gY3R4IFRoZSBjb250ZXh0IHRoaXMgZm9yd2FyZGVkIGNhbGwgc2hvdWxkIHJ1biBpblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGZvcndhcmQgb24gdG9cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIHdhcm4gb25jZSBhbmQgdGhlbiBjYWxsIGZuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoZm5OYW1lLCBuZXdNb2R1bGUsIG5ld1BhY2thZ2UsIGN0eCwgZm4pIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBuZXdGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5lZCxcbiAgICAgIC8vIFJlcXVpcmUgZXhhbXBsZXMgaW4gdGhpcyBzdHJpbmcgbXVzdCBiZSBzcGxpdCB0byBwcmV2ZW50IFJlYWN0J3NcbiAgICAgIC8vIGJ1aWxkIHRvb2xzIGZyb20gbWlzdGFraW5nIHRoZW0gZm9yIHJlYWwgcmVxdWlyZXMuXG4gICAgICAvLyBPdGhlcndpc2UgdGhlIGJ1aWxkIHRvb2xzIHdpbGwgYXR0ZW1wdCB0byBidWlsZCBhICclcycgbW9kdWxlLlxuICAgICAgJ1JlYWN0LiVzIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJXMuJXMgZnJvbSByZXF1aXJlJyArICcoXFwnJXNcXCcpICcgKyAnaW5zdGVhZC4nLCBmbk5hbWUsIG5ld01vZHVsZSwgZm5OYW1lLCBuZXdQYWNrYWdlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9yaWdpbmFsIGZuIGFyZSBjb3BpZWQgb3Zlci5cbiAgICAvLyBJbiBwYXJ0aWN1bGFyLCB0aGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IFByb3BUeXBlc1xuICAgIHJldHVybiBhc3NpZ24obmV3Rm4sIGZuKTtcbiAgfVxuXG4gIHJldHVybiBmbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGVkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9kZXByZWNhdGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMTU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1kb20vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBTdWJzY2hlbWEse0Zvcm0sIGxvYWRlciwgVmFsdWVNYW5hZ2VyLCBsb2FkZXJGYWN0b3J5fSBmcm9tIFwiU3Vic2NoZW1hXCI7XG5pbXBvcnQgaGVsbG8gZnJvbSAnaGVsbG9qcyc7XG5pbXBvcnQgTG9naW4gZnJvbSAnLi9Mb2dpbi5qc3gnO1xuaW1wb3J0IExvZ2luU3R5bGUgZnJvbSAnLi9Mb2dpbi5sZXNzJztcbmltcG9ydCBHaXRodWJQcm9jZXNzb3IgZnJvbSAnLi9HaXRodWJQcm9jZXNzb3InO1xuXG5sb2FkZXIuYWRkVHlwZSh7TG9naW59KTtcbmxvYWRlci5hZGRTdHlsZSh7TG9naW46IExvZ2luU3R5bGV9KTtcbmxvYWRlci5hZGRQcm9jZXNzb3Ioe0dpdGh1YlByb2Nlc3Nvcn0pO1xuXG5jb25zdCB2YWx1ZU1hbmFnZXIgPSBWYWx1ZU1hbmFnZXIoKTtcbnZhbHVlTWFuYWdlci5hZGRMaXN0ZW5lcignbG9naW4nLCAodik9PiB7XG4gICAgY29uc29sZS5sb2coJ2xvZ2luJywgdik7XG59KTtcblxuY29uc3Qgc2NoZW1hID0ge1xuICAgIFwic2NoZW1hXCI6IHtcbiAgICAgICAgXCJsb2dpblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJMb2dpblwiLFxuICAgICAgICAgICAgXCJ0ZW1wbGF0ZVwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcIm9yZ2FuaXphdGlvbnNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQXV0b2NvbXBsZXRlXCIsXG4gICAgICAgICAgICBcInByb2Nlc3NvclwiOiBcIkdpdGh1YlByb2Nlc3NvclwiLFxuICAgICAgICAgICAgXCJ1cmxcIjogXCIvdXNlci9vcmdzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXBvc2l0b3JpZXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQXV0b2NvbXBsZXRlXCIsXG4gICAgICAgICAgICBcInByb2Nlc3NvclwiOiBcIkdpdGh1YlByb2Nlc3NvclwiLFxuICAgICAgICAgICAgXCJ1cmxcIjogXCIvdXNlci9yZXBvc1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiZmllbGRzZXRzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJmaWVsZHNcIjogXCJsb2dpblwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibGVnZW5kXCI6IFwiR2l0aHViIEluZm9cIixcbiAgICAgICAgICAgIGZpZWxkczogW1wib3JnYW5pemF0aW9uc1wiLCBcInJlcG9zaXRvcmllc1wiXVxuICAgICAgICB9XG4gICAgXVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHAgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIDxkaXY+XG4gICAgICAgICAgICA8cD5TdWJzY2hlbWEgR2l0aHViIEludGVncmF0aW9uPC9wPlxuICAgICAgICAgICAgPEZvcm0gc2NoZW1hPXtzY2hlbWF9IGxvYWRlcj17bG9hZGVyfSB2YWx1ZU1hbmFnZXI9e3ZhbHVlTWFuYWdlcn0vPlxuICAgICAgICA8L2Rpdj5cbiAgICB9XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9wdWJsaWMvQXBwLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IF9SZWFjdENTU1JlcGxhY2VUcmFuc2l0aW9uIGZyb20gJy4vdHJhbnNpdGlvbi9SZWFjdENTU1JlcGxhY2VUcmFuc2l0aW9uJztcblxuaW1wb3J0IHtwcm92aWRlfSBmcm9tICcuL2RlY29yYXRvcnMnO1xuaW1wb3J0IF9EZWZhdWx0TG9hZGVyIGZyb20gJy4vRGVmYXVsdExvYWRlcic7XG5pbXBvcnQgKiBhcyBfdGVtcGxhdGVzIGZyb20gJy4vdGVtcGxhdGVzJztcbmltcG9ydCAqIGFzIF90eXBlcyBmcm9tICcuL3R5cGVzJztcbmltcG9ydCAqIGFzIF9wcm9jZXNzb3JzIGZyb20gJy4vcHJvY2Vzc29ycyc7XG5pbXBvcnQgKiBhcyBfc3R5bGVzIGZyb20gJy4vc3R5bGVzJztcbmltcG9ydCAqIGFzIF9yZXNvbHZlcnMgZnJvbSAnLi9yZXNvbHZlcnMnO1xuaW1wb3J0IHt0cmFuc2l0aW9ucyBhcyBfdHJhbnNpdGlvbnN9IGZyb20gJy4vdHJhbnNpdGlvbic7XG5pbXBvcnQgcHJvdmlkZUZhY3RvcnkgZnJvbSAnLi9kZWNvcmF0b3JzL3Byb3ZpZGVGYWN0b3J5JztcbmltcG9ydCBfY2FjaGVkSW5qZWN0b3IgZnJvbSAnLi9jYWNoZWRJbmplY3Rvcic7XG5pbXBvcnQge2luamVjdG9yRmFjdG9yeSBhcyBfaW5qZWN0b3JGYWN0b3J5fSBmcm9tICdzdWJzY2hlbWEtaW5qZWN0aW9uJztcblxuaW1wb3J0IFN1YnNjaGVtYSwge0NvbmRpdGlvbmFsIGFzIF9DLFxuICAgIEZpZWxkIGFzIF9GaWVsZCxcbiAgICBGaWVsZFNldCBhcyBfRmllbGRTZXQsXG4gICAgRm9ybSBhcyBfRixcbiAgICBOZXdDaGlsZENvbnRleHQgYXMgX04sXG4gICAgRG9tIGFzIF9ELFxuICAgIFByb3BUeXBlcyBhcyBfUHJvcFR5cGVzLFxuICAgIFRlbXBsYXRlIGFzIF9ULFxuICAgIFZhbHVlTWFuYWdlciBhcyBfVixcbiAgICBjc3MgYXMgX2MsXG4gICAgZGVjb3JhdG9ycyBhcyBfZGVjb3JhdG9ycyxcbiAgICBldmVudGFibGUgYXMgX2UsXG4gICAgbGlzdGVuVXRpbCBhcyBfbCxcbiAgICBsb2FkZXJGYWN0b3J5IGFzIF9sb2FkZXJGYWN0b3J5LFxuICAgIHR1dGlscyBhcyBfdCxcbiAgICB2YWxpZGF0b3JzIGFzIF92LFxuICAgIHdhcm5pbmcgYXMgX3csXG4gICAgbmV3U3Vic2NoZW1hQ29udGV4dCBhcyBfbmV3U3Vic2NoZW1hQ29udGV4dCxcbn0gZnJvbSAnLi9pbmRleC5qcyc7XG5cbmV4cG9ydCBjb25zdCBsb2FkZXJGYWN0b3J5ID0gX2xvYWRlckZhY3Rvcnk7XG5leHBvcnQgY29uc3QgQ29uZGl0aW9uYWwgPSBfQztcbmV4cG9ydCBjb25zdCBGaWVsZCA9IF9GaWVsZDtcbmV4cG9ydCBjb25zdCBGaWVsZFNldCA9IF9GaWVsZFNldDtcbmV4cG9ydCBjb25zdCBGb3JtID0gX0Y7XG5leHBvcnQgY29uc3QgTmV3Q2hpbGRDb250ZXh0ID0gX047XG5leHBvcnQgY29uc3QgRG9tID0gX0Q7XG5leHBvcnQgY29uc3QgUHJvcFR5cGVzID0gX1Byb3BUeXBlcztcbmV4cG9ydCBjb25zdCBUZW1wbGF0ZSA9IF9UO1xuZXhwb3J0IGNvbnN0IFZhbHVlTWFuYWdlciA9IF9WO1xuZXhwb3J0IGNvbnN0IGNzcyA9IF9jO1xuZXhwb3J0IGNvbnN0IGRlY29yYXRvcnMgPSBfZGVjb3JhdG9ycztcbmV4cG9ydCBjb25zdCBldmVudGFibGUgPSBfZTtcbmV4cG9ydCBjb25zdCBsaXN0ZW5VdGlsID0gX2w7XG5leHBvcnQgY29uc3QgdHV0aWxzID0gX3Q7XG5leHBvcnQgY29uc3QgdmFsaWRhdG9ycyA9IF92O1xuZXhwb3J0IGNvbnN0IHdhcm5pbmcgPSBfdztcbmV4cG9ydCBjb25zdCB0cmFuc2l0aW9ucyA9IF90cmFuc2l0aW9ucztcbmV4cG9ydCBjb25zdCB0ZW1wbGF0ZXMgPSBfdGVtcGxhdGVzO1xuZXhwb3J0IGNvbnN0IHR5cGVzID0gX3R5cGVzO1xuZXhwb3J0IGNvbnN0IHByb2Nlc3NvcnMgPSBfcHJvY2Vzc29ycztcbmV4cG9ydCBjb25zdCBzdHlsZXMgPSBfc3R5bGVzO1xuZXhwb3J0IGNvbnN0IERlZmF1bHRMb2FkZXIgPSBfRGVmYXVsdExvYWRlcjtcbmV4cG9ydCBjb25zdCByZXNvbHZlcnMgPSBfcmVzb2x2ZXJzO1xuZXhwb3J0IGNvbnN0IFJlYWN0Q1NTUmVwbGFjZVRyYW5zaXRpb24gPSBfUmVhY3RDU1NSZXBsYWNlVHJhbnNpdGlvbjtcblxuU3Vic2NoZW1hLnR5cGVzID0gX3R5cGVzO1xuU3Vic2NoZW1hLnRlbXBsYXRlcyA9IF90ZW1wbGF0ZXM7XG5TdWJzY2hlbWEucHJvY2Vzc29ycyA9IF9wcm9jZXNzb3JzO1xuU3Vic2NoZW1hLnN0eWxlcyA9IF9zdHlsZXM7XG5TdWJzY2hlbWEucmVzb2x2ZXJzID0gX3Jlc29sdmVycztcblN1YnNjaGVtYS5EZWZhdWx0TG9hZGVyID0gX0RlZmF1bHRMb2FkZXI7XG5cbmNvbnN0IF9pbml0U3ViY2hlbWFDb250ZXh0ID0gbmV3U3Vic2NoZW1hQ29udGV4dCgpO1xuZXhwb3J0IGNvbnN0IGxvYWRlciA9IF9pbml0U3ViY2hlbWFDb250ZXh0LmxvYWRlcjtcbmV4cG9ydCBjb25zdCBpbmplY3RvciA9IFN1YnNjaGVtYS5pbmplY3RvciA9IF9pbml0U3ViY2hlbWFDb250ZXh0LmluamVjdG9yO1xuZXhwb3J0IGRlZmF1bHQgX2luaXRTdWJjaGVtYUNvbnRleHQ7XG5cbi8qKlxuICogQWxsb3dzIGZvciBhIG5ldyBTdWJzY2hlbWEgaW5zdGFuY2UgdG8gYmUgY3JlYXRlZC4gTW9zdGx5IGZvciB0ZXN0aW5nLFxuICogYnV0IGZvciBvdGhlciBzdHVmZiwgbWF5IGJlIHVzZWZ1bC5cbiAqXG4gKiBAcGFyYW0gZGVmYXVsdExvYWRlcnNcbiAqIEBwYXJhbSBkZWZhdWx0UmVzb2x2ZXJzXG4gKiBAcGFyYW0gZGVmYXVsdFByb3BUeXBlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmV3U3Vic2NoZW1hQ29udGV4dChkZWZhdWx0TG9hZGVycyA9IFtfRGVmYXVsdExvYWRlcl0sIGRlZmF1bHRSZXNvbHZlcnMgPSBfcmVzb2x2ZXJzLCBkZWZhdWx0UHJvcFR5cGVzID0gX1Byb3BUeXBlcywgZGVmYXVsdEluamVjdG9yRmFjdG9yeSA9IF9pbmplY3RvckZhY3RvcnksIGRlZmF1bHRTdWJzY2hlbWEgPSBTdWJzY2hlbWEpIHtcbiAgICByZXR1cm4gX25ld1N1YnNjaGVtYUNvbnRleHQoZGVmYXVsdExvYWRlcnMsIGRlZmF1bHRSZXNvbHZlcnMsIGRlZmF1bHRQcm9wVHlwZXMsIGRlZmF1bHRJbmplY3RvckZhY3RvcnksIGRlZmF1bHRTdWJzY2hlbWEpO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvaW5kZXguanN4XG4gKiovIiwiLyoqXG4gKiBBZGFwdGVkIGZyb20gUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAuanMgYnkgRmFjZWJvb2tcbiAqIEJvcnJvd2VkLCB3aXRoIG11Y2ggdGhhbmtzICBmcm9tIC0gaHR0cDovL21hcm51c3cuZ2l0aHViLmlvL3JlYWN0LWNzcy10cmFuc2l0aW9uLXJlcGxhY2UvXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q1NTVHJhbnNpdGlvblJlcGxhY2VcbiAqL1xuXG5pbXBvcnQgUmVhY3QsIHtQcm9wVHlwZXMsIGNyZWF0ZUVsZW1lbnQsIENoaWxkcmVufSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge2ZpbmRET01Ob2RlfSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCBmcm9tICdyZWFjdC9saWIvUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCc7XG5cbmNvbnN0IHJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSBSZWFjdC5jcmVhdGVGYWN0b3J5KFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQpO1xuXG5jb25zdCBUSUNLID0gMTc7XG5cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvblRpbWVvdXRQcm9wVmFsaWRhdG9yKHRyYW5zaXRpb25UeXBlKSB7XG4gICAgY29uc3QgdGltZW91dFByb3BOYW1lID0gJ3RyYW5zaXRpb24nICsgdHJhbnNpdGlvblR5cGUgKyAnVGltZW91dCc7XG4gICAgY29uc3QgZW5hYmxlZFByb3BOYW1lID0gJ3RyYW5zaXRpb24nICsgdHJhbnNpdGlvblR5cGU7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIC8vIElmIHRoZSB0cmFuc2l0aW9uIGlzIGVuYWJsZWRcbiAgICAgICAgaWYgKHByb3BzW2VuYWJsZWRQcm9wTmFtZV0pIHtcbiAgICAgICAgICAgIC8vIElmIG5vIHRpbWVvdXQgZHVyYXRpb24gaXMgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmICghcHJvcHNbdGltZW91dFByb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IodGltZW91dFByb3BOYW1lICsgJyB3YXNuXFwndCBzdXBwbGllZCB0byBSZWFjdENTU1RyYW5zaXRpb25SZXBsYWNlOiAnXG4gICAgICAgICAgICAgICAgICAgICsgJ3RoaXMgY2FuIGNhdXNlIHVucmVsaWFibGUgYW5pbWF0aW9ucyBhbmQgd29uXFwndCBiZSBzdXBwb3J0ZWQgaW4gJ1xuICAgICAgICAgICAgICAgICAgICArICdhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0LiBTZWUgJ1xuICAgICAgICAgICAgICAgICAgICArICdodHRwczovL2ZiLm1lL3JlYWN0LWFuaW1hdGlvbi10cmFuc2l0aW9uLWdyb3VwLXRpbWVvdXQgZm9yIG1vcmUgJyArICdpbmZvcm1hdGlvbi4nKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkdXJhdGlvbiBpc24ndCBhIG51bWJlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHByb3BzW3RpbWVvdXRQcm9wTmFtZV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcih0aW1lb3V0UHJvcE5hbWUgKyAnIG11c3QgYmUgYSBudW1iZXIgKGluIG1pbGxpc2Vjb25kcyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWN0Q1NTVHJhbnNpdGlvblJlcGxhY2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgdHJhbnNpdGlvbk5hbWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgICAgICBlbnRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIGVudGVyQWN0aXZlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgbGVhdmU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICBsZWF2ZUFjdGl2ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIGFwcGVhcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIGFwcGVhckFjdGl2ZTogUHJvcFR5cGVzLnN0cmluZ1xuICAgICAgICB9KV0pLFxuICAgICAgICB0cmFuc2l0aW9uQXBwZWFyVGltZW91dDogY3JlYXRlVHJhbnNpdGlvblRpbWVvdXRQcm9wVmFsaWRhdG9yKCdBcHBlYXInKSxcbiAgICAgICAgdHJhbnNpdGlvbkVudGVyVGltZW91dDogY3JlYXRlVHJhbnNpdGlvblRpbWVvdXRQcm9wVmFsaWRhdG9yKCdFbnRlcicpLFxuICAgICAgICB0cmFuc2l0aW9uTGVhdmVUaW1lb3V0OiBjcmVhdGVUcmFuc2l0aW9uVGltZW91dFByb3BWYWxpZGF0b3IoJ0xlYXZlJyksXG4gICAgICAgIHRyYW5zaXRpb25IZWlnaHRDbGFzczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgb3ZlcmZsb3dIaWRkZW46IFByb3BUeXBlcy5ib29sLFxuXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IGZhbHNlLFxuICAgICAgICB0cmFuc2l0aW9uRW50ZXI6IHRydWUsXG4gICAgICAgIHRyYW5zaXRpb25MZWF2ZTogdHJ1ZSxcbiAgICAgICAgb3ZlcmZsb3dIaWRkZW46IHRydWUsXG4gICAgICAgIGNvbXBvbmVudDogJ3NwYW4nLFxuICAgICAgICBzdHlsZToge31cbiAgICB9O1xuXG4gICAgc3RhdGUgPSB7XG4gICAgICAgIGN1cnJlbnRDaGlsZDogdGhpcy5wcm9wcy5jaGlsZHJlbiA/IENoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbikgOiBudWxsLFxuICAgICAgICBuZXh0Q2hpbGQ6IG51bGwsXG4gICAgICAgIGhlaWdodDogbnVsbFxuICAgIH07XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudHJhbnNpdGlvbkFwcGVhciAmJiB0aGlzLnN0YXRlLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJDdXJyZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICAvLyBTZXR0aW5nIGZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBjaGlsZCBoYXMgY2hhbmdlZCwgYnV0IGl0IGlzIGEgcmVtb3ZhbCBzbyB0aGVyZSBpcyBubyBuZXh0IGNoaWxkLlxuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBuZXh0UHJvcHMuY2hpbGRyZW4gPyBDaGlsZHJlbi5vbmx5KG5leHRQcm9wcy5jaGlsZHJlbikgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgY3VycmVudENoaWxkID0gdGhpcy5zdGF0ZS5jdXJyZW50Q2hpbGQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDaGlsZCAmJiBuZXh0Q2hpbGQgJiYgbmV4dENoaWxkLmtleSA9PT0gY3VycmVudENoaWxkLmtleSkge1xuICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBidXQgd2UgYXJlIHJlLXJlbmRlcmluZyBzbyB1cGRhdGUgdGhlIGN1cnJlbnRDaGlsZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGQ6IG5leHRDaGlsZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIG5leHQgY2hpbGQgdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24sIGFuZCBzZXQgdGhlIGN1cnJlbnQgaGVpZ2h0LlxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5jdXJyZW50Q2hpbGQgPyBmaW5kRE9NTm9kZSh0aGlzLnJlZnMuY3Vycikub2Zmc2V0SGVpZ2h0IDogMFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBFbnF1ZXVlIHNldHRpbmcgdGhlIG5leHQgaGVpZ2h0IHRvIHRyaWdnZXIgdGhlIGhlaWdodCB0cmFuc2l0aW9uLlxuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2hlaWdodDogdGhpcy5zdGF0ZS5uZXh0Q2hpbGQgPyBmaW5kRE9NTm9kZSh0aGlzLnJlZnMubmV4dCkub2Zmc2V0SGVpZ2h0IDogMH0pO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfSwgVElDSyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5uZXh0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY3VycmVudENoaWxkICYmICh0aGlzLnN0YXRlLm5leHRDaGlsZCB8fCB0aGlzLnN0YXRlLm5leHRDaGlsZCA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFwcGVhckN1cnJlbnQoKSB7XG4gICAgICAgIHRoaXMucmVmcy5jdXJyLmNvbXBvbmVudFdpbGxBcHBlYXIodGhpcy5faGFuZGxlRG9uZUFwcGVhcmluZyk7XG4gICAgICAgIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfaGFuZGxlRG9uZUFwcGVhcmluZyA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgZW50ZXJOZXh0KCkge1xuICAgICAgICB0aGlzLnJlZnMubmV4dC5jb21wb25lbnRXaWxsRW50ZXIodGhpcy5faGFuZGxlRG9uZUVudGVyaW5nKTtcbiAgICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIF9oYW5kbGVEb25lRW50ZXJpbmcgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY3VycmVudENoaWxkOiB0aGlzLnN0YXRlLm5leHRDaGlsZCxcbiAgICAgICAgICAgIG5leHRDaGlsZDogbnVsbCxcbiAgICAgICAgICAgIGhlaWdodDogbnVsbFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGVhdmVDdXJyZW50KCkge1xuICAgICAgICB0aGlzLnJlZnMuY3Vyci5jb21wb25lbnRXaWxsTGVhdmUodGhpcy5faGFuZGxlRG9uZUxlYXZpbmcpO1xuICAgICAgICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2hlbiB0aGUgbGVhdmUgdHJhbnNpdGlvbiB0aW1lLW91dCBleHBpcmVzIHRoZSBhbmltYXRpb24gY2xhc3NlcyBhcmUgcmVtb3ZlZCwgc28gdGhlXG4gICAgLy8gZWxlbWVudCBtdXN0IGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGlmIHRoZSBlbnRlciB0cmFuc2l0aW9uIGlzIHN0aWxsIGluIHByb2dyZXNzLlxuICAgIF9oYW5kbGVEb25lTGVhdmluZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHtjdXJyZW50Q2hpbGQ6IG51bGx9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUubmV4dENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfd3JhcENoaWxkKGNoaWxkLCBtb3JlUHJvcHMpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBwcm92aWRlIHRoaXMgY2hpbGRGYWN0b3J5IHNvIHRoYXRcbiAgICAgICAgLy8gUmVhY3RDU1NUcmFuc2l0aW9uUmVwbGFjZUNoaWxkIGNhbiByZWNlaXZlIHVwZGF0ZXMgdG8gbmFtZSxcbiAgICAgICAgLy8gZW50ZXIsIGFuZCBsZWF2ZSB3aGlsZSBpdCBpcyBsZWF2aW5nLlxuICAgICAgICByZXR1cm4gcmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCh7XG4gICAgICAgICAgICAuLi5tb3JlUHJvcHMsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLnByb3BzLnRyYW5zaXRpb25OYW1lLFxuICAgICAgICAgICAgYXBwZWFyOiB0aGlzLnByb3BzLnRyYW5zaXRpb25BcHBlYXIsXG4gICAgICAgICAgICBlbnRlcjogdGhpcy5wcm9wcy50cmFuc2l0aW9uRW50ZXIsXG4gICAgICAgICAgICBsZWF2ZTogdGhpcy5wcm9wcy50cmFuc2l0aW9uTGVhdmUsXG4gICAgICAgICAgICBhcHBlYXJUaW1lb3V0OiB0aGlzLnByb3BzLnRyYW5zaXRpb25BcHBlYXJUaW1lb3V0LFxuICAgICAgICAgICAgZW50ZXJUaW1lb3V0OiB0aGlzLnByb3BzLnRyYW5zaXRpb25FbnRlclRpbWVvdXQsXG4gICAgICAgICAgICBsZWF2ZVRpbWVvdXQ6IHRoaXMucHJvcHMudHJhbnNpdGlvbkxlYXZlVGltZW91dFxuICAgICAgICB9LCBjaGlsZCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRDaGlsZCwgbmV4dENoaWxkLCBoZWlnaHQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuVG9SZW5kZXIgPSBbXTtcblxuICAgICAgICBjb25zdCB7IG92ZXJmbG93SGlkZGVuLCAuLi5jb250YWluZXJQcm9wcyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAoY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZHJlblRvUmVuZGVyLnB1c2godGhpcy5fd3JhcENoaWxkKGN1cnJlbnRDaGlsZCwge1xuICAgICAgICAgICAgICAgIHJlZjogJ2N1cnInLCBrZXk6ICdjdXJyJ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHt0cmFuc2l0aW9uSGVpZ2h0Q2xhc3MsIHN0eWxlLCBjbGFzc05hbWV9ID0gY29udGFpbmVyUHJvcHM7XG4gICAgICAgICAgICBjb250YWluZXJQcm9wcy5jbGFzc05hbWUgPSBgJHtjbGFzc05hbWUgfHwgJyd9ICR7dHJhbnNpdGlvbkhlaWdodENsYXNzfWA7XG4gICAgICAgICAgICBjb250YWluZXJQcm9wcy5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG92ZXJmbG93SGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyUHJvcHMuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0Q2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuVG9SZW5kZXIucHVzaChcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KCdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICduZXh0J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93cmFwQ2hpbGQobmV4dENoaWxkLCB7cmVmOiAnbmV4dCd9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmNvbXBvbmVudCwgY29udGFpbmVyUHJvcHMsIGNoaWxkcmVuVG9SZW5kZXIpO1xuICAgIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3RyYW5zaXRpb24vUmVhY3RDU1NSZXBsYWNlVHJhbnNpdGlvbi5qc3hcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L3JlYWN0LWRvbS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCcuL1JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCcuL1JlYWN0RE9NJyk7XG5cbnZhciBDU1NDb3JlID0gcmVxdWlyZSgnZmJqcy9saWIvQ1NTQ29yZScpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkV2ZW50cyA9IHJlcXVpcmUoJy4vUmVhY3RUcmFuc2l0aW9uRXZlbnRzJyk7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xuXG4vLyBXZSBkb24ndCByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NIHVudGlsIHdlIHJlY2VpdmUgYW4gYW5pbWF0aW9uZW5kIG9yXG4vLyB0cmFuc2l0aW9uZW5kIGV2ZW50LiBJZiB0aGUgdXNlciBzY3Jld3MgdXAgYW5kIGZvcmdldHMgdG8gYWRkIGFuIGFuaW1hdGlvblxuLy8gdGhlaXIgbm9kZSB3aWxsIGJlIHN0dWNrIGluIHRoZSBET00gZm9yZXZlciwgc28gd2UgZGV0ZWN0IGlmIGFuIGFuaW1hdGlvblxuLy8gZG9lcyBub3Qgc3RhcnQgYW5kIGlmIGl0IGRvZXNuJ3QsIHdlIGp1c3QgY2FsbCB0aGUgZW5kIGxpc3RlbmVyIGltbWVkaWF0ZWx5LlxudmFyIFRJQ0sgPSAxNztcblxudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgbmFtZTogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGVudGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgbGVhdmU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgICBhY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgICB9KSwgUmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGVudGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgZW50ZXJBY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgICBsZWF2ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIGxlYXZlQWN0aXZlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgYXBwZWFyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgYXBwZWFyQWN0aXZlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG4gICAgfSldKS5pc1JlcXVpcmVkLFxuXG4gICAgLy8gT25jZSB3ZSByZXF1aXJlIHRpbWVvdXRzIHRvIGJlIHNwZWNpZmllZCwgd2UgY2FuIHJlbW92ZSB0aGVcbiAgICAvLyBib29sZWFuIGZsYWdzIChhcHBlYXIgZXRjLikgYW5kIGp1c3QgYWNjZXB0IGEgbnVtYmVyXG4gICAgLy8gb3IgYSBib29sIGZvciB0aGUgdGltZW91dCBmbGFncyAoYXBwZWFyVGltZW91dCBldGMuKVxuICAgIGFwcGVhcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgZW50ZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGxlYXZlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhcHBlYXJUaW1lb3V0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGVudGVyVGltZW91dDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBsZWF2ZVRpbWVvdXQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgfSxcblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAoYW5pbWF0aW9uVHlwZSwgZmluaXNoQ2FsbGJhY2ssIHVzZXJTcGVjaWZpZWREZWxheSkge1xuICAgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIGlmIChmaW5pc2hDYWxsYmFjaykge1xuICAgICAgICBmaW5pc2hDYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLm5hbWVbYW5pbWF0aW9uVHlwZV0gfHwgdGhpcy5wcm9wcy5uYW1lICsgJy0nICsgYW5pbWF0aW9uVHlwZTtcbiAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gdGhpcy5wcm9wcy5uYW1lW2FuaW1hdGlvblR5cGUgKyAnQWN0aXZlJ10gfHwgY2xhc3NOYW1lICsgJy1hY3RpdmUnO1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcblxuICAgIHZhciBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgQ1NTQ29yZS5yZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgICAgQ1NTQ29yZS5yZW1vdmVDbGFzcyhub2RlLCBhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgICBSZWFjdFRyYW5zaXRpb25FdmVudHMucmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRMaXN0ZW5lcik7XG5cbiAgICAgIC8vIFVzdWFsbHkgdGhpcyBvcHRpb25hbCBjYWxsYmFjayBpcyB1c2VkIGZvciBpbmZvcm1pbmcgYW4gb3duZXIgb2ZcbiAgICAgIC8vIGEgbGVhdmUgYW5pbWF0aW9uIGFuZCB0ZWxsaW5nIGl0IHRvIHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgICBpZiAoZmluaXNoQ2FsbGJhY2spIHtcbiAgICAgICAgZmluaXNoQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ1NTQ29yZS5hZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuXG4gICAgLy8gTmVlZCB0byBkbyB0aGlzIHRvIGFjdHVhbGx5IHRyaWdnZXIgYSB0cmFuc2l0aW9uLlxuICAgIHRoaXMucXVldWVDbGFzcyhhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgdGltZW91dCBkZWxheS5cbiAgICBpZiAodXNlclNwZWNpZmllZERlbGF5KSB7XG4gICAgICAvLyBDbGVhbi11cCB0aGUgYW5pbWF0aW9uIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXlcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGVuZExpc3RlbmVyLCB1c2VyU3BlY2lmaWVkRGVsYXkpO1xuICAgICAgdGhpcy50cmFuc2l0aW9uVGltZW91dHMucHVzaCh0aW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gREVQUkVDQVRFRDogdGhpcyBsaXN0ZW5lciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiByZWFjdFxuICAgICAgUmVhY3RUcmFuc2l0aW9uRXZlbnRzLmFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kTGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICBxdWV1ZUNsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZS5wdXNoKGNsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmZsdXNoQ2xhc3NOYW1lUXVldWUsIFRJQ0spO1xuICAgIH1cbiAgfSxcblxuICBmbHVzaENsYXNzTmFtZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgIHRoaXMuY2xhc3NOYW1lUXVldWUuZm9yRWFjaChDU1NDb3JlLmFkZENsYXNzLmJpbmQoQ1NTQ29yZSwgUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZSA9IFtdO1xuICAgIHRoaXMudHJhbnNpdGlvblRpbWVvdXRzID0gW107XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2l0aW9uVGltZW91dHMuZm9yRWFjaChmdW5jdGlvbiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxBcHBlYXI6IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuYXBwZWFyKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2FwcGVhcicsIGRvbmUsIHRoaXMucHJvcHMuYXBwZWFyVGltZW91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbEVudGVyOiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmVudGVyKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2VudGVyJywgZG9uZSwgdGhpcy5wcm9wcy5lbnRlclRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxMZWF2ZTogZnVuY3Rpb24gKGRvbmUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5sZWF2ZSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdsZWF2ZScsIGRvbmUsIHRoaXMucHJvcHMubGVhdmVUaW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb25seUNoaWxkKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMTYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTQ29yZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFRoZSBDU1NDb3JlIG1vZHVsZSBzcGVjaWZpZXMgdGhlIEFQSSAoYW5kIGltcGxlbWVudHMgbW9zdCBvZiB0aGUgbWV0aG9kcylcbiAqIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBkZWFsaW5nIHdpdGggdGhlIGRpc3BsYXkgb2YgZWxlbWVudHMgKHZpYSB0aGVpclxuICogQ1NTIGNsYXNzZXMgYW5kIHZpc2liaWxpdHkgb24gc2NyZWVuLiBJdCBpcyBhbiBBUEkgZm9jdXNlZCBvbiBtdXRhdGluZyB0aGVcbiAqIGRpc3BsYXkgYW5kIG5vdCByZWFkaW5nIGl0IGFzIG5vIGxvZ2ljYWwgc3RhdGUgc2hvdWxkIGJlIGVuY29kZWQgaW4gdGhlXG4gKiBkaXNwbGF5IG9mIGVsZW1lbnRzLlxuICovXG5cbnZhciBDU1NDb3JlID0ge1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBjbGFzcyBwYXNzZWQgaW4gdG8gdGhlIGVsZW1lbnQgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgcGFzc2VkIGluXG4gICAqL1xuICBhZGRDbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgICEhL1xccy8udGVzdChjbGFzc05hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NTU0NvcmUuYWRkQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLiBcIiVzXCIgY29udGFpbnMgJyArICdtdWx0aXBsZSBjbGFzc2VzLicsIGNsYXNzTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIGlmICghQ1NTQ29yZS5oYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBjbGFzcyBwYXNzZWQgaW4gZnJvbSB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAhIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDU1NDb3JlLnJlbW92ZUNsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4gXCIlc1wiIGNvbnRhaW5zICcgKyAnbXVsdGlwbGUgY2xhc3Nlcy4nLCBjbGFzc05hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQ1NTQ29yZS5oYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzfCQpJywgJ2cnKSwgJyQxJykucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIG11bHRpcGxlIHNwYWNlcyB0byBvbmVcbiAgICAgICAgLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTsgLy8gdHJpbSB0aGUgZW5kc1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIHRvIGFkZCBvciByZW1vdmUgYSBjbGFzcyBmcm9tIGFuIGVsZW1lbnQgYmFzZWQgb24gYSBjb25kaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHBhcmFtIHsqfSBib29sIGNvbmRpdGlvbiB0byB3aGV0aGVyIHRvIGFkZCBvciByZW1vdmUgdGhlIGNsYXNzXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgY29uZGl0aW9uQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUsIGJvb2wpIHtcbiAgICByZXR1cm4gKGJvb2wgPyBDU1NDb3JlLmFkZENsYXNzIDogQ1NTQ29yZS5yZW1vdmVDbGFzcykoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzIHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtET01Ob2RlfERPTVdpbmRvd30gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzLCBmYWxzZSBpZiBub3RcbiAgICovXG4gIGhhc0NsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgISEvXFxzLy50ZXN0KGNsYXNzTmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ1NTLmhhc0NsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gISFjbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuICgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignICcgKyBjbGFzc05hbWUgKyAnICcpID4gLTE7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NDb3JlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZianMvbGliL0NTU0NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRyYW5zaXRpb25FdmVudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbi8qKlxuICogRVZFTlRfTkFNRV9NQVAgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZXZlbnQgZmlyZWQgd2hlbiBhXG4gKiB0cmFuc2l0aW9uL2FuaW1hdGlvbiBlbmRzLCBiYXNlZCBvbiB0aGUgc3R5bGUgcHJvcGVydHkgdXNlZCB0b1xuICogZGVmaW5lIHRoYXQgZXZlbnQuXG4gKi9cbnZhciBFVkVOVF9OQU1FX01BUCA9IHtcbiAgdHJhbnNpdGlvbmVuZDoge1xuICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdNb3pUcmFuc2l0aW9uJzogJ21velRyYW5zaXRpb25FbmQnLFxuICAgICdPVHJhbnNpdGlvbic6ICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgJ21zVHJhbnNpdGlvbic6ICdNU1RyYW5zaXRpb25FbmQnXG4gIH0sXG5cbiAgYW5pbWF0aW9uZW5kOiB7XG4gICAgJ2FuaW1hdGlvbic6ICdhbmltYXRpb25lbmQnLFxuICAgICdXZWJraXRBbmltYXRpb24nOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICAnTW96QW5pbWF0aW9uJzogJ21vekFuaW1hdGlvbkVuZCcsXG4gICAgJ09BbmltYXRpb24nOiAnb0FuaW1hdGlvbkVuZCcsXG4gICAgJ21zQW5pbWF0aW9uJzogJ01TQW5pbWF0aW9uRW5kJ1xuICB9XG59O1xuXG52YXIgZW5kRXZlbnRzID0gW107XG5cbmZ1bmN0aW9uIGRldGVjdEV2ZW50cygpIHtcbiAgdmFyIHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgc3R5bGUgPSB0ZXN0RWwuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2VhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtXG4gIC8vIGZyb20gdGhlIG1hcFxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgRVZFTlRfTkFNRV9NQVAuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgfVxuXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgRVZFTlRfTkFNRV9NQVAudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG5cbiAgZm9yICh2YXIgYmFzZUV2ZW50TmFtZSBpbiBFVkVOVF9OQU1FX01BUCkge1xuICAgIHZhciBiYXNlRXZlbnRzID0gRVZFTlRfTkFNRV9NQVBbYmFzZUV2ZW50TmFtZV07XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIGJhc2VFdmVudHMpIHtcbiAgICAgIGlmIChzdHlsZU5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgZW5kRXZlbnRzLnB1c2goYmFzZUV2ZW50c1tzdHlsZU5hbWVdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgZGV0ZWN0RXZlbnRzKCk7XG59XG5cbi8vIFdlIHVzZSB0aGUgcmF3IHthZGR8cmVtb3ZlfUV2ZW50TGlzdGVuZXIoKSBjYWxsIGJlY2F1c2UgRXZlbnRMaXN0ZW5lclxuLy8gZG9lcyBub3Qga25vdyBob3cgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBhbmQgd2UgcmVhbGx5IHNob3VsZFxuLy8gY2xlYW4gdXAuIEFsc28sIHRoZXNlIGV2ZW50cyBhcmUgbm90IHRyaWdnZXJlZCBpbiBvbGRlciBicm93c2Vyc1xuLy8gc28gd2Ugc2hvdWxkIGJlIEEtT0sgaGVyZS5cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcikge1xuICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbnZhciBSZWFjdFRyYW5zaXRpb25FdmVudHMgPSB7XG4gIGFkZEVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIElmIENTUyB0cmFuc2l0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCwgdHJpZ2dlciBhbiBcImVuZCBhbmltYXRpb25cIlxuICAgICAgLy8gZXZlbnQgaW1tZWRpYXRlbHkuXG4gICAgICB3aW5kb3cuc2V0VGltZW91dChldmVudExpc3RlbmVyLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGVuZEV2ZW50KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfSxcblxuICByZW1vdmVFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAobm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbmRFdmVudCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uRXZlbnRzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25FdmVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgX2RlY29yYXRvciBmcm9tICcuL2RlY29yYXRvcic7XG5pbXBvcnQgX2xpZmVjeWNsZSBmcm9tICcuL2xpZmVjeWNsZSc7XG5cbmV4cG9ydCBjb25zdCBkZWNvcmF0b3IgPSBfZGVjb3JhdG9yO1xuZXhwb3J0IGNvbnN0IGxpZmVjeWNsZSA9IF9saWZlY3ljbGU7XG5cbmV4cG9ydCBkZWZhdWx0ICh7XG4gICAgZGVjb3JhdG9yOiBfZGVjb3JhdG9yLFxuICAgIGxpZmVjeWNsZTogX2xpZmVjeWNsZVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9kZWNvcmF0b3JzL2luZGV4LmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJy4uL3dhcm5pbmcnO1xuaW1wb3J0IHtGUkVFWkVfQVJSfSBmcm9tICcuLi90dXRpbHMnO1xuXG5mdW5jdGlvbiBpc0Rlc2NyaXB0b3Iob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGlmIChrZXlzLmluZGV4T2YoJ2VudW1lcmFibGUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoa2V5cy5pbmRleE9mKCdjb25maWd1cmFibGUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoa2V5cy5pbmRleE9mKCd3cml0YWJsZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW1wdHlDbGFzc0NvbmZpZygpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZW1wdHlDbGFzcyRyZXR1cm4oVGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBUYXJnZXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZW1wdHlQcm9wZXJ0eUNvbmZpZygpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZW1wdHlQcm9wJHJldHVybih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBNZXRob2QgZGVjb3JhdG9yLlxuICogUmV0dXJucyB0cnVlIGlmIGl0IGlzIGEgcHJvcGVydHkgZGVjb3JhdG9yLlxuICogaXNzdWVzIHdhcm5pbmcgaWYgaXQgaXMgYSBwcm9wZXJ0eSBkZWNvcmF0b3IgdXNlZCBvbiBhIGNsYXNzLlxuICovXG5mdW5jdGlvbiBpc1Byb3BlcnR5KGNvbmZpZywgYXJncykge1xuICAgIC8vMyBhcmd1bWVudHNcbiAgICBpZiAoYXJncyA9PSBudWxsIHx8IGFyZ3MubGVuZ3RoICE9IDMgfHwgYXJnc1swXSA9PSBudWxsIHx8IGFyZ3NbMV0gPT0gbnVsbCB8fCBhcmdzWzJdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vRmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggYSBmdW5jdGlvbiBjb25zdHJ1Y3Rvci5cbiAgICAvL1RPRE8gZmluZCBiZXR0ZXIgaXNudGFuY2UgZGV0ZWN0aW9uLlxuICAgIGlmICghKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYXJnc1swXS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vU2Vjb25kIGFyZ3VtZW50IGlzIGEgc3RyaW5nXG4gICAgaWYgKCEodHlwZW9mIGFyZ3NbMV0gPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy9UaGlyZCBhcmd1bWVudCBpcyB0aGUgZGVzY3JpcHRvcnMgYXJndW1lbnQuXG4gICAgaWYgKCFpc0Rlc2NyaXB0b3IoYXJnc1syXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvL3JldHVybiBPYmplY3QuaGFzT3duUHJvcHR5KGFyZ3NbMl0sICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgZGVjb3JhdG9yLndhcm5pbmcoZmFsc2UsICdkZWNvcmF0b3IgWyVzXSNbJXNdIHdhcyB1c2VkIG9uIGEgbWV0aG9kLCBidXQgdGhlIGRlY29yYXRvciBkb2VzIG5vdCBzdXBwb3J0IHRoaXMnLCAuLi5hcmdzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIENsYXNzIGRlY29yYXRvclxuICogUmV0dXJucyB0cnVlIGlmIGl0IGlzIGEgY2xhc3MgZGVjb3JhdG9yLlxuICogSXNzdWVzIHdhcm5pbmcgaWYgaXQgaXMgYSBjbGFzcyBkZWNvcmF0b3IgdXNlZCBvbiBhIHByb3BlcnR5IGFuZCByZXR1cm4gdHJ1ZS5cbiAqIHJldHVybiBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogLy9CVUctXG4gKiBJZiBzb21lb25lIHVzZXMgYSBmdW5jdGlvbiBhcyB0aGUgb25seSBwYXJhbWV0ZXIgdG8gYSBwcm9wZXJ0eSBkZXNjcmlwdG9yLCB0aGlzIHdpbGwgZmFpbC5cbiAqIGFzIHdlIGNhbiBub3QgZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYmVpbmcgaW52b2tlZFxuICogRXhhbXBsZVxuICogdmFyIGEgPSBmdW5jdGlvbigpe31cbiAqIEBkZWNvcmF0b3IoYSk7XG4gKiBjbGFzcyBTdHVmZiB7XG4gKiBcbiAqIH1cbiAqXG4gKlxuICovXG5mdW5jdGlvbiBpc0NsYXNzKGNvbmZpZywgYXJncykge1xuXG4gICAgaWYgKGFyZ3MgIT0gbnVsbCAmJiBhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY29yYXRvci53YXJuaW5nKGZhbHNlLCAnZGVjb3JhdG9yIFslc10gd2FzIHVzZWQgb24gYSBjbGFzcywgYnV0IHRoZSBkZWNvcmF0b3IgZG9lcyBub3Qgc3VwcG9ydCB0aGlzJywgLi4uYXJncylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZGVjb3JhdG9yIGlzIGEgcHJvcGVydHkgb3IgYSBjbGFzcyBkZWNvcmF0b3IgYW5kIGludm9rZSBhY2NvcmRpbmdseVxuICovXG5mdW5jdGlvbiBkZWNvcmF0b3IkY29uZmlnJGNvbmZpZyhwcm9wZXJ0eUNvbmZpZywgY2xhc3NDb25maWcsIGRlY29yYXRvckFyZ3MgPSBbXSwgLi4uYXJncykge1xuICAgIGlmIChpc1Byb3BlcnR5KHByb3BlcnR5Q29uZmlnLCBhcmdzKSkge1xuXG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnR5Q29uZmlnKC4uLmRlY29yYXRvckFyZ3MpKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBpZiAoaXNDbGFzcyhjbGFzc0NvbmZpZywgYXJncykpIHtcblxuICAgICAgICByZXR1cm4gY2xhc3NDb25maWcoLi4uZGVjb3JhdG9yQXJncykoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBjb25maWcgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGRlY29yYXRvci5cbiAqIFRoaXMgc2hvdWxkIG5vcm1hbGl6ZSBkZWNvcmF0b3IgYWNjZXNzLlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBkZWNvcmF0b3IgaXMgJ21ldGhvZCcgaWYgaXQgaXMgYSBtZXRob2QgZGVjb3JhdG9yLCBvciAnY2xhc3MnIGlmIGl0IGlzXG4gKiBhIGNsYXNzIGRlY29yYXRvci5cbiAqXG4gKiBJdCBhbHNvIG51bWVyYWxpemVzIGludm9rZWQsIHZzIHVuaW52b2tlZCBkZWNvcmF0b3JzXG4gKiBAZGVjb3JhdG9yXG4gKiBjbGFzcyBTdHVmIHtcbiAqIH1cbiAqIG9yXG4gKiBAZGVjb3JhdG9yKClcbiAqIGNsYXNzIFN0dWYge1xuICogfVxuICpcbiAqIGNhbiBiZSBoYW5kbGVkIHdpdGhvdXQgYW55IG90aGVyIGNoZWNrcy5cbiAqXG4gKiBOb3RlIHRoaXMgZm9sbG93cyB0aGUgQGRlY29yYXRvcnMoKSBwcm90b2NvbC4gICBTbyB0aGUgbWV0aG9kIGRlY29yYXRlZCwgc2hvdWxkIGFsd2F5cyByZXR1cm5cbiAqIGEgbWV0aG9kLiAgIFJlZ2FyZGxlc3Mgb2YgdHlwaWNhbCB1c2FnZS5cbiAqXG4gKiBZb3UgY2FuIGFsc28gc3BlY2lmeSBkaWZmZXJlbnQgZnVuY3Rpb25zIGZvciBjbGFzcyBkZWNvcmF0aW9uIG9yIHByb3BlcnR5IGRlY29yYXRpb24uXG4gKlxuICovXG5mdW5jdGlvbiBkZWNvcmF0b3IocHJvcGVydHlDb25maWcgPSBudWxsLCBjbGFzc0NvbmZpZyA9IG51bGwpIHtcbiAgICB2YXIgZGVjb3JhdG9yJGNvbmZpZyA9IGZ1bmN0aW9uIGRlY29yYXRvciRjb25maWcoLi4uZGVjb3JhdG9yQXJncykge1xuICAgICAgICBpZiAoZGVjb3JhdG9yJGNvbmZpZy5ub0RlY29yYXRlIHx8IGRlY29yYXRvci5ub0RlY29yYXRlKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eUNvbmZpZyA9IGVtcHR5UHJvcGVydHlDb25maWc7XG4gICAgICAgICAgICBjbGFzc0NvbmZpZyA9IGVtcHR5Q2xhc3NDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29yYXRvciRjb25maWckY29uZmlnKHByb3BlcnR5Q29uZmlnLCBjbGFzc0NvbmZpZywgRlJFRVpFX0FSUiwgLi4uZGVjb3JhdG9yQXJncykgfHwgZGVjb3JhdG9yJGNvbmZpZyRjb25maWcuYmluZChudWxsLCBwcm9wZXJ0eUNvbmZpZywgY2xhc3NDb25maWcsIGRlY29yYXRvckFyZ3MpXG4gICAgfVxuICAgIHJldHVybiBkZWNvcmF0b3IkY29uZmlnO1xufVxuZGVjb3JhdG9yLnByb3BlcnR5ID0gZGVjb3JhdG9yLmJpbmQobnVsbCk7XG5kZWNvcmF0b3IuY2xhenogPSBkZWNvcmF0b3IuYmluZChudWxsLCBudWxsKTtcbmRlY29yYXRvci53YXJuaW5nID0gd2FybmluZztcblxuLy9EaXNhYmxlIGRlY29yYXRpb24gLSB1c2VmdWwgZm9yIHRlc3RpbmcuXG5kZWNvcmF0b3Iubm9EZWNvcmF0ZSA9IGZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBkZWNvcmF0b3I7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL2RlY29yYXRvcnMvZGVjb3JhdG9yLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IG5vb3AgZnJvbSAnbG9kYXNoL3V0aWxpdHkvbm9vcCc7XG52YXIgd2FybmluZyA9IG5vb3A7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybmluZyA9IGZ1bmN0aW9uIChjaGVjaywgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgc3Vic2NoZW1hOiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLCBpID0gMiwgbWVzc2FnZSA9ICdTdWJzY2hlbWEgV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCAoKT0+YXJnc1tpKytdKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHZvaWQoMCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvL3RyaWdnZXIgZGVidWdnZXI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgd2FybmluZztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3dhcm5pbmcuanNcbiAqKi8iLCIvKipcbiAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdW5kZWZpbmVkYCByZWdhcmRsZXNzIG9mIHRoZVxuICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIF8ubm9vcChvYmplY3QpID09PSB1bmRlZmluZWQ7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9vcDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL3V0aWxpdHkvbm9vcC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBleHRlbmQgZnJvbSAnbG9kYXNoL29iamVjdC9leHRlbmQnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnbG9kYXNoL2xhbmcvaXNGdW5jdGlvbic7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSAnbG9kYXNoL2xhbmcvaXNTdHJpbmcnO1xuaW1wb3J0IGlzUmVnRXhwIGZyb20gJ2xvZGFzaC9sYW5nL2lzUmVnRXhwJztcbmltcG9ydCBpc0RhdGUgZnJvbSAnbG9kYXNoL2xhbmcvaXNEYXRlJztcbmltcG9ydCBpc0Jvb2xlYW4gZnJvbSAnbG9kYXNoL2xhbmcvaXNCb29sZWFuJztcbmltcG9ydCBpc0FycmF5IGZyb20gJ2xvZGFzaC9sYW5nL2lzQXJyYXknO1xuaW1wb3J0IGlzTnVtYmVyIGZyb20gJ2xvZGFzaC9sYW5nL2lzTnVtYmVyJztcbmltcG9ydCBpc09iamVjdCBmcm9tICdsb2Rhc2gvbGFuZy9pc09iamVjdCc7XG5pbXBvcnQgZmluZCBmcm9tICdsb2Rhc2gvY29sbGVjdGlvbi9maW5kJztcbmltcG9ydCB1bmlxdWUgZnJvbSAnbG9kYXNoL2FycmF5L3VuaXF1ZSc7XG5pbXBvcnQgbm9vcCBmcm9tICdsb2Rhc2gvdXRpbGl0eS9ub29wJztcbmltcG9ydCBlYWNoIGZyb20gJ2xvZGFzaC9jb2xsZWN0aW9uL2VhY2gnO1xuaW1wb3J0IHZhbHVlcyBmcm9tICdsb2Rhc2gvb2JqZWN0L3ZhbHVlcyc7XG5cbmNvbnN0IEZSRUVaRV9PQkogPSBPYmplY3QuZnJlZXplKHt9KTtcbmNvbnN0IEZSRUVaRV9BUlIgPSBPYmplY3QuZnJlZXplKFtdKTtcbmNvbnN0IGZsYXR0ZW4gPSBGdW5jdGlvbi5hcHBseS5iaW5kKEFycmF5LnByb3RvdHlwZS5jb25jYXQsIFtdKTtcbmNvbnN0IHB1c2ggPSBGdW5jdGlvbi5hcHBseS5iaW5kKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbmNvbnN0IHNsaWNlID0gRnVuY3Rpb24uY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5zbGljZSk7XG5cbmZ1bmN0aW9uIHJldHVybkZpcnN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlS2V5KHBhdGgsIGtleSkge1xuICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBpZiAoa2V5WzBdICE9ICcuJykge1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBwYXRoID8gcGF0aC5zcGxpdCgnLicpIDogW107XG4gICAga2V5ID0ga2V5LnN1YnN0cmluZygxKTtcbiAgICB3aGlsZSAoa2V5WzBdID09PSAnLicpIHtcbiAgICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygxKTtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgfVxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcGFydHMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAwID8gbnVsbCA6IHBhcnRzLmpvaW4oJy4nKTtcbn1cblxuZnVuY3Rpb24gcmVzdWx0KHNjb3BlLCBrZXkpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQoc2NvcGUsIHNjb3BlW2tleV0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4ga2V5LmNhbGwoc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBwYXRoKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKSwgbCA9IGFyZ3MubGVuZ3RoLCBpID0gMCwgaiA9IDAsIHA7XG4gICAgdmFyIHJldCA9ICcnO1xuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHAgPSBhcmdzW2ldO1xuICAgICAgICBpZiAocCA9PSBudWxsIHx8IHAgPT09ICcnKSBjb250aW51ZTtcbiAgICAgICAgcmV0ICs9IChqKysgPT09IDApID8gcCA6IFwiLlwiICsgcDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSh2KSB7XG4gICAgaWYgKGlzQXJyYXkodikpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyh2KSkge1xuICAgICAgICByZXR1cm4gdi5zcGxpdCgvXFwsXFxzKi8pO1xuICAgIH1cbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIFt2XTtcbn1cblxuZnVuY3Rpb24geHRlbmQoZGVzdCwgYXJncykge1xuICAgIGRlc3QgPSBkZXN0IHx8IHt9O1xuICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoYXJnID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKHZhciBqIGluIGFyZykge1xuICAgICAgICAgICAgZGVzdFtqXSA9IGFyZ3Nbal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5cbmZ1bmN0aW9uIGNsb25lKHQpIHtcbiAgICBpZiAodCA9PSBudWxsKSByZXR1cm4gdDtcbiAgICB2YXIgdHQgPSB0eXBlb2YgdDtcbiAgICBpZiAodHQgPT0gJ2Jvb2xlYW4nIHx8IHR0ID09PSAnbnVtYmVyJyB8fCB0dCA9PT0gJ3N0cmluZycgfHwgdHQgPT09ICdmdW5jdGlvbicgfHwgdHQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSh0KSkge1xuICAgICAgICByZXR1cm4gdC5jb25jYXQoKTtcbiAgICB9XG4gICAgaWYgKHQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0LmdldFRpbWUoKSk7XG4gICAgfVxuICAgIHJldHVybiBleHRlbmQoe30sIHQpO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgdG8pIHtcbiAgICB2YXIgdGk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLCBzZWxmID0gdGhpcztcbiAgICAgICAgdGkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9LCB0byk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBudWxsQ2hlY2sodikge1xuICAgIHJldHVybiB2ICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGVtcHR5Q2hlY2sodikge1xuICAgIHJldHVybiB2ICE9IG51bGwgJiYgdi5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiB1cHBlcmNhc2Uodikge1xuICAgIHJldHVybiB2LnRvVXBwZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlbGl6ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoKHZhbHVlIHx8ICcnKSArICcnKS5yZXBsYWNlKC8oW0EtWl0pL2csICcgJDEnKS5yZXBsYWNlKC9eLi8sIHVwcGVyY2FzZSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5RnVuY3MoZjEsIGYyKSB7XG4gICAgaWYgKGYxICYmICFmMikgcmV0dXJuIGYxO1xuICAgIGlmICghZjEgJiYgZjIpIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlGdW5jcyRib3RoRnVuY3MoLi4uYXJncykge1xuICAgICAgICB0aGlzOjpmMSguLi5hcmdzKTtcbiAgICAgICAgdGhpczo6ZjIoLi4uYXJncyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5oZXJpdHMoQ2xhenopIHtcbiAgICBsZXQgUHJvdG8gPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKFByb3RvID09PSBDbGF6eikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUHJvdG8pO1xuICAgIH0gd2hpbGUgKFByb3RvICE9PSBPYmplY3QgJiYgUHJvdG8gIT0gbnVsbCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBXaGVuIGYxIGFuZCBmMiBhcmUgZGVmaW5lZC1cbiAqXG4gKiBDYWxscyBmMSBhbmQgZjIgaWYgZjEgYW5kIGYyIGFyZSBkZWZpbmVkIGFuZCBmMSBkb2VzIG5vdCByZXR1cm4gZmFsc2UuXG4gKiBJZiBmMSByZXR1cm5zIGZhbHNlLCBmMiBpcyBub3QgY2FsbGVkLlxuICpcbiAqIElmIGYyIGlzIG5vdCBkZWZpbmVkIGYxIGlzIHJldHVybmVkLlxuICogaWYgZjEgaXMgbm90IGRlZmluZWQgZjIgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGYxXG4gKiBAcGFyYW0gZjJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbmV4dEZ1bmMoZjEsIGYyKSB7XG4gICAgaWYgKGYxICYmICFmMikgcmV0dXJuIGYxO1xuICAgIGlmIChmMiAmJiAhZjEpIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dEZ1bmMkd3JhcHBlciguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzOjpmMSguLi5hcmdzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzOjpmMiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vcmUtZXhwb3J0c1xuZXhwb3J0IHtcbiAgICBleHRlbmQsXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc1N0cmluZyxcbiAgICBpc1JlZ0V4cCxcbiAgICBpc0RhdGUsXG4gICAgaXNCb29sZWFuLFxuICAgIGlzQXJyYXksXG4gICAgaXNOdW1iZXIsXG4gICAgZmluZCxcbiAgICB1bmlxdWUsXG4gICAgbm9vcCxcbiAgICBlYWNoLFxuICAgIHZhbHVlcyxcbiAgICBpc09iamVjdCxcbiAgICBGUkVFWkVfT0JKLFxuICAgIEZSRUVaRV9BUlIsXG4gICAgZmxhdHRlbixcbiAgICBwdXNoLFxuICAgIHNsaWNlLFxuICAgIHJlc29sdmVLZXksXG4gICAgcmV0dXJuRmlyc3QsXG4gICAgcmVzdWx0LFxuICAgIHBhdGgsXG4gICAgdG9BcnJheSxcbiAgICB4dGVuZCxcbiAgICBjbG9uZSxcbiAgICBkZWJvdW5jZSxcbiAgICBudWxsQ2hlY2ssXG4gICAgZW1wdHlDaGVjayxcbiAgICB1cHBlcmNhc2UsXG4gICAgdGl0bGVsaXplLFxuICAgIGFwcGx5RnVuY3MsXG4gICAgbmV4dEZ1bmMsXG4gICAgaW5oZXJpdHNcbn07XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNTdHJpbmcsXG4gICAgaXNSZWdFeHAsXG4gICAgaXNEYXRlLFxuICAgIGlzQm9vbGVhbixcbiAgICBpc0FycmF5LFxuICAgIGlzTnVtYmVyLFxuICAgIGZpbmQsXG4gICAgdW5pcXVlLFxuICAgIG5vb3AsXG4gICAgZWFjaCxcbiAgICB2YWx1ZXMsXG4gICAgaXNPYmplY3QsXG4gICAgRlJFRVpFX09CSixcbiAgICBGUkVFWkVfQVJSLFxuICAgIGZsYXR0ZW4sXG4gICAgcHVzaCxcbiAgICByZXNvbHZlS2V5LFxuICAgIHNsaWNlLFxuICAgIGluaGVyaXRzLFxuICAgIHJldHVybkZpcnN0LFxuICAgIHJlc3VsdCxcbiAgICBwYXRoLFxuICAgIHRvQXJyYXksXG4gICAgeHRlbmQsXG4gICAgY2xvbmUsXG4gICAgZGVib3VuY2UsXG4gICAgbnVsbENoZWNrLFxuICAgIGVtcHR5Q2hlY2ssXG4gICAgdXBwZXJjYXNlLFxuICAgIHRpdGxlbGl6ZSxcbiAgICBhcHBseUZ1bmNzLFxuICAgIG5leHRGdW5jXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90dXRpbHMuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYXNzaWduJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9vYmplY3QvZXh0ZW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMTcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYXNzaWduV2l0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Fzc2lnbldpdGgnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUFzc2lnbicpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICogSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0J3MgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOlxuICogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGJhc2VkIG9uXG4gKiBbYE9iamVjdC5hc3NpZ25gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QuYXNzaWduKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGFsaWFzIGV4dGVuZFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5hc3NpZ24oeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDQwIH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICpcbiAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZCh2YWx1ZSkgPyBvdGhlciA6IHZhbHVlO1xuICogfSk7XG4gKlxuICogZGVmYXVsdHMoeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gKi9cbnZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICByZXR1cm4gY3VzdG9taXplclxuICAgID8gYXNzaWduV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcilcbiAgICA6IGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvb2JqZWN0L2Fzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGtleXMgPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5hc3NpZ25gIGZvciBjdXN0b21pemluZyBhc3NpZ25lZCB2YWx1ZXMgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmBcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBhc3NpZ25XaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyKHZhbHVlLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG5cbiAgICBpZiAoKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHx8XG4gICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25XaXRoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYXNzaWduV2l0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2dldE5hdGl2ZScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKSxcbiAgICBzaGltS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3NoaW1LZXlzJyk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbnZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgQ3RvciA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvb2JqZWN0L2tleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc05hdGl2ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNOYXRpdmUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9nZXROYXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTmF0aXZlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc05hdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2xhbmcvaXNGdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2xhbmcvaXNPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9pc09iamVjdExpa2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRMZW5ndGggPSByZXF1aXJlKCcuL2dldExlbmd0aCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2lzQXJyYXlMaWtlLmpzXG4gKiogbW9kdWxlIGlkID0gMTgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9iYXNlUHJvcGVydHknKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRMZW5ndGg7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9nZXRMZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAxODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZVByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvaXNMZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAxODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vaXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG4gKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gIHZhciBhbGxvd0luZGV4ZXMgPSAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGltS2V5cztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL3NoaW1LZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc0FyZ3VtZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2dldE5hdGl2ZScpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNBcnJheSA9IGdldE5hdGl2ZShBcnJheSwgJ2lzQXJyYXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2xhbmcvaXNBcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL15cXGQrJC87XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSA/ICt2YWx1ZSA6IC0xO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9pc0luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICBpbmRleCA9IC0xLFxuICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICBza2lwSW5kZXhlcyA9IGxlbmd0aCA+IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gKGluZGV4ICsgJycpO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShza2lwSW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgJiZcbiAgICAgICAgIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9vYmplY3Qva2V5c0luLmpzXG4gKiogbW9kdWxlIGlkID0gMTg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYmFzZUNvcHkgPSByZXF1aXJlKCcuL2Jhc2VDb3B5JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICogbXVsdGlwbGUgc291cmNlcywgYW5kIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgPT0gbnVsbFxuICAgID8gb2JqZWN0XG4gICAgOiBiYXNlQ29weShzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZUFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQ29weShzb3VyY2UsIHByb3BzLCBvYmplY3QpIHtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ29weTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VDb3B5LmpzXG4gKiogbW9kdWxlIGlkID0gMTkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnLi9iaW5kQ2FsbGJhY2snKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vaXNJdGVyYXRlZUNhbGwnKSxcbiAgICByZXN0UGFyYW0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9yZXN0UGFyYW0nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8uYXNzaWduYCwgYF8uZGVmYXVsdHNgLCBvciBgXy5tZXJnZWAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgIHRoaXNBcmcgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDUpO1xuICAgICAgbGVuZ3RoIC09IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nID8gdGhpc0FyZyA6IHVuZGVmaW5lZDtcbiAgICAgIGxlbmd0aCAtPSAoY3VzdG9taXplciA/IDEgOiAwKTtcbiAgICB9XG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZUFzc2lnbmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi91dGlsaXR5L2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAqIGFuZCBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodGhpc0FyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbiAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9O1xuICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZENhbGxiYWNrO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmluZENhbGxiYWNrLmpzXG4gKiogbW9kdWxlIGlkID0gMTkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC91dGlsaXR5L2lkZW50aXR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vaXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KSkge1xuICAgIHZhciBvdGhlciA9IG9iamVjdFtpbmRleF07XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvaXNJdGVyYXRlZUNhbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzIGFuIGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3Jlc3RfcGFyYW1ldGVycykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2F5ID0gXy5yZXN0UGFyYW0oZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gKiB9KTtcbiAqXG4gKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gcmVzdFBhcmFtKGZ1bmMsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6ICgrc3RhcnQgfHwgMCksIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgcmVzdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdFtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0YXJ0KSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgcmVzdCk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgcmVzdCk7XG4gICAgfVxuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIGluZGV4ID0gLTE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gcmVzdDtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc3RQYXJhbTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2Z1bmN0aW9uL3Jlc3RQYXJhbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc1N0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1JlZ0V4cDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2xhbmcvaXNSZWdFeHAuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZGF0ZVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0RhdGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9sYW5nL2lzRGF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCb29sZWFuKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCb29sZWFuO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc0Jvb2xlYW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmUgY2xhc3NpZmllZFxuICogYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDguNCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoJzguNCcpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc051bWJlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUVhY2gnKSxcbiAgICBjcmVhdGVGaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY3JlYXRlRmluZCcpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAqXG4gKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBhbGlhcyBkZXRlY3RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gKiAgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAqIH0pLCAndXNlcicpO1xuICogLy8gPT4gJ2Jhcm5leSdcbiAqXG4gKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICogLy8gPT4gJ3BlYmJsZXMnXG4gKlxuICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gKiAvLyA9PiAnZnJlZCdcbiAqXG4gKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gKiAvLyA9PiAnYmFybmV5J1xuICovXG52YXIgZmluZCA9IGNyZWF0ZUZpbmQoYmFzZUVhY2gpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9jb2xsZWN0aW9uL2ZpbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL2NyZWF0ZUJhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VFYWNoLmpzXG4gKiogbW9kdWxlIGlkID0gMjAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlRm9yT3duLmpzXG4gKiogbW9kdWxlIGlkID0gMjAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9ySW5gIGFuZCBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXNcbiAqIG92ZXIgYG9iamVjdGAgcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGludm9raW5nIGBpdGVyYXRlZWAgZm9yXG4gKiBlYWNoIHByb3BlcnR5LiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHlcbiAqIHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZUZvci5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi90b09iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gdG9PYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZUJhc2VGb3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIG9iamVjdCBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9PYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC90b09iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldExlbmd0aCA9IHJlcXVpcmUoJy4vZ2V0TGVuZ3RoJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9PYmplY3QgPSByZXF1aXJlKCcuL3RvT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGdldExlbmd0aChjb2xsZWN0aW9uKSA6IDA7XG4gICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSB0b09iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9jcmVhdGVCYXNlRWFjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGJhc2VDYWxsYmFjayA9IHJlcXVpcmUoJy4vYmFzZUNhbGxiYWNrJyksXG4gICAgYmFzZUZpbmQgPSByZXF1aXJlKCcuL2Jhc2VGaW5kJyksXG4gICAgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vYmFzZUZpbmRJbmRleCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmluZChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICBwcmVkaWNhdGUgPSBiYXNlQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGluZGV4ID0gYmFzZUZpbmRJbmRleChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG4gICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGNvbGxlY3Rpb25baW5kZXhdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmluZDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZUZpbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnLi9iaW5kQ2FsbGJhY2snKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL3V0aWxpdHkvaWRlbnRpdHknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3V0aWxpdHkvcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jYWxsYmFja2Agd2hpY2ggc3VwcG9ydHMgc3BlY2lmeWluZyB0aGVcbiAqIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXNBcmcgPT09IHVuZGVmaW5lZFxuICAgICAgPyBmdW5jXG4gICAgICA6IGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gIH1cbiAgaWYgKGZ1bmMgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBiYXNlTWF0Y2hlcyhmdW5jKTtcbiAgfVxuICByZXR1cm4gdGhpc0FyZyA9PT0gdW5kZWZpbmVkXG4gICAgPyBwcm9wZXJ0eShmdW5jKVxuICAgIDogYmFzZU1hdGNoZXNQcm9wZXJ0eShmdW5jLCB0aGlzQXJnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2FsbGJhY2s7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlQ2FsbGJhY2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL2dldE1hdGNoRGF0YScpLFxuICAgIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi90b09iamVjdCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXMgbm90IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgdmFyIGtleSA9IG1hdGNoRGF0YVswXVswXSxcbiAgICAgICAgdmFsdWUgPSBtYXRjaERhdGFbMF1bMV07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSB2YWx1ZSAmJiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIHRvT2JqZWN0KG9iamVjdCkpKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZU1hdGNoZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vYmFzZUlzRXF1YWwnKSxcbiAgICB0b09iamVjdCA9IHJlcXVpcmUoJy4vdG9PYmplY3QnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIGN1c3RvbWl6ZXIsIHRydWUpIDogcmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZUlzTWF0Y2guanNcbiAqKiBtb2R1bGUgaWQgPSAyMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2l0aG91dCBzdXBwb3J0IGZvciBgdGhpc2AgYmluZGluZ1xuICogYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0KHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VJc0VxdWFsLmpzXG4gKiogbW9kdWxlIGlkID0gMjEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vZXF1YWxPYmplY3RzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICBpZiAoIW9iaklzQXJyKSB7XG4gICAgb2JqVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgIGlmIChvYmpUYWcgPT0gYXJnc1RhZykge1xuICAgICAgb2JqVGFnID0gb2JqZWN0VGFnO1xuICAgIH0gZWxzZSBpZiAob2JqVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgb2JqSXNBcnIgPSBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvdGhJc0Fycikge1xuICAgIG90aFRhZyA9IG9ialRvU3RyaW5nLmNhbGwob3RoZXIpO1xuICAgIGlmIChvdGhUYWcgPT0gYXJnc1RhZykge1xuICAgICAgb3RoVGFnID0gb2JqZWN0VGFnO1xuICAgIH0gZWxzZSBpZiAob3RoVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgb3RoSXNBcnIgPSBpc1R5cGVkQXJyYXkob3RoZXIpO1xuICAgIH1cbiAgfVxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmICEob2JqSXNBcnIgfHwgb2JqSXNPYmopKSB7XG4gICAgcmV0dXJuIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnKTtcbiAgfVxuICBpZiAoIWlzTG9vc2UpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LCBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXIsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZXRlY3RpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBzZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNKTy5cbiAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gb2JqZWN0KSB7XG4gICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF0gPT0gb3RoZXI7XG4gICAgfVxuICB9XG4gIC8vIEFkZCBgb2JqZWN0YCBhbmQgYG90aGVyYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gIHN0YWNrQS5wdXNoKG9iamVjdCk7XG4gIHN0YWNrQi5wdXNoKG90aGVyKTtcblxuICB2YXIgcmVzdWx0ID0gKG9iaklzQXJyID8gZXF1YWxBcnJheXMgOiBlcXVhbE9iamVjdHMpKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuXG4gIHN0YWNrQS5wb3AoKTtcbiAgc3RhY2tCLnBvcCgpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZUlzRXF1YWxEZWVwLmpzXG4gKiogbW9kdWxlIGlkID0gMjEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9hcnJheVNvbWUnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgYXJyYXlzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNMb29zZSAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdLFxuICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihpc0xvb3NlID8gb3RoVmFsdWUgOiBhcnJWYWx1ZSwgaXNMb29zZSA/IGFyclZhbHVlIDogb3RoVmFsdWUsIGluZGV4KSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoaXNMb29zZSkge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvZXF1YWxBcnJheXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYXJyYXlTb21lLmpzXG4gKiogbW9kdWxlIGlkID0gMjE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAvLyB0byBgMWAgb3IgYDBgIHRyZWF0aW5nIGludmFsaWQgZGF0ZXMgY29lcmNlZCB0byBgTmFOYCBhcyBub3QgZXF1YWwuXG4gICAgICByZXR1cm4gK29iamVjdCA9PSArb3RoZXI7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gVHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsLlxuICAgICAgcmV0dXJuIChvYmplY3QgIT0gK29iamVjdClcbiAgICAgICAgPyBvdGhlciAhPSArb3RoZXJcbiAgICAgICAgOiBvYmplY3QgPT0gK290aGVyO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzIHByaW1pdGl2ZXMgYW5kIHN0cmluZ1xuICAgICAgLy8gb2JqZWN0cyBhcyBlcXVhbC4gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9lcXVhbEJ5VGFnLmpzXG4gKiogbW9kdWxlIGlkID0gMjE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIga2V5cyA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNMb29zZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc0xvb3NlID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdmFyIHNraXBDdG9yID0gaXNMb29zZTtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XSxcbiAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoaXNMb29zZSA/IG90aFZhbHVlIDogb2JqVmFsdWUsIGlzTG9vc2U/IG9ialZhbHVlIDogb3RoVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCA/IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSA6IHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmICghc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvZXF1YWxPYmplY3RzLmpzXG4gKiogbW9kdWxlIGlkID0gMjE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNMZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9XG50eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2xhbmcvaXNUeXBlZEFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBwYWlycyA9IHJlcXVpcmUoJy4uL29iamVjdC9wYWlycycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gcGFpcnMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2xlbmd0aF1bMl0gPSBpc1N0cmljdENvbXBhcmFibGUocmVzdWx0W2xlbmd0aF1bMV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvZ2V0TWF0Y2hEYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMjE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9pc1N0cmljdENvbXBhcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyksXG4gICAgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC90b09iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2YgdGhlIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAsXG4gKiBlLmcuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgcmVzdWx0W2luZGV4XSA9IFtrZXksIG9iamVjdFtrZXldXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhaXJzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvb2JqZWN0L3BhaXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMjIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vYmFzZUdldCcpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9iYXNlSXNFcXVhbCcpLFxuICAgIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vYmFzZVNsaWNlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vaXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbGFzdCA9IHJlcXVpcmUoJy4uL2FycmF5L2xhc3QnKSxcbiAgICB0b09iamVjdCA9IHJlcXVpcmUoJy4vdG9PYmplY3QnKSxcbiAgICB0b1BhdGggPSByZXF1aXJlKCcuL3RvUGF0aCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHBhdGgpLFxuICAgICAgaXNDb21tb24gPSBpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpLFxuICAgICAgcGF0aEtleSA9IChwYXRoICsgJycpO1xuXG4gIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGtleSA9IHBhdGhLZXk7XG4gICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICBpZiAoKGlzQXJyIHx8ICFpc0NvbW1vbikgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBrZXkgPSBsYXN0KHBhdGgpO1xuICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZVxuICAgICAgPyAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIG9iamVjdCkpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmplY3Rba2V5XSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZU1hdGNoZXNQcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi90b09iamVjdCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RyaW5nIHBhdGhzXG4gKiBhbmQgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aEtleV0gVGhlIGtleSByZXByZXNlbnRhdGlvbiBvZiBwYXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCwgcGF0aEtleSkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhdGhLZXkgIT09IHVuZGVmaW5lZCAmJiBwYXRoS2V5IGluIHRvT2JqZWN0KG9iamVjdCkpIHtcbiAgICBwYXRoID0gW3BhdGhLZXldO1xuICB9XG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbcGF0aFtpbmRleCsrXV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlR2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICB9XG4gIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogKCtlbmQgfHwgMCk7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlU2xpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgdG9PYmplY3QgPSByZXF1aXJlKCcuL3RvT2JqZWN0Jyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXG5cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAoKHR5cGUgPT0gJ3N0cmluZycgJiYgcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSkgfHwgdHlwZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIHJlc3VsdCB8fCAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gdG9PYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9pc0tleS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubGFzdChbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvYXJyYXkvbGFzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vYmFzZVRvU3RyaW5nJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXG5cXFxcXXxcXFxcLikqPylcXDIpXFxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gcHJvcGVydHkgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBiYXNlVG9TdHJpbmcodmFsdWUpLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QYXRoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvdG9QYXRoLmpzXG4gKiogbW9kdWxlIGlkID0gMjI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgaWYgaXQncyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAqIGZvciBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6ICh2YWx1ZSArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlVG9TdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNLZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBhdCBgcGF0aGAgb24gYVxuICogZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiB7ICdjJzogMiB9IH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiB7ICdjJzogMSB9IH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmIuYycpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ucGx1Y2soXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYicsICdjJ10pKSwgJ2EuYi5jJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkocGF0aCkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvdXRpbGl0eS9wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL2Jhc2VHZXQnKSxcbiAgICB0b1BhdGggPSByZXF1aXJlKCcuL3RvUGF0aCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICB2YXIgcGF0aEtleSA9IChwYXRoICsgJycpO1xuICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoLCBwYXRoS2V5KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZVByb3BlcnR5RGVlcC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kYCwgYF8uZmluZExhc3RgLCBgXy5maW5kS2V5YCwgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcsIHdoaWNoIGl0ZXJhdGVzXG4gKiBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyB0aGUgcHJvdmlkZWQgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRLZXldIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnRcbiAqICBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMsIHJldEtleSkge1xuICB2YXIgcmVzdWx0O1xuICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0ID0gcmV0S2V5ID8ga2V5IDogdmFsdWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VGaW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMjMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlRmluZEluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdW5pcScpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvYXJyYXkvdW5pcXVlLmpzXG4gKiogbW9kdWxlIGlkID0gMjMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYmFzZUNhbGxiYWNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUNhbGxiYWNrJyksXG4gICAgYmFzZVVuaXEgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlVW5pcScpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNJdGVyYXRlZUNhbGwnKSxcbiAgICBzb3J0ZWRVbmlxID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvc29ydGVkVW5pcScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICogaXMga2VwdC4gUHJvdmlkaW5nIGB0cnVlYCBmb3IgYGlzU29ydGVkYCBwZXJmb3JtcyBhIGZhc3RlciBzZWFyY2ggYWxnb3JpdGhtXG4gKiBmb3Igc29ydGVkIGFycmF5cy4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQncyBpbnZva2VkIGZvclxuICogZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHVuaXF1ZW5lc3NcbiAqIGlzIGNvbXB1dGVkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gKlxuICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICpcbiAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAYWxpYXMgdW5pcXVlXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWRdIFNwZWNpZnkgdGhlIGFycmF5IGlzIHNvcnRlZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxKFsyLCAxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiAvLyB1c2luZyBgaXNTb3J0ZWRgXG4gKiBfLnVuaXEoWzEsIDEsIDJdLCB0cnVlKTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIHVzaW5nIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gKiBfLnVuaXEoWzEsIDIuNSwgMS41LCAyXSwgZnVuY3Rpb24obikge1xuICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAqIH0sIE1hdGgpO1xuICogLy8gPT4gWzEsIDIuNV1cbiAqXG4gKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICogXy51bmlxKFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICovXG5mdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKGlzU29ydGVkICE9IG51bGwgJiYgdHlwZW9mIGlzU29ydGVkICE9ICdib29sZWFuJykge1xuICAgIHRoaXNBcmcgPSBpdGVyYXRlZTtcbiAgICBpdGVyYXRlZSA9IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc1NvcnRlZCwgdGhpc0FyZykgPyB1bmRlZmluZWQgOiBpc1NvcnRlZDtcbiAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICB9XG4gIGl0ZXJhdGVlID0gaXRlcmF0ZWUgPT0gbnVsbCA/IGl0ZXJhdGVlIDogYmFzZUNhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgcmV0dXJuIChpc1NvcnRlZClcbiAgICA/IHNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKVxuICAgIDogYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvYXJyYXkvdW5pcS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9iYXNlSW5kZXhPZicpLFxuICAgIGNhY2hlSW5kZXhPZiA9IHJlcXVpcmUoJy4vY2FjaGVJbmRleE9mJyksXG4gICAgY3JlYXRlQ2FjaGUgPSByZXF1aXJlKCcuL2NyZWF0ZUNhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluZGV4T2YgPSBiYXNlSW5kZXhPZixcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIGlzTGFyZ2UgPSBpc0NvbW1vbiAmJiBsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSxcbiAgICAgIHNlZW4gPSBpc0xhcmdlID8gY3JlYXRlQ2FjaGUoKSA6IG51bGwsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBpZiAoc2Vlbikge1xuICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgMCkgPCAwKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUgfHwgaXNMYXJnZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZVVuaXEuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpbmRleE9mTmFOID0gcmVxdWlyZSgnLi9pbmRleE9mTmFOJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCk7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2Jhc2VJbmRleE9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBOYU5gIGlzIGZvdW5kIGluIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgYE5hTmAsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gaW5kZXhPZk5hTihhcnJheSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDAgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKG90aGVyICE9PSBvdGhlcikge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZk5hTjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2luZGV4T2ZOYU4uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY2FjaGVgIG1pbWlja2luZyB0aGUgcmV0dXJuIHNpZ25hdHVyZSBvZlxuICogYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gY2FjaGUuZGF0YSxcbiAgICAgIHJlc3VsdCA9ICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNPYmplY3QodmFsdWUpKSA/IGRhdGEuc2V0Lmhhcyh2YWx1ZSkgOiBkYXRhLmhhc2hbdmFsdWVdO1xuXG4gIHJldHVybiByZXN1bHQgPyAwIDogLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVJbmRleE9mO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvY2FjaGVJbmRleE9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL1NldENhY2hlJyksXG4gICAgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9nZXROYXRpdmUnKTtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUoZ2xvYmFsLCAnU2V0Jyk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgU2V0YCBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgbmV3IGNhY2hlIG9iamVjdCBpZiBgU2V0YCBpcyBzdXBwb3J0ZWQsIGVsc2UgYG51bGxgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSh2YWx1ZXMpIHtcbiAgcmV0dXJuIChuYXRpdmVDcmVhdGUgJiYgU2V0KSA/IG5ldyBTZXRDYWNoZSh2YWx1ZXMpIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDYWNoZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZUNhY2hlLmpzXG4gKiogbW9kdWxlIGlkID0gMjM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2FjaGVQdXNoID0gcmVxdWlyZSgnLi9jYWNoZVB1c2gnKSxcbiAgICBnZXROYXRpdmUgPSByZXF1aXJlKCcuL2dldE5hdGl2ZScpO1xuXG4vKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShnbG9iYWwsICdTZXQnKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmRhdGEgPSB7ICdoYXNoJzogbmF0aXZlQ3JlYXRlKG51bGwpLCAnc2V0JzogbmV3IFNldCB9O1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB0aGlzLnB1c2godmFsdWVzW2xlbmd0aF0pO1xuICB9XG59XG5cbi8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGBTZXRgIGNhY2hlLlxuU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBjYWNoZVB1c2g7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9TZXRDYWNoZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHB1c2hcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBkYXRhLnNldC5hZGQodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGRhdGEuaGFzaFt2YWx1ZV0gPSB0cnVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVQdXNoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvY2FjaGVQdXNoLmpzXG4gKiogbW9kdWxlIGlkID0gMjQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIG9wdGltaXplZCBmb3Igc29ydGVkIGFycmF5cyB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIHNlZW4sXG4gICAgICBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgIGlmICghaW5kZXggfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHtcbiAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRlZFVuaXE7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9zb3J0ZWRVbmlxLmpzXG4gKiogbW9kdWxlIGlkID0gMjQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZm9yRWFjaCcpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvY29sbGVjdGlvbi9lYWNoLmpzXG4gKiogbW9kdWxlIGlkID0gMjQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlRWFjaCcpLFxuICAgIGNyZWF0ZUZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jcmVhdGVGb3JFYWNoJyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5XG4gKiBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiIHByb3BlcnR5XG4gKiBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgYF8uZm9ySW5gIG9yIGBfLmZvck93bmBcbiAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfKFsxLCAyXSkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gKiAgIGNvbnNvbGUubG9nKG4pO1xuICogfSkudmFsdWUoKTtcbiAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIGxlZnQgdG8gcmlnaHQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24obiwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKG4sIGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZS1rZXkgcGFpciBhbmQgcmV0dXJucyB0aGUgb2JqZWN0IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbnZhciBmb3JFYWNoID0gY3JlYXRlRm9yRWFjaChhcnJheUVhY2gsIGJhc2VFYWNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvY29sbGVjdGlvbi9mb3JFYWNoLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYXJyYXlFYWNoLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnLi9iaW5kQ2FsbGJhY2snKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JFYWNoYCBvciBgXy5mb3JFYWNoUmlnaHRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBhcnJheS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgIHJldHVybiAodHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgdGhpc0FyZyA9PT0gdW5kZWZpbmVkICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgICA/IGFycmF5RnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSlcbiAgICAgIDogZWFjaEZ1bmMoY29sbGVjdGlvbiwgYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRm9yRWFjaDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZUZvckVhY2guanNcbiAqKiBtb2R1bGUgaWQgPSAyNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBiYXNlVmFsdWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVZhbHVlcycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9vYmplY3QvdmFsdWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlVmFsdWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7YXBwbHlGdW5jc30gZnJvbSAnLi4vdHV0aWxzJztcbmltcG9ydCBkZWNvcmF0b3IgZnJvbSAnLi9kZWNvcmF0b3InO1xuLyoqXG4gKiBBZGQgYSBmdW5jdGlvbiB0byB0aGUgbGlmZWN5Y2xlLiBCeSBEZWZhdWx0IGl0cyBjb21wb25lbnRXaWxsTW91bnQ7XG4gKiBpdCBoYXMgMiBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gKlxuICogY29tcG9uZW50V2lsbE1vdW50XG4gKlxuICogWW91ciBmdW5jdGlvbiB3aWxsIGdldCBpbnZva2VkIGJlZm9yZSwgdGhlIGRvd24gc3RyZWFtcyBjb21wb25lbnQuXG4gKlxuICogVGhpcyBhbGxvd3MgZm9yIG5pY2UgbmFtZXMsIGFuZCBtZXRob2RzIHRoYXQgY2FuIGJlIGludm9rZWQgd2l0aG91dCB3b3JyeVxuICogb2Ygc3ViY2xhc3NlcyBiZWluZyBjYWxsZWQuXG4gKlxuICogIEBsaWZlY3ljbGUoXCJjb21wb25lbnRXaWxsTW91bnRcIilcbiAqICB5b3VyRnVuYygpe1xuICpcbiAqICB9XG4gKi9cbi8qKlxuICogQHBhcmFtIHN0YWdlIFtzdHJnaW49Y29tcG9uZW50V2lsbE1vdW50XSAtIFRoZSBsaWZlY3ljbGUgbWV0aG9kIHRvIHBhcnRha2UgaW4gLlxuICogQHBhcmFtIGJlZm9yZSBbYm9vbGVhbj10cnVlXSAtIFJ1biB5b3VycyBiZWZvcmUgdGhlIG9yaWdpbmFsIG9yIGlmIGZhbHNlIGFmdGVyLlxuICogKi9cbmZ1bmN0aW9uIGxpZmVjeWNsZShzdGFnZSA9IFwiY29tcG9uZW50V2lsbE1vdW50XCIsIGJlZm9yZSA9IHRydWUpIHtcbiAgICBiZWZvcmUgPSBiZWZvcmUgPT0gbnVsbCA/IHRydWUgOiBiZWZvcmU7XG4gICAgcmV0dXJuIGJlZm9yZSA/IGxpZmVjeWNsZSRjb25maWckYmVmb3JlIDpsaWZlY3ljbGUkY29uZmlnJGFmdGVyO1xuICAgIFxuICAgIGZ1bmN0aW9uIGxpZmVjeWNsZSRjb25maWckYmVmb3JlKFRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICAgICAgICBUYXJnZXRbc3RhZ2VdID0gYXBwbHlGdW5jcyhkZXNjcmlwdG9yLnZhbHVlLCBUYXJnZXRbc3RhZ2VdKTtcbiAgICB9IFxuXG4gICAgZnVuY3Rpb24gbGlmZWN5Y2xlJGNvbmZpZyRhZnRlcihUYXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgVGFyZ2V0W3N0YWdlXSA9IGFwcGx5RnVuY3MoVGFyZ2V0W3N0YWdlXSwgZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWNvcmF0b3IobGlmZWN5Y2xlKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL2RlY29yYXRvcnMvbGlmZWN5Y2xlLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgbG9hZGVyRmFjdG9yeSBmcm9tICcuL2xvYWRlckZhY3RvcnknO1xuaW1wb3J0IHRlbXBsYXRlcyBmcm9tICcuL3RlbXBsYXRlcyc7XG5pbXBvcnQgdHlwZXMgZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgcHJvY2Vzc29ycyBmcm9tICcuL3Byb2Nlc3NvcnMnO1xuaW1wb3J0IHZhbGlkYXRvcnMgZnJvbSAnLi92YWxpZGF0b3JzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMnO1xuaW1wb3J0IHRyYW5zaXRpb25zIGZyb20gJy4vdHJhbnNpdGlvbic7XG5cbmNvbnN0IGxvYWRlciA9IGxvYWRlckZhY3RvcnkoKTtcblxubG9hZGVyLmFkZFRlbXBsYXRlKHRlbXBsYXRlcyk7XG5sb2FkZXIuYWRkUHJvY2Vzc29yKHByb2Nlc3NvcnMpO1xubG9hZGVyLmFkZFR5cGUoT2JqZWN0LmtleXModHlwZXMpLnJlZHVjZSgocmV0LCBrZXkpPT4ge1xuICAgIGlmICgvXihpbmRleHwuKk1peGluKSQvLnRlc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXRba2V5XSA9IHR5cGVzW2tleV07XG4gICAgcmV0dXJuIHJldDtcbn0sIHt9KSk7XG5sb2FkZXIuYWRkU3R5bGUoc3R5bGVzKTtcbmxvYWRlci5hZGRWYWxpZGF0b3IodmFsaWRhdG9ycyk7XG5sb2FkZXIuYWRkVHJhbnNpdGlvbih0cmFuc2l0aW9ucy50cmFuc2l0aW9ucyk7XG5cbmV4cG9ydCBkZWZhdWx0IGxvYWRlcjtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvRGVmYXVsdExvYWRlci5qc1xuICoqLyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IHtpc0FycmF5LHRvQXJyYXksaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzUmVnRXhwfSBmcm9tICcuL3R1dGlscyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3dhcm5pbmcnO1xuXG5jb25zdCBjb25jYXQgPSBGdW5jdGlvbi5hcHBseS5iaW5kKEFycmF5LnByb3RvdHlwZS5jb25jYXQsIFtdKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9hZGVyRmFjdG9yeShsb2FkZXJzID0gW10pIHtcbiAgICBjb25zdCB0eXBlcyA9IHtsb2FkLCBsaXN0LCBhZGR9LFxuICAgICAgICBhcGkgPSB7XG5cbiAgICAgICAgICAgIGFkZExvYWRlcihsb2FkZXIpe1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGxvYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlci5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZExvYWRlcih2KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobG9hZGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSAvXihsb2FkfGxpc3QpKC4qKS8uZXhlYyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDIgJiYgcGFydHNbMV0gaW4gdHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB0eXBlc1twYXJ0c1sxXV0ocGFydHNbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZG8gbm90IHVuZGVyc3RhbmQgJyArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIGxvYWRlcnMudW5zaGlmdChsb2FkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlTG9hZGVyKGxvYWRlcil7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGxvYWRlcnMuaW5kZXhPZihsb2FkZXIpO1xuICAgICAgICAgICAgICAgIGlmICgwID4gaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGxvYWRlcnMuc3BsaWNlKGlkeCwgMSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKHJldCAmJiByZXQgJiYgcmV0LnJlbW92ZUxvYWRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXQucmVtb3ZlTG9hZGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjbGVhckxvYWRlcnMoKXtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbG9hZGVycy5jb25jYXQoKTtcbiAgICAgICAgICAgICAgICBsb2FkZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuXG4gICAgZnVuY3Rpb24gbGlzdChtZXRob2QpIHtcbiAgICAgICAgdmFyIHR5cGUgPSAnbGlzdCcgKyBtZXRob2QgKyAncyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb2FkZXIkbGlzdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQobG9hZGVycy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZbdHlwZV0gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2W3R5cGVdKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QgPSAnbG9hZCcgKyBtZXRob2Q7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb2FkJGxvYWQobG9hZCkge1xuICAgICAgICAgICAgdmFyIGkgPSAwLCBsID0gbG9hZGVycy5sZW5ndGgsIHJldCA9IG51bGwsIHNjb3BlO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbG9hZGVyc1tpXVttZXRob2RdICYmIGxvYWRlcnNbaV1bbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZCh0eXBlKSB7XG4gICAgICAgIHZhciBsaXN0S2V5ID0gJ2xpc3QnICsgdHlwZSArICdzJywgbG9hZEtleSA9ICdsb2FkJyArIHR5cGUsIGxjVHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvYWRlciRhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG1hcCwgX2FwaSA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBtYXBba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYXBpW2xpc3RLZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge25hbWV9O1xuICAgICAgICAgICAgICAgICAgICByZXRbbGNUeXBlXSA9IG1hcFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfYXBpW2xvYWRLZXldID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwW25hbWVdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFwaS5hZGRMb2FkZXIoX2FwaSk7XG4gICAgICAgICAgICByZXR1cm4gX2FwaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkZXJUeXBlKG5hbWUsIGFkZEYgPSBhZGQsIGxvYWRGID0gbG9hZCwgbGlzdEYgPSBsaXN0KSB7XG4gICAgICAgIGlmIChhZGRGKSB7XG4gICAgICAgICAgICB0aGlzW2BhZGQke25hbWV9YF0gPSBhZGRGKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2FkRikge1xuICAgICAgICAgICAgdGhpc1tgbG9hZCR7bmFtZX1gXSA9IGxvYWRGKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0Rikge1xuICAgICAgICAgICAgdGhpc1tgbGlzdCR7bmFtZX1zYF0gPSBsaXN0RihuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgWydPcGVyYXRvcicsICdUZW1wbGF0ZScsICdQcm9jZXNzb3InLCAnVHlwZScsICdTY2hlbWEnLCAnVmFsaWRhdG9yJywgJ1N0eWxlJywgJ1RyYW5zaXRpb24nXS5mb3JFYWNoKHYgPT4gYXBpOjpsb2FkZXJUeXBlKHYpKTtcbiAgICByZXR1cm4gYXBpO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9sb2FkZXJGYWN0b3J5LmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBleHRlbmQgICBmcm9tICdsb2Rhc2gvb2JqZWN0L2V4dGVuZCc7XG5pbXBvcnQgZmluZCAgICAgZnJvbSAnbG9kYXNoL2NvbGxlY3Rpb24vZmluZCc7XG5pbXBvcnQgbWFwICAgICAgZnJvbSAnbG9kYXNoL2NvbGxlY3Rpb24vbWFwJztcbmltcG9ydCB7UHJvcFR5cGVzIGFzIElQfSBmcm9tICdzdWJzY2hlbWEtaW5qZWN0aW9uL3NyYy9pbmRleCc7XG5cbi8vd2UnbGwgcmUtZXhwb3J0IHRoZXNlIGZvciBjb252ZW5pZW5jZSBpbiB0aGUgYmFiZWw2IHdvcmxkLlxuY29uc3Qge3N0cmluZyxib29sLG51bWJlcixvYmplY3QsZnVuYywgYW55LCBub2RlLHNoYXBlLCBhcnJheU9mLGluc3RhbmNlT2Ysb25lT2YsIG9uZU9mVHlwZX0gPSBQcm9wVHlwZXM7XG5cbmZ1bmN0aW9uIGN1c3RvbVByb3BUeXBlKHR5cGUsIG5hbWUpIHtcbiAgICBmdW5jdGlvbiBjdXN0b21Qcm9wVHlwZSRyZXR1cm4oLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdHlwZS5hcHBseShhcGksIGFyZ3MpO1xuICAgIH1cblxuICAgIGN1c3RvbVByb3BUeXBlJHJldHVybi5pc1JlcXVpcmVkID0gZnVuY3Rpb24gY3VzdG9tUHJvcFR5cGUkcmV0dXJuJGlzUmVxdWlyZWQoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdHlwZS5pc1JlcXVpcmVkLmFwcGx5KHR5cGUsIGFyZ3MpO1xuICAgIH07XG4gICAgaWYgKG5hbWUpXG4gICAgICAgIGN1c3RvbVByb3BUeXBlJHJldHVybi5wcm9wVHlwZU5hbWUgPSBuYW1lO1xuXG4gICAgcmV0dXJuIGN1c3RvbVByb3BUeXBlJHJldHVybjtcbn1cblxuZnVuY3Rpb24gcHJvcFR5cGVUb05hbWUocHJvcFR5cGUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXBpKSwgbCA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGxldCBrZXkgPSBrZXlzW2ldLCBmID0gYXBpW2tleV07XG4gICAgICAgIGlmIChmLmlzUmVxdWlyZWQgPT09IHByb3BUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyonICsga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmID09PSBwcm9wVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvcFR5cGVzVG9OYW1lcyhwcm9wcykge1xuICAgIGxldCByZXQgPSB7fTtcbiAgICBtYXAocHJvcHMsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHJldFtrXSA9IHByb3BUeXBlVG9OYW1lKHYpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IGNvbmRpdGlvbmFsID0gb25lT2ZUeXBlKFtzdHJpbmcsIHNoYXBlKHtcbiAgICBvcGVyYXRvcjogb25lT2ZUeXBlKFtzdHJpbmcsIGZ1bmNdKVxufSldKTtcblxuY29uc3QgZG9tVHlwZSA9IGN1c3RvbVByb3BUeXBlKG5vZGUsICdkb21UeXBlJyk7XG5cbmNvbnN0IGZpZWxkcyA9IGN1c3RvbVByb3BUeXBlKGFycmF5T2Yoc3RyaW5nKSwgJ2ZpZWxkcycpO1xuXG5jb25zdCB0aXRsZSA9IGN1c3RvbVByb3BUeXBlKG9uZU9mVHlwZShbc3RyaW5nLCBib29sXSksICd0aXRsZScpO1xuXG5jb25zdCBpbmplY3RvciA9IElQLmluamVjdG9yO1xuXG5jb25zdCBibHVyVmFsaWRhdGUgPSBjdXN0b21Qcm9wVHlwZShmdW5jLCAnYmx1clZhbGlkYXRlJyk7XG5cbmNvbnN0IGNoYW5nZVZhbGlkYXRlID0gY3VzdG9tUHJvcFR5cGUoZnVuYywgJ2NoYW5nZVZhbGlkYXRlJyk7XG5cbmNvbnN0IHZhbGlkYXRlID0gY3VzdG9tUHJvcFR5cGUoZnVuYywgJ3ZhbGlkYXRlJyk7XG5cbmNvbnN0IHZhbHVlID0gY3VzdG9tUHJvcFR5cGUoYW55LCAndmFsdWUnKTtcblxuY29uc3QgbWVzc2FnZSA9IGN1c3RvbVByb3BUeXBlKGFueSwgJ21lc3NhZ2UnKTtcblxuY29uc3QgZXJyb3IgPSBjdXN0b21Qcm9wVHlwZShhbnksICdlcnJvcicpO1xuXG5jb25zdCBlcnJvcnMgPSBjdXN0b21Qcm9wVHlwZShhbnksICdlcnJvcnMnKTtcblxuY29uc3QgcHJvbWlzZSA9IHNoYXBlKHt0aGVuOiBmdW5jfSk7XG5cbmNvbnN0IGlkID0gY3VzdG9tUHJvcFR5cGUoc3RyaW5nLCAnaWQnKTtcblxuY29uc3QgaHRtbEZvciA9IGN1c3RvbVByb3BUeXBlKGlkLCAnaHRtbEZvcicpO1xuXG5jb25zdCBmaWVsZEF0dHJzID0gY3VzdG9tUHJvcFR5cGUob2JqZWN0LCAnZmllbGRBdHRycycpO1xuXG5jb25zdCBjc3NDbGFzcyA9IGN1c3RvbVByb3BUeXBlKHN0cmluZywgJ2Nzc0NsYXNzJyk7XG5cbmNvbnN0IHN0eWxlID0gY3VzdG9tUHJvcFR5cGUob2JqZWN0LCAnc3R5bGUnKTtcblxuY29uc3QgdHlwZUNsYXNzID0gY3VzdG9tUHJvcFR5cGUoY3NzQ2xhc3MsICd0eXBlQ2xhc3MnKTtcblxuY29uc3QgdGVtcGxhdGVDbGFzcyA9IGN1c3RvbVByb3BUeXBlKGNzc0NsYXNzLCAndGVtcGxhdGVDbGFzcycpO1xuXG5jb25zdCBpbmplY3RlZENsYXNzID0gY3VzdG9tUHJvcFR5cGUoYW55LCBcImluamVjdGVkQ2xhc3NcIik7XG5cbmNvbnN0IGV2ZW50ID0gY3VzdG9tUHJvcFR5cGUoZnVuYywgJ2V2ZW50Jyk7XG5cbmNvbnN0IHZhbGlkYXRvciA9IGN1c3RvbVByb3BUeXBlKGZ1bmMsICd2YWxpZGF0b3InKTtcblxuY29uc3QgcGF0aCA9IGN1c3RvbVByb3BUeXBlKHN0cmluZywgJ3BhdGgnKTtcblxuY29uc3QgcGxhY2Vob2xkZXIgPSBjdXN0b21Qcm9wVHlwZShzdHJpbmcsICdwbGFjZWhvbGRlcicpO1xuXG5jb25zdCBhcnJheVN0cmluZyA9IG9uZU9mVHlwZShbc3RyaW5nLCBhcnJheU9mKHN0cmluZyldKVxuXG5cbmNvbnN0IGxpc3RlbmVyID0gY3VzdG9tUHJvcFR5cGUoYW55LCAnbGlzdGVuZXInKTtcblxuLyoqXG4gKiBBIHZhbHVlRXZlbnQgZG9lcyBub3QgZXhwZWN0IHRhcmdldC52YWx1ZVxuICovXG5jb25zdCB2YWx1ZUV2ZW50ID0gY3VzdG9tUHJvcFR5cGUoZnVuYywgJ3ZhbHVlRXZlbnQnKTtcblxuLyoqXG4gKiBBIHRhcmdldEV2ZW50IGV4cGVjdHMgdGhlIGZpcnN0IGFyZyB0byBoYXZlIHRhcmdldC52YWx1ZVxuICovXG5jb25zdCB0YXJnZXRFdmVudCA9IGN1c3RvbVByb3BUeXBlKGZ1bmMsICd0YXJnZXRFdmVudCcpO1xuXG4vKipcbiAqIEEgZXJyb3JFdmVudCBleHBlY3RzIHRoZSBmaXJzdCBhcmcgdG8gYmUgYW4gZXJyb3IuXG4gKi9cbmNvbnN0IGVycm9yRXZlbnQgPSBjdXN0b21Qcm9wVHlwZShmdW5jLCAnZXJyb3JFdmVudCcpO1xuXG4vKipcbiAqIFNpZ25pZnkgdGhpcyBpcyBhIGJsdXIgRXZlbnQgTGlzdGVuZXIuXG4gKi9cbmNvbnN0IGJsdXJFdmVudCA9IGN1c3RvbVByb3BUeXBlKGZ1bmMsICdibHVyRXZlbnQnKTtcblxuXG4vKipcbiAqIFNpZ25pZnkgdGhpcyBpcyBhIG9uVmFsaWQgRXZlbnQgbGlzdGVuZXIuXG4gKi9cbmNvbnN0IHZhbGlkRXZlbnQgPSBjdXN0b21Qcm9wVHlwZShmdW5jLCAndmFsaWRFdmVudCcpO1xuXG5jb25zdCBkYXRhVHlwZSA9IGN1c3RvbVByb3BUeXBlKHN0cmluZywgJ2RhdGFUeXBlJyk7XG5cbmNvbnN0IHR5cGUgPSBvbmVPZlR5cGUoW3N0cmluZywgZnVuY10pO1xuXG5jb25zdCB0eXBlRGVzY3JpcHRpb24gPSBvbmVPZlR5cGUoW3N0cmluZywgc2hhcGUoe1xuICAgIHR5cGU6IHN0cmluZy5pc1JlcXVpcmVkXG59KV0pO1xuXG5jb25zdCBfdHJhbnNpdGlvblR5cGVzID0gb25lT2YoWydhcHBlYXInLCAnZW50ZXInLCAnbGVhdmUnXSk7XG5jb25zdCB0cmFuc2l0aW9uID0gb25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBzaGFwZSh7XG4gICAgdHJhbnNpdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbjogX3RyYW5zaXRpb25UeXBlc1xufSldKTtcblxuLyoqXG4gKiBTaWduaWZ5IHRoaXMgcHJvcGVydHkgY2FuIHRha2UgYW4gZXhwcmVzc2lvbi4gIFRoaXNcbiAqIGFsbG93cyBwcm9wZXJ0aWVzIHRvIGJlIHRpZWQgdG8gdGhlIHZhbHVlTWFuYWdlci4gIFNvXG4gKiBpdCB3aWxsIGV2YWx1YXRlIHRoZSBwcm9wZXJ0eSBhZ2FpbnN0IHRoZSB2YWx1ZU1hbmFnZXIuXG4gKlxuICogSXQgd2lsbCBhZGQgYSBsaXN0ZW5lciBmb3IgZWFjaCBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICogbWF0Y2hpbmcgc3RyaW5ncy5cbiAqXG4gKi9cbmNvbnN0IGV4cHJlc3Npb24gPSBjdXN0b21Qcm9wVHlwZShzdHJpbmcsICdleHByZXNzaW9uJyk7XG5cbmNvbnN0IGxvYWRlciA9IHNoYXBlKHtcbiAgICBsb2FkVGVtcGxhdGU6IGZ1bmMsXG4gICAgbG9hZFR5cGU6IGZ1bmMsXG4gICAgbG9hZFNjaGVtYTogZnVuYyxcbiAgICBsb2FkVmFsaWRhdG9yOiBmdW5jLFxuICAgIGxvYWRQcm9jZXNzb3I6IGZ1bmMsXG4gICAgbG9hZE9wZXJhdG9yOiBmdW5jXG59KTtcblxuY29uc3QgdmFsdWVNYW5hZ2VyID0gc2hhcGUoe1xuICAgIGFkZExpc3RlbmVyOiBmdW5jLFxuXG4gICAgYWRkRXJyb3JMaXN0ZW5lcjogZnVuYyxcblxuICAgIGFkZFZhbGlkYXRlTGlzdGVuZXI6IGZ1bmMsXG5cbiAgICBhZGRTdWJtaXRMaXN0ZW5lcjogZnVuYyxcblxuICAgIGFkZFN0YXRlTGlzdGVuZXI6IGZ1bmMsXG59KTtcblxubGV0IGNvbnRlbnRTaGFwZSA9IHtcbiAgICBjbGFzc05hbWU6IGNzc0NsYXNzLFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBjaGlsZHJlbjogYm9vbFxufTtcblxubGV0IHBDb250ZW50U2hhcGUgPSBzaGFwZShjb250ZW50U2hhcGUpO1xuXG5sZXQgY29udGVudFR5cGUgPSBvbmVPZlR5cGUoW3BDb250ZW50U2hhcGUsIHN0cmluZywgYm9vbCwgZnVuYywgbnVtYmVyLCBhcnJheU9mKG9uZU9mVHlwZShbc3RyaW5nLCBzdHJpbmcsIGJvb2wsIG51bWJlciwgZnVuYywgcENvbnRlbnRTaGFwZV0pKV0pO1xuXG5jb250ZW50U2hhcGUuY29udGVudCA9IGNvbnRlbnRUeXBlO1xuXG5jb25zdCBjb250ZW50ID0gY29udGVudFR5cGU7XG5cbmNvbnN0IHRlbXBsYXRlID0gb25lT2ZUeXBlKFtzdHJpbmcsIGJvb2wsIHNoYXBlKHtcbiAgICB0ZW1wbGF0ZTogb25lT2ZUeXBlKFtzdHJpbmcsIGJvb2wsIGZ1bmNdKSxcbiAgICBjb250ZW50OiBjb250ZW50LFxuICAgIGNsYXNzTmFtZTogY3NzQ2xhc3Ncbn0pLCBmdW5jXSk7XG5cbmNvbnN0IGJ1dHRvbiA9IG9uZU9mVHlwZShbc3RyaW5nLCBzaGFwZSh7XG4gICAgb25DbGljazogZXZlbnQsXG4gICAgYnV0dG9uQ2xhc3M6IGNzc0NsYXNzLFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIGljb25DbGFzczogY3NzQ2xhc3Ncbn0pXSk7XG5cbmNvbnN0IGJ1dHRvbnMgPSBvbmVPZlR5cGUoW1xuICAgIGJ1dHRvbixcbiAgICBhcnJheU9mKGJ1dHRvbiksXG4gICAgc2hhcGUoe1xuICAgICAgICBidXR0b25zQ2xhc3M6IGNzc0NsYXNzLFxuICAgICAgICBvbkJ1dHRvbkNsaWNrOiBldmVudCxcbiAgICAgICAgYnV0dG9uczogb25lT2ZUeXBlKGFycmF5U3RyaW5nLCBhcnJheU9mKGJ1dHRvbikpLFxuICAgICAgICBidXR0b25UZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgIGJ1dHRvbnNUZW1wbGF0ZTogdGVtcGxhdGVcbiAgICB9KVxuXSk7XG5cblxuY29uc3QgZmllbGRzZXQgPSBzaGFwZSh7XG4gICAgZmllbGRzOiBhcnJheVN0cmluZyxcbiAgICBsZWdlbmQ6IGNvbnRlbnQsXG4gICAgY2xhc3NOYW1lOiBjc3NDbGFzcyxcbiAgICBidXR0b25zOiBidXR0b25zLFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZVxufSk7XG5cbmNvbnN0IGxpdGVyYWwgPSBvbmVPZlR5cGUoW3N0cmluZywgYm9vbCwgbnVtYmVyLCBpbnN0YW5jZU9mKERhdGUpXSlcblxuY29uc3Qgb3B0aW9ucyA9IG9uZU9mVHlwZShbXG4gICAgYXJyYXlTdHJpbmcsXG4gICAgYXJyYXlPZihzaGFwZSh7XG4gICAgICAgIGxhYmVsOiBzdHJpbmcsXG4gICAgICAgIHZhbDogbGl0ZXJhbFxuICAgIH0pKVxuXSk7XG5cbmNvbnN0IG9wdGlvbnNHcm91cCA9IG9uZU9mVHlwZShbXG4gICAgYXJyYXlTdHJpbmcsXG4gICAgYXJyYXlPZihzaGFwZSh7XG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIGdyb3VwOiBzdHJpbmcsXG4gICAgICAgIGxhYmVsOiBzdHJpbmcsXG4gICAgICAgIGxhYmVsSFRNTDogc3RyaW5nLFxuICAgICAgICB2YWw6IGxpdGVyYWxcbiAgICB9KSlcbl0pXG5cbmNvbnN0IHNjaGVtYSA9IG9uZU9mVHlwZShbc3RyaW5nLCBzaGFwZSh7XG4gICAgZmllbGRzOiBhcnJheVN0cmluZyxcbiAgICBmaWVsZHNldHM6IG9uZU9mVHlwZShbYXJyYXlTdHJpbmcsIGZpZWxkc2V0LCBhcnJheU9mKGZpZWxkc2V0KV0pLFxuICAgIHNjaGVtYTogb2JqZWN0LFxufSldKTtcblxuY29uc3QgYXJyYXkgPSBhcnJheU9mKGFueSk7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSBvbmVPZlR5cGUoW2FycmF5U3RyaW5nLCBhcnJheU9mKHZhbGlkYXRvcnMpXSk7XG5cbmNvbnN0IG9wZXJhdG9yID0gb25lT2ZUeXBlKFtzdHJpbmcsIGZ1bmMsIGluc3RhbmNlT2YoUmVnRXhwKV0pO1xuXG5jb25zdCBldmVudHMgPSB7XG4gICAgb25WYWxpZGF0ZTogZXZlbnQsXG4gICAgb25Gb2N1czogZXZlbnQsXG4gICAgb25CbHVyOiBldmVudCxcbiAgICBvblZhbGlkOiBldmVudCxcbiAgICBvbkNoYW5nZTogb25lT2ZUeXBlKHRhcmdldEV2ZW50LCB2YWx1ZUV2ZW50KVxufTtcblxuY29uc3QgZmllbGQgPSBjdXN0b21Qcm9wVHlwZShhbnksICdmaWVsZCcpO1xuXG5jb25zdCBtaXhpbiA9IHtcbiAgICBldmVudHM6IGV2ZW50cyxcbiAgICBmaWVsZDogZXh0ZW5kKHtcbiAgICAgICAgdGl0bGU6IGNvbnRlbnQsXG4gICAgICAgIGhlbHA6IGNvbnRlbnQsXG4gICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXG4gICAgICAgIGVkaXRvckNsYXNzOiBjc3NDbGFzcyxcbiAgICAgICAgZmllbGRDbGFzczogY3NzQ2xhc3MsXG4gICAgICAgIGZpZWxkOiB7fVxuICAgIH0sIGV2ZW50cylcbn07XG5cbmNvbnN0IGNvbnRleHRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHZhbHVlTWFuYWdlcixcbiAgICBsb2FkZXIsXG4gICAgaW5qZWN0b3Jcbn0pO1xuXG5cbmNvbnN0IHByb2Nlc3NvciA9IG9uZU9mVHlwZShbc3RyaW5nLCBzaGFwZSh7XG4gICAgZmV0Y2g6IGZ1bmMsXG4gICAgdmFsdWU6IGZ1bmMsXG4gICAgZm9ybWF0OiBmdW5jXG59KV0pO1xuXG5jb25zdCBpbmplY3RDbGFzcyA9IG9uZU9mVHlwZShbXG4gICAgZnVuYyxcbiAgICBzaGFwZSh7XG4gICAgICAgIGluamVjdENsYXNzOiBmdW5jLFxuICAgICAgICBwcm9wVHlwZXM6IG9iamVjdCxcbiAgICAgICAgaW5qZWN0UHJvcHM6IG9iamVjdCxcbiAgICAgICAgc3RyaWN0OiBib29sXG4gICAgfSlcbl0pO1xuXG5jb25zdCBhcGkgPSB7XG4gICAgY29uZGl0aW9uYWwsXG4gICAgdHJhbnNpdGlvbixcbiAgICBpbmplY3RDbGFzcyxcbiAgICBibHVyVmFsaWRhdGUsXG4gICAgY2hhbmdlVmFsaWRhdGUsXG4gICAgcHJvbWlzZSxcbiAgICBpZCxcbiAgICBpbmplY3RlZENsYXNzLFxuICAgIGZpZWxkQXR0cnMsXG4gICAgY3NzQ2xhc3MsXG4gICAgZXJyb3IsXG4gICAgZXJyb3JzLFxuICAgIGV2ZW50LFxuICAgIGh0bWxGb3IsXG4gICAgdmFsaWRhdG9yLFxuICAgIHBhdGgsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgYXJyYXlTdHJpbmcsXG4gICAgbGlzdGVuZXIsXG4gICAgdmFsdWVFdmVudCxcbiAgICB0YXJnZXRFdmVudCxcbiAgICBibHVyRXZlbnQsXG4gICAgdmFsaWRFdmVudCxcbiAgICBkYXRhVHlwZSxcbiAgICB0eXBlLFxuICAgIGRvbVR5cGUsXG4gICAgdHlwZURlc2NyaXB0aW9uLFxuICAgIGV4cHJlc3Npb24sXG4gICAgbG9hZGVyLFxuICAgIHZhbHVlTWFuYWdlcixcbiAgICBjb250ZW50LFxuICAgIHRlbXBsYXRlLFxuICAgIGJ1dHRvbixcbiAgICBidXR0b25zLFxuICAgIGZpZWxkcyxcbiAgICBmaWVsZHNldCxcbiAgICBsaXRlcmFsLFxuICAgIG9wdGlvbnMsXG4gICAgb3B0aW9uc0dyb3VwLFxuICAgIHNjaGVtYSxcbiAgICB2YWx1ZSxcbiAgICB2YWxpZGF0ZSxcbiAgICB2YWxpZGF0b3JzLFxuICAgIG9wZXJhdG9yLFxuICAgIGV2ZW50cyxcbiAgICBmaWVsZCxcbiAgICBtaXhpbixcbiAgICBzdHlsZSxcbiAgICBjb250ZXh0VHlwZXMsXG4gICAgcHJvY2Vzc29yLFxuICAgIHR5cGVDbGFzcyxcbiAgICBzdHJpbmcsIGJvb2wsIG51bWJlciwgb2JqZWN0LCBmdW5jLCBhbnksIG5vZGUsIHNoYXBlLCBhcnJheU9mLCBpbnN0YW5jZU9mLCBvbmVPZlR5cGUsIG9uZU9mXG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0XG4oe1xuICAgIHByb3BUeXBlc1RvTmFtZXMsXG4gICAgcHJvcFR5cGVUb05hbWUsXG4gICAgY3VzdG9tUHJvcFR5cGUsXG4gICAgY29uZGl0aW9uYWwsXG4gICAgYmx1clZhbGlkYXRlLFxuICAgIGNoYW5nZVZhbGlkYXRlLFxuICAgIHByb21pc2UsXG4gICAgaWQsXG4gICAgZmllbGRBdHRycyxcbiAgICBjc3NDbGFzcyxcbiAgICBlcnJvcixcbiAgICBlcnJvcnMsXG4gICAgZXZlbnQsXG4gICAgdmFsdWVFdmVudCxcbiAgICB0YXJnZXRFdmVudCxcbiAgICBlcnJvckV2ZW50LFxuICAgIHZhbGlkYXRvcixcbiAgICBwYXRoLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGFycmF5U3RyaW5nLFxuICAgIGxpc3RlbmVyLFxuICAgIGJsdXJFdmVudCxcbiAgICB2YWxpZEV2ZW50LFxuICAgIGRhdGFUeXBlLFxuICAgIGRvbVR5cGUsXG4gICAgdHlwZSxcbiAgICB0eXBlRGVzY3JpcHRpb24sXG4gICAgZXhwcmVzc2lvbixcbiAgICBsb2FkZXIsXG4gICAgdmFsdWVNYW5hZ2VyLFxuICAgIGNvbnRlbnQsXG4gICAgdGVtcGxhdGUsXG4gICAgYnV0dG9uLFxuICAgIGJ1dHRvbnMsXG4gICAgZmllbGRzLFxuICAgIGZpZWxkc2V0LFxuICAgIGluamVjdGVkQ2xhc3MsXG4gICAgaW5qZWN0b3IsXG4gICAgbGl0ZXJhbCxcbiAgICBodG1sRm9yLFxuICAgIG9wdGlvbnMsXG4gICAgb3B0aW9uc0dyb3VwLFxuICAgIHNjaGVtYSxcbiAgICB2YWxpZGF0b3JzLFxuICAgIG9wZXJhdG9yLFxuICAgIGV2ZW50cyxcbiAgICBmaWVsZCxcbiAgICBtaXhpbixcbiAgICBjb250ZXh0VHlwZXMsXG4gICAgcHJvY2Vzc29yLFxuICAgIHZhbHVlLFxuICAgIHZhbGlkYXRlLFxuICAgIGFycmF5LFxuICAgIHRpdGxlLFxuICAgIGluamVjdENsYXNzLFxuICAgIHR5cGVDbGFzcyxcbiAgICBzdHlsZSxcbiAgICB0cmFuc2l0aW9uLFxuICAgIHN0cmluZywgYm9vbCwgbnVtYmVyLCBvYmplY3QsIGZ1bmMsIGFueSwgbm9kZSwgc2hhcGUsIGFycmF5T2YsIGluc3RhbmNlT2YsIG9uZU9mVHlwZSwgb25lT2Zcbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvUHJvcFR5cGVzLmpzXG4gKiovIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYXJyYXlNYXAnKSxcbiAgICBiYXNlQ2FsbGJhY2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlQ2FsbGJhY2snKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhyb3VnaFxuICogYGl0ZXJhdGVlYC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAqXG4gKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjYWxsYmFja2AsIGBjaHVua2AsIGBjbG9uZWAsIGBjcmVhdGVgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsXG4gKiBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLCBgZmlsbGAsIGBmbGF0dGVuYCwgYGludmVydGAsIGBtYXhgLCBgbWluYCxcbiAqIGBwYXJzZUludGAsIGBzbGljZWAsIGBzb3J0QnlgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGVtcGxhdGVgLCBgdHJpbWAsXG4gKiBgdHJpbUxlZnRgLCBgdHJpbVJpZ2h0YCwgYHRydW5jYCwgYHJhbmRvbWAsIGByYW5nZWAsIGBzYW1wbGVgLCBgc29tZWAsXG4gKiBgc3VtYCwgYHVuaXFgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAYWxpYXMgY29sbGVjdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICogIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gdGltZXNUaHJlZShuKSB7XG4gKiAgIHJldHVybiBuICogMztcbiAqIH1cbiAqXG4gKiBfLm1hcChbMSwgMl0sIHRpbWVzVGhyZWUpO1xuICogLy8gPT4gWzMsIDZdXG4gKlxuICogXy5tYXAoeyAnYSc6IDEsICdiJzogMiB9LCB0aW1lc1RocmVlKTtcbiAqIC8vID0+IFszLCA2XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgaXRlcmF0ZWUgPSBiYXNlQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvY29sbGVjdGlvbi9tYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9hcnJheU1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlTWFwLmpzXG4gKiogbW9kdWxlIGlkID0gMjU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7UHJvcFR5cGVzIGFzIFJlYWN0UHJvcFR5cGVzfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgaW5qZWN0b3IgZnJvbSAnLi9pbmplY3Rvcic7XG5pbXBvcnQgaW5qRiBmcm9tICcuL2luamVjdG9yRmFjdG9yeSc7XG5pbXBvcnQgdXQgZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGNvbnN0IHV0aWwgPSB1dDtcblxuZXhwb3J0IGNvbnN0IGluamVjdG9yRmFjdG9yeSA9IGluakY7XG5cbmV4cG9ydCBjb25zdCBQcm9wVHlwZXMgPSB7XG4gICAgaW5qZWN0b3I6IFJlYWN0UHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgaW5qZWN0OiBSZWFjdFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5qZWN0b3I7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvfi9zdWJzY2hlbWEtaW5qZWN0aW9uL3NyYy9pbmRleC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IGZhY3RvcnkgZnJvbSAnLi9pbmplY3RvckZhY3RvcnknO1xuZXhwb3J0IGRlZmF1bHQgZmFjdG9yeSgpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9+L3N1YnNjaGVtYS1pbmplY3Rpb24vc3JjL2luamVjdG9yLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7a2V5SW4sIG9ubHlLZXlzLCB1bmlxdWVLZXlzLCByZXNvbHZlS2V5LCBleHRlbmRQcm90b3R5cGUsIGxpc3RlbmVyLCB1bm1vdW50LCBwcm9wIGFzIHByb3BlcnR5fSBmcm9tICcuL3V0aWwnO1xuXG5cbmV4cG9ydCBjbGFzcyBCYXNlSW5qZWN0Q29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0ZSA9IHt9O1xuICAgIGluamVjdGVkID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc0FueUtleXMob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gaXNJdGVyYWJsZShvYmopIHtcbiAgICAvLyBjaGVja3MgZm9yIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIG9ialtTeW1ib2wuaXRlcmF0b3JdICE9PSB2b2lkKDApXG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmplY3RvcihyZXNvbHZlcnMgPSBuZXcgTWFwKCkpIHtcbiAgICBpZiAoIShyZXNvbHZlcnMgaW5zdGFuY2VvZiBNYXAgKSkge1xuICAgICAgICBpZiAoaXNJdGVyYWJsZShyZXNvbHZlcnMpKSB7XG4gICAgICAgICAgICByZXNvbHZlcnMgPSBuZXcgTWFwKHJlc29sdmVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc29sdmVycyBtdXN0IGJlIGl0ZXJhYmxlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVByb3AocHJvcFR5cGUpIHtcbiAgICAgICAgaWYgKHByb3BUeXBlID09IG51bGwpIHJldHVybiBwcm9wVHlwZTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlcnMuZ2V0KHByb3BUeXBlKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH1cblxuXG4gICAgY29uc3QgSW5qZWN0b3IgPSB7XG4gICAgICAgIHJlc29sdmVyKHByb3BUeXBlLCByZXNvbHZlKXtcbiAgICAgICAgICAgIGlmIChwcm9wVHlwZSA9PSBudWxsIHx8IHJlc29sdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBkZWZpbmUgYm90aCBhIHByb3BUeXBlIGFuZCBhIHJlc29sdmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcFR5cGUuaXNSZXF1aXJlZCl7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXJzLnNldChwcm9wVHlwZS5pc1JlcXVpcmVkLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVycy5zZXQocHJvcFR5cGUsIHJlc29sdmUpO1xuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50LFxuICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIGV4dGVuZFByb3RvdHlwZSxcbiAgICAgICAgcmVzb2x2ZUtleSxcbiAgICAgICAgY3JlYXRlV3JhcHBlckNsYXNzKENsYXp6LCBjb3B5UHJvcFR5cGVLZXlzLCBzdHJpY3RQcm9wcyl7XG4gICAgICAgICAgICBjb25zdCB7ZGVmYXVsdFByb3BzLCBwcm9wVHlwZXN9ID0gQ2xheno7XG4gICAgICAgICAgICBjb25zdCByZW5kZXIgPSBzdHJpY3RQcm9wcyAhPT0gZmFsc2UgPyBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBvbmx5S2V5cyhjb3B5UHJvcFR5cGVLZXlzLCB0aGlzLmluamVjdGVkLCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gPENsYXp6IHsuLi5wcm9wc30gey4uLnRoaXMuaW5qZWN0ZWQgfSA+e3RoaXMucHJvcHMuY2hpbGRyZW59PC9DbGF6ej5cblxuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIGxvb3NlUHJvcHNSZW5kZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxDbGF6eiB7Li4udGhpcy5wcm9wc30gey4uLnRoaXMuaW5qZWN0ZWQgfT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L0NsYXp6PlxuXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qge25hbWUsIGRpc3BsYXlOYW1lfSA9IENsYXp6O1xuICAgICAgICAgICAgLy9CYXNlSW5qZWN0Q29tcG9uZW50IGlzIGp1c3QgYSBtYXJrZXIgY2xhc3MuXG4gICAgICAgICAgICBjbGFzcyBJbmplY3RlZENsYXNzIGV4dGVuZHMgQmFzZUluamVjdENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBzdGF0aWMgZGlzcGxheU5hbWUgPSBgJHtkaXNwbGF5TmFtZSB8fCBuYW1lfSRXcmFwcGVyYDtcbiAgICAgICAgICAgICAgICByZW5kZXIgPSByZW5kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSW5qZWN0ZWRDbGFzc1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5qZWN0cyBwcm9wZXJ0aWVzIGJhc2VkIHByb3BUeXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gQ2xhenogLSBjbGFzcyB0byB3cmFwLlxuICAgICAgICAgKiBAcGFyYW0gZXh0cmFQcm9wVHlwZXMgLSBleHRyYSBwcm9wIHR5cGVzIGlmIHRoZSBjb21wb25lbnQgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcFR5cGUgdGhhbiBpdCB3aWxsIHVzZSB0aGlzIHByb3BUeXBlLCBvdGhlcndpc2UgdGhlXG4gICAgICAgICAqIHRoZSBjbGFzcydlcyBkZWZhdWx0IHByb3BUeXBlIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICogQHBhcmFtIGV4dHJhUHJvcHMgLSBJZiBhIGNvbXBvbmVudCBoYXMgYSBkZWZhdWx0UHJvcCB0aGFuIGl0IHdpbGwgdXNlIHRoYXQgb3RoZXJ3aXNlIGl0IHdpbGwgdXNlIHRoaXMuXG4gICAgICAgICAqIEBwYXJhbSBzdHJpY3RQcm9wcyAtIElmIGZhbHNlIHRoYW4gaXQgd2lsbCBwYXNzIGFsbCBwcm9wcyBvbiB0byBjb21wb25lbnQsIG90aGVyd2lzZSBpdCBqdXN0IHBhc3NlcyBkZWZpbmVkIHByb3BzLlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICAgICAgaW5qZWN0KENsYXp6LCBleHRyYVByb3BUeXBlcywgZXh0cmFQcm9wcywgc3RyaWN0UHJvcHMpe1xuICAgICAgICAgICAgY29uc3QgaGFzRXh0cmEgPSBoYXNBbnlLZXlzKGV4dHJhUHJvcFR5cGVzKSB8fCBoYXNBbnlLZXlzKGV4dHJhUHJvcHMpO1xuXG4gICAgICAgICAgICBjb25zdCB7ZGVmYXVsdFByb3BzLCBwcm9wVHlwZXN9ID0gQ2xheno7XG5cbiAgICAgICAgICAgIGNvbnN0IHByb3BUeXBlS2V5cyA9IHVuaXF1ZUtleXMocHJvcFR5cGVzLCBkZWZhdWx0UHJvcHMsIGV4dHJhUHJvcFR5cGVzKTtcblxuICAgICAgICAgICAgY29uc3QgWy4uLmNvcHlQcm9wVHlwZUtleXNdID0gcHJvcFR5cGVLZXlzO1xuXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGhhc0V4dHJhID8gdGhpcy5jcmVhdGVXcmFwcGVyQ2xhc3MoQ2xhenosIGNvcHlQcm9wVHlwZUtleXMsIHN0cmljdFByb3BzKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnN0IGluamVjdGVkID0gcHJvcFR5cGVLZXlzLnJlZHVjZSgoaW5qZWN0ZWRDbGFzcywga2V5KT0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gcmVzb2x2ZVByb3Aoa2V5SW4oa2V5LCBwcm9wVHlwZXMsIGV4dHJhUHJvcFR5cGVzKSk7XG4gICAgICAgICAgICAgICAgLy9yZXNvbHZlciBpcyBudWxsLCBub3RoaW5nIHRvIGRvIGp1c3QgcmV0dXJuLlxuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmplY3RlZENsYXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2luamVjdGVkQ2xhc3MgbWF5IGJlIG51bGwgaWYgaXQgZGlkbid0IGhhdmUgYW55IGV4dHJhcy4gIFNvIHdlIHdpbGwgY3JlYXRlIGlmIGl0IGlzLlxuICAgICAgICAgICAgICAgIGluamVjdGVkQ2xhc3MgPSBpbmplY3RlZENsYXNzIHx8IHRoaXMuY3JlYXRlV3JhcHBlckNsYXNzKENsYXp6LCBjb3B5UHJvcFR5cGVLZXlzLCBzdHJpY3RQcm9wcyk7XG5cbiAgICAgICAgICAgICAgICAvL0FkZCBkZWZhdWx0IHByb3BzIHRvIHRoaXMgdGhpbmcuXG4gICAgICAgICAgICAgICAgaW5qZWN0ZWRDbGFzcy5kZWZhdWx0UHJvcHNba2V5XSA9IGtleUluKGtleSwgZGVmYXVsdFByb3BzLCBleHRyYVByb3BzKTtcblxuICAgICAgICAgICAgICAgIC8vUmVzb2x2ZXIgY291bGQgcmV0dXJuIGEgZGlmZmVyZW50IGNsYXNzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDbGFzcyA9IEluamVjdG9yOjpyZXNvbHZlcihpbmplY3RlZENsYXNzLCBrZXksIHByb3BUeXBlS2V5cywgQ2xhenopO1xuXG4gICAgICAgICAgICAgICAgLy9JZiBhIGRpZmZlcmVudCBjbGFzcyB3YXMgbnVsbCwgcmV0dXJuIHRoZSBvcmlnaW5hbCBjbGFzcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gKG5leHRDbGFzcyA9PSBudWxsKSA/IGluamVjdGVkQ2xhc3MgOiBuZXh0Q2xhc3M7XG4gICAgICAgICAgICB9LCBzdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gaW5qZWN0ZWQgfHwgQ2xheno7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbmplY3Rvcjtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvfi9zdWJzY2hlbWEtaW5qZWN0aW9uL3NyYy9pbmplY3RvckZhY3RvcnkuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBhcHBseU5pY2UoZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBmMiB8fCAhZjIpIHJldHVybiBmMTtcbiAgICBpZiAoIWYxKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5TmljZSRyZXR1cm4oLi4uYXJncykge1xuICAgICAgICB0aGlzOjpmMSguLi5hcmdzKTtcbiAgICAgICAgdGhpczo6ZjIoLi4uYXJncyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kUHJvdG90eXBlKHByb3BlcnR5LCBmbikge1xuICAgIHRoaXMucHJvdG90eXBlW3Byb3BlcnR5XSA9IGFwcGx5TmljZShmbiwgdGhpcy5wcm90b3R5cGVbcHJvcGVydHldKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZXhlY0FyZyh2KSB7XG4gICAgdiAmJiB2KCk7XG59XG5cbmNvbnN0IHB1c2ggPSBGdW5jdGlvbi5hcHBseS5iaW5kKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcblxuZnVuY3Rpb24ga2V5SW4oa2V5LCAuLi5hcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmdzW2ldID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoa2V5IGluIGFyZ3NbaV0pXG4gICAgICAgICAgICByZXR1cm4gYXJnc1tpXVtrZXldO1xuICAgIH1cbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBvbmx5S2V5cyhrZXlzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgY29uc3QgYXJnTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgS0VZUzogZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBBUkdTOiBmb3IgKGxldCBqID0gMDsgaiA8IGFyZ0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2pdO1xuICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSBjb250aW51ZSBBUkdTO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IGFyZ1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIEtFWVM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdW5pcXVlS2V5cyguLi5hcmdzKSB7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0gPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGsgPSBPYmplY3Qua2V5cyhhcmdzW2ldKSwgamwgPSBrLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGtbal0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVLZXkocGF0aCwga2V5KSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGlmIChrZXlbMF0gIT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IHBhdGggPyBwYXRoLnNwbGl0KCcuJykgOiBbXTtcbiAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDEpO1xuICAgIHdoaWxlIChrZXlbMF0gPT09ICcuJykge1xuICAgICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDEpO1xuICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGtleSkge1xuICAgICAgICBwYXJ0cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyBudWxsIDogcGFydHMuam9pbignLicpO1xufVxuZnVuY3Rpb24gZXh0ZW5kKG5hbWUsIGZuKSB7XG4gICAgY29uc3QgZm4yID0gdGhpcy5wcm90b3R5cGVbbmFtZV07XG4gICAgdGhpcy5wcm90b3R5cGVbbmFtZV0gPSBhcHBseU5pY2UoZm4sIGZuMik7XG59XG5mdW5jdGlvbiBkaWRNb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBsaXN0ZW5lcihrZXksIGZuKSB7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXIkbGlzdGVuKHByb3BzLCBjb250ZXh0KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xpc3RlbmVyc1trZXldKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNba2V5XSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1trZXldID0gdGhpczo6Zm4ocHJvcHNba2V5XSwga2V5LCBwcm9wcywgY29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpczo6ZXh0ZW5kKCdjb21wb25lbnREaWRNb3VudCcsIGRpZE1vdW50KTtcblxuICAgIHRoaXM6OmV4dGVuZCgnY29tcG9uZW50V2lsbE1vdW50JywgZnVuY3Rpb24gbGlzdGVuZXIkd2lsbE1vdW50KCkge1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpczo6bGlzdGVuZXIkbGlzdGVuKHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICB0aGlzOjpleHRlbmQoJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLCBsaXN0ZW5lciRsaXN0ZW4pO1xuXG4gICAgdGhpczo6dW5tb3VudChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgJiYgdGhpcy5fbGlzdGVuZXJzW2tleV0gJiYgdGhpcy5fbGlzdGVuZXJzW2tleV0oKTtcbiAgICB9KTtcblxufVxuZnVuY3Rpb24gcHJvcChrZXksIGZuKSB7XG4gICAgLy90aGlzIGlzIGNsYXNzIHNjb3BlLlxuICAgIHRoaXM6OmV4dGVuZCgnY29tcG9uZW50V2lsbE1vdW50JywgZnVuY3Rpb24gdXRpbCRwcm9wJHdpbGxNb3VudCgpIHtcbiAgICAgICAgLy90aGlzIGlzIGluc3RhbmNlIHNjb3BlLlxuICAgICAgICB0aGlzLmluamVjdGVkW2tleV0gPSB0aGlzOjpmbih0aGlzLnByb3BzW2tleV0sIGtleSwgdGhpcy5wcm9wcywgdGhpcy5jb250ZXh0KTtcbiAgICB9KTtcblxuICAgIHRoaXM6OmV4dGVuZCgnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsIGZ1bmN0aW9uIHV0aWwkcHJvcCRyZWNlaXZlUHJvcHMocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT09IHRoaXMucHJvcHNba2V5XSkge1xuICAgICAgICAgICAgdGhpcy5pbmplY3RlZFtrZXldID0gdGhpczo6Zm4ocHJvcHNba2V5XSwga2V5LCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZXh0ZW5kU3RhdGljKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGxpc3RlbmVycykge1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZXhlY0FyZyk7XG4gICAgICAgIGxpc3RlbmVycy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXJzO1xufVxuZnVuY3Rpb24gY2xlYXJMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVMaXN0ZW5lcnModGhpcy5saXN0ZW5lcnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVubW91bnQoZm4pIHtcbiAgICB0aGlzLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGFwcGx5TmljZShmbiwgdGhpcy5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQpO1xufVxuXG5leHBvcnQgIHthcHBseU5pY2UsbGlzdGVuZXIsIGV4dGVuZCwgcHJvcCwgdW5tb3VudCwgZXh0ZW5kU3RhdGljLCBleHRlbmRQcm90b3R5cGUsIG9ubHlLZXlzLCBrZXlJbiwgdW5pcXVlS2V5cywgcmVzb2x2ZUtleSwgZXhlY0FyZywgcHVzaCwgcmVtb3ZlTGlzdGVuZXJzLCBjbGVhckxpc3RlbmVyc31cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvfi9zdWJzY2hlbWEtaW5qZWN0aW9uL3NyYy91dGlsLmpzXG4gKiovIiwidmFyIGNvbnRleHQgPSByZXF1aXJlLmNvbnRleHQoJy4nLCBmYWxzZSwgL1RlbXBsYXRlLmpzKHgpPyQvKSwgYXBpID0ge307IC8vbWFrZSBzdXJlIHlvdSBoYXZlIHlvdXIgZGlyZWN0b3J5IGFuZCByZWdleCB0ZXN0IHNldCBjb3JyZWN0bHkhXG5jb250ZXh0LmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgayA9IGtleS5yZXBsYWNlKC9eXFwuXFwvKC4qKVxcLmpzKHgpPyQvLCAnJDEnKTtcbiAgICBhcGlba10gPSBjb250ZXh0KGtleSkuZGVmYXVsdDtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90ZW1wbGF0ZXMvaW5kZXguanNcbiAqKi8iLCJ2YXIgbWFwID0ge1xuXHRcIi4vQXV0b2NvbXBsZXRlSXRlbVRlbXBsYXRlLmpzeFwiOiAyNjIsXG5cdFwiLi9CdXR0b25UZW1wbGF0ZS5qc3hcIjogMjYzLFxuXHRcIi4vQnV0dG9uc1RlbXBsYXRlLmpzeFwiOiAyNjQsXG5cdFwiLi9DaGVja2JveFRlbXBsYXRlLmpzeFwiOiAyNjUsXG5cdFwiLi9DaGVja2JveGVzR3JvdXBUZW1wbGF0ZS5qc3hcIjogMjY2LFxuXHRcIi4vQ2hlY2tib3hlc1RlbXBsYXRlLmpzeFwiOiAyNjcsXG5cdFwiLi9Db2xsZWN0aW9uQ3JlYXRlVGVtcGxhdGUuanN4XCI6IDI2OCxcblx0XCIuL0NvbnRlbnRJdGVtVGVtcGxhdGUuanN4XCI6IDI3NCxcblx0XCIuL0VkaXRvclRlbXBsYXRlLmpzeFwiOiAyNzYsXG5cdFwiLi9GaWVsZFNldFRlbXBsYXRlLmpzeFwiOiAyNzcsXG5cdFwiLi9Gb3JtVGVtcGxhdGUuanN4XCI6IDI3OCxcblx0XCIuL0xpc3RJdGVtVGVtcGxhdGUuanN4XCI6IDI3OSxcblx0XCIuL01vZGFsVGVtcGxhdGUuanN4XCI6IDI4MCxcblx0XCIuL09iamVjdFRlbXBsYXRlLmpzeFwiOiAyOTIsXG5cdFwiLi9SYWRpb0l0ZW1UZW1wbGF0ZS5qc3hcIjogMjkzLFxuXHRcIi4vV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZS5qc3hcIjogMjk0LFxuXHRcIi4vV2l6YXJkVGVtcGxhdGUuanN4XCI6IDI5NVxufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRyZXR1cm4gbWFwW3JlcV0gfHwgKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKSB9KCkpO1xufTtcbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAyNjE7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzIG5vbnJlY3Vyc2l2ZSBUZW1wbGF0ZS5qcyh4KT8kXG4gKiogbW9kdWxlIGlkID0gMjYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvY29tcGxldGVJdGVtVGVtcGxhdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICBmb2N1czogZmFsc2UsXG4gICAgICAgIHByb2Nlc3NvcjogbnVsbFxuICAgIH07XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBvblNlbGVjdDogUHJvcFR5cGVzLmV2ZW50LFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLnN0eWxlXG4gICAgfTtcblxuXG4gICAgaGFuZGxlQ2xpY2soZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdCh0aGlzLnByb3BzLmRhdGEpO1xuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtkYXRhLCBmb2N1cywgaXRlbUNsYXNzLCBmb2N1c2VkQ2xhc3MsIHZhbHVlLCBwcm9jZXNzb3J9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgX19odG1sID0gcHJvY2Vzc29yLmZvcm1hdChkYXRhLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBfX2h0bWwgPT0gbnVsbCA/IG51bGwgOlxuICAgICAgICAgICAgPGxpIHJlZj1cIml0ZW1cIiBjbGFzc05hbWU9eyBgJHtpdGVtQ2xhc3N9ICAke2ZvY3VzID8gZm9jdXNlZENsYXNzIDogJyd9YH0gb25DbGljaz17dGhpczo6dGhpcy5oYW5kbGVDbGlja31cbiAgICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbH19Lz5cbiAgICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9BdXRvY29tcGxldGVJdGVtVGVtcGxhdGUuanN4XG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnQsIFByb3BUeXBlc30gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgYWN0aW9uOiAnU3VibWl0JyxcbiAgICAgICAgbGFiZWw6ICdTdWJtaXQnLFxuICAgICAgICBidXR0b25DbGFzczogJ2J0bicsXG4gICAgICAgIGljb25DbGFzczogbnVsbCxcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYnV0dG9uQ2xhc3M6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGljb25DbGFzczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfTtcblxuICAgIGhhbmRsZUNsaWNrID0gKGUpPT4ge1xuICAgICAgICBjb25zdCB7dmFsdWUsIGFjdGlvbiwgbGFiZWx9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKGUsIHZhbHVlIHx8IGFjdGlvbiB8fCBsYWJlbCwgdGhpcyk7XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBidXR0b25DbGFzcywgY2xhc3NOYW1lLCB0aXRsZSwgaWNvbkNsYXNzLCBvbkNsaWNrLCAgbGFiZWwsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiA8YnV0dG9uIGNsYXNzTmFtZT17Y2xhc3NOYW1lIHx8IGJ1dHRvbkNsYXNzfSB7Li4ucHJvcHN9IG9uQ2xpY2s9e3RoaXM6OnRoaXMuaGFuZGxlQ2xpY2t9PlxuICAgICAgICAgICAge2ljb25DbGFzcyA/IDxpIGNsYXNzTmFtZT17aWNvbkNsYXNzfS8+IDogbnVsbH1cbiAgICAgICAgICAgIHtsYWJlbH08L2J1dHRvbj5cbiAgICB9XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90ZW1wbGF0ZXMvQnV0dG9uVGVtcGxhdGUuanN4XG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7aXNTdHJpbmcsIGV4dGVuZH0gZnJvbSAnLi4vdHV0aWxzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uc1RlbXBsYXRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBidXR0b25UZW1wbGF0ZTogJ0J1dHRvblRlbXBsYXRlJyxcbiAgICAgICAgYnV0dG9uczogW3tcbiAgICAgICAgICAgIGFjdGlvbjogJ3N1Ym1pdCcsXG4gICAgICAgICAgICBsYWJlbDogJ1N1Ym1pdCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ0J1dHRvbicsXG4gICAgICAgICAgICBwcmltYXJ5OiB0cnVlXG4gICAgICAgIH1dLFxuICAgICAgICBvbkJ1dHRvbkNsaWNrIChldmVudCwgYWN0aW9uLCBidG4sIHZhbHVlKSB7XG5cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBidXR0b25UZW1wbGF0ZTogUHJvcFR5cGVzLnRlbXBsYXRlLFxuICAgICAgICBidXR0b25DbGFzczogUHJvcFR5cGVzLmNzc0NsYXNzLFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLnN0eWxlXG4gICAgfTtcblxuICAgIG1ha2VCdXR0b25zKGJ1dHRvbnMpIHtcbiAgICAgICAgbGV0IG9uQ2xpY2sgPSB0aGlzLnByb3BzLm9uQnV0dG9uQ2xpY2sgfHwgdGhpcy5wcm9wcy5vbkNsaWNrLCBidXR0b25UZW1wbGF0ZSA9IHRoaXMucHJvcHMuYnV0dG9uVGVtcGxhdGU7XG4gICAgICAgIHJldHVybiBidXR0b25zLm1hcChiID0+IHtcbiAgICAgICAgICAgIG9uQ2xpY2sgPSBiLm9uQ2xpY2sgfHwgb25DbGljaztcbiAgICAgICAgICAgIGNvbnN0IGJ0biA9IGlzU3RyaW5nKGIpID8ge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogYixcbiAgICAgICAgICAgICAgICBsYWJlbDogYixcbiAgICAgICAgICAgICAgICBvbkNsaWNrXG4gICAgICAgICAgICB9IDogZXh0ZW5kKHt9LCBiLCB7b25DbGljaywgdGVtcGxhdGU6IGJ1dHRvblRlbXBsYXRlfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5idXR0b25DbGFzcykge1xuICAgICAgICAgICAgICAgIGJ0bi5idXR0b25DbGFzcyA9IGAke2J0bi5idXR0b25DbGFzcyB8fCAnJ30gJHt0aGlzLnByb3BzLmJ1dHRvbkNsYXNzIHx8ICcnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnRuLnByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBidG4uYnV0dG9uQ2xhc3MgPSBgJHtidG4uYnV0dG9uQ2xhc3N9ICR7dGhpcy5wcm9wcy5wcmltYXJ5Q2xhc3N9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidG47XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHtidXR0b25zLCBidXR0b25UZW1wbGF0ZSxidXR0b25zQ2xhc3MsYnV0dG9uQ29udGFpbmVyQ2xhc3N9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKGJ1dHRvbnMuYnV0dG9ucykge1xuICAgICAgICAgICAgYnV0dG9uc0NsYXNzID0gYnV0dG9ucy5idXR0b25zQ2xhc3MgfHwgYnV0dG9uc0NsYXNzO1xuICAgICAgICAgICAgYnV0dG9ucyA9IGJ1dHRvbnMuYnV0dG9uc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEJ1dHRvblRlbXBsYXRlID0gYnV0dG9uVGVtcGxhdGU7XG4gICAgICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9e2J1dHRvbkNvbnRhaW5lckNsYXNzfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtidXR0b25zQ2xhc3N9PlxuICAgICAgICAgICAgICAgIHt0aGlzLm1ha2VCdXR0b25zKGJ1dHRvbnMpLm1hcCgoYiwgaSkgPT4gPEJ1dHRvblRlbXBsYXRlIGtleT17XCJidG4tXCIraX0gey4uLmJ9Lz4pfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxuXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90ZW1wbGF0ZXMvQnV0dG9uc1RlbXBsYXRlLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hlY2tib3hUZW1wbGF0ZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLnN0eWxlLFxuICAgICAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbFxuICAgIH07XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgc3R5bGU6IFwiQ2hlY2tib3hUZW1wbGF0ZVwiLFxuICAgICAgICBjaGVja2VkQ2xhc3M6IFwiXCIsXG4gICAgICAgIHVuY2hlY2tlZENsYXNzOiBcIlwiLFxuICAgICAgICBjaGVja2JveENsYXNzOiBcIlwiXG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge2NoaWxkcmVuLGNoZWNrYm94Q2xhc3MsIGNoZWNrZWQsIGNoZWNrZWRDbGFzcywgdW5jaGVja2VkQ2xhc3MgLCBsYWJlbH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPXtgJHtjaGVja2JveENsYXNzfSAke2NoZWNrZWQgPyBjaGVja2VkQ2xhc3MgOiB1bmNoZWNrZWRDbGFzc30gYH0+XG4gICAgICAgICAgICA8bGFiZWw+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0NoZWNrYm94VGVtcGxhdGUuanN4XG4gKiovIiwiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94ZXNHcm91cFRlbXBsYXRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBsZWdlbmQ6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLnN0eWxlXG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuICg8ZmllbGRzZXQgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmdyb3VwQ2xhc3N9PlxuICAgICAgICAgICAgPGxlZ2VuZD57dGhpcy5wcm9wcy5sZWdlbmR9PC9sZWdlbmQ+XG4gICAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgPC9maWVsZHNldD4pO1xuICAgIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0NoZWNrYm94ZXNHcm91cFRlbXBsYXRlLmpzeFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9DaGVja2JveFRlbXBsYXRlLmpzeCcpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0NoZWNrYm94ZXNUZW1wbGF0ZS5qc3hcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IENvbnRlbnQgZnJvbSAnLi4vdHlwZXMvQ29udGVudC5qc3gnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xsZWN0aW9uQ3JlYXRlVGVtcGxhdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHRpdGxlOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5zdHlsZSxcbiAgICAgICAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY3JlYXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZWRpdFRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNyZWF0ZVRleHQ6IFByb3BUeXBlcy5zdHJpbmdcbiAgICB9O1xuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgZWRpdFRleHQ6ICdFZGl0ICcsXG4gICAgICAgIGNyZWF0ZVRleHQ6ICdDcmVhdGUgJyxcbiAgICB9O1xuXG4gICAgcmVuZGVySW5saW5lKCkge1xuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuaW5saW5lQ2xhc3N9Pnt0aGlzLnByb3BzLmNoaWxkcmVufTwvZGl2PlxuICAgIH1cblxuICAgIHJlbmRlclBhbmVsKCkge1xuICAgICAgICBsZXQge3RpdGxlLCBwYW5lbENsYXNzLCBlZGl0VGV4dCwgY3JlYXRlVGV4dCwgcGFuZWxUaXRsZUNsYXNzLCBwYW5lbEhlYWRpbmdDbGFzcywgcGFuZWxCb2R5Q2xhc3MsZ3JvdXBDbGFzcywgY3JlYXRlfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmICh0aXRsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRpdGxlID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodGl0bGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGl0bGUgPSBjcmVhdGUgPyBjcmVhdGVUZXh0IDogZWRpdFRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRpdGxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGl0bGUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2gzJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAoY3JlYXRlID8gYCR7Y3JlYXRlVGV4dH0gJHt0aXRsZX1gIDogYCR7ZWRpdFRleHR9ICR7dGl0bGV9YCksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwYW5lbFRpdGxlQ2xhc3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPXtwYW5lbENsYXNzfT5cbiAgICAgICAgICAgIDxDb250ZW50IGNvbnRlbnQ9e3RpdGxlfSB0eXBlPSdkaXYnIGNsYXNzTmFtZT17cGFuZWxIZWFkaW5nQ2xhc3N9Lz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt0aGlzLnByb3BzLnBhbmVsQm9keUNsYXNzfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5ncm91cENsYXNzfT5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmlubGluZSA/IHRoaXMucmVuZGVySW5saW5lKCkgOiB0aGlzLnJlbmRlclBhbmVsKCk7XG4gICAgfVxufTtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90ZW1wbGF0ZXMvQ29sbGVjdGlvbkNyZWF0ZVRlbXBsYXRlLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnQsIERPTX0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1hcCBmcm9tICdsb2Rhc2gvY29sbGVjdGlvbi9tYXAnO1xuaW1wb3J0IHtpc1N0cmluZyxpc09iamVjdCwgaXNBcnJheSwgdG9BcnJheX0gZnJvbSAnLi4vdHV0aWxzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICdsb2Rhc2gvb2JqZWN0L2RlZmF1bHRzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCBEZWZhdWx0V3JhcHBlciBmcm9tICcuL0NvbnRlbnRXcmFwcGVyLmpzeCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBpc0NvbnRhaW5lciA9IHRydWU7XG5cbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICBsb2FkZXI6IFByb3BUeXBlcy5sb2FkZXJcbiAgICB9O1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGNvbnRlbnRXcmFwcGVyOiBQcm9wVHlwZXMuaW5qZWN0Q2xhc3MsXG4gICAgICAgIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgdGl0bGU6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLmNzc0NsYXNzLFxuICAgICAgICBpZDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgbmFtZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgaW5qZWN0ZWQ6IFByb3BUeXBlcy5pbmplY3RlZENsYXNzXG5cblxuICAgIH07XG5cbiAgICAvL0V4cG9zZSBmb3IgcmVhY3QtbmF0aXZlIHN1YnNjaGVtYS5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICB0eXBlOiAnc3BhbicsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICBjb250ZW50V3JhcHBlcjogRGVmYXVsdFdyYXBwZXJcbiAgICB9O1xuXG4gICAgc3RhdGljIFR5cGVzID0gRE9NIHx8IHt9O1xuXG4gICAgcmVuZGVyQ2hpbGRyZW4ocHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBwcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyQ2hpbGQoY29udGVudCwgcHJvcHMsIHByZWZpeCwgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gbnVsbCB8fCBjb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICB2YXIgQ29udGVudFdyYXBwZXIgPSB0aGlzLnByb3BzLmNvbnRlbnRXcmFwcGVyO1xuICAgICAgICAgICAgcmV0dXJuIDxDb250ZW50V3JhcHBlciB7Li4ucHJvcHN9IGtleT17J2NvbnRlbnQtJytwcmVmaXh9IGNvbnRlbnQ9e2NvbnRlbnR9Lz5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBDb250ZW50ID0gdGhpcy5wcm9wcy5pbmplY3RlZDtcblxuICAgICAgICBpZiAoaXNBcnJheShjb250ZW50KSkge1xuICAgICAgICAgICAgLy9UT0RPIC0gY2hlY2sgaWYgd2UgbmVlZCB0byBmbGF0dGVuIHRoaXMuXG4gICAgICAgICAgICByZXR1cm4gIGNvbnRlbnQubWFwKChjLCBrZXkpPT4ge1xuICAgICAgICAgICAgICAgIC8vcHJldmVudCBjaGlsZHJlbiBmcm9tIGJlaW5nIHdyYXBwZWQuXG4gICAgICAgICAgICAgICAgaWYgKGMuY2hpbGRyZW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYy5jb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxDb250ZW50IHsuLi5jfSBrZXk9eydjb250ZW50LScrcHJlZml4KyctJytrZXl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckNoaWxkcmVuKGMsIGNoaWxkcmVuKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQ29udGVudD5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckNoaWxkKGMuY29udGVudCwgcHJvcHMsIHByZWZpeCArICctcy0nICsga2V5LCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ2hpbGQoYywge30sIHByZWZpeCArICctYS0nICsga2V5LCBjaGlsZHJlbik7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoY29udGVudC5jb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gPENvbnRlbnQgey4uLmNvbnRlbnQuY29udGVudH0ga2V5PXsnY29udGVudC1jb250ZW50J30+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQ2hpbGRyZW4oY29udGVudC5jb250ZW50LCBjaGlsZHJlbil9XG4gICAgICAgICAgICA8L0NvbnRlbnQ+XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPENvbnRlbnQgey4uLnByb3BzfSBrZXk9eydjb250ZW50LWZ0LScrcHJlZml4fSBjb250ZW50PXtjb250ZW50fT5cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckNoaWxkcmVuKGNvbnRlbnQsIGNoaWxkcmVuKX1cbiAgICAgICAgPC9Db250ZW50PlxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHt0eXBlLCBjb250ZW50LCBjaGlsZHJlbiwgZmllbGQsIGNvbnRleHQsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC5jb250ZW50KSB7XG4gICAgICAgICAgICBjb250ZW50ID0gZmllbGQuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudCA9PSBudWxsIHx8IGNvbnRlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogYSBmaWVsZCBjb3VsZCBiZSBkZXNjcmliZWQgbGlrZVxuICAgICAgICAgKlxuICAgICAgICAgKiB7XG4gICAgICAgICAqICAgdHlwZTonQ29udGVudCcsXG4gICAgICAgICAqICAgY29udGVudDonSGVsbG8ge25hbWV9J1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGFuZCBjb250ZW50IHR5cGUgd291bGQgYmUgQ29udGVudCBzby4uLiB0aGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0eXBlID09PSBDb250ZW50LmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAvL1RoZSByZWFsIHR5cGUgd2hlbiB0eXBlID09ICdDb250ZW50JyBub3QgYSBncmVhdCBzb2x1dGlvbiBhbmQgd2lsbCBicmVhayBpZiBzb21lb25lIHJlbmFtZXMgY29udGVudC5cbiAgICAgICAgICAgIC8vIGlmIHRoZXkgZG8gdGhleSB3aWxsIG5lZWQgdG8gY2hhbmdlIHRoZSBkaXNwbGF5IG5hbWU7XG4gICAgICAgICAgICBwcm9wcy50eXBlID0gdHlwZSA9IENvbnRlbnQuZGVmYXVsdFByb3BzLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgIHR5cGU6J0NvbnRlbnQnLFxuICAgICAgICAgKiAgIGNvbnRlbnQ6e1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lOidzdHVmZicsXG4gICAgICAgICAqICAgICB0eXBlOidkaXYnLFxuICAgICAgICAgKiAgICAgY29udGVudDpbey8vYXJyYXkgb3Igb2JqZWN0IG9mIGNvbnRlbnR9XVxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGNvbnRlbnQuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIHsuLi5yZXN0fSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICBkZWxldGUgcmVzdC5jb250ZW50O1xuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnJlbmRlckNoaWxkKGNvbnRlbnQuY29udGVudCwgcmVzdCwgJ2RvbScsIGNoaWxkcmVuKVxuICAgICAgICB9IGVsc2VcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FzZSB3aGVyZSBjb250ZW50IGlzIGEgc3RyaW5nLlxuICAgICAgICAgKiB7XG4gICAgICAgICAqICAgY29udGVudDonaGVsbG8gd29ybGQnLlxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNTdHJpbmcoY29udGVudCkpIHtcbiAgICAgICAgICAgIHByb3BzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ2hpbGQoY29udGVudCwgcHJvcHMsICdzdHItYycpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhc2Ugd2hlcmUgY29udGVudCBpcyBhbiBhcnJheSBtYXliZSBtaXhlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB7XG4gICAgICAgICAgICAgKiAgIGNvbnRlbnQ6W3tcbiAgICAgICAgICAgICAqICAgICAgY29udGVudDonV2hhdCcsXG4gICAgICAgICAgICAgKiAgICAgIGNsYXNzTmFtZTonc3R1ZmYnXG4gICAgICAgICAgICAgKiAgIH0sXG4gICAgICAgICAgICAgKiAgICdIZWxsbycsXG4gICAgICAgICAgICAgKiAgIFsnbW9yZScsIHtjb250ZW50OidzdHVmZid9XSxcbiAgICAgICAgICAgICAqICAge1xuICAgICAgICAgICAgICogICAgY2hpbGRyZW46dHJ1ZVxuICAgICAgICAgICAgICogICB9XG4gICAgICAgICAgICAgICogIF1cbiAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBwcm9wcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5yZW5kZXJDaGlsZChjb250ZW50LCBwcm9wcywgJ2FycicsIGNoaWxkcmVuKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZW50LmNvbnRlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwcm9wcyA9IGRlZmF1bHRzKGNvbnRlbnQsIHByb3BzKTtcbiAgICAgICAgICAgIHR5cGUgPSBwcm9wcy50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbnRlbnQuVHlwZXNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCBjaGlsZHJlbik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgQ3R5cGUgPSB0aGlzLmNvbnRleHQubG9hZGVyLmxvYWRUeXBlKHR5cGUpO1xuXG4gICAgICAgIHJldHVybiA8Q3R5cGUgey4uLnByb3BzfSA+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvQ3R5cGU+XG4gICAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9Db250ZW50LmpzeFxuICoqLyIsInZhciBhc3NpZ24gPSByZXF1aXJlKCcuL2Fzc2lnbicpLFxuICAgIGFzc2lnbkRlZmF1bHRzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYXNzaWduRGVmYXVsdHMnKSxcbiAgICBjcmVhdGVEZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NyZWF0ZURlZmF1bHRzJyk7XG5cbi8qKlxuICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHMoeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gKi9cbnZhciBkZWZhdWx0cyA9IGNyZWF0ZURlZmF1bHRzKGFzc2lnbiwgYXNzaWduRGVmYXVsdHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvb2JqZWN0L2RlZmF1bHRzLmpzXG4gKiogbW9kdWxlIGlkID0gMjcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduYCB1c2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkge1xuICByZXR1cm4gb2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVZhbHVlIDogb2JqZWN0VmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduRGVmYXVsdHM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9hc3NpZ25EZWZhdWx0cy5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHJlc3RQYXJhbSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL3Jlc3RQYXJhbScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5kZWZhdWx0c2Agb3IgYF8uZGVmYXVsdHNEZWVwYCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVmYXVsdHMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRzKGFzc2lnbmVyLCBjdXN0b21pemVyKSB7XG4gIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuICAgIHZhciBvYmplY3QgPSBhcmdzWzBdO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgYXJncy5wdXNoKGN1c3RvbWl6ZXIpO1xuICAgIHJldHVybiBhc3NpZ25lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWZhdWx0cztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2NyZWF0ZURlZmF1bHRzLmpzXG4gKiogbW9kdWxlIGlkID0gMjcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRXcmFwcGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICB0eXBlOiAnc3BhbicsXG4gICAgICAgIGNvbnRlbnQ6ICcnXG4gICAgfTtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5leHByZXNzaW9uLFxuICAgICAgICB0eXBlOiBQcm9wVHlwZXMuZG9tVHlwZSxcbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICB0aXRsZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuY3NzQ2xhc3MsXG4gICAgICAgIGlkOlByb3BUeXBlcy5hbnksXG4gICAgICAgIG5hbWU6UHJvcFR5cGVzLmFueVxuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHt0eXBlLCBjb250ZW50LCBjaGlsZHJlbiwgY29udGV4dCwgIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID0ge19faHRtbDogY29udGVudH07XG4gICAgICAgIGNvbnN0IFR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gPFR5cGUgey4uLnByb3BzfS8+O1xuXG4gICAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvQ29udGVudFdyYXBwZXIuanN4XG4gKiovIiwiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvb2JqZWN0L2dldCc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGVudEl0ZW1UZW1wbGF0ZSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgcGlkOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBwb3M6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIHNob3dLZXk6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBsYWJlbEtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgaXRlbUlubmVyQ2xhc3M6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsaWNrYWJsZUNsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB2YWx1ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIHZhciBsYWJlbEtleSA9IHByb3BzLmxhYmVsS2V5O1xuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb3BUeXBlcy5ub2RlKHByb3BzLnZhbHVlLCBsYWJlbEtleSwgY29tcG9uZW50TmFtZSlcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb3BUeXBlcy5ub2RlKHZhbHVlLCAndmFsdWUnLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wcy5zaG93S2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3BUeXBlcy5ub2RlKHByb3BzLCAna2V5JywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNsaWNrYWJsZUNsYXNzOiAnY2xpY2thYmxlJ1xuICAgIH07XG4gICAgLy8ocG9zLCB2YWwsIHBpZClcbiAgICBoYW5kbGVDbGljayA9IChlKT0+IHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMucHJvcHMub25DbGljayh0aGlzLnByb3BzLnBvcywgdGhpcy5wcm9wcy52YWx1ZS52YWx1ZSwgdGhpcy5wcm9wcy5waWQpO1xuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHt2YWx1ZSxzaG93S2V5LCBjaGlsZHJlbixpdGVtSW5uZXJDbGFzcywgaXRlbUNsYXNzLCBjbGlja2FibGVDbGFzcywgbGFiZWxLZXl9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qga2V5ID0gdmFsdWUua2V5IHx8ICcnO1xuICAgICAgICBjb25zdCBfbGFiZWwgPSBsYWJlbEtleSA/IF9nZXQodmFsdWUudmFsdWUsIGxhYmVsS2V5LCAnJykgOiB2YWx1ZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuICg8c3BhbiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfSBjbGFzc05hbWU9e3RoaXMucHJvcHMub25DbGljayA/IGNsaWNrYWJsZUNsYXNzIDogJyd9PlxuICAgICAgICAgICAge3Nob3dLZXkgPyA8aDQgY2xhc3NOYW1lPXtpdGVtQ2xhc3N9PntrZXl9PC9oND4gOiBudWxsfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtpdGVtSW5uZXJDbGFzc30+e19sYWJlbH08L3NwYW4+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvc3Bhbj4pO1xuICAgIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0NvbnRlbnRJdGVtVGVtcGxhdGUuanN4XG4gKiovIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlR2V0JyksXG4gICAgdG9QYXRoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvdG9QYXRoJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyB1c2VkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHRvUGF0aChwYXRoKSwgKHBhdGggKyAnJykpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvb2JqZWN0L2dldC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCBVbmluamVjdGVkQ29udGVudCBmcm9tICcuLi90eXBlcy9Db250ZW50LmpzeCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkaXRvclRlbXBsYXRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBlcnJvcjogUHJvcFR5cGVzLmVycm9yLFxuICAgICAgICB0aXRsZTogUHJvcFR5cGVzLnRpdGxlLFxuICAgICAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBoZWxwOiBQcm9wVHlwZXMuY29udGVudCxcbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5zdHlsZSxcbiAgICAgICAgaHRtbEZvcjogUHJvcFR5cGVzLmh0bWxGb3IsXG4gICAgICAgIENvbnRlbnQ6IFByb3BUeXBlcy5pbmplY3RDbGFzc1xuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBDb250ZW50OiBVbmluamVjdGVkQ29udGVudFxuICAgIH07XG5cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHtDb250ZW50LCBuYW1lLCBodG1sRm9yLCB0aXRsZSwgaGVscCxsYWJlbENsYXNzLCBoYXNUaXRsZUNsYXNzLG5vVGl0bGVDbGFzcywgZXJyb3JDbGFzcywgaGVscENsYXNzLCBlcnJvciwgaGFzRXJyb3JDbGFzcywgZXJyb3JDbGFzc05hbWUsIG1lc3NhZ2UsIGZpZWxkQ2xhc3MsICBjaGlsZHJlbn0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoaGFzRXJyb3JDbGFzcykge1xuICAgICAgICAgICAgZXJyb3JDbGFzc05hbWUgPSBoYXNFcnJvckNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9e2ZpZWxkQ2xhc3MrXCIgXCIgKyAoZXJyb3IgIT0gbnVsbCA/IGVycm9yQ2xhc3NOYW1lIHx8ICcnIDogJycpfT5cbiAgICAgICAgICAgIDxDb250ZW50IGNvbnRlbnQ9e3RpdGxlfSB0eXBlPVwibGFiZWxcIiBjbGFzc05hbWU9e2xhYmVsQ2xhc3N9IGh0bWxGb3I9e2h0bWxGb3J9Lz5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3RpdGxlID8gaGFzVGl0bGVDbGFzcyA6IG5vVGl0bGVDbGFzc30+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgIDxDb250ZW50IGNvbnRlbnQ9e2Vycm9yIHx8IGhlbHAgfSBrZXk9J2Vycm9yLWJsb2NrJyB0eXBlPSdwJyBjbGFzc05hbWU9e2Vycm9yID8gZXJyb3JDbGFzcyA6IGhlbHBDbGFzc30vPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9FZGl0b3JUZW1wbGF0ZS5qc3hcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IHtGUkVFWkVfT0JKIGFzIGZpZWxkfSBmcm9tICcuLi90dXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWVsZFNldFRlbXBsYXRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBidXR0b25zOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgbGVnZW5kOiBQcm9wVHlwZXMubm9kZSxcbiAgICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuY3NzQ2xhc3MsXG4gICAgICAgIGZpZWxkOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBjb250ZW50OiBQcm9wVHlwZXMubm9kZVxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBmaWVsZFxuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtsZWdlbmQsIGNvbnRlbnQsIGxlZ2VuZENsYXNzLCBidXR0b25zLCBjbGFzc05hbWUsIC4uLnJlc3R9ID0gIHsuLi50aGlzLnByb3BzLmZpZWxkLCAuLi50aGlzLnByb3BzfTtcbiAgICAgICAgcmV0dXJuIGxlZ2VuZCA/XG4gICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgICAgICAgICAgIDxsZWdlbmQgY2xhc3NOYW1lPXtsZWdlbmRDbGFzc30+e2xlZ2VuZH08L2xlZ2VuZD5cbiAgICAgICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgICAgICAgICB7YnV0dG9uc31cbiAgICAgICAgICAgIDwvZmllbGRzZXQ+IDpcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgICAgICAgICAgIHtidXR0b25zfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL0ZpZWxkU2V0VGVtcGxhdGUuanN4XG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybVRlbXBsYXRlIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMuc3R5bGUsXG4gICAgICAgIG9uU3VibWl0OiBQcm9wVHlwZXMuZXZlbnQsXG4gICAgICAgIGFjY2VwdDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYWNjZXB0Q2hhcnNldDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBhdXRvY2FwaXRhbGl6ZTogUHJvcFR5cGVzLm9uZU9mKFsnb24nLCAnb2ZmJywgJ3dvcmRzJywgJ3NlbnRlbmNlcycsICdjaGFyZWN0ZXJzJywgJ25vbmUnXSksXG4gICAgICAgIGF1dG9jb21wbGV0ZTogUHJvcFR5cGVzLm9uZU9mKFsnb24nLCAnb2ZmJ10pLFxuICAgICAgICBlbmN0eXBlOiBQcm9wVHlwZXMub25lT2YoWydhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsICd0ZXh0L3BsYWluJ10pLFxuICAgICAgICBtZXRob2Q6IFByb3BUeXBlcy5vbmVPZihbJ2dldCcsICdwb3N0J10pLFxuICAgICAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBub3ZhbGlkYXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBmaWVsZEF0dHJzOiBQcm9wVHlwZXMuYW55XG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNsYXNzTmFtZTogJydcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIge2NoaWxkcmVuLCBuYW1lLCBmaWVsZEF0dHJzLCBlbmN0eXBlLGZvcm1DbGFzcywgY2xhc3NOYW1lLCBhY3Rpb24sIG1ldGhvZCwgb25TdWJtaXQsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoPGZvcm0gbmFtZT17bmFtZX0gYWN0aW9uPXthY3Rpb259IGVuY3R5cGU9e2VuY3R5cGV9IG1ldGhvZD17bWV0aG9kfSBvblN1Ym1pdD17b25TdWJtaXR9XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWUgfHwgZm9ybUNsYXNzfSB7Li4uZmllbGRBdHRyc30+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvZm9ybT4pO1xuICAgIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9Gb3JtVGVtcGxhdGUuanN4XG4gKiovIiwiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge3BhdGgsIG5vb3B9IGZyb20gJy4uL3R1dGlscyc7XG5pbXBvcnQgVW5pbmplY3RlZEJ1dHRvbnMgZnJvbSAnLi9CdXR0b25zVGVtcGxhdGUnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0SXRlbVRlbXBsYXRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLnN0eWxlLFxuICAgICAgICBCdXR0b25zOiBQcm9wVHlwZXMuaW5qZWN0Q2xhc3NcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgdHlwZTogJ1RleHQnLFxuICAgICAgICBvbk1vdmVVcDogbm9vcCxcbiAgICAgICAgb25Nb3ZlRG93bjogbm9vcCxcbiAgICAgICAgb25EZWxldGU6IG5vb3AsXG4gICAgICAgIG9uVmFsaWRhdGU6IG5vb3AsXG4gICAgICAgIG9uVmFsdWVDaGFuZ2U6IG5vb3AsXG4gICAgICAgIG9uRWRpdDogbm9vcCxcbiAgICAgICAgY2FuQWRkOiBmYWxzZSxcbiAgICAgICAgY2FuUmVvcmRlcjogZmFsc2UsXG4gICAgICAgIGNhbkVkaXQ6IGZhbHNlLFxuICAgICAgICBjYW5EZWxldGU6IGZhbHNlLFxuICAgICAgICBsYXN0OiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBudWxsLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIHN0eWxlOiBcIkxpc3RJdGVtVGVtcGxhdGVcIixcbiAgICAgICAgQnV0dG9uczogVW5pbmplY3RlZEJ1dHRvbnNcbiAgICB9O1xuXG4gICAgaGFuZGxlTW92ZVVwID0gKGUpPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMucHJvcHMub25Nb3ZlVXAodGhpcy5wcm9wcy5wb3MsIHRoaXMucHJvcHMudmFsdWUsIHRoaXMucHJvcHMucGlkKTtcbiAgICB9O1xuXG4gICAgaGFuZGxlTW92ZURvd24gPSAoZSk9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbk1vdmVEb3duKHRoaXMucHJvcHMucG9zLCB0aGlzLnByb3BzLnZhbHVlLCB0aGlzLnByb3BzLnBpZCk7XG4gICAgfTtcblxuICAgIGhhbmRsZURlbGV0ZSA9IChlKT0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnByb3BzLm9uRGVsZXRlKHRoaXMucHJvcHMucG9zLCB0aGlzLnByb3BzLnZhbHVlLCB0aGlzLnByb3BzLnBpZCk7XG4gICAgfTtcblxuICAgIGhhbmRsZUVkaXQgPSAoZSk9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMucHJvcHMudmFsdWU7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkVkaXQodGhpcy5wcm9wcy5wb3MsIHZhbC52YWx1ZSwgdGhpcy5wcm9wcy5waWQpO1xuICAgIH07XG5cbiAgICBidXR0b25zKHBvcywgbGFzdCwgY2FuUmVvcmRlciwgY2FuRGVsZXRlKSB7XG4gICAgICAgIHZhciBidXR0b25zID0gW107XG4gICAgICAgIHZhciBidXR0b25DbGFzcyA9IHRoaXMucHJvcHMuYnV0dG9uQ2xhc3M7XG4gICAgICAgIGlmIChjYW5SZW9yZGVyKSB7XG4gICAgICAgICAgICBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlTW92ZVVwLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ01vdmUgVXAnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246J3VwJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IHRoaXMucHJvcHMubW92ZVVwQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZU1vdmVEb3duLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ01vdmUgRG93bicsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjonZG93bicsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogdGhpcy5wcm9wcy5tb3ZlRG93bkNsYXNzLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25DbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICcnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5EZWxldGUpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdEZWxldGUnLFxuICAgICAgICAgICAgICAgIGFjdGlvbjonZGVsZXRlJyxcbiAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IHRoaXMucHJvcHMuZGVsZXRlQ2xhc3MsXG4gICAgICAgICAgICAgICAgYnV0dG9uQ2xhc3MsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnV0dG9uc1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHtwb3MsIEJ1dHRvbnMsIHZhbHVlLCBlcnJvcnMsIHBhdGgsIGN0cmxCdXR0b25zQ2xhc3MsIGxpc3RHcm91cEl0ZW1DbGFzcyxoZWxwQ2xhc3MsIG9uVmFsaWRhdGUsdHlwZSwgbmFtZSwgaGFzRXJyb3JDbGFzcywgY2FuUmVvcmRlciwgY2FuRGVsZXRlLCBsYXN0LCBvblZhbHVlQ2hhbmdlfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBlcnJvciA9IGVycm9ycyAmJiBlcnJvcnNbMF0gJiYgZXJyb3JzWzBdLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiA8bGkgY2xhc3NOYW1lPXtgJHtsaXN0R3JvdXBJdGVtQ2xhc3N9ICR7KGVycm9yID8gaGFzRXJyb3JDbGFzcyA6ICcnKX1gfT5cbiAgICAgICAgICAgIHsgZXJyb3IgPyA8cCByZWY9XCJlcnJvclwiIGtleT1cImVycm9yXCIgY2xhc3NOYW1lPXtoZWxwQ2xhc3N9PntlcnJvcn08L3A+IDogbnVsbCB9XG4gICAgICAgICAgICA8QnV0dG9ucyBrZXk9XCJidXR0b25zXCIgYnV0dG9ucz17dGhpcy5idXR0b25zKHBvcywgbGFzdCwgY2FuUmVvcmRlciwgY2FuRGVsZXRlKX0gcmVmPVwiYnV0dG9uc1wiXG4gICAgICAgICAgICAgICAgICAgICBidXR0b25zQ2xhc3M9e2N0cmxCdXR0b25zQ2xhc3N9IGJ1dHRvbkNvbnRhaW5lckNsYXNzPVwiIFwiLz5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgICA8L2xpPlxuXG4gICAgfVxuXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90ZW1wbGF0ZXMvTGlzdEl0ZW1UZW1wbGF0ZS5qc3hcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudCwgQ2hpbGRyZW59IGZyb20gJ3JlYWN0JztcbmltcG9ydCBCdXR0b25zIGZyb20gJy4vQnV0dG9uc1RlbXBsYXRlLmpzeCc7XG5pbXBvcnQgVmFsdWVNYW5hZ2VyIGZyb20gJy4uL1ZhbHVlTWFuYWdlcic7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQgTmV3Q2hpbGRDb250ZXh0IGZyb20gJy4uL2NvbXBvbmVudHMvTmV3Q2hpbGRDb250ZXh0LmpzeCc7XG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC9sYW5nL2Nsb25lRGVlcCc7XG5pbXBvcnQgUmVuZGVyQ29udGVudCBmcm9tICcuLi9jb21wb25lbnRzL1JlbmRlckNvbnRlbnQuanN4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWxUZW1wbGF0ZSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLnN0eWxlLFxuICAgICAgICB0aXRsZTogUHJvcFR5cGVzLmNvbnRlbnQsXG4gICAgICAgIGJ1dHRvbnM6IFByb3BUeXBlcy5idXR0b25zLFxuICAgICAgICBwYXRoOiBQcm9wVHlwZXMucGF0aCxcbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy52YWx1ZSxcbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy52YWx1ZUV2ZW50LFxuICAgICAgICBNb2RhbFRlbXBsYXRlOiBQcm9wVHlwZXMuaW5qZWN0Q2xhc3MsXG4gICAgICAgIGRpc21pc3M6IFByb3BUeXBlcy52YWx1ZUV2ZW50LFxuICAgICAgICBidXR0b25zVGVtcGxhdGU6IFByb3BUeXBlcy50ZW1wbGF0ZSxcblxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBidXR0b25zVGVtcGxhdGU6ICdCdXR0b25zVGVtcGxhdGUnLFxuICAgICAgICBvbkNhbmNlbCgpe1xuICAgICAgICB9LFxuICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICBidXR0b25zQ2xhc3M6ICdwdWxsLXJpZ2h0IGJ0bi1ncm91cCcsXG4gICAgICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJDYW5jZWxcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnYnRuJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJTYXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3N1Ym1pdCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2J0biBidG4tcHJpbWFyeSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBoYW5kbGVDYW5jZWwoKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMucHJvcHMuZGlzbWlzcygpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCAuLi5yZXN0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzLCAuLi5yZXN0KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNsb25lRGVlcChwcm9wcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyQnV0dG9ucyhidXR0b25zKSB7XG4gICAgICAgIGlmICghYnV0dG9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgQnV0dG9uc1RlbXBsYXRlID0gdGhpcy5wcm9wcy5idXR0b25zVGVtcGxhdGU7XG4gICAgICAgIGlmICghYnV0dG9ucy5idXR0b25zKSB7XG4gICAgICAgICAgICBidXR0b25zID0ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDxCdXR0b25zVGVtcGxhdGUgb25CdXR0b25DbGljaz17dGhpcy5oYW5kbGVCdG5DbG9zZX0gey4uLmJ1dHRvbnN9Lz5cbiAgICB9XG5cbiAgICBoYW5kbGVDbG9zZSA9IChlKT0+IHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMucHJvcHMuZGlzbWlzcygpO1xuICAgIH07XG4gICAgaGFuZGxlQnRuQ2xvc2UgPSAoZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdzdWJtaXQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgICAgY2FzZSAnY2FuY2VsJzpcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2UoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICByZW5kZXJGb290ZXIoYnV0dG9ucykge1xuICAgICAgICBpZiAoIWJ1dHRvbnMpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuZm9vdGVyQ2xhc3N9Pnt0aGlzLnJlbmRlckJ1dHRvbnMoYnV0dG9ucyl9PC9kaXY+XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7dGl0bGUsIGJ1dHRvbnMsIHBhdGgsdmFsdWUsYm9keUNsYXNzLCBoZWFkZXJDbGFzcywgY2xvc2VDbGFzcywgY29udGVudENsYXNzLCBiYWNrZHJvcENsYXNzLCBkaWFsb2dDbGFzcywgbmFtZXNwYWNlQ2xhc3MsIG92ZXJsYXlDbGFzcywgY2hpbGRyZW4sIC4uLnJlc3R9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2Ake25hbWVzcGFjZUNsYXNzfSAke292ZXJsYXlDbGFzc31gfSBzdHlsZT17e2Rpc3BsYXk6J2Jsb2NrJ319PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2JhY2tkcm9wQ2xhc3N9PjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2RpYWxvZ0NsYXNzfSByb2xlPVwiZG9jdW1lbnRcIiBzdHlsZT17e3pJbmRleDoyMDAwfX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NvbnRlbnRDbGFzc30+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtoZWFkZXJDbGFzc30+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xvc2V9IGNsYXNzTmFtZT17Y2xvc2VDbGFzc30gbmFtZT17dGhpcy5wcm9wcy5kaXNtaXNzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJDbG9zZVwiPjxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8UmVuZGVyQ29udGVudCB0eXBlPSdoNCcgY29udGVudD17dGl0bGV9Lz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtib2R5Q2xhc3N9PlxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMucmVuZGVyRm9vdGVyKGJ1dHRvbnMpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9Nb2RhbFRlbXBsYXRlLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQge3B1c2gsIHBhdGggYXMgdHBhdGgsIHVuaXF1ZSwgbm9vcCwgZXh0ZW5kLCBpc0Jvb2xlYW4sIGlzU3RyaW5nLCBpc0RhdGUsIGlzQXJyYXksIGlzTnVtYmVyfSBmcm9tICcuL3R1dGlscyc7XG5pbXBvcnQgZXZlbnRhYmxlIGZyb20gJy4vZXZlbnRhYmxlJztcblxuZnVuY3Rpb24gcmVkdWNlS2V5cyhhcnIsIHYsIGIsIGMpIHtcbiAgICBpZiAoY2FuRGVzY2VuZCh2KSkge1xuICAgICAgICBwdXNoKGFyciwgT2JqZWN0LmtleXModikpXG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBjYW5EZXNjZW5kKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCBpc051bWJlcihvYmopIHx8IGlzQm9vbGVhbihvYmopIHx8IGlzU3RyaW5nKG9iaikgfHwgaXNEYXRlKG9iaikgfHwgaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IG51bGwgOiBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoMCkgOiBleHRlbmQoe30sIG9iaik7XG59XG5cbmZ1bmN0aW9uIF9rZXlzKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdW5pcXVlKGFyZ3MucmVkdWNlKHJlZHVjZUtleXMsIFtdKSk7XG5cbn1cbi8qKlxuICogVmFsdWUgbWFuYWdlciBsaXN0ZW5zIGFuZCBjaGFuZ2VzIHZhbHVlcyBvbiB0aGUgb2JqZWN0cy5cbiAqIEl0IGNhbiBiZSBwYXNzZWQgYSBwcm9wZXJ0eSB0byBhbnkgc3Vic2NoZW1hIHR5cGUsIG9yIGZvcm0uXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gZXJyb3JzXG4gKiBAcmV0dXJucyB7VmFsdWVNYW5hZ2VyfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZhbHVlTWFuYWdlcih2YWx1ZSwgZXJyb3JzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZhbHVlTWFuYWdlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZU1hbmFnZXIodmFsdWUsIGVycm9ycyk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5lcnJvckxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMudmFsaWRhdGVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLnN0YXRlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSB8fCB7fSk7XG4gICAgdGhpcy5zZXRFcnJvcnMoZXJyb3JzKTtcbiAgICB0aGlzLm9sZFZhbHVlID0gZXh0ZW5kKHt9LCB0aGlzLnZhbHVlKTtcblxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSAtIFBhdGggdG8gbGlzdGVuIHRvLCBudWxsIG9yIG5vIHZhbHVlIHdpbGwgbGlzdGVuIHRvIGFsbCBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7VmFsdWVNYW5hZ2VyTGlzdGVuZXJ9IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIHRvIGV4ZWN1dGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSAgaW5pdCAtIHRydWUgb3IgYSBmdW5jdGlvbiB3aWxsIGV4ZWN1dGUgd2hlbiB0aGUgbGlzdGVuZXIgaXMgYWRkZWQuXG4gICAgICogKi9cbiAgICB0aGlzLmFkZExpc3RlbmVyID0gZXZlbnRhYmxlKHRoaXMubGlzdGVuZXJzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gc2VsZi5wYXRoKHByb3AsIHNlbGYudmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnBhdGgocHJvcCwgc2VsZi5vbGRWYWx1ZSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlcnJvciAgbGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIC0gUGF0aCB0byBsaXN0ZW4gdG8sIG51bGwgb3Igbm8gdmFsdWUgd2lsbCBsaXN0ZW4gdG8gYWxsIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtWYWx1ZU1hbmFnZXJMaXN0ZW5lcn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgdG8gZXhlY3V0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIFRoZSBzY29wZSB0byBleGVjdXRlIHRoZSBsaXN0ZW5lciBpbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259ICBpbml0IC0gdHJ1ZSBvciBhIGZ1bmN0aW9uIHdpbGwgZXhlY3V0ZSB3aGVuIHRoZSBsaXN0ZW5lciBpcyBhZGRlZC5cbiAgICAgKiAqL1xuICAgIHRoaXMuYWRkRXJyb3JMaXN0ZW5lciA9IGV2ZW50YWJsZSh0aGlzLmVycm9yTGlzdGVuZXJzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gc2VsZi5lcnJvcnNGb3IocHJvcCk7XG4gICAgfSwgbm9vcCk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdmFsaWRhdGUgIGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSAtIFBhdGggdG8gbGlzdGVuIHRvLCBudWxsIG9yIG5vIHZhbHVlIHdpbGwgbGlzdGVuIHRvIGFsbCBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7VmFsdWVNYW5hZ2VyTGlzdGVuZXJ9IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIHRvIGV4ZWN1dGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSAgaW5pdCAtIHRydWUgb3IgYSBmdW5jdGlvbiB3aWxsIGV4ZWN1dGUgd2hlbiB0aGUgbGlzdGVuZXIgaXMgYWRkZWQuXG4gICAgICogKi9cblxuICAgIHRoaXMuYWRkVmFsaWRhdGVMaXN0ZW5lciA9IGV2ZW50YWJsZSh0aGlzLnZhbGlkYXRlTGlzdGVuZXJzLCBub29wLCBub29wKTtcblxuICAgIHRoaXMuc3VibWl0TGlzdGVuZXJzID0gW107XG4gICAgLyoqXG4gICAgICogYWRkcyBhIHN1Ym1pdCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIC0gIHBhdGggdG8gbGlzdGVuIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtWYWx1ZU1hbmFnZXJMaXN0ZW5lcl0gLSB0aGUgbGlzdGVuZXIgdG8gbG9vayBmb3IuXG4gICAgICogQHBhcmFtIHtMaXN0ZW5lcn0gW2xpc3RlbmVyXSAtIHRoZSBsaXN0ZW5lciByZXR1cm5lZCBmcm9tIGV2ZW50YWJsZSgpO1xuICAgICAqL1xuICAgIHRoaXMuYWRkU3VibWl0TGlzdGVuZXIgPSBldmVudGFibGUodGhpcy5zdWJtaXRMaXN0ZW5lcnMpO1xuXG4gICAgLyoqXG4gICAgICogYWRkcyBhIHN1Ym1pdCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIC0gIHBhdGggdG8gbGlzdGVuIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtWYWx1ZU1hbmFnZXJMaXN0ZW5lcl0gLSB0aGUgbGlzdGVuZXIgdG8gbG9vayBmb3IuXG4gICAgICogQHBhcmFtIHtMaXN0ZW5lcn0gW2xpc3RlbmVyXSAtIHRoZSBsaXN0ZW5lciByZXR1cm5lZCBmcm9tIGV2ZW50YWJsZSgpO1xuICAgICAqL1xuICAgIHRoaXMuYWRkU3RhdGVMaXN0ZW5lciA9IGV2ZW50YWJsZSh0aGlzLnN0YXRlTGlzdGVuZXJzKTtcblxufVxuXG5mdW5jdGlvbiByZW1vdmUodikge1xuICAgIHYgJiYgdi5yZW1vdmUgJiYgdi5yZW1vdmUoKTtcbn1cbnZhciBsaXN0ZW5lcnNUeXBlcyA9IFsnbGlzdGVuZXJzJywgJ2Vycm9yTGlzdGVuZXJzJywgJ3ZhbGlkYXRlTGlzdGVuZXJzJywgJ3N0YXRlTGlzdGVuZXJzJywgJ3N1Ym1pdExpc3RlbmVycyddO1xuZnVuY3Rpb24gcmVtb3ZlQWxsKHYpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpc1t2XTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKHJlbW92ZSk7XG4gICAgICAgIGxpc3RlbmVycy5sZW5ndGggPSAwO1xuICAgIH1cblxufVxuVmFsdWVNYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICByZW1vdmVMaXN0ZW5lciguLi5hcmdzKXtcbiAgICAgICAgYXJncy5mb3JFYWNoKHJlbW92ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMsIGJvdGggZXJyb3IgYW5kIHZhbHVlLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbCgpXG4gICAge1xuICAgICAgICBsaXN0ZW5lcnNUeXBlcy5mb3JFYWNoKHJlbW92ZUFsbCwgdGhpcyk7XG4gICAgfVxuICAgICxcbiAgICAvKipcbiAgICAgKiBXaGVuIG9uU3VibWl0IGlzIGNhbGxlZCB0aGlzIGlzIGZpcmVkXG4gICAgICovXG4gICAgb25TdWJtaXQ6IGZ1bmN0aW9uIChlLCB2YWx1ZSwgZXJyb3JzLCBwYXRoKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGggJiYgcGF0aC5zcGxpdCgnLicpIHx8IFtdLCBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aCwgcHAgPSBudWxsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWJtaXRMaXN0ZW5lcnMuc29tZSh2PT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5wYXRoID09IG51bGwgfHwgdi5wYXRoID09PSBwcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2Lmxpc3RlbmVyLmNhbGwodi5zY29wZSwgZSwgdmFsdWUsIGVycm9ycywgcGF0aCkgPT09IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcCA9IHRwYXRoKHBwLCBwYXJ0c1tpXSk7XG4gICAgICAgIH0gd2hpbGUgKGkrKyA8IGwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgdGhlIHZhbHVlIGNoYW5nZSBvbiBhbGwgbGlzdGVuZW5lcnMuXG4gICAgICovXG4gICAgb25WYWx1ZUNoYW5nZShwYXRoLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAge1xuICAgICAgICB2YXIgcGFydHMgPSBwYXRoICYmIHBhdGguc3BsaXQoJy4nKSB8fCBbXSwgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGgsIHBwID0gbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLnNvbWUodj0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYucGF0aCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodi5saXN0ZW5lci5jYWxsKHYuc2NvcGUsIHRoaXMucGF0aChwcCwgdGhpcy52YWx1ZSksIHRoaXMucGF0aChwcCwgdGhpcy5vbGRWYWx1ZSksIHBhdGgpID09PSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHAgPSB0cGF0aChwcCwgcGFydHNbaV0pO1xuICAgICAgICB9IHdoaWxlIChpKysgPCBsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgICxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXRoIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAtIGEgZG90IGRlbGltaW50ZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSAtIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIHBhdGgocCwgb2JqKVxuICAgIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcCkgcmV0dXJuIG9iajtcblxuICAgICAgICB2YXIgcGFydHMgPSBwLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhKGtleSBpbiBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAsXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoLiBUaGlzIHdpbGwgdHJpZ2dlciB0aGUgdmFsdWUgbGlzdGVuZXJzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gUGF0aCB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gdXBkYXRlLmFyZ3VtZW50LlxuICAgICAqL1xuICAgIHVwZGF0ZShwYXRoLCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKSwgb2JqID0gdGhpcy52YWx1ZSB8fCAodGhpcy52YWx1ZSA9IHt9KSwgb29iaiA9IHRoaXMub2xkVmFsdWUsIGxhc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAvL1dlIHdvbid0IGJ1aWxkIHRoZSBvb2JqIHRyZWUsIHdlIG1heSBuZWVkIHRvIGluIHRoZSBjYXNlIG9mIG11bHRpcGxlIGNoYW5nZXMgdG8gdGhlIG9iamVjdC4gIFRoZSBxdWVzdGlvbiBiZWNvbWVzXG4gICAgICAgICAgICAgICAgLy8gYXJlIG9sZCB2YWx1ZXMgdGhlIG9yaWdpbmFsIHZhbHVlcyBvciB0aGUgbGFzdCBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgb29iaiA9IG9vYmogJiYgb29ialtrZXldO1xuXG4gICAgICAgICAgICAgICAgLy9XZSBjb3B5IGl0IHNvIHRoYXQgd2hlbiBvbGRWYWx1ZXMgYW5kIHZhbHVlIHNoYXJlIGEgbmVzdGVkIG9iamVjdCwgdGhleSBkbyBub3QgY29uZmxpY3QsIGJ1dCB3ZSBvbmx5IG5lZWQgdG8gZG8gaXQgd2hlblxuICAgICAgICAgICAgICAgIC8vIHRoZXkgYXJlIHJlZmVyZW5jaW5nIHRoZSBzYW1lIGluc3RhbmNlLCBub3RlIHdlIGFyZSBwYXJ0cyAtMSBsZXZlbHMgdXAsIHNvIHJlYWxseSBvbmx5IGFycmF5cyBhbmQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoL15cXGQrPyQvLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2tleV0gPSBbXVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2tleV0gPSB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2tleV0gPSAob29iaiA9PT0gb2JqW2tleV0pID8gY29weShvYmpba2V5XSkgOiBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy9TbyB0aGUgb2JqZWN0IHRyZWUgaXNuJ3QgcmVhY2hlZCB5ZXQsIHdlIHdpbGwgY3JlYXRlIGFuIGFycmF5IG9yIG9iamVjdC4gaWYgdGhlIGtleVxuICAgICAgICAgICAgICAgIC8vIGlzIGFuIGludGVnZXIgd2Ugd2lsbCBndWVzcyBpdHMgYW4gYXJyYXksIHRoaXMgd2lsbCBwcm9iYWJseSBiZSBjb3JyZWN0IDk5JSBvZiB0aGUgdGltZSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gaG9ycmlibGUgd3JvbmcgMSUsIHNlIGxhIHZpZS5cbiAgICAgICAgICAgICAgICBpZiAoL15cXGQrPyQvLnRlc3QocGFydHNbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmpba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9ialtrZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCgwKSkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtsYXN0XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtsYXN0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vV2Ugd2lsbCBidWlsZCBhIHBhdGggZm9yIHRoZSBuZXcgdmFsdWUsIGJ1dCBub3QgZm9yIHRoZSBvbGR2YWx1ZS4gICBUaGlzXG4gICAgICAgIC8vIG1pZ2h0IGJyZWFrIHdoZWFuIGEgdmFsdWUgY2hhbmdlcyBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAgcmV0dXJuIHRoaXMub25WYWx1ZUNoYW5nZShwYXRoLCB2YWx1ZSwgb29iaiAmJiBvb2JqW2xhc3RdKSAhPT0gZmFsc2U7XG4gICAgfVxuICAgICxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGdldFZhbHVlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHBhcmFtcy4gIFdpbGwgdHJpZ2dlclxuICAgICAqIGNoYW5nZXMgb24gYWxsIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZSh2YWx1ZSlcbiAgICB7XG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSBleHRlbmQoe30sIHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gZXh0ZW5kKHt9LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9zZXRWYWx1ZSh2YWx1ZSwgdGhpcy5vbGRWYWx1ZSkgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgICxcbiAgICBfc2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBwYXRoKVxuICAgIHtcbiAgICAgICAgaWYgKGNhbkRlc2NlbmQodmFsdWUpIHx8IGNhbkRlc2NlbmQob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBfa2V5cyh2YWx1ZSwgb2xkVmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKHZhbHVlICYmIHZhbHVlW2tleV0sIG9sZFZhbHVlICYmIG9sZFZhbHVlW2tleV0sIHRwYXRoKHBhdGgsIGtleSkpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vblZhbHVlQ2hhbmdlKHBhdGgsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH1cbiAgICAsXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgZXJyb3IgaGFuZGxlcnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBwYXRoIHRvIHRyaWdnZXIgdGhlIGVycm9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGVycm9ycyAtIEVycm9ycyB0byBzZXQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9ycy5uYW1lIC0gTmFtZSBvZiB0aGUgZXJyb3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9ycy5tZXNzYWdlIC0gTWVzc2FnZSBvZiB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgb25FcnJvcihwYXRoLCBlcnJvcnMsIHZhbHVlKVxuICAgIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzICYmIGVycm9yc1swXSA/IGVycm9ycyA6IG51bGw7XG4gICAgICAgIHZhciBvRXJyb3JzID0gdGhpcy5lcnJvcnMgfHwge30sIGxpc3RlbmVycyA9IHRoaXMuZXJyb3JMaXN0ZW5lcnM7XG5cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5zb21lKCh2KT0+IHtcbiAgICAgICAgICAgIGlmIChwYXRoID09IG51bGwgfHwgdi5wYXRoID09IG51bGwgfHwgdi5wYXRoID09PSBwYXRoIHx8IHBhdGguaW5kZXhPZih2LnBhdGggKyAnLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2Lmxpc3RlbmVyLmNhbGwodi5zY29wZSwgZXJyb3JzLCBvRXJyb3JzW3BhdGhdLCBwYXRoLCB2YWx1ZSkgPT09IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICB9XG4gICAgLFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgZXJyb3JzIGFuZCB0cmlnZ2VycyB0aGUgZXJyb3IgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVycm9ycyAtIG9iamVjdCBjb250YWluaW5nIGVycm9ycy4gVGhlIGtleSBpcyB0aGUgZnVsbCBxdWFsaWZpZWQgcGF0aCB0byB0aGUgdmFsdWUgaW4gZXJyb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHNldEVycm9ycyhlcnJvcnMpXG4gICAge1xuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKGVycm9ycywgdGhpcy5lcnJvcnMpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGV4dGVuZCh7fSwgZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIGtleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FcnJvcihrZXksIHRoaXMuZXJyb3JzW2tleV0pO1xuICAgICAgICAgICAgfSwgdGhpcykgIT09IHRydWU7XG4gICAgfVxuICAgICxcbiAgICBnZXRFcnJvcnMoKVxuICAgIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmVycm9ycykuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t2XSAhPSBudWxsO1xuICAgICAgICB9LCB0aGlzLmVycm9ycykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0W3ZdID0gdGhpc1t2XTtcbiAgICAgICAgfSwgdGhpcy5lcnJvcnMpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAsXG4gICAgdXBkYXRlRXJyb3JzKHBhdGgsIGVycm9ycywgdmFsdWUpXG4gICAge1xuICAgICAgICBlcnJvcnMgPSBpc0FycmF5KGVycm9ycykgPyBlcnJvcnMgOiBbZXJyb3JzXTtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzICYmIGVycm9yc1swXSA/IGVycm9ycyA6IG51bGw7XG4gICAgICAgIHRoaXMuZXJyb3JzW3BhdGhdID0gZXJyb3JzO1xuICAgICAgICB0aGlzLm9uRXJyb3IocGF0aCwgZXJyb3JzLCB2YWx1ZSk7XG4gICAgfVxuICAgICxcbiAgICBlcnJvcnNGb3IocGF0aClcbiAgICB7XG4gICAgICAgIHZhciBwYXRoZSA9IHBhdGggKyAnLicsIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmVycm9ycykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gIT0gbnVsbCAmJiAocGF0aCA9PSBudWxsIHx8IGtleSA9PT0gcGF0aCB8fCBrZXkuaW5kZXhPZihwYXRoZSkgPT09IDApO1xuICAgICAgICB9LCB0aGlzLmVycm9ycyksIGVycm9ycyA9IFtdO1xuXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yc1trZXlzWzBdXTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcHVzaChlcnJvcnMsIHRoaXNba2V5XSk7XG4gICAgICAgIH0sIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG4gICAgLFxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgdGhlIHZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKi9cbiAgICB2YWxpZGF0ZShwYXRoLCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIHZhciBwcCA9IHBhdGggJiYgcGF0aCArICcuJztcbiAgICAgICAgdGhpcy52YWxpZGF0ZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIFZhbHVlTWFuYWdlciR2YWxpZGF0ZSRmb3JFYWNoKHYpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09IG51bGwgfHwgdi5wYXRoID09PSBwYXRoIHx8IHBwLmluZGV4T2YocGF0aCkgPT09IDApXG4gICAgICAgICAgICAgICAgdi5saXN0ZW5lci5jYWxsKHYuc2NvcGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIFZhbGlkYXRvcnMgQW5kIENhbGxiYWNrIHdpdGggRXJyb3JzIGZvciBwYXRocy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBhdGhzKHBhdGhzLCBjYWxsYmFjayl7XG4gICAgICAgIGxldCBlcnJvcnMgPSBudWxsO1xuICAgICAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgICAgICAgLy92YWxpZGF0ZSBkb2VzIG5vdCByZXR1cm4gdGhlIGVycm9yLCBpdCBqdXN0IHRyaWdnZXJzIHRoZSBlcnJvciBoYW5kbGVyLFxuICAgICAgICAgICAgLy8gc28gd2UgYWRkIGEgbGlzdGVuZXIgZm9yIHRoYXQgcGF0aCwgdHJpZ2dlciBpdCBhbmQgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICAgICAgICAgIC8vICBzbyB0aGF0IHdlIGNhbiBnZXQgdGhlIGxpc3RlbmVyLiAgV2Ugc2hvdWxkIHByb2JhYmx5IGNoYW5nZSB2YWxpZGF0ZVxuICAgICAgICAgICAgLy8gdG8gcmV0dXJuIHRoZSBlcnJvciAob3IgYSBwcm9taXNlKSBidXQgbm90IHRvZGF5LlxuICAgICAgICAgICAgdGhpcy5hZGRFcnJvckxpc3RlbmVyKHBhdGgsIChlKT0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAoZXJyb3JzID09IG51bGwgPyAoZXJyb3JzID0ge30pIDogZXJyb3JzKVtwYXRoXSA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkub25jZSgpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZShwYXRoKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQcmV0dHkgbXVjaCB0aGUgc2FtZSBhcyB1cGRhdGUsIGV4Y2VwdCB0aGF0IGl0IGRvZXMgbm90LCBzdG9yZVxuICAgICAqIHRoZSB2YWx1ZXMuICBJdCBqdXN0IGZpcmVzLCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgdXBkYXRlU3RhdGUocGF0aCwgdmFsdWUpe1xuICAgICAgICByZXR1cm4gdGhpcy5vbkNoYW5nZVN0YXRlKHBhdGgsIHZhbHVlKSAhPT0gZmFsc2U7XG4gICAgfSxcbiAgICBvbkNoYW5nZVN0YXRlKHBhdGgsIHZhbHVlKXtcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aCAmJiBwYXRoLnNwbGl0KCcuJykgfHwgW10sIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoLCBwcCA9IG51bGw7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTGlzdGVuZXJzLnNvbWUoKHYpPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5wYXRoID09PSBwcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2Lmxpc3RlbmVyLmNhbGwodi5zY29wZSwgdmFsdWUsIHBhdGgpID09PSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHAgPSB0cGF0aChwcCwgcGFydHNbaV0pO1xuICAgICAgICB9IHdoaWxlIChpKysgPCBsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBjb3B5KCl7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVNYW5hZ2VyKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5nZXRFcnJvcnMoKSk7XG4gICAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9WYWx1ZU1hbmFnZXIuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHtpc0Z1bmN0aW9uLCByZXR1cm5GaXJzdH0gZnJvbSAnLi90dXRpbHMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi93YXJuaW5nJztcblxuLyoqXG4gKiBUaGlzIGNhbGxiYWNrIGlzIGRpc3BsYXllZCBhcyBhIGdsb2JhbCBtZW1iZXIuXG4gKiBJdCB3aWxsIGNhbGwgdGhlbSBpbiBvcmRlciBvZiBtb3N0IGRpc3RhbnQgdG8gbGVhc3QgZGlzdGFuY2UgcGF0aC5cbiAqIEluIHRoZSBldmVudCBvZiB0d28gcGF0aHMgYmVpbmcgdGhlIHNhbWUgZGlzdGFuY2UsIGl0IHdpbGwgY2FsbCB0aGUgbGFzdFxuICogYWRkZWQgZmlyc3QuXG4gKlxuICogQGNhbGxiYWNrIFZhbHVlTWFuYWdlckxpc3RlbmVyXG4gKiBAcGFyYW0geyp9IG5ld1ZhbHVlIC0gVGhlIG5ldyB2YWx1ZSB0byBiZSB1cGRhdGVkXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIC0gVGhlIHByZXZpb3VzIHZhbHVlIHVwZGF0ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIHRvIHZhbHVlIHVwZGF0ZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXZlbnRhYmxlKGxpc3RlbmVycywgZmluZCA9IHJldHVybkZpcnN0LCBmaW5kT2xkID0gcmV0dXJuRmlyc3QpIHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgW107XG5cbiAgICAvL1JlbW92ZSBpZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBjb25zdCBpZHggPSBsaXN0ZW5lcnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25jZSgpIHtcbiAgICAgICAgY29uc3QgcmVtID0gdGhpcy5yZW1vdmUsIGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lciwgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gbGlzdGVuZXIuYXBwbHkoc2VsZiwgLi4uYXJncyk7XG4gICAgICAgICAgICByZW0oKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXRoIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGxpc3RlbmVyIHtmdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0gc2NvcGUge29iamVjdH1cbiAgICAgKiBAcGFyYW0gaW5pdCB7Ym9vbGVhbnxmdW5jdGlvbn1cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gZXZlbnRhYmxlJGFkZExpc3RlbmVyKHBhdGgsIGxpc3RlbmVyLCBzY29wZSwgaW5pdCkge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2FybmluZyhsaXN0ZW5lciwgJ3RyeWluZyB0byBhZGQgYSBudWxsIGxpc3RlbmVyICVzJywgcGF0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqID0ge3BhdGgsIGxpc3RlbmVyLCBzY29wZSwgb25jZX07XG4gICAgICAgIG9iai5yZW1vdmUgPSBvYmo6OnJlbW92ZTtcbiAgICAgICAgaW5pdCA9IGluaXQgPT09IHRydWUgPyBvYmoubGlzdGVuZXIgOiBpc0Z1bmN0aW9uKGluaXQpID8gaW5pdCA6IG51bGw7XG4gICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICBpbml0LmNhbGwob2JqLnNjb3BlLCBmaW5kKHBhdGgpLCBmaW5kT2xkKHBhdGgpLCBwYXRoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChvYmopXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGxlbmd0aCA9IHBhdGggPyBwYXRoLnNwbGl0KCcuJykubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxwID0gbGlzdGVuZXJzW2ldLnBhdGgsIGNsbGVuZ3RoID0gbHAgPyBscC5zcGxpdCgnLicpLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAocGxlbmd0aCA+PSBjbGxlbmd0aCB8fCBpICsgMSA9PT0gbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDAsIG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvZXZlbnRhYmxlLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQgVmFsdWVNYW5hZ2VyIGZyb20gJy4vLi4vVmFsdWVNYW5hZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV3Q2hpbGRDb250ZXh0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZGlzcGxheU5hbWUgPSBcIk5ld0NoaWxkQ29udGV4dFwiO1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHZhbHVlTWFuYWdlcjogUHJvcFR5cGVzLnZhbHVlTWFuYWdlcixcbiAgICAgICAgbG9hZGVyOiBQcm9wVHlwZXMubG9hZGVyLFxuICAgICAgICBwYXRoOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgICB9O1xuICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgdmFsdWVNYW5hZ2VyOiBQcm9wVHlwZXMudmFsdWVNYW5hZ2VyLFxuICAgICAgICBsb2FkZXI6IFByb3BUeXBlcy5sb2FkZXIsXG4gICAgICAgIHBhcmVudFZhbHVlTWFuYWdlcjogUHJvcFR5cGVzLnZhbHVlTWFuYWdlclxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCwgLi4ucmVzdCkge1xuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCwgLi4ucmVzdCk7XG4gICAgICAgIHZhciBwYXJlbnRWYWx1ZU1hbmFnZXIgPSB0aGlzLnByb3BzLnZhbHVlTWFuYWdlcjtcbiAgICAgICAgdGhpcy52YWx1ZU1hbmFnZXIgPSBWYWx1ZU1hbmFnZXIocGFyZW50VmFsdWVNYW5hZ2VyLmdldFZhbHVlKCksIHBhcmVudFZhbHVlTWFuYWdlci5nZXRFcnJvcnMoKSk7XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWVNYW5hZ2VyOiB0aGlzLnZhbHVlTWFuYWdlcixcbiAgICAgICAgICAgIHBhcmVudFZhbHVlTWFuYWdlcjogdGhpcy5wcm9wcy52YWx1ZU1hbmFnZXIsXG4gICAgICAgICAgICBsb2FkZXI6IHRoaXMucHJvcHMubG9hZGVyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaGFuZGxlU3VibWl0ID0gKGUpPT4ge1xuICAgICAgICAvL3QoZSwgdm0uZ2V0RXJyb3JzKCksIHZtLmdldFZhbHVlKCksIHRoaXMucHJvcHMucGF0aClcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZU1hbmFnZXIucGF0aCh0aGlzLnByb3BzLnBhdGgpLCBlcnJvcnMgPSB0aGlzLnZhbHVlTWFuYWdlci5nZXRFcnJvcnMoKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vblN1Ym1pdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25TdWJtaXQoZSwgZXJyb3JzLCB2YWx1ZSwgdGhpcy5wcm9wcy5wYXRoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnZhbHVlTWFuYWdlci51cGRhdGUodGhpcy5wcm9wcy5wYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnZhbHVlTWFuYWdlci51cGRhdGUodGhpcy5wcm9wcy5wYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudCh0aGlzLnByb3BzLmNoaWxkcmVuLCB7b25TdWJtaXQ6IHRoaXMuaGFuZGxlU3VibWl0fSk7XG4gICAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9jb21wb25lbnRzL05ld0NoaWxkQ29udGV4dC5qc3hcbiAqKi8iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUNsb25lJyksXG4gICAgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmluZENhbGxiYWNrJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0J3MgaW52b2tlZFxuICogdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZ1xuICogaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gKiBhbmQgaW52b2tlZCB3aXRoIHVwIHRvIHRocmVlIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKS5cbiAqIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmQgb2JqZWN0cyBjcmVhdGVkIGJ5XG4gKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG4gKiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoIGFzIGZ1bmN0aW9ucywgRE9NIG5vZGVzLFxuICogTWFwcywgU2V0cywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAodXNlcnMpO1xuICogZGVlcFswXSA9PT0gdXNlcnNbMF07XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICogdmFyIGVsID0gXy5jbG9uZURlZXAoZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGVsID09PSBkb2N1bWVudC5ib2R5XG4gKiAvLyA9PiBmYWxzZVxuICogZWwubm9kZU5hbWVcbiAqIC8vID0+IEJPRFlcbiAqIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICogLy8gPT4gMjBcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gIHJldHVybiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nXG4gICAgPyBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAzKSlcbiAgICA6IGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEZWVwO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9jbG9uZURlZXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhcnJheUNvcHkgPSByZXF1aXJlKCcuL2FycmF5Q29weScpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vYXJyYXlFYWNoJyksXG4gICAgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4vYmFzZUFzc2lnbicpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL2Jhc2VGb3JPd24nKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IHJlcXVpcmUoJy4vaW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vaW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1ttYXBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAqIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCBgdmFsdWVgIGJlbG9uZ3MgdG8uXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0KSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZztcblxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2xvbmVhYmxlVGFnc1t0YWddXG4gICAgICAgID8gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKVxuICAgICAgICA6IChvYmplY3QgPyB2YWx1ZSA6IHt9KTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICB9XG4gIH1cbiAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmUuXG4gIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvYmFzZUNsb25lLmpzXG4gKiogbW9kdWxlIGlkID0gMjg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29weShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUNvcHk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9hcnJheUNvcHkuanNcbiAqKiBtb2R1bGUgaWQgPSAyODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvaW5pdENsb25lQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBidWZmZXJDbG9uZSA9IHJlcXVpcmUoJy4vYnVmZmVyQ2xvbmUnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gYnVmZmVyQ2xvbmUob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHZhciBidWZmZXIgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBDdG9yKGlzRGVlcCA/IGJ1ZmZlckNsb25lKGJ1ZmZlcikgOiBidWZmZXIsIG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QubGVuZ3RoKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcihvYmplY3Quc291cmNlLCByZUZsYWdzLmV4ZWMob2JqZWN0KSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gb2JqZWN0Lmxhc3RJbmRleDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvaW50ZXJuYWwvaW5pdENsb25lQnlUYWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgQXJyYXlCdWZmZXIgPSBnbG9iYWwuQXJyYXlCdWZmZXIsXG4gICAgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZ2l2ZW4gYXJyYXkgYnVmZmVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpLFxuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG5cbiAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVmZmVyQ2xvbmU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9idWZmZXJDbG9uZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgIEN0b3IgPSBPYmplY3Q7XG4gIH1cbiAgcmV0dXJuIG5ldyBDdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2luaXRDbG9uZU9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhpcyBpcyB0byBiZSB1c2VkIHRvIHJlbmRlciBwcm9wZXJ0aWVzIHdpdGggdHlwZSBjb250ZW50LlxuICogSnVzdCBhIGNvbnZpZW50IHdyYXBwZXIgc28gdGhhdCB0aGluZ3MgZ28gd2VsbC5cbiAqXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEByZXR1cm5zIHsqfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyQ29udGVudChwcm9wcykge1xuICAgIGlmIChwcm9wcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG5cbiAgICBjb25zdCB7Y29udGVudCwgLi4ub3Byb3BzfSA9IHByb3BzO1xuXG4gICAgaWYgKGNvbnRlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3Qge0NvbnRlbnQsIC4uLnJlc3R9ID0gY29udGVudDtcblxuICAgIHJldHVybiA8Q29udGVudCBjb250ZW50PXtyZXN0fSB7Li4ub3Byb3BzfS8+XG59XG5SZW5kZXJDb250ZW50LmRpc3BsYXlOYW1lID0gJ1JlbmRlckNvbnRlbnQnO1xuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQ29udGVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL2NvbXBvbmVudHMvUmVuZGVyQ29udGVudC5qc3hcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPYmplY3RUZW1wbGF0ZShwcm9wcykge1xuICAgIHZhciB7Y2hpbGRyZW4sIGNsYXNzTmFtZSwgZmllbGRBdHRycywgLi4ucmVzdH0gPSBwcm9wcztcbiAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9IHsuLi5maWVsZEF0dHJzfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgIDwvZGl2Pik7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9PYmplY3RUZW1wbGF0ZS5qc3hcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFVuaW5qZWN0ZWRDb250ZW50IGZyb20gJy4uL3R5cGVzL0NvbnRlbnQuanN4JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaW9JdGVtVGVtcGxhdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGxhYmVsOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBsYWJlbEhUTUw6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjaGVja2VkQ2xhc3M6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGlkOiBQcm9wVHlwZXMuaWQsXG4gICAgICAgIENvbnRlbnQ6IFByb3BUeXBlcy5pbmplY3RDbGFzcyxcbiAgICAgICAgc3R5bGU6IFByb3BUeXBlcy5zdHlsZVxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBDb250ZW50OiBVbmluamVjdGVkQ29udGVudCxcbiAgICAgICAgbmFtZXNwYWNlQ2xhc3M6IFwicmFkaW9cIixcbiAgICAgICAgY2hlY2tlZENsYXNzOiBcIlwiLFxuICAgICAgICB1bmNoZWNrZWRDbGFzczogXCJcIlxuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7Q29udGVudCwgbGFiZWwsbmFtZXNwYWNlQ2xhc3MsIGxhYmVsSFRNTCxjaGlsZHJlbiwgY2hlY2tlZCwgY2hlY2tlZENsYXNzLCB1bmNoZWNrZWRDbGFzcywgaWR9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGFiZWwgPSBsYWJlbEhUTUwgPyBsYWJlbEhUTUwgOiBsYWJlbDtcbiAgICAgICAgY2hlY2tlZENsYXNzID0gY2hlY2tlZENsYXNzIHx8ICcnO1xuICAgICAgICBsYWJlbCA9IHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycgPyBbe2NoaWxkcmVuOiB0cnVlfSwgbGFiZWxdIDogbGFiZWw7XG4gICAgICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9e2Ake25hbWVzcGFjZUNsYXNzfSAke2NoZWNrZWQgPyBjaGVja2VkQ2xhc3MgOiB1bmNoZWNrZWRDbGFzc31gfT5cbiAgICAgICAgICAgIDxDb250ZW50IHR5cGU9J2xhYmVsJyBjb250ZW50PXtsYWJlbH0+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgPC9Db250ZW50PlxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL1JhZGlvSXRlbVRlbXBsYXRlLmpzeFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpemFyZFByb2dyZXNzVGVtcGxhdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMuc3R5bGVcbiAgICB9O1xuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBmaWVsZHNldHM6IFtdLFxuICAgICAgICBvbkNsaWNrKGUpe1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldFN0eWxlKGkpIHtcbiAgICAgICAgY29uc3Qge2ZpZWxkc2V0czp7bGVuZ3RofSwgaW5kZXgsIGRvbmVDbGFzcywgZG9pbmdDbGFzcywgdG9kb0NsYXNzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChpIDwgaW5kZXggfHwgaW5kZXggPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZUNsYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9pbmdDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2RvQ2xhc3M7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gPG9sIGNsYXNzTmFtZT17dGhpcy5wcm9wcy5uYW1lc3BhY2VDbGFzc30+e1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5maWVsZHNldHMubWFwKChzLCBpKSA9PlxuICAgICAgICAgICAgICAgIDxsaSB2YWx1ZT17aX0ga2V5PXsnbGknK2l9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17dGhpcy5nZXRTdHlsZShpKX1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfT5cbiAgICAgICAgICAgICAgICAgICAgPGVtPntpICsgMX08L2VtPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57cy5sZWdlbmR9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICApfVxuICAgICAgICA8L29sPjtcbiAgICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9XaXphcmRQcm9ncmVzc1RlbXBsYXRlLmpzeFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCdcbmltcG9ydCBPYmplY3RUeXBlIGZyb20gJy4uL3R5cGVzL09iamVjdC5qc3gnO1xuaW1wb3J0IFdpemFyZE1peGluIGZyb20gJy4vV2l6YXJkTWl4aW4nO1xuaW1wb3J0IEJ1dHRvbnNUZW1wbGF0ZSBmcm9tICcuL0J1dHRvbnNUZW1wbGF0ZS5qc3gnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJ2xvZGFzaC9vYmplY3QvZGVmYXVsdHMnO1xuXG5cbmZ1bmN0aW9uIGRvbm5lcihkb25lKSB7XG4gICAgZG9uZSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXphcmRUZW1wbGF0ZSBleHRlbmRzIFdpemFyZE1peGluIHtcbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0gZGVmYXVsdHMoe1xuICAgICAgICB3aXphcmRQcm9ncmVzc1RlbXBsYXRlOiAnV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZScsXG4gICAgICAgIFRlbXBsYXRlOiAnT2JqZWN0VGVtcGxhdGUnLFxuICAgICAgICBvbk5leHQ6IGRvbm5lcixcbiAgICAgICAgb25QcmV2aW91czogZG9ubmVyLFxuICAgICAgICBvbkRvbmU6IGRvbm5lcixcbiAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgJ3ByZXZpb3VzJzoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnUHJldmlvdXMnLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3ByZXZpb3VzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICduZXh0Jzoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnTmV4dCcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbmV4dCcsXG4gICAgICAgICAgICAgICAgcHJpbWFyeTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdsYXN0Jzoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnRG9uZScsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnc3VibWl0JyxcbiAgICAgICAgICAgICAgICBwcmltYXJ5OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWN0aW9uOiBmdW5jdGlvbiAocG9zLCBhY3Rpb24sIHdpemFyZCkge1xuICAgICAgICB9LFxuICAgICAgICBvbk5hdkNoYW5nZShjdXJyZW50LCBwcmV2aW91cywgd2l6YXJkKXtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNpdGlvbkZvcndhcmQ6IFwic2xpZGVSaWdodFwiLFxuICAgICAgICB0cmFuc2l0aW9uQmFja3dhcmQ6IFwic2xpZGVMZWZ0XCIsXG4gICAgICAgIG5hbWVzcGFjZUNsYXNzOiAnd2l6YXJkJ1xuICAgIH0sIFdpemFyZE1peGluLmRlZmF1bHRQcm9wcyk7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAuLi5XaXphcmRNaXhpbi5wcm9wVHlwZXMsXG4gICAgICAgIHdpemFyZFByb2dyZXNzVGVtcGxhdGU6IFByb3BUeXBlcy50ZW1wbGF0ZSxcbiAgICAgICAgVGVtcGxhdGU6IFByb3BUeXBlcy50ZW1wbGF0ZSxcbiAgICAgICAgdHJhbnNpdGlvbkZvcndhcmQ6IFByb3BUeXBlcy50cmFuc2l0aW9uLFxuICAgICAgICB0cmFuc2l0aW9uQmFja3dhcmQ6IFByb3BUeXBlcy50cmFuc2l0aW9uLFxuICAgICAgICBzdHlsZTogUHJvcFR5cGVzLnN0eWxlXG4gICAgfTtcblxuICAgIHNldE5hdlN0YXRlKG5leHQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5wcm9wcy5zY2hlbWEuZmllbGRzZXRzLmxlbmd0aCwgY29tcFN0YXRlID0gdGhpcy5zdGF0ZS5jb21wU3RhdGU7XG4gICAgICAgIG5leHQgPSBNYXRoLm1heChNYXRoLm1pbihsZW4gLSAxLCBuZXh0KSwgMCk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTmF2Q2hhbmdlKG5leHQsIGNvbXBTdGF0ZSwgdGhpcy5wcm9wcy5zY2hlbWEuZmllbGRzZXRzW25leHRdKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGNvbXBTdGF0ZTogbmV4dCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJldlN0YXRlOiBuZXh0ID09PSBjb21wU3RhdGUgPyB0aGlzLnN0YXRlLnByZXZTdGF0ZSA6IGNvbXBTdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJQcm9ncmVzcyhmaWVsZHNldHMpIHtcbiAgICAgICAgY29uc3QgVGVtcGxhdGUgPSB0aGlzLnByb3BzLndpemFyZFByb2dyZXNzVGVtcGxhdGU7XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZSA/XG4gICAgICAgICAgICA8VGVtcGxhdGUgZmllbGRzZXRzPXtmaWVsZHNldHN9IGluZGV4PXt0aGlzLnN0YXRlLmRvbmUgPyBmaWVsZHNldHMubGVuZ3RoIDogdGhpcy5zdGF0ZS5jb21wU3RhdGV9XG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVPbkNsaWNrfS8+IDogbnVsbDtcbiAgICB9XG5cbiAgICBtYWtlVHJhbnNpdGlvbihjb21wU3RhdGUpIHtcbiAgICAgICAgaWYgKGNvbXBTdGF0ZSA8IHRoaXMuc3RhdGUucHJldlN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy50cmFuc2l0aW9uRm9yd2FyZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnRyYW5zaXRpb25CYWNrd2FyZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHtjbGFzc05hbWUsIFRlbXBsYXRlLCB0ZW1wbGF0ZSwgZmllbGRzZXRzLCBmaWVsZHMsIG9uQnV0dG9uQ2xpY2ssdHJhbnNpdGlvbkxlYXZlVGltZW91dCwgIHRyYW5zaXRpb25FbnRlclRpbWVvdXQsIGNhcm91c2VsSGVpZ2h0Q2xhc3MsIGNoaWxkcmVuLCBzY2hlbWEsIC4uLnJlc3R9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgKHtmaWVsZHNldHMsIHNjaGVtYX0gPSB0aGlzLnByb3BzLnNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGNvbXBTdGF0ZSA9IHRoaXMuc3RhdGUuY29tcFN0YXRlLFxuICAgICAgICAgICAgY3VycmVudCA9IGZpZWxkc2V0c1tjb21wU3RhdGVdLFxuICAgICAgICAgICAge1RyYW5zaXRpb24sIC4uLnRyYW5zaXRpb259ID0gdGhpcy5tYWtlVHJhbnNpdGlvbihjb21wU3RhdGUpO1xuICAgICAgICBjb25zdCBidXR0b25zID0gY3VycmVudC5idXR0b25zID8gY3VycmVudC5idXR0b25zIDogdGhpcy5jcmVhdGVCdXR0b25zKGNvbXBTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTY2hlbWEgPSB7c2NoZW1hLCBmaWVsZHNldHM6IFt7YnV0dG9ucywgLi4uY3VycmVudCwgbGVnZW5kOiBmYWxzZX1dLCBUZW1wbGF0ZX07XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7dGhpcy5wcm9wcy5uYW1lc3BhY2VDbGFzc30gJHsodGhpcy5zdGF0ZS5hbmltYXRpbmcgPyB0aGlzLnByb3BzLmFuaW1hdGluZ0NsYXNzIDogJycpfWB9XG4gICAgICAgICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXlEb3dufT5cbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJQcm9ncmVzcyhmaWVsZHNldHMpfVxuICAgICAgICAgICAgICAgIDxUcmFuc2l0aW9uIGtleT1cIndpemFyZC10cmFuc2l0aW9uXCIgey4uLnRyYW5zaXRpb259PlxuXG4gICAgICAgICAgICAgICAgICAgIDxPYmplY3RUeXBlIHsuLi5yZXN0fVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgY2xlYXJmaXggc3RhdGUtJHtjb21wU3RhdGV9YH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17XCJmb3JtLVwiK2NvbXBTdGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYT17Y3VycmVudFNjaGVtYX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQnV0dG9uQ2xpY2s9e3RoaXM6OnRoaXMuaGFuZGxlQnRufVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvVHJhbnNpdGlvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3RlbXBsYXRlcy9XaXphcmRUZW1wbGF0ZS5qc3hcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSAgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyAgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCB7RlJFRVpFX09CSiwgdG9BcnJheSxwdXNoLCBpc1N0cmluZywgaXNBcnJheSwgdW5pcXVlLCBwYXRoIGFzIF9wYXRoLCBjbG9uZSwgbm9vcH0gIGZyb20gJy4uL3R1dGlscyc7XG5pbXBvcnQgbWFwIGZyb20gJ2xvZGFzaC9jb2xsZWN0aW9uL21hcCc7XG5pbXBvcnQgVW5pbmplY3RlZEZpZWxkICBmcm9tICcuLi9jb21wb25lbnRzL0ZpZWxkJztcbmltcG9ydCBVbmluamVjdGVkRmllbGRTZXQgZnJvbSAnLi4vY29tcG9uZW50cy9GaWVsZFNldC5qc3gnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi4vd2FybmluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9iamVjdFR5cGUgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIHRlbXBsYXRlID0gZmFsc2U7XG5cbiAgICBzdGF0aWMgaW5wdXRDbGFzc05hbWUgPSAnICc7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBvYmplY3RUZW1wbGF0ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZyxQcm9wVHlwZXMuZnVuY10pLFxuICAgICAgICBzY2hlbWE6IFByb3BUeXBlcy5zY2hlbWEsXG4gICAgICAgIHN1YlNjaGVtYTogUHJvcFR5cGVzLnNjaGVtYSxcbiAgICAgICAgb25CdXR0b25DbGljazogUHJvcFR5cGVzLmV2ZW50LFxuICAgICAgICBvblN1Ym1pdDogUHJvcFR5cGVzLmV2ZW50LFxuICAgICAgICBidXR0b25zOiBQcm9wVHlwZXMuYnV0dG9ucyxcbiAgICAgICAgcGF0aDogUHJvcFR5cGVzLnBhdGgsXG4gICAgICAgIGZpZWxkc2V0czogUHJvcFR5cGVzLmZpZWxkc2V0LFxuICAgICAgICBmaWVsZHM6IFByb3BUeXBlcy5maWVsZHMsXG4gICAgICAgIEZpZWxkU2V0OiBQcm9wVHlwZXMuaW5qZWN0Q2xhc3MsXG4gICAgICAgIEZpZWxkOiBQcm9wVHlwZXMuaW5qZWN0Q2xhc3NcblxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBvbkJ1dHRvbkNsaWNrOiBub29wLFxuICAgICAgICBvblN1Ym1pdDogbm9vcCxcbiAgICAgICAgZmFsbGJhY2tUZW1wbGF0ZTogJ09iamVjdFRlbXBsYXRlJyxcbiAgICAgICAgRmllbGRTZXQ6IFVuaW5qZWN0ZWRGaWVsZFNldCxcbiAgICAgICAgRmllbGQ6IFVuaW5qZWN0ZWRGaWVsZCxcbiAgICAgICAgc3ViU2NoZW1hOnt9XG4gICAgfTtcblxuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IFByb3BUeXBlcy5jb250ZXh0VHlwZXM7XG5cblxuICAgIGFkZEVkaXRvcihmLCBmaWVsZCwgZmllbGRzLCBGaWVsZCkge1xuXG4gICAgICAgIGlmIChmaWVsZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3YXJuaW5nKHRydWUsICdObyBmaWVsZCBmb3VuZCBmb3IgJXMgcHJvYmFibHkgYSBrZXkgaW4gZmllbGRzIGRvZXMgbm90IG1hdGNoIGluIHNjaGVtYScsIGYpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGYgPSB0eXBlb2YgZiA9PT0gJ3N0cmluZycgPyBmIDogZi5uYW1lIHx8IGY7XG5cbiAgICAgICAgcmV0dXJuIDxGaWVsZCBrZXk9eydrZXktJyArIGZ9IHBhdGg9e19wYXRoKHRoaXMucHJvcHMucGF0aCwgZil9IGNvbmRpdGlvbmFsPXtmaWVsZC5jb25kaXRpb25hbH0gdHJhbnNpdGlvbj17ZmllbGQudHJhbnNpdGlvbn0gZmllbGQ9e2ZpZWxkfSBmaWVsZHM9e2ZpZWxkc30vPlxuICAgIH1cblxuICAgIG1ha2VGaWVsZHNldChmLCBpLCBzY2hlbWEsIEZpZWxkU2V0LCBGaWVsZCkge1xuICAgICAgICByZXR1cm4gPEZpZWxkU2V0IGtleT17YGZpZWxkc2V0LSR7aX1gfSB7Li4uZn0gZmllbGQ9e2Z9XG4gICAgICAgICAgICAgICAgICAgICAgICAgb25TdWJtaXQ9e3RoaXMuaGFuZGxlU3VibWl0fVxuICAgICAgICAgICAgICAgICAgICAgICAgIG9uQnV0dG9uQ2xpY2s9e3RoaXMuaGFuZGxlQnV0dG9uQ2xpY2t9PlxuICAgICAgICAgICAge2YuZmllbGRzID8gdGhpcy5tYWtlRmllbGRzKGYuZmllbGRzLCBzY2hlbWEsIEZpZWxkKSA6IHRoaXMubWFrZUZpZWxkc2V0cyhmLmZpZWxkc2V0cywgc2NoZW1hLCBGaWVsZFNldCwgRmllbGQpfVxuICAgICAgICA8L0ZpZWxkU2V0PlxuICAgIH07XG5cblxuICAgIG1ha2VGaWVsZHMoZmllbGRzLCBzY2hlbWEsIEZpZWxkKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkTWFwID0ge307XG4gICAgICAgIGNvbnN0IG1hcHBlZGZpZWxkcyA9IGZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICB2YXIgW2YsIHJlc3RdID0gZmllbGQuc3BsaXQoJy4nLCAyKTtcbiAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgKGZpZWxkTWFwW2ZdIHx8IChmaWVsZE1hcFtmXSA9IFtdKSkucHVzaChyZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdW5pcXVlKG1hcHBlZGZpZWxkcykubWFwKChmLCBpKSA9PiB0aGlzLmFkZEVkaXRvcihmLCBzY2hlbWFbZl0gfHwgZiwgZmllbGRNYXBbZl0sIEZpZWxkKSk7XG4gICAgfVxuXG4gICAgbWFrZUZpZWxkc2V0cyhmaWVsZHNldHMsIHNjaGVtYSwgRmllbGRTZXQsIEZpZWxkKSB7XG4gICAgICAgIGlmIChmaWVsZHNldHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkc2V0cy5tYXAoKGYsIGkpPT50aGlzLm1ha2VGaWVsZHNldChmLCBpLCBzY2hlbWEsIEZpZWxkU2V0LCBGaWVsZCkpO1xuICAgIH1cblxuICAgIHJlbmRlclNjaGVtYShzY2hlbWEsIEZpZWxkU2V0LCBGaWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlRmllbGRzZXRzKHNjaGVtYS5maWVsZHNldHMsIHNjaGVtYS5zY2hlbWEsIEZpZWxkU2V0LCBGaWVsZCk7XG4gICAgfVxuXG4gICAgaGFuZGxlQnV0dG9uQ2xpY2sgPSAoZSwgYWN0aW9uLCAuLi5yZXN0KT0+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25CdXR0b25DbGljayhlLCBhY3Rpb24sIC4uLnJlc3QpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3N1Ym1pdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uU3VibWl0KGUsIC4uLnJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvL2NhcHR1cmUgdGhlIHRoaW5ncyB0aGF0IHNob3VsZCBub3QgZmFsbCB0aHJvdWdoLlxuICAgICAgICBsZXQge3NjaGVtYSwgc3ViU2NoZW1hLCBvbkJ1dHRvbkNsaWNrLCBzdWJtaXRCdXR0b24sIGNvbmRpdGlvbmFsLCBGaWVsZFNldCwgRmllbGQsIGNoaWxkcmVuLCBvYmplY3RUZW1wbGF0ZSwgdGVtcGxhdGUsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IE9iamVjdFRlbXBsYXRlID0gb2JqZWN0VGVtcGxhdGU7XG4gICAgICAgIGNvbnN0IHtUZW1wbGF0ZSwgLi4ucnNjaGVtYX0gPSBzY2hlbWEgfHwgc3ViU2NoZW1hO1xuICAgICAgICByZXR1cm4gPFRlbXBsYXRlIHNjaGVtYT17cnNjaGVtYX0gb25CdXR0b25DbGljaz17dGhpcy5oYW5kbGVCdXR0b25DbGlja30gIHsuLi5wcm9wc30+XG4gICAgICAgICAgICB7cnNjaGVtYSAhPSBudWxsID8gdGhpcy5yZW5kZXJTY2hlbWEocnNjaGVtYSwgRmllbGRTZXQsIEZpZWxkKSA6IG51bGx9XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvVGVtcGxhdGU+XG4gICAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3R5cGVzL09iamVjdC5qc3hcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQge0ZSRUVaRV9BUlJ9IGZyb20gJy4uL3R1dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZGlzcGxheU5hbWUgPSBcIkZpZWxkXCI7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBwYXRoOiBQcm9wVHlwZXMucGF0aC5pc1JlcXVpcmVkLFxuICAgICAgICBmaWVsZDogUHJvcFR5cGVzLmZpZWxkLFxuICAgICAgICB0cmFuc2l0aW9uOiBQcm9wVHlwZXMudHJhbnNpdGlvbixcbiAgICAgICAgY29uZGl0aW9uYWw6IFByb3BUeXBlcy5jb25kaXRpb25hbFxuICAgIH07XG5cblxuICAgIHJlbmRlckZpZWxkKGZpZWxkLCBwcm9wUGF0aCkge1xuICAgICAgICBjb25zdCB7VGVtcGxhdGUsIFR5cGUsICAgcGF0aCwgLi4ucmVzdH0gPSBmaWVsZDtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9ycyA9IGZpZWxkLnZhbGlkYXRvcnMgfHwgRlJFRVpFX0FSUjtcbiAgICAgICAgY29uc3QgY3BhdGggPSBwcm9wUGF0aCB8fCBwYXRoO1xuICAgICAgICBjb25zdCBGaWVsZFRlbXBsYXRlID0gVGVtcGxhdGU7XG4gICAgICAgIHJldHVybiAoRmllbGRUZW1wbGF0ZSA/IDxGaWVsZFRlbXBsYXRlIHBhdGg9e2NwYXRofSAgey4uLnJlc3R9ID5cbiAgICAgICAgICAgIDxUeXBlIHBhdGg9e2NwYXRofSBvbkJsdXI9e3ZhbGlkYXRvcnN9IHsuLi5yZXN0fS8+XG4gICAgICAgIDwvRmllbGRUZW1wbGF0ZT4gOiA8VHlwZSBwYXRoPXtjcGF0aH0gey4uLnJlc3R9Lz4pO1xuXG4gICAgfVxuXG4gICAgcmVuZGVyQ29uZGl0aW9uYWwoY29uZGl0aW9uYWwpIHtcbiAgICAgICAgY29uc3Qge2ZpZWxkLCBwYXRofSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKCFjb25kaXRpb25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRmllbGQoZmllbGQsIHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge0NvbmRpdGlvbmFsLCAuLi5yZXN0fSA9IGNvbmRpdGlvbmFsO1xuXG4gICAgICAgIHJldHVybiA8Q29uZGl0aW9uYWwgcGF0aD17cGF0aH0gey4uLnJlc3R9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ9e2ZpZWxkfT57dGhpcy5yZW5kZXJGaWVsZChmaWVsZCwgY29uZGl0aW9uYWwucGF0aCB8fCBwYXRoKX08L0NvbmRpdGlvbmFsPlxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgY29uc3Qge1RyYW5zaXRpb24sIC4uLnRyYW5zaXRpb259ID0gdGhpcy5wcm9wcy50cmFuc2l0aW9uO1xuICAgICAgICAgICAgcmV0dXJuICg8VHJhbnNpdGlvbiB7Li4udHJhbnNpdGlvbn0+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQ29uZGl0aW9uYWwodGhpcy5wcm9wcy5jb25kaXRpb25hbCl9XG4gICAgICAgICAgICA8L1RyYW5zaXRpb24+KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDb25kaXRpb25hbCh0aGlzLnByb3BzLmNvbmRpdGlvbmFsKTtcbiAgICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL2NvbXBvbmVudHMvRmllbGQuanN4XG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCBSZW5kZXJDb250ZW50IGZyb20gJy4vUmVuZGVyQ29udGVudC5qc3gnO1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIHRoZSBmaWVsZHNldC4gIEl0ICB1c2VzIEZpZWxkU2V0VGVtcGxhdGUgb3Igc2ltaWxhciwgYnV0IG5vd1xuICogaXQgcmVuZGVycyB0aGUgYnV0dG9ucywgc28gdGhlIFRlbXBsYXRlIGRvZXMgbm90IGhhdmUgdG8gaGFuZGxlIHRoYXQuXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWVsZFNldCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGRpc3BsYXlOYW1lID0gXCJGaWVsZFNldFwiO1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGZpZWxkc2V0czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgICAgIGZpZWxkOiBQcm9wVHlwZXMuZmllbGQsXG4gICAgICAgICAgICBmaWVsZHNldHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgICAgICAgICAgZmllbGQ6IFByb3BUeXBlcy5maWVsZFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH0pKSxcbiAgICAgICAgY29uZGl0aW9uYWw6IFByb3BUeXBlcy5jb25kaXRpb25hbCxcbiAgICAgICAgYnV0dG9uczogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgb25CdXR0b25DbGljazogUHJvcFR5cGVzLmV2ZW50LFxuICAgICAgICBvblN1Ym1pdDogUHJvcFR5cGVzLmV2ZW50LFxuICAgICAgICBvbkNhbmNlbDogUHJvcFR5cGVzLmV2ZW50LFxuICAgICAgICBmaWVsZDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgbGVnZW5kOiBQcm9wVHlwZXMuYW55LFxuICAgICAgICB0ZW1wbGF0ZTogUHJvcFR5cGVzLnRlbXBsYXRlLFxuICAgICAgICB0cmFuc2l0aW9uOiBQcm9wVHlwZXMudHJhbnNpdGlvbixcbiAgICAgICAgYnV0dG9uc1RlbXBsYXRlOiBQcm9wVHlwZXMudGVtcGxhdGUsXG4gICAgICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5jb250ZW50XG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHRlbXBsYXRlOiAnRmllbGRTZXRUZW1wbGF0ZScsXG4gICAgICAgIGJ1dHRvbnNUZW1wbGF0ZTogJ0J1dHRvbnNUZW1wbGF0ZSdcbiAgICB9O1xuXG5cbiAgICByZW5kZXJCdXR0b25zKGJ1dHRvbnMpIHtcbiAgICAgICAgaWYgKCFidXR0b25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBCdXR0b25zVGVtcGxhdGUgPSB0aGlzLnByb3BzLmJ1dHRvbnNUZW1wbGF0ZTtcbiAgICAgICAgaWYgKCFidXR0b25zLmJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMgPSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gPEJ1dHRvbnNUZW1wbGF0ZSBrZXk9XCJidXR0b25zXCIgb25CdXR0b25DbGljaz17dGhpcy5wcm9wcy5vbkJ1dHRvbkNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xpY2t9ICB7Li4uYnV0dG9uc30vPlxuICAgIH1cblxuICAgIHJlbmRlckZpZWxkU2V0KGtleSkge1xuXG4gICAgICAgIGNvbnN0IHt0ZW1wbGF0ZSxjaGlsZHJlbiwgYnV0dG9ucywgY29udGVudCwgZmllbGQsIC4uLnJlc3R9ICA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IEZpZWxkU2V0VGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgcmV0dXJuIDxGaWVsZFNldFRlbXBsYXRlIGtleT17a2V5fSAgey4uLnJlc3R9IHsuLi5maWVsZH0gYnV0dG9ucz17dGhpcy5yZW5kZXJCdXR0b25zKGJ1dHRvbnMpfSBjb250ZW50PXs8UmVuZGVyQ29udGVudCBjb250ZW50PXtjb250ZW50fSAga2V5PXtgY29udGVudC0ke2tleX1gfS8+fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9GaWVsZFNldFRlbXBsYXRlPlxuXG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7VHJhbnNpdGlvbiwgLi4udHJhbnNpdGlvbn0gPSB0aGlzLnByb3BzLnRyYW5zaXRpb247XG4gICAgICAgICAgICByZXR1cm4gKDxUcmFuc2l0aW9uIHsuLi50cmFuc2l0aW9ufT5cbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJGaWVsZFNldCgndHJhbnNpdGlvbicpfVxuICAgICAgICAgICAgPC9UcmFuc2l0aW9uPik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHtDb25kaXRpb25hbCwgLi4uY29uZGl0aW9uYWx9ID0gdGhpcy5wcm9wcy5jb25kaXRpb25hbDtcbiAgICAgICAgICAgIHJldHVybiAoPENvbmRpdGlvbmFsIHsuLi5jb25kaXRpb25hbH0+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyRmllbGRTZXQoJ2NvbmRpdGlvbmFsJyl9XG4gICAgICAgICAgICA8L0NvbmRpdGlvbmFsPik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRmllbGRTZXQoKTtcbiAgICB9XG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvY29tcG9uZW50cy9GaWVsZFNldC5qc3hcbiAqKi8iLCIndXNlIHN0cmljdCdcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IE9iamVjdFR5cGUgZnJvbSAnLi4vdHlwZXMvT2JqZWN0LmpzeCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQgVW5pbmplY3RlZEZpZWxkIGZyb20gJy4uL2NvbXBvbmVudHMvRmllbGQuanN4JztcbmltcG9ydCBVbmluamVjdGVkRmllbGRTZXQgZnJvbSAnLi4vY29tcG9uZW50cy9GaWVsZFNldC5qc3gnO1xuZnVuY3Rpb24gZG9ubmVyKGQpIHtcbiAgICBkICYmIGQoKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpemFyZE1peGluIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgICAgICB2YWx1ZU1hbmFnZXI6IFByb3BUeXBlcy52YWx1ZU1hbmFnZXJcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgYnV0dG9uc1RlbXBsYXRlOiAnQnV0dG9uc1RlbXBsYXRlJyxcbiAgICAgICAgRmllbGQ6IFVuaW5qZWN0ZWRGaWVsZCxcbiAgICAgICAgRmllbGRTZXQ6IFVuaW5qZWN0ZWRGaWVsZFNldFxuICAgIH07XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBzY2hlbWE6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGJ1dHRvbnNUZW1wbGF0ZTogUHJvcFR5cGVzLnRlbXBsYXRlLFxuICAgICAgICBvblN1Ym1pdDogUHJvcFR5cGVzLmV2ZW50LFxuICAgICAgICBGaWVsZFNldDogUHJvcFR5cGVzLmluamVjdENsYXNzLFxuICAgICAgICBGaWVsZDogUHJvcFR5cGVzLmluamVjdENsYXNzXG4gICAgfTtcblxuICAgIHN0YXRlID0ge2NvbXBTdGF0ZTogMCwgcHJldlN0YXRlOiAwLCBtYXhTdGF0ZTogMCwgZG9uZTogZmFsc2V9O1xuXG4gICAgaGFuZGxlU3VibWl0KGUpIHtcbiAgICAgICAgLy8gICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcnMpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2Rpc2FibGVkOiBmYWxzZSwgZG9uZTogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2RvbmU6IHRydWV9KTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TdWJtaXQoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB9XG5cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBjb21wU3RhdGUgPSB0aGlzLnN0YXRlLmNvbXBTdGF0ZSxcbiAgICAgICAgICAgIG5leHRTdGF0ZSA9IGNvbXBTdGF0ZSArIDEsXG4gICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5wcm9wcy5zY2hlbWEuZmllbGRzZXRzW2NvbXBTdGF0ZV07XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2Rpc2FibGVkOiB0cnVlfSk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2Rpc2FibGVkOiBmYWxzZSwgZG9uZTogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbk5leHQoKHJlc3ApPT50aGlzLmdvKG5leHRTdGF0ZSwgcmVzcCksIG5leHRTdGF0ZSwgY3VycmVudCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7ZGlzYWJsZWQ6IGZhbHNlLCBkb25lOiBmYWxzZSwgbWF4U3RhdGU6IE1hdGgubWF4KG5leHRTdGF0ZSwgdGhpcy5zdGF0ZS5tYXhTdGF0ZSl9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcHJldmlvdXMoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBTdGF0ZSA9IHRoaXMuc3RhdGUuY29tcFN0YXRlLFxuICAgICAgICAgICAgbmV4dFN0YXRlID0gY29tcFN0YXRlIC0gMSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnByb3BzLnNjaGVtYS5maWVsZHNldHNbY29tcFN0YXRlXTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtkaXNhYmxlZDogdHJ1ZX0pO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vblByZXZpb3VzKChyZXNwKT0+dGhpcy5nbyhuZXh0U3RhdGUsIHJlc3ApLCBuZXh0U3RhdGUsIGN1cnJlbnQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7ZGlzYWJsZWQ6IGZhbHNlLCBkb25lOiBmYWxzZX0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgZ28ocG9zLCByZXNwKSB7XG4gICAgICAgIGlmIChyZXNwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7ZGlzYWJsZWQ6IGZhbHNlLCBkb25lOiBmYWxzZX0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0TmF2U3RhdGUocmVzcCA9PSBudWxsID8gcG9zIDogcmVzcCk7XG4gICAgfVxuXG4gICAgX3ZhbGlkYXRlKGRvbmUpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnZhbHVlTWFuYWdlci52YWxpZGF0ZVBhdGhzKHRoaXMucHJvcHMuc2NoZW1hLmZpZWxkc2V0c1t0aGlzLnN0YXRlLmNvbXBTdGF0ZV0uZmllbGRzLCBkb25lKVxuICAgIH1cblxuXG4gICAgaGFuZGxlT25DbGljayA9IChldnQpPT4ge1xuICAgICAgICBjb25zdCBzdGVwcyA9IHRoaXMucHJvcHMuc2NoZW1hLmZpZWxkc2V0cy5sZW5ndGgsIHZhbHVlID0gZXZ0LnRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlIDwgc3RlcHMgJiYgdmFsdWUgPD0gdGhpcy5zdGF0ZS5tYXhTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXROYXZTdGF0ZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cblxuICAgIGhhbmRsZUtleURvd24gPSAoZSk9PiB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY29tcFN0YXRlIDwgdGhpcy5wcm9wcy5zY2hlbWEuZmllbGRzZXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVCdG4oZSwgJ25leHQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQnRuKGUsICdzdWJtaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIGhhbmRsZVZhbGlkYXRlID0gKCkgPT4ge1xuICAgIH07XG5cblxuICAgIGNyZWF0ZUJ1dHRvbnMoc3RhdGUpIHtcbiAgICAgICAgbGV0IHtidXR0b25zfSA9IHRoaXMucHJvcHMuc2NoZW1hLmZpZWxkc2V0c1tzdGF0ZV07XG4gICAgICAgIGxldCByZXN0ID0ge307XG4gICAgICAgIGlmIChidXR0b25zKSB7XG4gICAgICAgICAgICBpZiAoYnV0dG9ucy5idXR0b25zKSB7XG4gICAgICAgICAgICAgICAgKHtidXR0b25zLCAuLi5yZXN0fSA9IGJ1dHRvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJ1dHRvbnMpKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9ucyA9IFtidXR0b25zXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1dHRvbnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHtuZXh0LCBwcmV2aW91cywgbGFzdCwgLi4ucmVzdEJ0bnN9ID0gdGhpcy5wcm9wcy5idXR0b25zO1xuICAgICAgICAgICAgcmVzdCA9IHJlc3RCdG5zO1xuICAgICAgICAgICAgY29uc3QgaXNGaXJzdCA9IHN0YXRlID09IDAsXG4gICAgICAgICAgICAgICAgaXNMYXN0ID0gKHN0YXRlICsgMSA9PT0gdGhpcy5wcm9wcy5zY2hlbWEuZmllbGRzZXRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucy5wdXNoKHtidXR0b25DbGFzczogdGhpcy5wcm9wcy5wcmV2aW91c0NsYXNzLCAuLi5wcmV2aW91c30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goe2J1dHRvbkNsYXNzOiB0aGlzLnByb3BzLmxhc3RDbGFzcywgcHJpbWFyeTp0cnVlLCAuLi5sYXN0fSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goe2J1dHRvbkNsYXNzOiB0aGlzLnByb3BzLm5leHRDbGFzcywgcHJpbWFyeTp0cnVlLCAuLi5uZXh0fSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7YnV0dG9uQ2xhc3M6IHRoaXMucHJvcHMucHJldmlvdXNDbGFzcywgLi4ucHJldmlvdXN9LCB7YnV0dG9uQ2xhc3M6IHRoaXMucHJvcHMubmV4dENsYXNzLCBwcmltYXJ5OnRydWUsICAuLi5uZXh0fSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgaWYgKGIuYWN0aW9uID09PSAnbmV4dCcgfHwgYi5hY3Rpb24gPT09ICdzdWJtaXQnKSB7XG4gICAgICAgICAgICAgICAgYi5kaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuc3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIGJ1dHRvbnNcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaGFuZGxlQnRuKGUsIGFjdGlvbiwgYnRuKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzdWJtaXQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3VibWl0KGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQWN0aW9uKHRoaXMuc3RhdGUuY29tcFN0YXRlLCBhY3Rpb24sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbiAgICBoYW5kbGVFbnRlciA9ICgpPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHthbmltYXRpbmc6IHRydWV9KVxuICAgIH07XG5cblxuICAgIGhhbmRsZUxlYXZlID0gKGRvbmUpPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHthbmltYXRpbmc6IGZhbHNlfSlcbiAgICAgICAgZG9uZSgpO1xuICAgIH07XG5cblxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdGVtcGxhdGVzL1dpemFyZE1peGluLmpzXG4gKiovIiwidmFyIGNvbnRleHQgPSByZXF1aXJlLmNvbnRleHQoJy4nLCBmYWxzZSwgL1xcLmpzKHgpPyQvKSwgYXBpID0ge307IC8vbWFrZSBzdXJlIHlvdSBoYXZlIHlvdXIgZGlyZWN0b3J5IGFuZCByZWdleCB0ZXN0IHNldCBjb3JyZWN0bHkhXG5jb250ZXh0LmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgayA9IGtleS5yZXBsYWNlKC9eXFwuXFwvKC4qKVxcLmpzKHgpPyQvLCAnJDEnKTtcbiAgICBhcGlba10gPSBjb250ZXh0KGtleSkuZGVmYXVsdDtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9pbmRleC5qc1xuICoqLyIsInZhciBtYXAgPSB7XG5cdFwiLi9BdXRvY29tcGxldGUuanN4XCI6IDMwMixcblx0XCIuL0NoZWNrYm94LmpzeFwiOiAzMDQsXG5cdFwiLi9DaGVja2JveGVzLmpzeFwiOiAzMDUsXG5cdFwiLi9Db2xsZWN0aW9uTWl4aW4uanN4XCI6IDMwNixcblx0XCIuL0NvbnRlbnQuanN4XCI6IDI2OSxcblx0XCIuL0NvbnRlbnRXcmFwcGVyLmpzeFwiOiAyNzMsXG5cdFwiLi9EYXRlLmpzeFwiOiAzMDcsXG5cdFwiLi9IaWRkZW4uanN4XCI6IDMwOCxcblx0XCIuL0xhenlUeXBlLmpzeFwiOiAzMDksXG5cdFwiLi9MaXN0LmpzeFwiOiAzMTAsXG5cdFwiLi9NaXhlZC5qc3hcIjogMzE1LFxuXHRcIi4vTnVtYmVyLmpzeFwiOiAzMTYsXG5cdFwiLi9PYmplY3QuanN4XCI6IDI5Nixcblx0XCIuL1Bhc3N3b3JkLmpzeFwiOiAzMTcsXG5cdFwiLi9SYWRpby5qc3hcIjogMzE4LFxuXHRcIi4vUmVzdHJpY3RlZC5qc3hcIjogMzE5LFxuXHRcIi4vUmVzdHJpY3RlZE1peGluLmpzXCI6IDMyMCxcblx0XCIuL1NlbGVjdC5qc3hcIjogMzIxLFxuXHRcIi4vU3Vic3RpdHV0ZU1peGluLmpzXCI6IDMyMixcblx0XCIuL1RleHQuanN4XCI6IDMyNSxcblx0XCIuL1RleHRBcmVhLmpzeFwiOiAzMjYsXG5cdFwiLi9pbmRleC5qc1wiOiAzMDBcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18od2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkpO1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0cmV0dXJuIG1hcFtyZXFdIHx8IChmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIikgfSgpKTtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMzAxO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3R5cGVzIG5vbnJlY3Vyc2l2ZSBcXC5qcyh4KT8kXG4gKiogbW9kdWxlIGlkID0gMzAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge25vb3AsIGFwcGx5RnVuY3MgfSBmcm9tICcuLi90dXRpbHMnO1xuaW1wb3J0IERvbSBmcm9tICcuLi9Eb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IGxpZmVjeWNsZSBmcm9tICcuLi9kZWNvcmF0b3JzL2xpZmVjeWNsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9jb21wbGV0ZSBleHRlbmRzIENvbXBvbmVudCB7XG5cblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIGlucHV0VHlwZTogUHJvcFR5cGVzLnR5cGUsXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMudmFsdWVFdmVudCxcbiAgICAgICAgb25TZWxlY3Q6IFByb3BUeXBlcy5ldmVudCxcbiAgICAgICAgbWluTGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBhdXRvU2VsZWN0U2luZ2xlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgdXNlc2hvd2luZzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIG1heElucHV0TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBpdGVtVGVtcGxhdGU6IFByb3BUeXBlcy50ZW1wbGF0ZSxcbiAgICAgICAgcHJvY2Vzc29yOiBQcm9wVHlwZXMucHJvY2Vzc29yLFxuICAgICAgICBzaG93aW5nOiBQcm9wVHlwZXMuY29udGVudCxcbiAgICAgICAgZm91bmRDbGFzczogUHJvcFR5cGVzLmNzc0NsYXNzLFxuICAgICAgICBub3RGb3VuZENsYXNzOiBQcm9wVHlwZXMuY3NzQ2xhc3MsXG4gICAgICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vcHRpb25zLFxuICAgICAgICBvbklucHV0Q2hhbmdlOiBQcm9wVHlwZXMuZXZlbnQsXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMuc3R5bGUsXG4gICAgICAgIHVybDogUHJvcFR5cGVzLmV4cHJlc3Npb25cblxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjb3VudHJ5OiAnVVMnLFxuICAgICAgICBsb2NhbGU6ICdlbl9VUycsXG4gICAgICAgIHVzZXNob3dpbmc6IHRydWUsXG4gICAgICAgIG1pbkxlbmd0aDogMSxcbiAgICAgICAgbWF4SW5wdXRMZW5ndGg6IDIwMCxcbiAgICAgICAgaXRlbVRlbXBsYXRlOiBcIkF1dG9jb21wbGV0ZUl0ZW1UZW1wbGF0ZVwiLFxuICAgICAgICBpbnB1dFR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdUZXh0JyxcbiAgICAgICAgICAgIHByb3BUeXBlczoge3ZhbHVlOiBQcm9wVHlwZXMuYW55fSxcbiAgICAgICAgICAgIGRlZmF1bHRQcm9wczoge3ZhbHVlOiAnJ31cbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc29yOiAnT3B0aW9uc1Byb2Nlc3NvcicsXG4gICAgICAgIHNob3dpbmc6ICdTZWFyY2hpbmcuLi4nLFxuICAgICAgICBpbnB1dDogJ2lucHV0JyxcbiAgICAgICAgaW5wdXRWYWx1ZTogJ2lucHV0J1xuICAgIH07XG5cbiAgICBzdGF0ZSA9IHtzdWdnZXN0aW9uczogW10sIHNob3dpbmc6IGZhbHNlLCBmb2N1czogLTF9O1xuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB0aGlzLl9wcm9jZXNzUHJvcHModGhpcy5wcm9wcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcywgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9wcm9jZXNzUHJvcHMocHJvcHMpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgaWYgKG5leHRTdGF0ZSAmJiBuZXh0U3RhdGUuc3VnZ2VzdGlvbnMgJiYgbmV4dFN0YXRlLnN1Z2dlc3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgc2V0VmFsdWUodikge1xuICAgICAgICB2YXIgcCA9IHRoaXMucHJvY2Vzc29yKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHAudmFsdWUodik7XG4gICAgICAgIHZhciBpbnB1dCA9IHAuZm9ybWF0KHYpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHYsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHNob3dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgc3VnZ2VzdGlvbnM6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBJbiB0aGUgZXZlbnQgdGhhdCB0aGUgdmFsdWUgZG9lcyBub3QgaGF2ZSB0aGUgbWV0YSBkYXRhIGZvciBkaXNwbGF5aW5nXG4gICAgICogV2Ugd2lsbCB0cnkgdG8gZmV0Y2ggdGhlIG9iamVjdCBhbmQgZm9ybWF0IGl0LlxuICAgICAqIEBwYXJhbSBwcm9wc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2Nlc3NQcm9wcyhwcm9wcykge1xuICAgICAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSB0aGlzLnN0YXRlLnZhbHVlKSB7XG4gICAgICAgICAgICAvL3NlZSBpZiB3ZSBjYW4gZ2V0IHRoZSBmb3JtYXR0ZWQgdmFsdWUgZnJvbSB0aGUgdmFsdWUsIG1heSBub3Qgd29yay5cbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHByb3BzLnByb2Nlc3Nvci5mb3JtYXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvL0l0IGRpZG4ndCBmb3JtYXQgdG8gYSB2YWx1ZSwgZ28gZmV0Y2ggaXQgc28gd2UgY2FuIGRpc3BsYXkgaXQuXG4gICAgICAgICAgICAgICAgcHJvcHMucHJvY2Vzc29yLmZldGNoKHByb3BzLnVybCwgdmFsdWUsIHRoaXMsIChlLCBvKT0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gJiYgby5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUob1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uczogbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93aW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2lucHV0LCB2YWx1ZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZSBjb3VsZCBiZSBjYWxsZWQgd2hlbiBhIHVzZXIgaGFzIG5vdCBzZWxlY3RlZCBhIHZhbHVlLlxuICAgICAqXG4gICAgICogSWYgdGhlaXIgaXMgYSBzZWxlY3RlZCB2YWx1ZSBhbmQgaW5wdXQgZXF1YWxzIGl0cyBsYWJlbCBzZWxlY3QgaXQuXG4gICAgICogU28gaWYgdGhlcmUgaXMgb25seSAxIHNlbGVjdGlvbiBzZWxlY3QgaXQuXG4gICAgICogSWZcbiAgICAgKi9cbiAgICBoaWRlID0gKHNlbGVjdFZhbHVlKT0+IHtcbiAgICAgICAgdmFyIHtzZWxlY3RlZCwgaW5wdXQsIHN1Z2dlc3Rpb25zLCBmb2N1c30gPSB0aGlzLnN0YXRlLCBpID0gMCwgbCwgb3B0aW9ucywgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgc3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9ucyB8fCBbXTtcbiAgICAgICAgaWYgKHNlbGVjdFZhbHVlKSB7XG5cblxuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmdldFByb2Nlc3NvcigpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdFZhbHVlICYmIGZvY3VzID4gLTEpIHtcblxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gc3VnZ2VzdGlvbnNbZm9jdXNdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PSBudWxsIHx8IGlucHV0LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc2VsZWN0ZWQgfHwgaW5wdXQgIT09IHNlbGVjdGVkLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1Z2dlc3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHN1Z2dlc3Rpb25zWzBdO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IHNlbGVjdGVkLmxhYmVsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHN1Z2dlc3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBsID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHQubGFiZWwgPT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBvcHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBvcHQubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAhPT0gdGhpcy5zdGF0ZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25TZWxlY3Qoc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVmFsaWRhdGUoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQudmFsLCB0aGlzLnByb3BzLnZhbHVlLCB0aGlzLnByb3BzLm5hbWUsIHRoaXMucHJvcHMucGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7c3VnZ2VzdGlvbnM6IFtdLCBzZWxlY3RlZCwgaW5wdXQsIHNob3dpbmc6IGZhbHNlLCBmb2N1czogLTF9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3Nob3dpbmc6IGZhbHNlLCBmb2N1czogLTEsIHN1Z2dlc3Rpb25zOiBbXX0sIHRoaXMudW4pXG4gICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgIHRoaXMucHJvcHMub25CbHVyKCk7XG4gICAgfTtcblxuXG4gICAgYmluZERvY3VtZW50ID0gKCk9PiB7XG4gICAgICAgIGlmICh0aGlzLl9ib3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnQoKTtcbiAgICAgICAgdGhpcy5fYm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9XG4gICAgICAgICAgICBEb20ubGlzdGVuKHRoaXMsICdjbGljaycsIHRoaXMuaGFuZGxlRG9jdW1lbnRDbGljayk7XG5cbiAgICAgICAgdGhpcy5fb25Eb2N1bWVudEtleXVwTGlzdGVuZXIgPVxuICAgICAgICAgICAgRG9tLmxpc3Rlbih0aGlzLCAna2V5dXAnLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5VXApO1xuXG4gICAgICAgIHRoaXMuX29uRG9jdW1lbnRLZXlkb3duTGlzdGVuZXIgPVxuICAgICAgICAgICAgRG9tLmxpc3Rlbih0aGlzLCAna2V5cHJlc3MnLCB0aGlzLmhhbmRsZURvY3VtZW50RW50ZXIpO1xuICAgIH07XG5cbiAgICBAbGlmZWN5Y2xlKFwiY29tcG9uZW50V2lsbFVubW91bnRcIilcbiAgICB1bmJpbmREb2N1bWVudCgpIHtcbiAgICAgICAgdGhpcy5fYm91bmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX29uRG9jdW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRvY3VtZW50Q2xpY2tMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vbkRvY3VtZW50S2V5dXBMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fb25Eb2N1bWVudEtleXVwTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29uRG9jdW1lbnRLZXlkb3duTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRG9jdW1lbnRLZXlkb3duTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGhhbmRsZURvY3VtZW50RW50ZXIgPSAoZSk9PiB7XG5cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgJiYgdGhpcy5zdGF0ZS5zdWdnZXN0aW9ucyAmJiB0aGlzLnN0YXRlLnN1Z2dlc3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIGhhbmRsZURvY3VtZW50S2V5VXAgPSAoZSk9PiB7XG5cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBoYW5kbGVEb2N1bWVudENsaWNrID0gKGUpPT4ge1xuICAgICAgICAvLyBJZiB0aGUgY2xpY2sgb3JpZ2luYXRlZCBmcm9tIHdpdGhpbiB0aGlzIGNvbXBvbmVudFxuICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAgICAgaWYgKERvbS5pc05vZGVJblJvb3QoZS50YXJnZXQsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgIH07XG5cblxuICAgIHByb2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMucHJvY2Vzc29yO1xuICAgIH1cblxuICAgIGhhbmRsZVN1Z2dlc3Rpb25DbGljayA9IChvKT0+IHtcbiAgICAgICAgdGhpcy5vblNlbGVjdChvKTtcbiAgICB9O1xuXG4gICAgb25TZWxlY3QgPSAobyk9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uU2VsZWN0KG8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gdGhpcy5wcm9jZXNzb3IoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcC52YWx1ZShvKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2UodmFsdWUpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gcC5mb3JtYXQobyk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzdWdnZXN0aW9uczogW10sXG4gICAgICAgICAgICAgICAgc2hvd2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9jdXM6IC0xLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBvLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGlucHV0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfaGFuZGxlRGlzcGF0Y2ggPSAoaW5wdXQpPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZldGNoICYmIHRoaXMuX2ZldGNoLmNhbmNlbCkge1xuICAgICAgICAgICAgdGhpcy5fZmV0Y2guY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9mZXRjaCA9IHRoaXMucHJvY2Vzc29yKCkuZmV0Y2godGhpcy5wcm9wcy51cmwsIGlucHV0LCB0aGlzLCAoZXJyLCBzdWdnZXN0aW9ucykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5hdXRvU2VsZWN0U2luZ2xlICYmIHN1Z2dlc3Rpb25zICYmIHN1Z2dlc3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uU2VsZWN0KHN1Z2dlc3Rpb25zWzBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25JbnB1dENoYW5nZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uczogc3VnZ2VzdGlvbnMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIHNob3dpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIGhhbmRsZUtleVVwID0gKGUpPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbktleVVwKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uS2V5VXAuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLnN0YXRlLmZvY3VzLCBzID0gdGhpcy5zdGF0ZS5zdWdnZXN0aW9ucztcbiAgICAgICAgaWYgKHMgJiYgcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkgfHwgZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnVXAnOlxuICAgICAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb2N1cyA9IE1hdGgubWF4KC0xLCBmb2N1cyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICBjYXNlICdEb3duJzpcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXMgPSBNYXRoLm1pbihzLmxlbmd0aCwgZm9jdXMgKyAxKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1Z2dlc3Rpb25DbGljayhzW01hdGgubWF4KHRoaXMuc3RhdGUuZm9jdXMsIDApXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtzdWdnZXN0aW9uczogW10sIHNob3dpbmc6IGZhbHNlLCBmb2N1czogLTF9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgLy9lLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7Zm9jdXN9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVDaGFuZ2UgPSAoZSkgPT4ge1xuICAgICAgICB0aGlzLl9oYW5kbGVEaXNwYXRjaChlLnRhcmdldC52YWx1ZSk7XG4gICAgfTtcblxuXG4gICAgaGFuZGxlUGFzdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIGl0ZW1zID0gZXZlbnQuY2xpcGJvYXJkRGF0YSAmJiBldmVudC5jbGlwYm9hcmREYXRhLml0ZW1zO1xuICAgICAgICBpdGVtcyAmJiBpdGVtc1swXSAmJiBpdGVtc1swXS5nZXRBc1N0cmluZygoaW5wdXQpPT4ge1xuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtpbnB1dCwgc3VnZ2VzdGlvbnM6IFtdLCBzaG93aW5nOiBmYWxzZX0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICBoYW5kbGVCbHVyID0gKGV2ZW50KT0+IHtcbiAgICAgICAgdmFyIHN1Z2dlc3Rpb25zID0gdGhpcy5zdGF0ZS5zdWdnZXN0aW9ucyB8fCBbXTtcbiAgICAgICAgaWYgKHN1Z2dlc3Rpb25zLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5zdGF0ZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWdnZXN0aW9uQ2xpY2soc3VnZ2VzdGlvbnNbTWF0aC5tYXgoMCwgdGhpcy5zdGF0ZS5mb2N1cyldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BzLm9uVmFsaWRhdGUoZXZlbnQpO1xuICAgICAgICB0aGlzLnByb3BzLm9uQmx1cihldmVudCk7XG4gICAgfTtcblxuICAgIHJlbmRlclN1Z2dlc3Rpb25zKCkge1xuICAgICAgICB2YXIgc3VnZ2VzdGlvbnMgPSB0aGlzLnN0YXRlLnN1Z2dlc3Rpb25zIHx8IFtdO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zaG93aW5nID09PSBmYWxzZSB8fCBzdWdnZXN0aW9ucy5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHtmb2N1cywgaW5wdXR9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIHByb2Nlc3NvciA9IHRoaXMucHJvY2Vzc29yKCk7XG4gICAgICAgIHZhciBoYW5kbGVTdWdnZXN0aW9uQ2xpY2sgPSB0aGlzLmhhbmRsZVN1Z2dlc3Rpb25DbGljaztcbiAgICAgICAgdmFyIENvbXBsZXRlSXRlbSA9IHRoaXMucHJvcHMuaXRlbVRlbXBsYXRlO1xuICAgICAgICByZXR1cm4gPHVsIGNsYXNzTmFtZT17dGhpcy5wcm9wcy5saXN0R3JvdXBDbGFzc30+XG4gICAgICAgICAgICB7c3VnZ2VzdGlvbnMubWFwKChpdGVtLCBpKSA9PiA8Q29tcGxldGVJdGVtXG4gICAgICAgICAgICAgICAga2V5PXtpdGVtLnZhbH1cbiAgICAgICAgICAgICAgICBmb2N1cz17Zm9jdXMgPT09IGl9XG4gICAgICAgICAgICAgICAgdmFsdWU9e2lucHV0fVxuICAgICAgICAgICAgICAgIHJlZj17XCJpdGVtX1wiK2l9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yPXtwcm9jZXNzb3J9XG4gICAgICAgICAgICAgICAgb25TZWxlY3Q9e2hhbmRsZVN1Z2dlc3Rpb25DbGlja31cbiAgICAgICAgICAgICAgICBkYXRhPXtpdGVtfS8+KX08L3VsPlxuXG5cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gdGhpcy5zdGF0ZS5zdWdnZXN0aW9ucyB8fCBbXTtcbiAgICAgICAgY29uc3Qge2ZvdW5kQ2xhc3MsICBuYW1lc3BhY2VDbGFzcywgaW5wdXRUeXBlLCBpZCwgaW5wdXQsIG5vdEZvdW5kQ2xhc3N9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgLy8gcHJvcHMub25DaGFuZ2UgPSB0aGlzOjp0aGlzLmhhbmRsZUNoYW5nZTtcbiAgICAgICAgY29uc3QgaW5wdXRQcm9wcyA9IHtcbiAgICAgICAgICAgIG9uUGFzdGU6IHRoaXM6OnRoaXMuaGFuZGxlUGFzdGUsXG4gICAgICAgICAgICBvbktleURvd246IHRoaXM6OnRoaXMuaGFuZGxlS2V5VXAsXG4gICAgICAgICAgICBvbkJsdXI6IHRoaXM6OnRoaXMuaGFuZGxlQmx1cixcbiAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzOjp0aGlzLmhhbmRsZUNoYW5nZSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmlucHV0LFxuICAgICAgICAgICAgaWRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIElucHV0ID0gaW5wdXRUeXBlO1xuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2Ake25hbWVzcGFjZUNsYXNzfSAkeyhzdWdnZXN0aW9ucy5sZW5ndGggPiAwID8gZm91bmRDbGFzcyA6IG5vdEZvdW5kQ2xhc3MpfWB9PlxuICAgICAgICAgICAgPElucHV0IHsuLi5pbnB1dFByb3BzfSByZWY9XCJpbnB1dFwiLz5cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlclN1Z2dlc3Rpb25zKCl9XG4gICAgICAgIDwvZGl2PlxuICAgIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9BdXRvY29tcGxldGUuanN4XG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEV2ZW50TGlzdGVuZXIsXG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBpc05vZGVJblJvb3QsXG4gICAgbGlzdGVuXG5cbn1cbi8qKlxuICogbGlzdGVuXG4gKi9cbmZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgZnVuYykge1xuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3Rlbihvd25lckRvY3VtZW50KG5vZGUpLCBldmVudCwgZnVuYyk7XG59XG4vKipcbiAqIEdldCBlbGVtZW50cyBvd25lciBkb2N1bWVudFxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8SFRNTEVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICovXG5mdW5jdGlvbiBvd25lckRvY3VtZW50KGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHZhciBlbGVtID0gUmVhY3RET00uZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgbm9kZSBpcyB3aXRoaW5cbiAqIGEgcm9vdCBub2RlcyB0cmVlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc05vZGVJblJvb3Qobm9kZSwgcm9vdCkge1xuICAgIG5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZShub2RlKSwgcm9vdCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHJvb3QpO1xuICAgIHJldHVybiBfaXNOb2RlSW5Sb290KG5vZGUsIHJvb3QpO1xufVxuZnVuY3Rpb24gX2lzTm9kZUluUm9vdChub2RlLCByb290KXtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9Eb20uanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBpbnB1dENsYXNzTmFtZSA9ICcgJztcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMudmFsdWVFdmVudCxcbiAgICAgICAgY2hlY2tlZENsYXNzOiBQcm9wVHlwZXMuY3NzQ2xhc3MsXG4gICAgICAgIG9uQmx1cjogUHJvcFR5cGVzLmNoYW5nZVZhbGlkYXRlXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICAgIGNoZWNrZWRDbGFzczogJydcbiAgICB9O1xuXG5cbiAgICBoYW5kbGVDaGFuZ2UoZSkge1xuICAgICAgICBjb25zdCB7dmFsdWV9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgLy9CbHVyIGRvZXMgbm90IGdldCBjYWxsZWQgb24gY2hlY2tib3gsIHNvIHdlIGRvIGNoZWNrIG9uIGNoYW5nZSBhbnl3YXlzLlxuICAgICAgICBjb25zdCB2YWwgPSBlLnRhcmdldC5jaGVja2VkID8gdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UgPyB0cnVlIDogdmFsdWUgOiB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09IHRydWUgPyBmYWxzZSA6IG51bGw7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodmFsKTtcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7b25DaGFuZ2UsIHZhbHVlLCBjbGFzc05hbWUsIGNoZWNrZWRDbGFzcywgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBjb25zdCBjaGVja2VkID0gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgPyB2YWx1ZSA6IHZhbHVlID09IG51bGwgPyB0aGlzLnByb3BzLmNoZWNrZWQgOiB0cnVlO1xuICAgICAgICByZXR1cm4gPGlucHV0IHsuLi5wcm9wc30gdmFsdWU9e3ZhbHVlfSBjbGFzc05hbWU9e2NsYXNzTmFtZSsnICcrKGNoZWNrZWQgPyBjaGVja2VkQ2xhc3MgOiAnJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfSBvbkNoYW5nZT17dGhpczo6dGhpcy5oYW5kbGVDaGFuZ2V9Lz5cbiAgICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3R5cGVzL0NoZWNrYm94LmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnXG5pbXBvcnQge3BhdGgsIEZSRUVaRV9BUlIgYXMgb3B0aW9uc30gZnJvbSAnLi4vdHV0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hlY2tib3hlcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLy9vdmVycmlkZSBhZGRlZCBpbnB1dCBDbGFzcyBOYW1lcy5cbiAgICBzdGF0aWMgaW5wdXRDbGFzc05hbWUgPSAnICc7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLnZhbHVlRXZlbnQsXG4gICAgICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vcHRpb25zLFxuICAgICAgICBpdGVtOiBQcm9wVHlwZXMudHlwZSxcbiAgICAgICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgaXRlbVRlbXBsYXRlOiBQcm9wVHlwZXMudGVtcGxhdGUsXG4gICAgICAgIGdyb3VwVGVtcGxhdGU6IFByb3BUeXBlcy50ZW1wbGF0ZSxcbiAgICAgICAgcGF0aDogUHJvcFR5cGVzLnBhdGgsXG4gICAgICAgIGRhdGFUeXBlOiBQcm9wVHlwZXMuZGF0YVR5cGUsXG4gICAgICAgIG9uQmx1cjogUHJvcFR5cGVzLmNoYW5nZVZhbGlkYXRlXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGl0ZW06ICdUZXh0JyxcbiAgICAgICAgaXRlbVRlbXBsYXRlOiAnQ2hlY2tib3hlc1RlbXBsYXRlJyxcbiAgICAgICAgZ3JvdXBUZW1wbGF0ZTogJ0NoZWNrYm94ZXNHcm91cFRlbXBsYXRlJyxcbiAgICAgICAgLy9tYWtlIHRoZSB2YWx1ZSBhbiBhcnJheSByZWdhcmRsZXNzIG9mIGlucHV0XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBwcm9jZXNzb3I6ICdBcnJheVByb2Nlc3NvcidcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YVR5cGU6IFwiY2hlY2tib3hcIlxuICAgIH07XG5cblxuICAgIGhhbmRsZUNoZWNrQ2hhbmdlKGUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGF0YVR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZS50YXJnZXQuY2hlY2tlZCA/IGUudGFyZ2V0LnZhbHVlIDogbnVsbCk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQmx1cigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSB0aGlzLnByb3BzLnZhbHVlLmNvbmNhdCgpO1xuICAgICAgICBjb25zdCBpZHggPSBuZXdWYWx1ZXMuaW5kZXhPZihlLnRhcmdldC52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGUudGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKVxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlcy5wdXNoKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpZHggPiAtMSlcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG5ld1ZhbHVlcyk7XG4gICAgICAgIHRoaXMucHJvcHMub25CbHVyKCk7XG5cbiAgICB9XG5cblxuICAgIF9jcmVhdGVDaGVja2JveChvcHRpb24sIGluZGV4LCBncm91cCkge1xuXG4gICAgICAgIGNvbnN0IENoZWNrYm94VGVtcGxhdGUgPSB0aGlzLnByb3BzLml0ZW1UZW1wbGF0ZTtcbiAgICAgICAgY29uc3QgaWQgPSBwYXRoKHRoaXMucHJvcHMucGF0aCwgZ3JvdXAsIGluZGV4KTtcbiAgICAgICAgbGV0IHt2YWwsIGxhYmVsSFRNTCwgbGFiZWx9ID0gb3B0aW9uO1xuICAgICAgICB2YWwgPSB2YWwgPT0gbnVsbCA/IGxhYmVsIHx8IGxhYmVsSFRNTCA6IHZhbDtcbiAgICAgICAgbGFiZWwgPSBsYWJlbEhUTUwgfHwgbGFiZWw7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgICAgY29uc3QgbGFiZWxDb250ZW50ID0gbGFiZWwgPyA8c3BhbiBkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbDpsYWJlbH19Lz4gOiB2YWw7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICBvbkNoYW5nZTogdGhpczo6dGhpcy5oYW5kbGVDaGVja0NoYW5nZSxcbiAgICAgICAgICAgIG5hbWU6IGdyb3VwLFxuICAgICAgICAgICAgY2hlY2tlZDogdmFsdWUgPyAhIX52YWx1ZS5pbmRleE9mKHZhbCkgOiBmYWxzZSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKDxDaGVja2JveFRlbXBsYXRlIGtleT17YGNoZWNrYm94LSR7aW5kZXh9LSR7Z3JvdXB9YH0gbGFiZWw9e2xhYmVsQ29udGVudH0gdHlwZT1cImNoZWNrYm94XCIgey4uLm9wdHN9PlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9e3RoaXMucHJvcHMudHlwZX0gey4uLm9wdHN9Lz5cbiAgICAgICAgPC9DaGVja2JveFRlbXBsYXRlPik7XG5cbiAgICB9XG5cbiAgICBfY3JlYXRlR3JvdXAob3B0aW9uLCBpbmRleCwgZ3JvdXApIHtcbiAgICAgICAgY29uc3Qge0NoZWNrYm94ZXMsIGdyb3VwVGVtcGxhdGUsIG5hbWUsIHZhbHVlLCAuLi5yZXN0fSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IEdyb3VwVGVtcGxhdGUgPSBncm91cFRlbXBsYXRlO1xuICAgICAgICByZXR1cm4gKDxHcm91cFRlbXBsYXRlIGtleT17YGNoZWNrYm94LWdyb3VwLSR7aW5kZXh9LSR7b3B0aW9uLmdyb3VwfWB9IGxlZ2VuZD17b3B0aW9uLmxlZ2VuZCB8fCBvcHRpb24uZ3JvdXB9PlxuICAgICAgICAgICAge3RoaXMubWFrZU9wdGlvbnMob3B0aW9uLm9wdGlvbnMsIGdyb3VwICsgJy0nICsgaW5kZXgpfVxuICAgICAgICA8L0dyb3VwVGVtcGxhdGU+KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgY2hlY2tib3ggbGlzdCBIVE1MXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBPcHRpb25zIGFzIGEgc2ltcGxlIGFycmF5IGUuZy4gWydvcHRpb24xJywgJ29wdGlvbjInXVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG9yIGFzIGFuIGFycmF5IG9mIG9iamVjdHMgZS5nLiBbe3ZhbDogNTQzLCBsYWJlbDogJ1RpdGxlIGZvciBvYmplY3QgNTQzJ31dXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBIVE1MXG4gICAgICovXG4gICAgbWFrZU9wdGlvbnMoYXJyYXksIGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKG9wdGlvbiwgaW5kZXgpPT4gb3B0aW9uLmdyb3VwID8gdGhpcy5fY3JlYXRlR3JvdXAob3B0aW9uLCBpbmRleCwgZ3JvdXApIDogdGhpcy5fY3JlYXRlQ2hlY2tib3gob3B0aW9uLCBpbmRleCwgZ3JvdXApKTtcbiAgICB9XG5cblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfT57dGhpcy5tYWtlT3B0aW9ucyh0aGlzLnByb3BzLm9wdGlvbnMsIHRoaXMucHJvcHMucGF0aCl9PC9kaXY+XG4gICAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9DaGVja2JveGVzLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBWYWx1ZU1hbmFnZXIgZnJvbSAnLi4vVmFsdWVNYW5hZ2VyJztcbmltcG9ydCB7aXNTdHJpbmcsIHBhdGgsY2xvbmUsIHJldHVybkZpcnN0LCBGUkVFWkVfQVJSLCBGUkVFWkVfT0JKfSBmcm9tICcuLi90dXRpbHMnO1xuaW1wb3J0IFVuaW5qZWN0ZWRPYmplY3RUeXBlIGZyb20gJy4vT2JqZWN0LmpzeCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQgbWFwIGZyb20gJ2xvZGFzaC9jb2xsZWN0aW9uL21hcCc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnbG9kYXNoL29iamVjdC9kZWZhdWx0cyc7XG5cbmZ1bmN0aW9uIG1ha2VFZGl0UGlkKHBhdGgsIHBpZCkge1xuICAgIHJldHVybiAnQCcgKyBwYXRoLnJlcGxhY2UoL1xcLi9nLCAnQCcpICsgKHBpZCAhPSBudWxsID8gYEAke3BpZH1gIDogJycpO1xufVxuZnVuY3Rpb24gd3JhcEZ1bmModmFsdWUsIGtleSkge1xuICAgIHJldHVybiB7dmFsdWUsIGtleTogJycgKyBrZXl9XG59XG5mdW5jdGlvbiByZW1vdmUob2JqLCBrZXkpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqLnNwbGljZShrZXksIDEpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xsZWN0aW9uTWl4aW4gZXh0ZW5kcyBDb21wb25lbnQge1xuXG5cbiAgICBzdGF0aWMgaW5wdXRDbGFzc05hbWUgPSAnbGlzdC1lZGl0b3InO1xuXG4gICAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHt2YWx1ZU1hbmFnZXI6IFByb3BUeXBlcy52YWx1ZU1hbmFnZXJ9O1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy52YWx1ZUV2ZW50LFxuICAgICAgICBwYXRoOiBQcm9wVHlwZXMucGF0aCxcbiAgICAgICAgc2hvd0FkZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNhbkVkaXQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBjYW5SZW9yZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY2FuRGVsZXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgY2FuQWRkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgc2hvd0tleTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGlubGluZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGxhYmVsS2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBpdGVtVHlwZTogUHJvcFR5cGVzLnR5cGVEZXNjcmlwdGlvbixcbiAgICAgICAgY3JlYXRlVGVtcGxhdGU6IFByb3BUeXBlcy50ZW1wbGF0ZSxcbiAgICAgICAgYnV0dG9uVGVtcGxhdGU6IFByb3BUeXBlcy50ZW1wbGF0ZSxcbiAgICAgICAgaXRlbVRlbXBsYXRlOiBQcm9wVHlwZXMudGVtcGxhdGUsXG4gICAgICAgIGNvbnRlbnRUZW1wbGF0ZTogUHJvcFR5cGVzLnRlbXBsYXRlLFxuICAgICAgICBidXR0b25zOiBQcm9wVHlwZXMuYnV0dG9ucyxcbiAgICAgICAgYWRkQnV0dG9uOiBQcm9wVHlwZXMuYnV0dG9uLFxuICAgICAgICBsaXN0Q29udGFpbmVyQ2xhc3NOYW1lOiBQcm9wVHlwZXMuY3NzQ2xhc3MsXG4gICAgICAgIE9iamVjdFR5cGU6IFByb3BUeXBlcy5pbmplY3RDbGFzcyxcbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy52YWx1ZSxcbiAgICAgICAgdGl0bGU6IFByb3BUeXBlcy50aXRsZVxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjcmVhdGVUZW1wbGF0ZTogJ0NvbGxlY3Rpb25DcmVhdGVUZW1wbGF0ZScsXG4gICAgICAgIGJ1dHRvblRlbXBsYXRlOiAnQnV0dG9uVGVtcGxhdGUnLFxuICAgICAgICBpdGVtVGVtcGxhdGU6ICdMaXN0SXRlbVRlbXBsYXRlJyxcbiAgICAgICAgY29udGVudFRlbXBsYXRlOiBcIkNvbnRlbnRJdGVtVGVtcGxhdGVcIixcbiAgICAgICAgc2hvd0tleTogZmFsc2UsXG4gICAgICAgIHNob3dBZGQ6IGZhbHNlLFxuICAgICAgICBpdGVtVHlwZToge1xuICAgICAgICAgICAgdHlwZTogJ1RleHQnXG4gICAgICAgIH0sXG4gICAgICAgIGFkZEJ1dHRvbjoge1xuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFkZFwiLFxuICAgICAgICAgICAgXCJjbGFzc05hbWVcIjogXCJidG4gYnRuLWRlZmF1bHQgYnRuLWFkZFwiXG4gICAgICAgIH0sXG4gICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgIGJ1dHRvbnNDbGFzczogJ2J0bi1ncm91cCBwdWxsLXJpZ2h0JyxcbiAgICAgICAgICAgIGJ1dHRvbnM6IFt7bGFiZWw6ICdDYW5jZWwnLCBhY3Rpb246ICdjYW5jZWwnLCBidXR0b25DbGFzczogJ2J0biBidG4tZGVmYXVsdCd9XG4gICAgICAgICAgICAgICAgLCB7bGFiZWw6ICdTYXZlJywgdHlwZTogJ3N1Ym1pdCcsIGFjdGlvbjogJ3N1Ym1pdCcsIGJ1dHRvbkNsYXNzOiAnYnRuLXByaW1hcnkgYnRuJ31dXG4gICAgICAgIH0sXG4gICAgICAgIE9iamVjdFR5cGU6IFVuaW5qZWN0ZWRPYmplY3RUeXBlXG4gICAgfTtcbiAgICBzdGF0ZSA9IHtcbiAgICAgICAgc2hvd0FkZDogdGhpcy5wcm9wcy5zaG93QWRkLFxuICAgICAgICB3cmFwcGVkOiB0aGlzLndyYXBWYWx1ZXModGhpcy5wcm9wcy52YWx1ZSlcbiAgICB9O1xuXG4gICAgd3JhcFZhbHVlcyh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG1hcCh2YWx1ZXMsIHdyYXBGdW5jKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdGhpcy5wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShwcm9wcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge3Nob3dBZGR9ID0gcHJvcHM7XG4gICAgICAgIGlmIChzaG93QWRkICE9PSB0aGlzLnByb3BzLnNob3dBZGQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3Nob3dBZGR9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVud3JhcCh0aGlzLnN0YXRlLndyYXBwZWQpO1xuICAgIH1cblxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3dyYXBwZWQ6IHRoaXMud3JhcFZhbHVlcyh2YWx1ZSl9KTtcbiAgICB9XG5cbiAgICBzZXRFcnJvcnMoZXJyb3JzKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2Vycm9yc30pO1xuICAgIH1cblxuICAgIGhhbmRsZU1vdmVVcCA9IChwb3MsIHZhbCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnN0YXRlLndyYXBwZWQsIG92YWwgPSB2YWx1ZXMgJiYgdmFsdWVzLmNvbmNhdCgpO1xuICAgICAgICB2YWx1ZXMuc3BsaWNlKE1hdGgubWF4KHBvcyAtIDEsIDApLCAwLCB2YWx1ZXMuc3BsaWNlKHBvcywgMSlbMF0pO1xuICAgICAgICB0aGlzLmNoYW5nZVZhbHVlKHZhbHVlcywgb3ZhbCk7XG4gICAgfTtcblxuICAgIGhhbmRsZU1vdmVEb3duID0gKHBvcywgdmFsKT0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5zdGF0ZS53cmFwcGVkLCBvdmFsID0gdmFsdWVzICYmIHZhbHVlcy5jb25jYXQoKTtcbiAgICAgICAgdmFsdWVzLnNwbGljZShNYXRoLm1pbihwb3MgKyAxLCB2YWx1ZXMubGVuZ3RoKSwgMCwgdmFsdWVzLnNwbGljZShwb3MsIDEpWzBdKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZSh2YWx1ZXMsIG92YWwpO1xuXG4gICAgfTtcblxuICAgIGhhbmRsZURlbGV0ZSA9IChwb3MsIHZhbCwgcGlkKT0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5zdGF0ZS53cmFwcGVkLCBvdmFsID0gdmFsdWVzICYmIHZhbHVlcy5jb25jYXQoKTtcbiAgICAgICAgdmFsdWVzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICB0aGlzLmNoYW5nZVZhbHVlKHZhbHVlcywgb3ZhbCk7XG4gICAgfTtcblxuXG4gICAgY2hhbmdlVmFsdWUgPSAobmV3VmFsdWUsIG9sZFZhbHVlKT0+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy51bndyYXAobmV3VmFsdWUpKSAhPT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgd3JhcHBlZDogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgc2hvd0FkZDogdGhpcy5wcm9wcy5zaG93QWRkLFxuICAgICAgICAgICAgICAgIHNob3dFZGl0OiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaGFuZGxlQWRkQnRuKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuY3JlYXRlUGlkKClcbiAgICAgICAgdGhpcy5jb250ZXh0LnZhbHVlTWFuYWdlci51cGRhdGUobWFrZUVkaXRQaWQodGhpcy5wcm9wcy5wYXRoLCBrZXkpLCB7XG4gICAgICAgICAgICBrZXlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3Nob3dBZGQ6IHRydWUsIGVkaXRQaWQ6IGtleX0pO1xuICAgIH07XG5cbiAgICBoYW5kbGVFZGl0ID0gKHBvcywgdmFsLCBwaWQpID0+IHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnZhbHVlTWFuYWdlci51cGRhdGUobWFrZUVkaXRQaWQodGhpcy5wcm9wcy5wYXRoLCBwaWQpLCB7XG4gICAgICAgICAgICB2YWx1ZTogY2xvbmUodmFsKSxcbiAgICAgICAgICAgIGtleTogcGlkXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNob3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0VkaXQ6IHRydWUsXG4gICAgICAgICAgICBlZGl0UGlkOiBwaWRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG4gICAgaGFuZGxlQ2FuY2VsQWRkID0gKGUpID0+IHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3Nob3dBZGQ6IHRoaXMucHJvcHMuc2hvd0FkZCwgc2hvd0VkaXQ6IGZhbHNlfSk7XG4gICAgfTtcblxuICAgIGhhbmRsZUJ0bkNsaWNrID0gKGUsIGFjdGlvbik9PiB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChhY3Rpb24gPT0gJ3N1Ym1pdCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3VibWl0KGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudmFsdWVNYW5hZ2VyLnVwZGF0ZShtYWtlRWRpdFBpZCh0aGlzLnByb3BzLnBhdGgsIHRoaXMuc3RhdGUuZWRpdFBpZCkpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2hvd0FkZDogdGhpcy5wcm9wcy5zaG93QWRkLFxuICAgICAgICAgICAgICAgIHNob3dFZGl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlZGl0UGlkOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVTdWJtaXQgPSAoZSk9PiB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIge3ZhbHVlTWFuYWdlcn0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcmlnS2V5ID0gbWFrZUVkaXRQaWQodGhpcy5wcm9wcy5wYXRoLCB0aGlzLnN0YXRlLmVkaXRQaWQpO1xuICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB2YWx1ZU1hbmFnZXIucGF0aChvcmlnS2V5KSB8fCB7fTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gb3JpZ1ZhbHVlXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IHZhbHVlTWFuYWdlci5nZXRFcnJvcnMoKTtcblxuICAgICAgICBpZiAoZXJyb3JzID09IG51bGwgfHwgT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UGF0aCA9IHBhdGgodGhpcy5wcm9wcy5wYXRoLCBrZXkpO1xuICAgICAgICAgICAgdmFyIGNsb25lZFZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZSA9PSBudWxsID8gdGhpcy5jcmVhdGVEZWZWYWx1ZSgpIDogY2xvbmUodGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvcHMub25TdWJtaXQgfHwgdGhpcy5wcm9wcy5vblN1Ym1pdChlLCBlcnJvcnMsIHZhbHVlLCBjdXJyZW50UGF0aCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWRWYWx1ZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIGtleSBjaGFuZ2VkLCByZW1vdmUgdGhlIG9yaWdpbmFsLlxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ0tleSAhPT0gbWFrZUVkaXRQaWQoY3VycmVudFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoY2xvbmVkVmFsdWUsIHRoaXMuc3RhdGUuZWRpdFBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWRWYWx1ZS51bnNoaWZ0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVNYW5hZ2VyLnVwZGF0ZShvcmlnS2V5KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoY2xvbmVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3JldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc2hvd0FkZDogdGhpcy5wcm9wcy5zaG93QWRkLFxuICAgICAgICAgICAgc2hvd0VkaXQ6IGZhbHNlLFxuICAgICAgICAgICAgZWRpdFBpZDogbnVsbFxuICAgICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICByZW5kZXJBZGRFZGl0VGVtcGxhdGUoZWRpdCwgY3JlYXRlKSB7XG4gICAgICAgIGlmICghKGVkaXQgfHwgY3JlYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aCh0aGlzLnByb3BzLnBhdGgsIHRoaXMuc3RhdGUuZWRpdFBpZCk7XG4gICAgICAgIGNvbnN0IHtPYmplY3RUeXBlLCBjcmVhdGVUZW1wbGF0ZX0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBDcmVhdGVUZW1wbGF0ZSA9IGNyZWF0ZVRlbXBsYXRlO1xuICAgICAgICByZXR1cm4gKDxDcmVhdGVUZW1wbGF0ZSBpbmxpbmU9e2VkaXQgPyB0aGlzLnByb3BzLmlubGluZSA6IGZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGU9e2VkaXQgPyBmYWxzZSA6IGNyZWF0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RoaXMucHJvcHMudGl0bGV9IGtleT1cImFkZEVkaXRUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgPE9iamVjdFR5cGUga2V5PVwiYWRkRWRpdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJ1dHRvbkNsaWNrPXt0aGlzLmhhbmRsZUJ0bkNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hPXt0aGlzLmNyZWF0ZUl0ZW1TY2hlbWEoY2hpbGRQYXRoKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg9e21ha2VFZGl0UGlkKHRoaXMucHJvcHMucGF0aCx0aGlzLnN0YXRlLmVkaXRQaWQpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9DcmVhdGVUZW1wbGF0ZT4pO1xuICAgIH1cblxuICAgIHJlbmRlckFkZEJ0bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmNhbkFkZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnRuID0gZGVmYXVsdHMoe30sIHRoaXMucHJvcHMuYWRkQnV0dG9uLCBDb2xsZWN0aW9uTWl4aW4uZGVmYXVsdFByb3BzLmFkZEJ1dHRvbik7XG4gICAgICAgIGNvbnN0IEJ1dHRvblRlbXBsYXRlID0gdGhpcy5wcm9wcy5idXR0b25UZW1wbGF0ZTtcbiAgICAgICAgcmV0dXJuIDxCdXR0b25UZW1wbGF0ZSBrZXk9XCJhZGRCdG5cIiAgey4uLmJ0bn0gb25DbGljaz17dGhpczo6dGhpcy5oYW5kbGVBZGRCdG59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzPXt0aGlzLnByb3BzLmljb25BZGRDbGFzc30vPlxuXG4gICAgfVxuXG4gICAgcmVuZGVyQWRkKCkge1xuICAgICAgICBpZiAoISh0aGlzLnByb3BzLmNhbkFkZCB8fCB0aGlzLnByb3BzLmNhbkVkaXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7c2hvd0FkZCwgc2hvd0VkaXR9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaW5saW5lKSB7XG4gICAgICAgICAgICBpZiAoc2hvd0FkZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckFkZEVkaXRUZW1wbGF0ZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckFkZEJ0bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoc2hvd0FkZCB8fCBzaG93RWRpdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckFkZEJ0bigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckFkZEVkaXRUZW1wbGF0ZShzaG93RWRpdCwgc2hvd0FkZCk7XG4gICAgfVxuXG4gICAgY3JlYXRlSXRlbVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5nZXRUZW1wbGF0ZUl0ZW0oKSxcbiAgICAgICAgICAgIGZpZWxkc2V0czogW3tcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgICAgICAgICAgYnV0dG9uczogdGhpcy5wcm9wcy5idXR0b25zXG4gICAgICAgICAgICB9XVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJSb3dFYWNoKGRhdGEsIHJvd0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJvdyhkYXRhLCBudWxsLCByb3dJZCk7XG4gICAgfVxuXG4gICAgcmVuZGVyUm93KHYsIHNlY3Rpb25JZCwgaSkge1xuICAgICAgICB2YXIgSXRlbVRlbXBsYXRlID0gdGhpcy5wcm9wcy5pdGVtVGVtcGxhdGUsIENvbnRlbnRJdGVtVGVtcGxhdGUgPSB0aGlzLnByb3BzLmNvbnRlbnRUZW1wbGF0ZTtcblxuICAgICAgICByZXR1cm4gPEl0ZW1UZW1wbGF0ZSBrZXk9e3RoaXMucHJvcHMucGF0aCsnLicraX0gcG9zPXtpfSBwYXRoPXsgcGF0aCh0aGlzLnByb3BzLnBhdGgsIHYua2V5KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3ZlVXA9e3RoaXMuaGFuZGxlTW92ZVVwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdmVEb3duPXt0aGlzLmhhbmRsZU1vdmVEb3dufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT17dGhpcy5oYW5kbGVEZWxldGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRWRpdD17dGhpcy5oYW5kbGVFZGl0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5SZW9yZGVyPXt0aGlzLnByb3BzLmNhblJlb3JkZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkRlbGV0ZT17dGhpcy5wcm9wcy5jYW5EZWxldGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkVkaXQ9e3RoaXMucHJvcHMuY2FuRWRpdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ9e3Z9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpZD17di5rZXl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2fSBlcnJvcnM9e3RoaXMucHJvcHMuZXJyb3JzfSBsYXN0PXtpICsgMSA9PT0gdGhpcy5zdGF0ZS53cmFwcGVkLmxlbmd0aH0+XG4gICAgICAgICAgICB7dGhpcy5wcm9wcy5pbmxpbmUgJiYgdGhpcy5zdGF0ZS5lZGl0UGlkID09PSB2LmtleSA/IHRoaXMucmVuZGVyQWRkRWRpdFRlbXBsYXRlKHYsIGZhbHNlKSA6XG4gICAgICAgICAgICAgICAgPENvbnRlbnRJdGVtVGVtcGxhdGUgdmFsdWU9e3Z9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxLZXk9e3RoaXMucHJvcHMubGFiZWxLZXl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zPXtpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpZD17di5rZXl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3Z9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0tleT17dGhpcy5wcm9wcy5zaG93S2V5fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMuY2FuRWRpdCA/IHRoaXMuaGFuZGxlRWRpdCA6IG51bGx9Lz4gfVxuICAgICAgICA8L0l0ZW1UZW1wbGF0ZT5cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7bmFtZSwgIGl0ZW1UeXBlLCBlcnJvcnMsY2xhc3NOYW1lLCBsaXN0Q29udGFpbmVyQ2xhc3NOYW1lLCBjYW5SZW9yZGVyLCBjYW5EZWxldGUsIGl0ZW1UZW1wbGF0ZSwgY2FuRWRpdCwgY2FuQWRkIH0gPSB0aGlzLnByb3BzLCB2YWx1ZXMgPSB0aGlzLnN0YXRlLndyYXBwZWQgfHwgRlJFRVpFX0FSUiwgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckFkZCgpfVxuICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT17bGlzdENvbnRhaW5lckNsYXNzTmFtZX0+XG4gICAgICAgICAgICAgICAge3ZhbHVlcy5tYXAodGhpcy5yZW5kZXJSb3dFYWNoLCB0aGlzKX1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3R5cGVzL0NvbGxlY3Rpb25NaXhpbi5qc3hcbiAqKi8iLCJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZUlucHV0IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMudmFsdWVFdmVudFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICB0eXBlOiBcImRhdGVcIlxuICAgIH07XG5cbiAgICBhc0lucHV0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpLnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICB9XG5cblxuICAgIGhhbmRsZURhdGVDaGFuZ2UgPSAoZSk9PiB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG5ldyBEYXRlKHZhbHVlKS5nZXRUaW1lKCkpO1xuICAgIH07XG5cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHt2YWx1ZSwgb25DaGFuZ2UsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiA8aW5wdXQgey4uLnByb3BzfSBvbkNoYW5nZT17dGhpcy5oYW5kbGVEYXRlQ2hhbmdlfSB2YWx1ZT17dGhpcy5hc0lucHV0VmFsdWUodmFsdWUpfS8+XG4gICAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9EYXRlLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcblxuLyoqXG4gKiBIaWRkZW4gZG9lcyBuZWVkIGEgdGVtcGxhdGUsIGFuZCBkb2VzIG5vdCBjYXJlIGFib3V0IGVycm9ycy5cbiAqIGJ1dCB3ZSB3aWxsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpZGRlbiBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIG5vVGVtcGxhdGUgPSB0cnVlO1xuICAgIC8vb25seSB1bm5vcm1hbCBpcyBhc0pTT04sIHdoaWNoIHdpbGwgc2V0IHRoZSB2YWx1ZSB0byBqc29uIHJhdGhlciB0aGFuIGEgc3RyaW5nXG4gICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCB0byBob2xkIGhpZGRlbiBzdGF0ZSBvZiBjb21wbGV4IHN0cnVjdHVyZXMuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgYXNKU09OOiBQcm9wVHlwZXMuYm9vbFxuICAgIH07XG5cbiAgICBzdGF0aWMgdGVtcGxhdGUgPSBmYWxzZTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHR5cGU6IFwiaGlkZGVuXCIsXG4gICAgICAgIGFzSlNPTjogZmFsc2VcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIge3ZhbHVlLGFzSlNPTiwgLi4ucHJvcHN9ID10aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gPGlucHV0IHsuLi5wcm9wc30gdmFsdWU9e2FzSlNPTiA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlfS8+XG4gICAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvSGlkZGVuLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF6eVR5cGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAgIHByb21pc2U6IFByb3BUeXBlcy5wcm9taXNlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtsb2FkZWQ6IGZhbHNlfTtcbiAgICB9O1xuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvcHMucHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZSAmJiBwcm9taXNlLnRoZW4odGhpcy5vblJlc29sdmUpO1xuICAgIH07XG5cbiAgICBvblJlc29sdmUgPSAocmVzb2x2ZWQpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7cmVzb2x2ZWQsIGxvYWRlZDogdHJ1ZX0pO1xuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmxvYWRlZCkge1xuICAgICAgICAgICAgdmFyIFR5cGUgPSB0aGlzLnN0YXRlLnJlc29sdmVkO1xuICAgICAgICAgICAgdmFyIHtwcm9taXNlLCAuLi5wcm9wc30gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgcmV0dXJuIDxUeXBlIGtleT1cInJlc29sdmVkXCIgey4uLnByb3BzfS8+XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDxzcGFuIGNsYXNzTmFtZT1cImxhenktbG9hZGluZy10eXBlXCIga2V5PVwidW5yZXNvbHZlZFwiLz47XG4gICAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvTGF6eVR5cGUuanN4XG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge25vb3AsIGlzU3RyaW5nfSBmcm9tICcuLi90dXRpbHMnO1xuaW1wb3J0IENvbGxlY3Rpb25NaXhpbiBmcm9tICcuL0NvbGxlY3Rpb25NaXhpbi5qc3gnO1xuaW1wb3J0IFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwIGZyb20gJ3JlYWN0LWFkZG9ucy1jc3MtdHJhbnNpdGlvbi1ncm91cCc7XG5pbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvb2JqZWN0L2dldCc7XG5pbXBvcnQgbWFwIGZyb20gJ2xvZGFzaC9jb2xsZWN0aW9uL21hcCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnbG9kYXNoL29iamVjdC9kZWZhdWx0cyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdElucHV0IGV4dGVuZHMgQ29sbGVjdGlvbk1peGluIHtcbiAgICBzdGF0aWMgaW5wdXRDbGFzc05hbWUgPSBDb2xsZWN0aW9uTWl4aW4uaW5wdXRDbGFzc05hbWU7XG5cblxuXG4gICAgdW53cmFwKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtYXAodmFsdWUsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlZlZhbHVlKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY3JlYXRlUGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS53cmFwcGVkLmxlbmd0aCB8fCAwO1xuICAgIH1cblxuICAgIGdldFRlbXBsYXRlSXRlbSgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXNTdHJpbmcodGhpcy5wcm9wcy5pdGVtVHlwZSkgPyB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnByb3BzLml0ZW1UeXBlXG4gICAgICAgIH0gOiB0aGlzLnByb3BzLml0ZW1UeXBlIHx8IHt9O1xuICAgICAgICB2YWx1ZS50aXRsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBrZXk6IHt0aXRsZTogZmFsc2UsIHRlbXBsYXRlOiBmYWxzZSwgdHlwZTogJ0hpZGRlbid9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvTGlzdC5qc3hcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vcmVhY3QtYWRkb25zLWNzcy10cmFuc2l0aW9uLWdyb3VwL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCcuL1JlYWN0Jyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gcmVxdWlyZSgnLi9SZWFjdFRyYW5zaXRpb25Hcm91cCcpO1xudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSByZXF1aXJlKCcuL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQnKTtcblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvblRpbWVvdXRQcm9wVmFsaWRhdG9yKHRyYW5zaXRpb25UeXBlKSB7XG4gIHZhciB0aW1lb3V0UHJvcE5hbWUgPSAndHJhbnNpdGlvbicgKyB0cmFuc2l0aW9uVHlwZSArICdUaW1lb3V0JztcbiAgdmFyIGVuYWJsZWRQcm9wTmFtZSA9ICd0cmFuc2l0aW9uJyArIHRyYW5zaXRpb25UeXBlO1xuXG4gIHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAvLyBJZiB0aGUgdHJhbnNpdGlvbiBpcyBlbmFibGVkXG4gICAgaWYgKHByb3BzW2VuYWJsZWRQcm9wTmFtZV0pIHtcbiAgICAgIC8vIElmIG5vIHRpbWVvdXQgZHVyYXRpb24gaXMgcHJvdmlkZWRcbiAgICAgIGlmIChwcm9wc1t0aW1lb3V0UHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcih0aW1lb3V0UHJvcE5hbWUgKyAnIHdhc25cXCd0IHN1cHBsaWVkIHRvIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwOiAnICsgJ3RoaXMgY2FuIGNhdXNlIHVucmVsaWFibGUgYW5pbWF0aW9ucyBhbmQgd29uXFwndCBiZSBzdXBwb3J0ZWQgaW4gJyArICdhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0LiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWFuaW1hdGlvbi10cmFuc2l0aW9uLWdyb3VwLXRpbWVvdXQgZm9yIG1vcmUgJyArICdpbmZvcm1hdGlvbi4nKTtcblxuICAgICAgICAvLyBJZiB0aGUgZHVyYXRpb24gaXNuJ3QgYSBudW1iZXJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzW3RpbWVvdXRQcm9wTmFtZV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcih0aW1lb3V0UHJvcE5hbWUgKyAnIG11c3QgYmUgYSBudW1iZXIgKGluIG1pbGxpc2Vjb25kcyknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0cmFuc2l0aW9uTmFtZTogUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZC5wcm9wVHlwZXMubmFtZSxcblxuICAgIHRyYW5zaXRpb25BcHBlYXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHRyYW5zaXRpb25FbnRlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdHJhbnNpdGlvbkxlYXZlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uQXBwZWFyVGltZW91dDogY3JlYXRlVHJhbnNpdGlvblRpbWVvdXRQcm9wVmFsaWRhdG9yKCdBcHBlYXInKSxcbiAgICB0cmFuc2l0aW9uRW50ZXJUaW1lb3V0OiBjcmVhdGVUcmFuc2l0aW9uVGltZW91dFByb3BWYWxpZGF0b3IoJ0VudGVyJyksXG4gICAgdHJhbnNpdGlvbkxlYXZlVGltZW91dDogY3JlYXRlVHJhbnNpdGlvblRpbWVvdXRQcm9wVmFsaWRhdG9yKCdMZWF2ZScpXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb25BcHBlYXI6IGZhbHNlLFxuICAgICAgdHJhbnNpdGlvbkVudGVyOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkxlYXZlOiB0cnVlXG4gICAgfTtcbiAgfSxcblxuICBfd3JhcENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdGhpcyBjaGlsZEZhY3Rvcnkgc28gdGhhdFxuICAgIC8vIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgY2FuIHJlY2VpdmUgdXBkYXRlcyB0byBuYW1lLCBlbnRlciwgYW5kXG4gICAgLy8gbGVhdmUgd2hpbGUgaXQgaXMgbGVhdmluZy5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLCB7XG4gICAgICBuYW1lOiB0aGlzLnByb3BzLnRyYW5zaXRpb25OYW1lLFxuICAgICAgYXBwZWFyOiB0aGlzLnByb3BzLnRyYW5zaXRpb25BcHBlYXIsXG4gICAgICBlbnRlcjogdGhpcy5wcm9wcy50cmFuc2l0aW9uRW50ZXIsXG4gICAgICBsZWF2ZTogdGhpcy5wcm9wcy50cmFuc2l0aW9uTGVhdmUsXG4gICAgICBhcHBlYXJUaW1lb3V0OiB0aGlzLnByb3BzLnRyYW5zaXRpb25BcHBlYXJUaW1lb3V0LFxuICAgICAgZW50ZXJUaW1lb3V0OiB0aGlzLnByb3BzLnRyYW5zaXRpb25FbnRlclRpbWVvdXQsXG4gICAgICBsZWF2ZVRpbWVvdXQ6IHRoaXMucHJvcHMudHJhbnNpdGlvbkxlYXZlVGltZW91dFxuICAgIH0sIGNoaWxkKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdFRyYW5zaXRpb25Hcm91cCwgYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IGNoaWxkRmFjdG9yeTogdGhpcy5fd3JhcENoaWxkIH0pKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwLmpzXG4gKiogbW9kdWxlIGlkID0gMzEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUcmFuc2l0aW9uR3JvdXBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJy4vUmVhY3QnKTtcbnZhciBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcgPSByZXF1aXJlKCcuL1JlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcblxudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0VHJhbnNpdGlvbkdyb3VwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjb21wb25lbnQ6IFJlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgY2hpbGRGYWN0b3J5OiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wb25lbnQ6ICdzcGFuJyxcbiAgICAgIGNoaWxkRmFjdG9yeTogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50XG4gICAgfTtcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcodGhpcy5wcm9wcy5jaGlsZHJlbilcbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXMgPSB7fTtcbiAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluaXRpYWxDaGlsZE1hcHBpbmcgPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuICAgIGZvciAodmFyIGtleSBpbiBpbml0aWFsQ2hpbGRNYXBwaW5nKSB7XG4gICAgICBpZiAoaW5pdGlhbENoaWxkTWFwcGluZ1trZXldKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUFwcGVhcihrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgdmFyIG5leHRDaGlsZE1hcHBpbmcgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKG5leHRQcm9wcy5jaGlsZHJlbik7XG4gICAgdmFyIHByZXZDaGlsZE1hcHBpbmcgPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjaGlsZHJlbjogUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLm1lcmdlQ2hpbGRNYXBwaW5ncyhwcmV2Q2hpbGRNYXBwaW5nLCBuZXh0Q2hpbGRNYXBwaW5nKVxuICAgIH0pO1xuXG4gICAgdmFyIGtleTtcblxuICAgIGZvciAoa2V5IGluIG5leHRDaGlsZE1hcHBpbmcpIHtcbiAgICAgIHZhciBoYXNQcmV2ID0gcHJldkNoaWxkTWFwcGluZyAmJiBwcmV2Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAobmV4dENoaWxkTWFwcGluZ1trZXldICYmICFoYXNQcmV2ICYmICF0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0pIHtcbiAgICAgICAgdGhpcy5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gcHJldkNoaWxkTWFwcGluZykge1xuICAgICAgdmFyIGhhc05leHQgPSBuZXh0Q2hpbGRNYXBwaW5nICYmIG5leHRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChwcmV2Q2hpbGRNYXBwaW5nW2tleV0gJiYgIWhhc05leHQgJiYgIXRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSkge1xuICAgICAgICB0aGlzLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSB3YW50IHRvIHNvbWVkYXkgY2hlY2sgZm9yIHJlb3JkZXJpbmcsIHdlIGNvdWxkIGRvIGl0IGhlcmUuXG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleXNUb0VudGVyID0gdGhpcy5rZXlzVG9FbnRlcjtcbiAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAga2V5c1RvRW50ZXIuZm9yRWFjaCh0aGlzLnBlcmZvcm1FbnRlcik7XG5cbiAgICB2YXIga2V5c1RvTGVhdmUgPSB0aGlzLmtleXNUb0xlYXZlO1xuICAgIHRoaXMua2V5c1RvTGVhdmUgPSBbXTtcbiAgICBrZXlzVG9MZWF2ZS5mb3JFYWNoKHRoaXMucGVyZm9ybUxlYXZlKTtcbiAgfSxcblxuICBwZXJmb3JtQXBwZWFyOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldID0gdHJ1ZTtcblxuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcblxuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbEFwcGVhcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxBcHBlYXIodGhpcy5faGFuZGxlRG9uZUFwcGVhcmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYW5kbGVEb25lQXBwZWFyaW5nKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVEb25lQXBwZWFyaW5nOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkQXBwZWFyKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50RGlkQXBwZWFyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XTtcblxuICAgIHZhciBjdXJyZW50Q2hpbGRNYXBwaW5nID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyh0aGlzLnByb3BzLmNoaWxkcmVuKTtcblxuICAgIGlmICghY3VycmVudENoaWxkTWFwcGluZyB8fCAhY3VycmVudENoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBUaGlzIHdhcyByZW1vdmVkIGJlZm9yZSBpdCBoYWQgZnVsbHkgYXBwZWFyZWQuIFJlbW92ZSBpdC5cbiAgICAgIHRoaXMucGVyZm9ybUxlYXZlKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIHBlcmZvcm1FbnRlcjogZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSA9IHRydWU7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG5cbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcih0aGlzLl9oYW5kbGVEb25lRW50ZXJpbmcuYmluZCh0aGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlRG9uZUVudGVyaW5nKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVEb25lRW50ZXJpbmc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRFbnRlcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudERpZEVudGVyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XTtcblxuICAgIHZhciBjdXJyZW50Q2hpbGRNYXBwaW5nID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyh0aGlzLnByb3BzLmNoaWxkcmVuKTtcblxuICAgIGlmICghY3VycmVudENoaWxkTWFwcGluZyB8fCAhY3VycmVudENoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBUaGlzIHdhcyByZW1vdmVkIGJlZm9yZSBpdCBoYWQgZnVsbHkgZW50ZXJlZC4gUmVtb3ZlIGl0LlxuICAgICAgdGhpcy5wZXJmb3JtTGVhdmUoa2V5KTtcbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUxlYXZlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldID0gdHJ1ZTtcblxuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxMZWF2ZSkge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxMZWF2ZSh0aGlzLl9oYW5kbGVEb25lTGVhdmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBzb21ld2hhdCBkYW5nZXJvdXMgYi9jIGl0IGNhbGxzIHNldFN0YXRlKClcbiAgICAgIC8vIGFnYWluLCBlZmZlY3RpdmVseSBtdXRhdGluZyB0aGUgY29tcG9uZW50IGJlZm9yZSBhbGwgdGhlIHdvcmtcbiAgICAgIC8vIGlzIGRvbmUuXG4gICAgICB0aGlzLl9oYW5kbGVEb25lTGVhdmluZyhrZXkpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlRG9uZUxlYXZpbmc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG5cbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZExlYXZlKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50RGlkTGVhdmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldO1xuXG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKGN1cnJlbnRDaGlsZE1hcHBpbmcgJiYgY3VycmVudENoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBUaGlzIGVudGVyZWQgYWdhaW4gYmVmb3JlIGl0IGZ1bGx5IGxlZnQuIEFkZCBpdCBhZ2Fpbi5cbiAgICAgIHRoaXMucGVyZm9ybUVudGVyKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IGFzc2lnbih7fSwgc3RhdGUuY2hpbGRyZW4pO1xuICAgICAgICBkZWxldGUgbmV3Q2hpbGRyZW5ba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgY2hpbGRyZW46IG5ld0NoaWxkcmVuIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETzogd2UgY291bGQgZ2V0IHJpZCBvZiB0aGUgbmVlZCBmb3IgdGhlIHdyYXBwZXIgbm9kZVxuICAgIC8vIGJ5IGNsb25pbmcgYSBzaW5nbGUgY2hpbGRcbiAgICB2YXIgY2hpbGRyZW5Ub1JlbmRlciA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnN0YXRlLmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLnN0YXRlLmNoaWxkcmVuW2tleV07XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgLy8gWW91IG1heSBuZWVkIHRvIGFwcGx5IHJlYWN0aXZlIHVwZGF0ZXMgdG8gYSBjaGlsZCBhcyBpdCBpcyBsZWF2aW5nLlxuICAgICAgICAvLyBUaGUgbm9ybWFsIFJlYWN0IHdheSB0byBkbyBpdCB3b24ndCB3b3JrIHNpbmNlIHRoZSBjaGlsZCB3aWxsIGhhdmVcbiAgICAgICAgLy8gYWxyZWFkeSBiZWVuIHJlbW92ZWQuIEluIGNhc2UgeW91IG5lZWQgdGhpcyBiZWhhdmlvciB5b3UgY2FuIHByb3ZpZGVcbiAgICAgICAgLy8gYSBjaGlsZEZhY3RvcnkgZnVuY3Rpb24gdG8gd3JhcCBldmVyeSBjaGlsZCwgZXZlbiB0aGUgb25lcyB0aGF0IGFyZVxuICAgICAgICAvLyBsZWF2aW5nLlxuICAgICAgICBjaGlsZHJlblRvUmVuZGVyLnB1c2goUmVhY3QuY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuY2hpbGRGYWN0b3J5KGNoaWxkKSwgeyByZWY6IGtleSwga2V5OiBrZXkgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmNvbXBvbmVudCwgdGhpcy5wcm9wcywgY2hpbGRyZW5Ub1JlbmRlcik7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VHJhbnNpdGlvbkdyb3VwO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25Hcm91cC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xuXG52YXIgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nID0ge1xuICAvKipcbiAgICogR2l2ZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gLCByZXR1cm4gYW4gb2JqZWN0IG1hcHBpbmcga2V5IHRvIGNoaWxkLiBKdXN0XG4gICAqIHNpbXBsZSBzeW50YWN0aWMgc3VnYXIgYXJvdW5kIGZsYXR0ZW5DaGlsZHJlbigpLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGNoaWxkcmVuIGB0aGlzLnByb3BzLmNoaWxkcmVuYFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE1hcHBpbmcgb2Yga2V5IHRvIGNoaWxkXG4gICAqL1xuICBnZXRDaGlsZE1hcHBpbmc6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4geW91J3JlIGFkZGluZyBvciByZW1vdmluZyBjaGlsZHJlbiBzb21lIG1heSBiZSBhZGRlZCBvciByZW1vdmVkIGluIHRoZVxuICAgKiBzYW1lIHJlbmRlciBwYXNzLiBXZSB3YW50IHRvIHNob3cgKmJvdGgqIHNpbmNlIHdlIHdhbnQgdG8gc2ltdWx0YW5lb3VzbHlcbiAgICogYW5pbWF0ZSBlbGVtZW50cyBpbiBhbmQgb3V0LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgcHJldmlvdXMgc2V0IG9mIGtleXNcbiAgICogYW5kIGEgbmV3IHNldCBvZiBrZXlzIGFuZCBtZXJnZXMgdGhlbSB3aXRoIGl0cyBiZXN0IGd1ZXNzIG9mIHRoZSBjb3JyZWN0XG4gICAqIG9yZGVyaW5nLiBJbiB0aGUgZnV0dXJlIHdlIG1heSBleHBvc2Ugc29tZSBvZiB0aGUgdXRpbGl0aWVzIGluXG4gICAqIFJlYWN0TXVsdGlDaGlsZCB0byBtYWtlIHRoaXMgZWFzeSwgYnV0IGZvciBub3cgUmVhY3QgaXRzZWxmIGRvZXMgbm90XG4gICAqIGRpcmVjdGx5IGhhdmUgdGhpcyBjb25jZXB0IG9mIHRoZSB1bmlvbiBvZiBwcmV2Q2hpbGRyZW4gYW5kIG5leHRDaGlsZHJlblxuICAgKiBzbyB3ZSBpbXBsZW1lbnQgaXQgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXYgcHJldiBjaGlsZHJlbiBhcyByZXR1cm5lZCBmcm9tXG4gICAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dCBuZXh0IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAgICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gICAqIEByZXR1cm4ge29iamVjdH0gYSBrZXkgc2V0IHRoYXQgY29udGFpbnMgYWxsIGtleXMgaW4gYHByZXZgIGFuZCBhbGwga2V5c1xuICAgKiBpbiBgbmV4dGAgaW4gYSByZWFzb25hYmxlIG9yZGVyLlxuICAgKi9cbiAgbWVyZ2VDaGlsZE1hcHBpbmdzOiBmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgIHByZXYgPSBwcmV2IHx8IHt9O1xuICAgIG5leHQgPSBuZXh0IHx8IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVGb3JLZXkoa2V5KSB7XG4gICAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXh0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJldltrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAgIC8vIHRoZSBjb21iaW5lZCBsaXN0XG4gICAgdmFyIG5leHRLZXlzUGVuZGluZyA9IHt9O1xuXG4gICAgdmFyIHBlbmRpbmdLZXlzID0gW107XG4gICAgZm9yICh2YXIgcHJldktleSBpbiBwcmV2KSB7XG4gICAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eShwcmV2S2V5KSkge1xuICAgICAgICBpZiAocGVuZGluZ0tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgbmV4dEtleXNQZW5kaW5nW3ByZXZLZXldID0gcGVuZGluZ0tleXM7XG4gICAgICAgICAgcGVuZGluZ0tleXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0tleXMucHVzaChwcmV2S2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgY2hpbGRNYXBwaW5nID0ge307XG4gICAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0KSB7XG4gICAgICBpZiAobmV4dEtleXNQZW5kaW5nLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGVuZGluZ05leHRLZXkgPSBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV07XG4gICAgICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXV0gPSBnZXRWYWx1ZUZvcktleShwZW5kaW5nTmV4dEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5XSA9IGdldFZhbHVlRm9yS2V5KG5leHRLZXkpO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIGFkZCB0aGUga2V5cyB3aGljaCBkaWRuJ3QgYXBwZWFyIGJlZm9yZSBhbnkga2V5IGluIGBuZXh0YFxuICAgIGZvciAoaSA9IDA7IGkgPCBwZW5kaW5nS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRNYXBwaW5nW3BlbmRpbmdLZXlzW2ldXSA9IGdldFZhbHVlRm9yS2V5KHBlbmRpbmdLZXlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRNYXBwaW5nO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMzE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IENvbGxlY3Rpb25NaXhpbiBmcm9tICcuL0NvbGxlY3Rpb25NaXhpbi5qc3gnO1xuaW1wb3J0IHtpc1N0cmluZ30gZnJvbSAnLi4vdHV0aWxzJztcbmltcG9ydCBfZ2V0IGZyb20gJ2xvZGFzaC9vYmplY3QvZ2V0JztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICdsb2Rhc2gvb2JqZWN0L2RlZmF1bHRzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1peGVkSW5wdXQgZXh0ZW5kcyBDb2xsZWN0aW9uTWl4aW4ge1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IGRlZmF1bHRzKHtcbiAgICAgICAgbGFiZWxLZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGtleVR5cGU6IFByb3BUeXBlcy50eXBlRGVzY3JpcHRpb24sXG4gICAgICAgIHZhbHVlVHlwZTogUHJvcFR5cGVzLnR5cGVEZXNjcmlwdGlvbixcbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy52YWx1ZSxcbiAgICB9LCBDb2xsZWN0aW9uTWl4aW4ucHJvcFR5cGVzKTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0cyh7XG4gICAgICAgIG5ld0tleVByZWZpeDogJ25ld19rZXknLFxuICAgICAgICBzaG93S2V5OiB0cnVlLFxuICAgICAgICB2YWx1ZVR5cGU6IHt0eXBlOiAnVGV4dCd9LFxuICAgICAgICBrZXlUeXBlOiB7dHlwZTogJ1RleHQnfVxuICAgIH0sIENvbGxlY3Rpb25NaXhpbi5kZWZhdWx0UHJvcHMpO1xuXG4gICAgdW53cmFwKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXQgPSB7fVxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXRbdi5rZXldID0gdi52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdW5pcXVlQ2hlY2sgPSAodmFsdWUpPT4ge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lZGl0UGlkID09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW4gdmFsdWVzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0tleXMgbXVzdCBiZSB1bmlxdWUnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgY3JlYXRlUGlkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5wcm9wcy5uZXdLZXlQcmVmaXh9JHt0aGlzLnN0YXRlLndyYXBwZWQubGVuZ3RofWA7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVmVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBnZXRUZW1wbGF0ZUl0ZW0oKSB7XG4gICAgICAgIGxldCB7a2V5VHlwZSwgdmFsdWVUeXBlLCBpdGVtVHlwZX0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGtleVR5cGUgPSBrZXlUeXBlID8gaXNTdHJpbmcoa2V5VHlwZSkgPyB7dHlwZToga2V5VHlwZX0gOiBrZXlUeXBlIDoge3R5cGU6ICdUZXh0J307XG5cbiAgICAgICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgICAgICAga2V5OiBpc1N0cmluZyhrZXlUeXBlKSA/IHtrZXlUeXBlfSA6IGtleVR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlIHx8IGl0ZW1UeXBlXG4gICAgICAgIH07XG5cbiAgICAgICAgKGtleVR5cGUudmFsaWRhdG9ycyB8fCAoa2V5VHlwZS52YWxpZGF0b3JzID0gW10pKS51bnNoaWZ0KCdyZXF1aXJlZCcsIHRoaXMudW5pcXVlQ2hlY2spO1xuXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvTWl4ZWQuanN4XG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcblxudmFyIG5vUmUgPSAvXigtfFxcKyk/KFswLTldKlxcLik/JC8sIG51bVJlID0gL14oXFwtfFxcKyk/KFswLTldKyhcXC5bMC05XSspP3xJbmZpbml0eSkkLztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOdW1iZXJJbnB1dCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLnZhbHVlRXZlbnRcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMsIC4uLnJlc3QpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIC4uLnJlc3QpO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlIHx8ICh0aGlzLnN0YXRlID0ge30pO1xuICAgICAgICBzdGF0ZS52YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcykge1xuICAgICAgICBpZiAobmV3UHJvcHMudmFsdWUgIT09IHRoaXMucHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiBuZXdQcm9wcy52YWx1ZX0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlRGF0ZUNoYW5nZSA9IChlKT0+IHtcblxuICAgICAgICB2YXIgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgLy9Ob3QgYSB2YWxpZCBudW1iZXIgYnV0IHZhbGlkIHRvIGJlY29tZSBhIG51bWJlclxuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vUmUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICgvXFwuJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHBhcnNlRmxvYXQodmFsdWUpKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgIC8vY2hlY2sgaWYgcmVhbCBhY3R1YWwgbnVtYmVycy5cbiAgICAgICAgaWYgKG51bVJlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHBhcnNlRmxvYXQodmFsdWUpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHtvbkNoYW5nZSwgdmFsdWUsIC4uLnByb3BzfSA9IHRoaXMucHJvcHNcbiAgICAgICAgcmV0dXJuIDxpbnB1dCB7Li4ucHJvcHN9IHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfSBvbkNoYW5nZT17dGhpcy5oYW5kbGVEYXRlQ2hhbmdlfS8+XG4gICAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvTnVtYmVyLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFzc3dvcmQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHR5cGU6ICdwYXNzd29yZCdcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gPGlucHV0IHsuLi50aGlzLnByb3BzfS8+XG4gICAgfVxuXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9QYXNzd29yZC5qc3hcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge3JldHVybkZpcnN0LCBwYXRoIGFzIHRwYXRofSBmcm9tICcuLi90dXRpbHMnO1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5cbmZ1bmN0aW9uIGNvbXBhcmUodmFsLCB2YWwyKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsICYmIHZhbDIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbCA9PSBudWxsIHx8IHZhbDIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoJycgKyB2YWwgPT09ICcnICsgdmFsMik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlvSW5wdXQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBpbnB1dENsYXNzTmFtZSA9ICcgICc7XG5cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGl0ZW1UZW1wbGF0ZTogJ1JhZGlvSXRlbVRlbXBsYXRlJyxcbiAgICAgICAgb3B0aW9uczogW10sXG4gICAgICAgIGZvcmNlU2VsZWN0aW9uOiBmYWxzZVxuICAgIH07XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLnZhbHVlRXZlbnQsXG4gICAgICAgIGl0ZW1UZW1wbGF0ZTogUHJvcFR5cGVzLnRlbXBsYXRlLFxuICAgICAgICBmb3JjZVNlbGVjdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGNoZWNrZWRDbGFzczogUHJvcFR5cGVzLmNzc0NsYXNzLFxuICAgICAgICBvcHRpb25zOiBQcm9wVHlwZXMub3B0aW9ucy5pc1JlcXVpcmVkXG4gICAgfTtcblxuXG4gICAgaGFuZGxlQ2hlY2tDaGFuZ2UoZSkge1xuICAgICAgICAvL01ha2UgYSByYWRpbyBiZWhhdmUgbGlrZSBhIGNoZWNrYm94IHdoZW4gdGhlcmUgaXMgb25seSAxLlxuICAgICAgICBpZiAodGhpcy5wcm9wcy5mb3JjZVNlbGVjdGlvbiA9PT0gZmFsc2UgfHwgdGhpcy5wcm9wcy5vcHRpb25zICYmIHRoaXMucHJvcHMub3B0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoY29tcGFyZShlLnRhcmdldC52YWx1ZSwgdGhpcy5wcm9wcy52YWx1ZSkgPyBudWxsIDogZS50YXJnZXQudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbWFrZU9wdGlvbnMob3B0aW9ucyl7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IFtdO1xuICAgICAgICBjb25zdCBvbkNoYW5nZSA9IHRoaXM6OnRoaXMuaGFuZGxlQ2hlY2tDaGFuZ2U7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMucHJvcHMucGF0aDtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KT0+IHtcbiAgICAgICAgICAgIHZhciB7dmFsLCBsYWJlbCwgbGFiZWxIVE1MfSA9IG9wdGlvbjtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdHBhdGgocGF0aCwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgICAgICAgICBjaGVja2VkQ2xhc3M6IHRoaXMucHJvcHMuY2hlY2tlZENsYXNzLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNvbXBhcmUodmFsdWUsIHZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHtuYW1lLGl0ZW1UZW1wbGF0ZSxjbGFzc05hbWUsIGNoZWNrZWRDbGFzcywgdmFsdWUsIG9wdGlvbnMsIGZpZWxkfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5tYWtlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIFJhZGlvSXRlbVRlbXBsYXRlID0gaXRlbVRlbXBsYXRlO1xuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+e29wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KT0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gb3B0aW9ucy5pZCB8fCBgJHtuYW1lfS4ke2luZGV4fWBcbiAgICAgICAgICAgIHJldHVybiA8UmFkaW9JdGVtVGVtcGxhdGUgaWQ9e2lkfSBjaGVja2VkQ2xhc3M9e2NoZWNrZWRDbGFzc30gey4uLm9wdGlvbn0ga2V5PXtvcHRpb24ucGF0aH0+XG4gICAgICAgICAgICAgICAgPGlucHV0IGlkPXtpZH0gdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17bmFtZX0gey4uLm9wdGlvbn0gdmFsdWU9e29wdGlvbi52YWx9Lz5cbiAgICAgICAgICAgIDwvUmFkaW9JdGVtVGVtcGxhdGU+XG4gICAgICAgIH0sIHRoaXMpfTwvZGl2PlxuXG4gICAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9SYWRpby5qc3hcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUmVzdHJpY3RlZE1peGluIGZyb20gJy4vUmVzdHJpY3RlZE1peGluJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCB7bm9vcCwgcmV0dXJuRmlyc3R9IGZyb20gJy4uL3R1dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3RyaWN0ZWQgZXh0ZW5kcyBSZXN0cmljdGVkTWl4aW4ge1xuICAgIHN0YXRpYyBjb250ZXh0VHlwZXMgPSBQcm9wVHlwZXMuY29udGV4dFR5cGVzO1xuXG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb25WYWxpZDogbm9vcFxuICAgIH07XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgb25WYWxpZDogUHJvcFR5cGVzLnZhbGlkRXZlbnQsXG4gICAgICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMudmFsdWVFdmVudCxcbiAgICAgICAgZm9ybWF0dGVyOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfTtcblxuXG4gICAgaGFuZGxlU2VsZWN0aW9uUmFuZ2UgPSAoY2FyZXQpPT4ge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnJlZnMgJiYgUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmlucHV0KTtcbiAgICAgICAgaWYgKCFpbnB1dClyZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FyZXQgIT0gbnVsbClcbiAgICAgICAgICAgIGlucHV0ICYmIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKHRoaXMuc3RhdGUuY2FyZXQsIHRoaXMuc3RhdGUuY2FyZXQpO1xuICAgIH07XG5cbiAgICBoYW5kbGVWYWx1ZUNoYW5nZSA9IChlKT0+IHtcbiAgICAgICAgdGhpcy5fdmFsdWUoZS50YXJnZXQudmFsdWUsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIge29uVmFsaWQsZm9ybWF0dGVyLCBvbkNoYW5nZSwgb25LZXlEb3duLHZhbHVlLCAuLi5wcm9wc30gPSB0aGlzLnByb3BzXG4gICAgICAgIHJldHVybiA8aW5wdXQgcmVmPVwiaW5wdXRcIiAgey4uLnByb3BzfSB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX0gb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleURvd259XG4gICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlVmFsdWVDaGFuZ2V9Lz5cbiAgICB9XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9SZXN0cmljdGVkLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4uL3dhcm5pbmcnO1xuXG52YXIgemlwUmUgPSAvXihcXGR7MCw1fSkoPzpbXlxcZF0/KFxcZHswLDR9KSk/JC8sIHJlUmUgPSAvKCN7MSx9fEF7MSx9fGF7MSx9fDB7MSx9KD86XFwuMHsxLH0pPyk/KC4rPyk/L21nO1xuXG5mdW5jdGlvbiBsYXN0RXEoaW5wdXQsIHZhbCkge1xuICAgIHJldHVybiBpbnB1dCAmJiBpbnB1dFtpbnB1dC5sZW5ndGggLSAxXSA9PT0gdmFsO1xufVxuXG5mdW5jdGlvbiBmaXhEZWxpbShzdHIpIHtcbiAgICByZXR1cm4gKHN0ciB8fCAnJykucmVwbGFjZSgvKFsgKCkuLV0pL2csICdcXFxcJDEnKTtcbn1cblxuZnVuY3Rpb24gcmV0KGV4YWN0LCB2YWwsIGQsIGJhY2t3YXJkKSB7XG4gICAgcmV0dXJuIChleGFjdCAhPSBudWxsICYmIGV4YWN0ID09PSBkKSA/IGV4YWN0IDogZXhhY3QgPT0gbnVsbCB8fCBleGFjdCA9PSAnJyA/IHZhbCA6IGV4YWN0O1xufVxuXG5mdW5jdGlvbiBmbXQoZGVsaW0sIHBsYWNlaG9sZGVyKSB7XG4gICAgZGVsaW0gPSBkZWxpbSB8fCAnJztcbiAgICBmdW5jdGlvbiBmbXQkcmV0dXJuKGV4YWN0LCB2YWwsIGQsIGJhY2t3YXJkKSB7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciAmJiAhYmFja3dhcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxpbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhhY3QgPT09IGQpIHtcbiAgICAgICAgICAgIHJldHVybiBleGFjdCB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGV4YWN0ID09IG51bGwgfHwgZXhhY3QgPT09ICcnICkgPyB2YWwgOiBiYWNrd2FyZCA/IGV4YWN0IDogZXhhY3QgKyBkZWxpbTtcbiAgICB9O1xuICAgIGZtdCRyZXR1cm4ucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICByZXR1cm4gZm10JHJldHVybjtcbn1cblxuZnVuY3Rpb24gdXBwZXIoZGVsaW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZm10JHJldHVybihleGFjdCwgdmFsLCBkLCBiYWNrd2FyZCkge1xuICAgICAgICBleGFjdCA9IChyZXQoZXhhY3QsIHZhbCwgZCkgfHwgJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBiYWNrd2FyZCA/IGV4YWN0IDogZXhhY3QgKyBkZWxpbTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbG93ZXIoZGVsaW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZm10JHJldHVybihleGFjdCwgdmFsLCBkLCBiYWNrd2FyZCkge1xuICAgICAgICBleGFjdCA9IChyZXQoZXhhY3QsIHZhbCwgZCkgfHwgJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBiYWNrd2FyZCA/IGV4YWN0IDogZXhhY3QgKyBkZWxpbTtcbiAgICB9O1xufVxuZnVuY3Rpb24gX3BhZCh2YWx1ZSwgbGVuZ3RoLCByaWdodCkge1xuICAgIHZhbHVlID0gdmFsdWUgfHwgJyc7XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIHZhbHVlICs9ICcwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gJzAnICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcGFkKGRlbGltLCBwYWRkaW5nKSB7XG4gICAgdmFyIHBhcnRzID0gcGFkZGluZy5zcGxpdCgnLicsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmbXQkcmV0dXJuKGV4YWN0LCB2YWwsIGQsIGJhY2t3YXJkKSB7XG4gICAgICAgIGV4YWN0ID0gcmV0KGV4YWN0LCB2YWwsIGQpLnNwbGl0KCcuJywgMik7XG4gICAgICAgIHJldHVybiBfcGFkKGV4YWN0WzBdLCBwYXJ0c1swXS5sZW5ndGgsIGZhbHNlKSArICggcGFydHMubGVuZ3RoID4gMSA/ICcuJyArIF9wYWQoZXhhY3RbMV0sIHBhcnRzWzFdLmxlbmd0aCwgdHJ1ZSkgOiAnJyk7XG4gICAgfTtcblxufVxuZnVuY3Rpb24gZGVmYXVsdFZhbGlkYXRvcih2YWx1ZSwgcmVnZXgpIHtcbiAgICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kQ2hhclBvc0FmdGVyKHZhbHVlLCBjaGFyLCBwb3MpIHtcbiAgICBmb3IgKHZhciBpID0gcG9zLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZVtpXSA9PT0gY2hhcikge1xuICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG59XG5mdW5jdGlvbiBtYWtlRm9ybWF0dGVyKGZvcm1hdCwgdmFsaWRhdG9yKSB7XG4gICAgdmFsaWRhdG9yID0gdmFsaWRhdG9yIHx8IGRlZmF1bHRWYWxpZGF0b3I7XG4gICAgdmFyIHBhcnRzO1xuICAgIHZhciBwYXR0ZXJuID0gJycsIHZhbGlkUGF0dGVybiA9ICcnO1xuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgIHJlUmUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKHBhcnRzID0gcmVSZS5leGVjKGZvcm1hdCkpICE9IG51bGwgJiYgcGFydHMuaW5kZXggPCBmb3JtYXQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IHBhcnRzWzFdLCBkZWxpbSA9IHBhcnRzWzJdLCBleGFjdDtcbiAgICAgICAgc3dpdGNoIChmaXJzdCAmJiBmaXJzdFswXSB8fCAnJykge1xuICAgICAgICAgICAgLy9taXhlZCBjYXNlXG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBleGFjdCA9ICcoXFxcXFthLXpBLVpdeycgKyBmaXJzdC5sZW5ndGggKyAnfSknO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gZXhhY3QgKyAnfChcXFxcW2EtekEtWl17MCwnICsgKGZpcnN0Lmxlbmd0aCAtIDEpICsgJ30pJztcbiAgICAgICAgICAgICAgICB2YWxpZFBhdHRlcm4gKz0gZXhhY3Q7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChmbXQoZGVsaW0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBwZXIgY2FzZVxuICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXhhY3QgPSAnKFxcXFxbQS1aXXsnICsgZmlyc3QubGVuZ3RoICsgJ30pJztcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGV4YWN0ICsgJ3woXFxcXFthLXpBLVpdezAsJyArIChmaXJzdC5sZW5ndGggLSAxKSArICd9KSc7XG4gICAgICAgICAgICAgICAgdmFsaWRQYXR0ZXJuICs9IGV4YWN0O1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2godXBwZXIoZGVsaW0pKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9sb3dlciBjYXNlXG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBleGFjdCA9ICcoXFxcXFtBLVpdeycgKyBmaXJzdC5sZW5ndGggKyAnfSknO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gZXhhY3QgKyAnfChcXFxcW2EtekEtWl17MCwnICsgKGZpcnN0Lmxlbmd0aCAtIDEpICsgJ30pJztcbiAgICAgICAgICAgICAgICB2YWxpZFBhdHRlcm4gKz0gZXhhY3Q7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChsb3dlcihkZWxpbSkpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3BhZGRpbmdcbiAgICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgICAgIGV4YWN0ID0gJyhcXFxcZHsnICsgZmlyc3QubGVuZ3RoICsgJyx9KSc7XG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSAnKCcgKyBleGFjdCArICd8KFxcXFxkezAsfSkpKD86W15cXFxcZF0pPyc7XG4gICAgICAgICAgICAgICAgdmFsaWRQYXR0ZXJuICs9IGV4YWN0ICsgZml4RGVsaW0oZGVsaW0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocGFkKGRlbGltLCBmaXJzdCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvL051bWJlclxuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGZkZWxpbSA9IGZpeERlbGltKGRlbGltKTtcbiAgICAgICAgICAgICAgICBleGFjdCA9ICcoXFxcXGR7JyArIGZpcnN0Lmxlbmd0aCArICd9KSc7XG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSAnKCcgKyBleGFjdCArICd8KFxcXFxkezAsJyArIChmaXJzdC5sZW5ndGggLSAxKSArICd9KSkoPzonICsgZmRlbGltICsgJ3xbXlxcXFxkXSs/KT8nO1xuICAgICAgICAgICAgICAgIHZhbGlkUGF0dGVybiArPSBleGFjdCArIGZkZWxpbTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKGZtdChkZWxpbSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvL2VtcHR5IHBhdHRlcm4gc28gdGhhdCB0aGUgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIGlucHV0IGFsaWduIHdoZW4gaXRzIGEgbm9uIG1hdGNoaW5nIHBhdHRlcm5cbiAgICAgICAgICAgICAgICB2YXIgZmRlbGltID0gZml4RGVsaW0oZGVsaW0pO1xuICAgICAgICAgICAgICAgIGV4YWN0ID0gJygnICsgZmRlbGltICsgJyknO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gJygnICsgZmRlbGltICsgJ3wpKCkoPzonICsgZmRlbGltICsgJ3woIScgKyBmZGVsaW0gKyAnKSk/JztcbiAgICAgICAgICAgICAgICB2YWxpZFBhdHRlcm4gKz0gJygpKCcgKyBmZGVsaW0gKyAnKSc7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChmbXQoZGVsaW0sIHRydWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdeJyArIHBhdHRlcm4pLCB2cmUgPSBuZXcgUmVnRXhwKCdeJyArIHZhbGlkUGF0dGVybiArICckJywgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWFrZUZvcm1hdHRlciRmb3JtYXR0ZXIoaW5wdXQsIGlzQmFja3dhcmQsIGVuZCkge1xuICAgICAgICB2cmUubGFzdEluZGV4ID0gcmUuaW5kZXggPSByZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgaWR4ID0gMCwgZCA9IDAsIHAsIHBhcnRzID0gcmUuZXhlYyhpbnB1dCksIHBvc2l0aW9uID0gZW5kIHx8IDA7XG4gICAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIC8vcmVtb3ZlIGRlbGltZXRlcnNcblxuICAgICAgICBwYXJ0cyA9IHJlLmV4ZWMoY2xlYW4ocGFydHMpKTtcbiAgICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHAgPT0gbnVsbCB8fCBwID09ICcnKVxuICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmNyID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgdmFsdWUgPSAnJywgZG9uZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluY3IgKiAzOyBpIDwgbDsgaSArPSAzLCBkKyspIHtcblxuICAgICAgICAgICAgLyppZiAocGFydHNbaV0gPT0gJycgJiYgcGFydHNbaSArIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHZhciBpc05leHRQbGFjZWhvbGRlciA9IChwYXJ0c1tpXSAhPT0gcGFydHNbaSArIDJdKSAmJiAoaGFuZGxlcnNbZCArIDFdICYmIGhhbmRsZXJzW2QgKyAxXS5wbGFjZWhvbGRlciA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICBkb25lID0gKGkgKyAzICE9PSBsKSA/IHBhcnRzW2kgKyAzXSA9PSBudWxsICYmIHBhcnRzW2kgKyA0XSA9PSBudWxsID8gaXNCYWNrd2FyZCA/IHRydWUgOiAhaXNOZXh0UGxhY2Vob2xkZXIgOiBmYWxzZSA6IGlzTmV4dFBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgdmFsdWUgKz0gaGFuZGxlcnNbZF0ocGFydHNbaV0sIHBhcnRzW2kgKyAxXSwgcGFydHNbaSArIDJdLCBkb25lID8gaXNCYWNrd2FyZCA6IGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0JhY2t3YXJkICYmIGVuZCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBmaW5kQ2hhclBvc0FmdGVyKHZhbHVlLCBpbnB1dFtlbmRdLCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1ZhbGlkOiB2YWxpZGF0b3IodmFsdWUsIHZyZSksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vU28gd2Ugb25seSBjYXJlIGFib3V0IGV2ZXJ5IDNyZCBncm91cC4gIFJlbW92ZSBkZWxpbWV0ZXJzXG4vLyBhbmQgc3VjaCwgc28gdGhlIG5leHQgcGFyc2UgY2FuIGhhdmUgc29tZXRoaW5nIG5pY2UgdG8gd29yayB3aXRoLlxuZnVuY3Rpb24gY2xlYW4ocGFydHMpIHtcbiAgICB2YXIgcCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgcCArPSBwYXJ0c1tpXSB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRWYWxpZGF0b3IodmFsdWUsIHJlZ2V4KSB7XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QodmFsdWUpO1xufVxudmFyIGRkX3l5eXkgPSBtYWtlRm9ybWF0dGVyKCcjIy8jIyMjJyk7XG5cbmZ1bmN0aW9uIHNob3J0RGF0ZSh2YWx1ZSwgaXNCYWNrc3BhY2UsIGNhcmV0KSB7XG4gICAgdmFyIHJlZiA9IGRkX3l5eXkodmFsdWUsIGlzQmFja3NwYWNlLCBjYXJldCksXG4gICAgICAgIHBhcnRzID0gLyhcXGR7MSwyfSkoW15cXGRdKz8pPyhcXGR7MCw0fSk/Ly5leGVjKHZhbHVlKSB8fCBbXSxcbiAgICAgICAgcG9zaXRpb24gPSByZWYucG9zaXRpb24sXG4gICAgICAgIHN0ciA9ICcnLFxuICAgICAgICBbd2hvbGUsIG1tLCBkZWxpbSwgbGFzdF0gPSBwYXJ0cyxcbiAgICAgICAgbW1JbnQgPSBwYXJzZUludChtbSB8fCAnMCcsIDEwKTtcblxuICAgIC8vaW52YWxpZCBtb250aCwgYmVzdCBndWVzc1xuXG4gICAgaWYgKCFpc0JhY2tzcGFjZSkge1xuICAgICAgICAvLzEzLT4wMS8zXG4gICAgICAgIGlmIChwYXJzZUludChtbSwgMTApID4gMTIpIHtcbiAgICAgICAgICAgIHN0ciA9ICcwJyArIG1tWzBdICsgJy8nO1xuICAgICAgICAgICAgbGFzdCA9IG1tWzFdICsgKGxhc3QgPT0gbnVsbCA/ICcnIDogbGFzdCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAvLzExLT4xMS9cbiAgICAgICAgaWYgKGRlbGltKSB7XG4gICAgICAgICAgICBzdHIgPSAobW1JbnQgPCAxMCA/ICcwJyArIG1tSW50IDogbW1JbnQpICsgJy8nO1xuICAgICAgICB9IGVsc2UgaWYgKG1tSW50ID4gOSkge1xuICAgICAgICAgICAgc3RyID0gbW1JbnQgKyAnLyc7XG4gICAgICAgIH0gZWxzZSBpZiAobW1JbnQgPiAxKSB7XG4gICAgICAgICAgICBzdHIgPSAnMCcgKyBtbUludCArICcvJztcbiAgICAgICAgfSBlbHNlIGlmICghbW0pIHtcbiAgICAgICAgICAgIC8vc3dhbGxvd1xuICAgICAgICB9IGVsc2UgaWYgKG1tLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc3RyID0gbW0gKyAnLyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBtbTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QgPSBwYXJzZUludChsYXN0LCAxMCk7XG4gICAgICAgICAgICBpZiAobGFzdCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnMic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QgPCAyKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcyMCcgKyBsYXN0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSAyMCkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnMjAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0IDwgMjEpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJzIwJyArIGxhc3Q7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QgPiAxMDApIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gbGFzdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcyMCcgKyBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gcmVmLnZhbHVlO1xuICAgIH1cbiAgICB2YXIgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy8nKTtcbiAgICAgICAgcGFydHMucHVzaChwYXJ0cy5wb3AoKS5yZXBsYWNlKC9eMjAvLCAnJykpO1xuICAgICAgICBzdHIgPSBwYXJ0cy5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCA3KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHN0cixcbiAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgcG9zaXRpb25cbiAgICB9O1xuXG59O1xuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yKHZhbGlkYXRvciwgbG9hZGVyKSB7XG4gICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCgwKSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbGlkYXRvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbGlkYXRvciA9IGxvYWRlci5sb2FkVmFsaWRhdG9yKHZhbGlkYXRvcikoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICF2YWxpZGF0b3IodmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbGlkYXRvciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQocmUpXG4gICAgfVxuICAgIHRocm93ICdEbyBub3Qga25vdyB3aGF0IHRvIGRvIHdpdGggJyArIHZhbGlkYXRvcjtcblxuXG59XG5mdW5jdGlvbiB0aXRsZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zdWJzdHJpbmcoMSk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXN0cmljdGVkTWl4aW4gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBtYWtlRm9ybWF0dGVyID0gbWFrZUZvcm1hdHRlcjtcbiAgICBzdGF0aWMgZm9ybWF0dGVycyA9IHtcbiAgICAgICAgdXN6aXAodmFsdWUsIGlzQmFja3NwYWNlLCBwb3NpdGlvbil7XG4gICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8fCAnJykuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHppcFJlLmV4ZWModmFsdWUpIHx8IFtdLCBpc1ZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1syXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnRzWzFdICsgJy0nICsgcGFydHNbMl1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnRzWzFdIHx8ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdmFsdWUubGVuZ3RoID09PSA1IHx8IHZhbHVlLmxlbmd0aCA9PT0gMTA7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhcGl0YWxpemUodmFsdWUsIGlzQmFja3dhcmQsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAyIHx8IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGl0bGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZSh2YWx1ZSwgaXNCYWNrd2FyZCwgcG9zaXRpb24pe1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMiB8fCBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpc0JhY2t3YXJkKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24tLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oW15cXHNdKikoXFxzKikvZywgdGl0bGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGl0Y2FyZDogJyMjIyMgIyMjIyAjIyMjICMjIyMnLFxuICAgICAgICBtbTIwWVk6IHNob3J0RGF0ZSxcbiAgICAgICAgc2hvcnREYXRlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCAuLi5yZXN0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzLCAuLi5yZXN0KTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVByb3BzKHRoaXMucHJvcHMpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMocHJvcHMpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlUHJvcHMocHJvcHMpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdGlvblJhbmdlKHRoaXMuc3RhdGUuY2FyZXQpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3Rpb25SYW5nZSh0aGlzLnN0YXRlLmNhcmV0KTtcbiAgICB9XG5cbiAgICBfaGFuZGxlUHJvcHMocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzICYmICd2YWx1ZScgaW4gcHJvcHMgJiYgcHJvcHMudmFsdWUgIT09IHRoaXMuc3RhdGUudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlID8gdGhpcy5mb3JtYXR0ZXIocHJvcHMudmFsdWUpIDoge1xuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaGFzVmFsaWRWYWx1ZSA9IHZhbHVlLmlzVmFsaWQ7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICBmb3JtYXR0ZXIodmFsdWUsIGlzQmFja3NwYWNlLCBjYXJldCkge1xuICAgICAgICBpZiAodGhpcy5fZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVyLmNhbGwodGhpcywgdmFsdWUsIGlzQmFja3NwYWNlLCBjYXJldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IHRoaXMucHJvcHMuZm9ybWF0dGVyO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9ybWF0dGVyID0gUmVzdHJpY3RlZE1peGluLmZvcm1hdHRlcnNbZm9ybWF0dGVyXSB8fCBmb3JtYXR0ZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fZm9ybWF0dGVyID0gZm9ybWF0dGVyKS5jYWxsKHRoaXMsIHZhbHVlLCBpc0JhY2tzcGFjZSwgY2FyZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2Zvcm1hdHRlciA9IG1ha2VGb3JtYXR0ZXIoZm9ybWF0dGVyLCBjcmVhdGVWYWxpZGF0b3IodGhpcy5wcm9wcy52YWxpZGF0b3IsIHRoaXMuY29udGV4dC5sb2FkZXIpKSkuY2FsbCh0aGlzLCB2YWx1ZSwgaXNCYWNrc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fZm9ybWF0dGVyID0gZm9ybWF0dGVyKS5jYWxsKHRoaXMsIHZhbHVlLCBpc0JhY2tzcGFjZSwgY2FyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGZpbmQgYSBmb3JtYXR0ZXIgZm9yICVzJywgdGhpcy5wcm9wcy5mb3JtYXR0ZXIpO1xuICAgICAgICByZXR1cm4ge3ZhbHVlfTtcbiAgICB9XG5cbiAgICBoYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25LZXlEb3duKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uS2V5RG93bi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3MgPSBlLnRhcmdldC5zZWxlY3Rpb25TdGFydCwgZW5kID0gZS50YXJnZXQuc2VsZWN0aW9uRW5kLCB2YWx1ZSA9ICh0aGlzLnN0YXRlLnZhbHVlIHx8ICcnKTtcbiAgICAgICAgaWYgKGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uVmFsaWQodGhpcy5zdGF0ZS5oYXNWYWxpZFZhbHVlLCB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZDogdGhpcy5zdGF0ZS5oYXNWYWxpZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXkgPT09ICdEZWxldGUnKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwb3MpICsgdmFsdWUuc3Vic3RyaW5nKGVuZCk7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSh2YWx1ZSwgZmFsc2UsIHBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciBiYWNrID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocG9zID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgYmFjayA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHBvcykgKyB2YWx1ZS5zdWJzdHJpbmcoZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlKHZhbHVlLCBiYWNrLCBwb3MgKyB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBpZiAoZS5rZXkgPT09ICdTaGlmdCcpe1xuICAgICAgICAgdGhpcy5fc2hpZnQgPSB0cnVlO1xuICAgICAgICAgcmV0dXJuXG4gICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICBpZiAocG9zIDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAvL1RoaXMgcHJldmVudHMgb25DaGFuZ2UgZnJvbSBmaXJpbmcuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdmFyIG52YWx1ZSA9IHZhbHVlLnNwbGl0KCcnKTtcbiAgICAgICAgICAgIHZhciBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUpO1xuICAgICAgICAgICAgaWYgKCFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgY2hhciA9IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG52YWx1ZS5zcGxpY2UocG9zLCBNYXRoLm1heChlbmQgLSBwb3MsIDEpLCBjaGFyKTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlKG52YWx1ZS5qb2luKCcnKSwgZmFsc2UsIHBvcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaGFuZGxlU3RhdGUoc3RyLCBpc0JhY2tzcGFjZSwgY2FyZXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5mb3JtYXR0ZXIoc3RyLCBpc0JhY2tzcGFjZSwgY2FyZXQpIHx8IHtpc1ZhbGlkOiBmYWxzZX07XG5cblxuICAgICAgICBpZiAoY2FyZXQgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoaXNCYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBjYXJldCArPSB2YWx1ZS5wb3NpdGlvbiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYXJldCA9IHZhbHVlLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHN0YXRlLmNhcmV0ID0gY2FyZXQ7XG4gICAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgICAgIHN0YXRlLmhhc1ZhbHVlID0gdmFsdWUudmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS52YWx1ZS5sZW5ndGggIT09IDA7XG4gICAgICAgIHN0YXRlLmhhc1ZhbGlkVmFsdWUgPSB2YWx1ZS5pc1ZhbGlkO1xuICAgICAgICAvKlxuICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICBjYXJldCxcbiAgICAgICAgIHZhbHVlOiB2YWx1ZS52YWx1ZSxcbiAgICAgICAgIGhhc1ZhbHVlOiB2YWx1ZS52YWx1ZSAhPSBudWxsICYmIHZhbHVlLnZhbHVlLmxlbmd0aCAhPT0gMCxcbiAgICAgICAgIGhhc1ZhbGlkVmFsdWU6IHZhbHVlLmlzVmFsaWRcbiAgICAgICAgIH0sIHRoaXMuaGFuZGxlU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgfVxuXG4gICAgX3ZhbHVlKHN0ciwgaXNCYWNrc3BhY2UsIGNhcmV0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaGFuZGxlU3RhdGUoc3RyLCBpc0JhY2tzcGFjZSwgY2FyZXQpO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vblZhbGlkKHZhbHVlLmlzVmFsaWQsIHZhbHVlKTtcbiAgICB9XG5cblxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvUmVzdHJpY3RlZE1peGluLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IHtyZXR1cm5GaXJzdCwgaXNBcnJheX0gZnJvbSAnLi4vdHV0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgb3B0aW9uczogUHJvcFR5cGVzLm9wdGlvbnMsXG4gICAgICAgIG11bHRpcGxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgb25DaGFuZ2U6IFByb3BUeXBlcy52YWx1ZUV2ZW50LFxuICAgICAgICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnBsYWNlaG9sZGVyXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIG9wdGlvbnM6IFtdLFxuICAgICAgICBtdWx0aXBsZTogZmFsc2VcbiAgICB9O1xuXG4gICAgaGFuZGxlU2VsZWN0ID0gKGUpPT4ge1xuICAgICAgICB2YXIge211bHRpcGxlLCBwbGFjZWhvbGRlcn0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgIC8vbm9ybWFsaXplIG11bHRpcGxlICBzZWxlY3Rpb25cbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXSwgb3B0aW9ucyA9IGUudGFyZ2V0Lm9wdGlvbnMsIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGgsIG9wdGlvbjtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24ubGFiZWwgIT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2UgaWYgKGUudGFyZ2V0LnZhbHVlID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKTtcblxuICAgIH07XG5cbiAgICByZW5kZXJPcHRpb25zKHZhbHVlKSB7XG4gICAgICAgIHZhciB7bXVsdGlwbGUsIG9wdGlvbnMsIHBsYWNlaG9sZGVyfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgW107XG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlLCByZXQgPSBvcHRpb25zLm1hcChtdWx0aXBsZSA/IChvLCBpKT0+IHtcbiAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIGtleT17J3MnICsgaX0gdmFsdWU9e28udmFsfT57by5sYWJlbH08L29wdGlvbj47XG4gICAgICAgIH0gOiAobywgaSk9PiB7XG4gICAgICAgICAgICBpZiAoIWhhc1ZhbHVlICYmIG8udmFsICsgJycgPT0gdmFsdWUgKyAnJykgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIDxvcHRpb24ga2V5PXsncycgKyBpfSB2YWx1ZT17by52YWx9PntvLmxhYmVsfTwvb3B0aW9uPlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHJldC51bnNoaWZ0KDxvcHRpb24ga2V5PXsnbnVsbC0nICsgb3B0aW9ucy5sZW5ndGh9PlxuICAgICAgICAgICAgICAgIHtwbGFjZWhvbGRlcn08L29wdGlvbj4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBvbkNoYW5nZSx2YWx1ZSwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IFt2YWx1ZV0gOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gPHNlbGVjdCB7Li4ucHJvcHN9IHZhbHVlPXt2YWx1ZX0gb25DaGFuZ2U9e3RoaXMuaGFuZGxlU2VsZWN0fT5cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlck9wdGlvbnModmFsdWUpfVxuICAgICAgICA8L3NlbGVjdD5cbiAgICB9XG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvU2VsZWN0LmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgZXNjYXBlIGZyb20gJ2xvZGFzaC9zdHJpbmcvZXNjYXBlJztcbmltcG9ydCBsb2dldCBmcm9tICdsb2Rhc2gvb2JqZWN0L2dldCc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnbG9kYXNoL29iamVjdC9kZWZhdWx0cyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnbG9kYXNoL2xhbmcvaXNPYmplY3QnO1xuXG5mdW5jdGlvbiBlc2NhcGVHZXQob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gZXNjYXBlKGxvZ2V0KG9iaiwga2V5LCAnJykpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdWJzdGl0dXRlKHN0cikge1xuXG4gICAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgICAgIHN0ciA9ICcnO1xuICAgIH1cbiAgICB2YXIgY2hlY2tzID0ge307XG5cbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlJGlubmVyKHYsIGtleSkge1xuICAgICAgICBjaGVja3Nba2V5XSA9IHRydWU7XG4gICAgICAgIHJldHVybiBcIicrKGVzY2FwZUdldChvYmosICdcIiArIGtleSArIFwiJykpKydcIjtcbiAgICB9XG5cbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpO1xuICAgIHZhciBmb3JtYXQgPSBuZXcgRnVuY3Rpb24oJ2VzY2FwZUdldCcsICdvYmonLCBcIm9iaiA9IG9iaiB8fCB7fTsgcmV0dXJuIFxcJ1wiICsgKHN0ci5yZXBsYWNlKC9cXHsoW15cXHtcXH1dKilcXH0vZywgc3Vic3RpdHV0ZSRpbm5lcikpICsgXCInXCIpLmJpbmQobnVsbCwgZXNjYXBlR2V0KTtcbiAgICB2YXIgbGlzdGVuID0gT2JqZWN0LmtleXMoY2hlY2tzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXQsXG4gICAgICAgIGxpc3RlblxuICAgIH07XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHlwZXMvU3Vic3RpdHV0ZU1peGluLmpzXG4gKiovIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VUb1N0cmluZycpLFxuICAgIGVzY2FwZUh0bWxDaGFyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZXNjYXBlSHRtbENoYXInKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInYF0vZyxcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgXCInXCIsIGFuZCBcIlxcYFwiLCBpbiBgc3RyaW5nYCB0b1xuICogdGhlaXIgY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbCBjaGFyYWN0ZXJzXG4gKiB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICogU2VlIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEJhY2t0aWNrcyBhcmUgZXNjYXBlZCBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyIDwgOSwgdGhleSBjYW4gYnJlYWsgb3V0XG4gKiBvZiBhdHRyaWJ1dGUgdmFsdWVzIG9yIEhUTUwgY29tbWVudHMuIFNlZSBbIzU5XShodHRwczovL2h0bWw1c2VjLm9yZy8jNTkpLFxuICogWyMxMDJdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDIpLCBbIzEwOF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwOCksIGFuZFxuICogWyMxMzNdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMzMpIG9mIHRoZSBbSFRNTDUgU2VjdXJpdHkgQ2hlYXRzaGVldF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZylcbiAqIHRvIHJlZHVjZSBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAvLyBSZXNldCBgbGFzdEluZGV4YCBiZWNhdXNlIGluIElFIDwgOSBgU3RyaW5nI3JlcGxhY2VgIGRvZXMgbm90LlxuICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvc3RyaW5nL2VzY2FwZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgJ2AnOiAnJiM5NjsnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKGNocikge1xuICByZXR1cm4gaHRtbEVzY2FwZXNbY2hyXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVIdG1sQ2hhcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vbG9kYXNoL2ludGVybmFsL2VzY2FwZUh0bWxDaGFyLmpzXG4gKiogbW9kdWxlIGlkID0gMzI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRJbnB1dCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICB0eXBlOiAndGV4dCdcbiAgICB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gPGlucHV0IHsuLi50aGlzLnByb3BzfVxuICAgICAgICAvPlxuICAgIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9UZXh0LmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dEFyZWEgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIDx0ZXh0YXJlYSB7Li4udGhpcy5wcm9wc30gLz5cbiAgICB9XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90eXBlcy9UZXh0QXJlYS5qc3hcbiAqKi8iLCJ2YXIgY29udGV4dCA9IHJlcXVpcmUuY29udGV4dCgnLicsIGZhbHNlLCAvXFwuanMoeCk/JC8pLCBhcGkgPSB7fTsgLy9tYWtlIHN1cmUgeW91IGhhdmUgeW91ciBkaXJlY3RvcnkgYW5kIHJlZ2V4IHRlc3Qgc2V0IGNvcnJlY3RseSFcbmNvbnRleHQua2V5cygpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBrID0ga2V5LnJlcGxhY2UoL15cXC5cXC8oLiopXFwuanMoeCk/JC8sICckMScpO1xuICAgIGFwaVtrXSA9IGNvbnRleHQoa2V5KS5kZWZhdWx0O1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Byb2Nlc3NvcnMvaW5kZXguanNcbiAqKi8iLCJ2YXIgbWFwID0ge1xuXHRcIi4vQXJyYXlQcm9jZXNzb3IuanNcIjogMzI5LFxuXHRcIi4vT3B0aW9uc1Byb2Nlc3Nvci5qc1wiOiAzMzAsXG5cdFwiLi9pbmRleC5qc1wiOiAzMjdcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18od2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkpO1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0cmV0dXJuIG1hcFtyZXFdIHx8IChmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIikgfSgpKTtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMzI4O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Byb2Nlc3NvcnMgbm9ucmVjdXJzaXZlIFxcLmpzKHgpPyRcbiAqKiBtb2R1bGUgaWQgPSAzMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHt0b0FycmF5IGFzIHZhbHVlfSBmcm9tICcuLi90dXRpbHMnO1xuY29uc3QgYXBpID0ge3ZhbHVlfTtcbmV4cG9ydCBkZWZhdWx0IGFwaTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Byb2Nlc3NvcnMvQXJyYXlQcm9jZXNzb3IuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGFwaSA9IHtcbiAgICAvKiogZmV0Y2ggd2lsbCBiZSBjYWxsZWQgd2hlbiB2YWx1ZSBjaGFuZ2VzICoqL1xuICAgIGZldGNoKHVybCwgdmFsdWUsIGNvbXBvbmVudCwgY2IpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgZGF0YSA9IChjb21wb25lbnQucHJvcHMub3B0aW9ucyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgbCA9ICgnJyArIHYudmFsKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGwuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjYihudWxsLCBkYXRhKTtcbiAgICB9LFxuICAgIC8qKlZhbHVlIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBvYmplY3QsIG5vdCBuZWNlc3NhcmlseSB3aGF0cyBpbiB0aGUgaW5wdXQgYm94KiovXG4gICAgdmFsdWUob2JqKXtcbiAgICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gbnVsbCA6IG9iai52YWwgfHwgb2JqO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHJldHVybnMgdGhlIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gdlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGZvcm1hdCh2KXtcbiAgICAgICAgcmV0dXJuIHYgPT0gbnVsbCA/IG51bGwgOiB2LmxhYmVsIHx8IHY7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgYXBpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcHJvY2Vzc29ycy9PcHRpb25zUHJvY2Vzc29yLmpzXG4gKiovIiwiLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9WQUxJREFUT1JTXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL0JvcnJvd2VkIGZyb20gYmFja2JvbmUtZm9ybXMsIHRoYW5rcyFcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKF8pIHtcblxuICAgIHZhciB2YWxpZGF0b3JzID0ge307XG5cbiAgICB2YWxpZGF0b3JzLmVyck1lc3NhZ2VzID0ge1xuICAgICAgICByZXF1aXJlZDogJ1JlcXVpcmVkJyxcbiAgICAgICAgcmVnZXhwOiAnSW52YWxpZCcsXG4gICAgICAgIG51bWJlcjogJ011c3QgYmUgYSBudW1iZXInLFxuICAgICAgICBlbWFpbDogJ0ludmFsaWQgZW1haWwgYWRkcmVzcycsXG4gICAgICAgIHVybDogJ0ludmFsaWQgVVJMJyxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgICAgIHJldHVybiAnTXVzdCBtYXRjaCBmaWVsZCBcInt9XCInXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFsaWRhdG9ycy5yZXF1aXJlZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICAgICB0eXBlOiAncmVxdWlyZWQnLFxuICAgICAgICAgICAgbWVzc2FnZTogdmFsaWRhdG9ycy5lcnJNZXNzYWdlcy5yZXF1aXJlZFxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWlyZWQodmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXy5pc0Z1bmN0aW9uKG9wdGlvbnMubWVzc2FnZSkgPyBvcHRpb25zLm1lc3NhZ2Uob3B0aW9ucykgOiBvcHRpb25zLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gJycpIHJldHVybiBlcnI7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhbGlkYXRvcnMucmVnZXhwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlZ2V4cCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIFwicmVnZXhwXCIgb3B0aW9uIGZvciBcInJlZ2V4cFwiIHZhbGlkYXRvcicpO1xuXG4gICAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICAgICB0eXBlOiAncmVnZXhwJyxcbiAgICAgICAgICAgIG1hdGNoOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogdmFsaWRhdG9ycy5lcnJNZXNzYWdlcy5yZWdleHBcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlZ2V4cCh2YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBfLmlzRnVuY3Rpb24ob3B0aW9ucy5tZXNzYWdlKSA/IG9wdGlvbnMubWVzc2FnZShvcHRpb25zKSA6IG9wdGlvbnMubWVzc2FnZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy9Eb24ndCBjaGVjayBlbXB0eSB2YWx1ZXMgKGFkZCBhICdyZXF1aXJlZCcgdmFsaWRhdG9yIGZvciB2YWxpZGF0b3JzKVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vQ3JlYXRlIFJlZ0V4cCBmcm9tIHN0cmluZyBpZiBpdCdzIHZhbGlkXG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBvcHRpb25zLnJlZ2V4cCkgb3B0aW9ucy5yZWdleHAgPSBuZXcgUmVnRXhwKG9wdGlvbnMucmVnZXhwLnJlcGxhY2UoL15cXC8oLiopXFwvJC8sICckMScpLCBvcHRpb25zLmZsYWdzKTtcblxuICAgICAgICAgICAgaWYgKChvcHRpb25zLm1hdGNoKSA/ICFvcHRpb25zLnJlZ2V4cC50ZXN0KHZhbHVlKSA6IG9wdGlvbnMucmVnZXhwLnRlc3QodmFsdWUpKSByZXR1cm4gZXJyO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3JzLm51bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHZhbGlkYXRvcnMuZXJyTWVzc2FnZXMubnVtYmVyLFxuICAgICAgICAgICAgcmVnZXhwOiAvXlswLTldKlxcLj9bMC05XSo/JC9cbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcnMucmVnZXhwKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3JzLmVtYWlsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgICAgIHR5cGU6ICdlbWFpbCcsXG4gICAgICAgICAgICBtZXNzYWdlOiB2YWxpZGF0b3JzLmVyck1lc3NhZ2VzLmVtYWlsLFxuICAgICAgICAgICAgcmVnZXhwOiAvXltcXHdcXC1dezEsfShbXFx3XFwtXFwrLl17MSwxfVtcXHdcXC1dezEsfSl7MCx9W0BdW1xcd1xcLV17MSx9KFsuXShbXFx3XFwtXXsxLH0pKXsxLDN9JC9cbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcnMucmVnZXhwKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3JzLnVybCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICAgICB0eXBlOiAndXJsJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHZhbGlkYXRvcnMuZXJyTWVzc2FnZXMudXJsLFxuICAgICAgICAgICAgcmVnZXhwOiAvXihodHRwfGh0dHBzKTpcXC9cXC8oKFtBLVowLTldW0EtWjAtOV9cXC1dKikoXFwuW0EtWjAtOV1bQS1aMC05X1xcLV0qKSspKDooXFxkKykpP1xcLz8vaVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdmFsaWRhdG9ycy5yZWdleHAob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvcnMubWF0Y2ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZmllbGQpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBcImZpZWxkXCIgb3B0aW9ucyBmb3IgXCJtYXRjaFwiIHZhbGlkYXRvcicpO1xuXG4gICAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICAgICB0eXBlOiAnbWF0Y2gnLFxuICAgICAgICAgICAgbWVzc2FnZTogdmFsaWRhdG9ycy5lcnJNZXNzYWdlcy5tYXRjaFxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2godmFsdWUsIGF0dHJzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF8uaXNGdW5jdGlvbihvcHRpb25zLm1lc3NhZ2UpID8gb3B0aW9ucy5tZXNzYWdlKG9wdGlvbnMpIDogb3B0aW9ucy5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL0Rvbid0IGNoZWNrIGVtcHR5IHZhbHVlcyAoYWRkIGEgJ3JlcXVpcmVkJyB2YWxpZGF0b3IgZm9yIHZhbGlkYXRvcnMpXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRycy5wYXRoKG9wdGlvbnMuZmllbGQpKSByZXR1cm4gZXJyO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHJldHVybiB2YWxpZGF0b3JzO1xuXG59KShyZXF1aXJlKCcuL3R1dGlscycpKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdmFsaWRhdG9ycy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHN0eWxlQ3R4ID0gcmVxdWlyZS5jb250ZXh0KCcuJywgZmFsc2UsIC9eLiotc3R5bGVcXC5qcyQvKTtcbnZhciBsZXNzQ3R4ID0gcmVxdWlyZS5jb250ZXh0KCcuJywgZmFsc2UsIC9eLipcXC4obGVzc3xjc3MpJC8pO1xuXG52YXIgYXBpID0ge307XG4vKipcbiAqIFRoaXMgbG9hZHMgdGhlIHN0eWxlLmpzIGFuZCB0aGVuIHRoZSBsZXNzL2NzcyBmaWxlcyBtZXJnaW5nXG4gKiB0aGUgc3R5bGVzIGZyb20gdGhlIGNzcyBpZiB0aGV5IGV4aXN0LlxuICovXG5zdHlsZUN0eC5rZXlzKCkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIG9ialtrZXkucmVwbGFjZSgvXlxcLlxcLyguKiktc3R5bGVcXC5qcyQvLCAnJDEnKV0gPSBzdHlsZUN0eChrZXkpO1xuICAgIHJldHVybiBvYmo7XG59LCBhcGkpXG5cbmxlc3NDdHgua2V5cygpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgICAgdmFyIG5rZXkgPSBrZXkucmVwbGFjZSgvXlxcLlxcLyguKilcXC4obGVzc3xjc3MpJC8sICckMScpO1xuICAgICAgICB2YXIgY29iaiA9IG9ialtua2V5XTtcbiAgICAgICAgdmFyIFN0eWxlID0gbGVzc0N0eChrZXkpO1xuICAgICAgICBpZiAoY29iaikge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoU3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKHNrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ialtza2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBjb2JqW3NrZXldICs9ICcgJyArIFN0eWxlW3NrZXldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvYmpbc2tleV0gPSBTdHlsZVtza2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtua2V5XSA9IFN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwgYXBpKTtcblxuY29uc29sZS5sb2coJ3N0eWxlJywgYXBpKTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL2luZGV4LmpzXG4gKiovIiwidmFyIG1hcCA9IHtcblx0XCIuL0F1dG9jb21wbGV0ZUl0ZW1UZW1wbGF0ZS1zdHlsZS5qc1wiOiAzMzQsXG5cdFwiLi9CdXR0b25zVGVtcGxhdGUtc3R5bGUuanNcIjogMzM1LFxuXHRcIi4vQ2hlY2tib3hUZW1wbGF0ZS1zdHlsZS5qc1wiOiAzMzYsXG5cdFwiLi9DaGVja2JveGVzR3JvdXBUZW1wbGF0ZS1zdHlsZS5qc1wiOiAzMzcsXG5cdFwiLi9Db2xsZWN0aW9uQ3JlYXRlVGVtcGxhdGUtc3R5bGUuanNcIjogMzM4LFxuXHRcIi4vQ29sbGVjdGlvbk1peGluLXN0eWxlLmpzXCI6IDMzOSxcblx0XCIuL0VkaXRvclRlbXBsYXRlLXN0eWxlLmpzXCI6IDM0MCxcblx0XCIuL0Zvcm1UZW1wbGF0ZS1zdHlsZS5qc1wiOiAzNDEsXG5cdFwiLi9JdGVtVG9TdHJpbmdUZW1wbGF0ZS1zdHlsZS5qc1wiOiAzNDIsXG5cdFwiLi9MaXN0LXN0eWxlLmpzXCI6IDM0Myxcblx0XCIuL0xpc3RJdGVtVGVtcGxhdGUtc3R5bGUuanNcIjogMzQ0LFxuXHRcIi4vTWl4ZWQtc3R5bGUuanNcIjogMzQ1LFxuXHRcIi4vTW9kYWxUZW1wbGF0ZS1zdHlsZS5qc1wiOiAzNDYsXG5cdFwiLi9SYWRpb0l0ZW1UZW1wbGF0ZS1zdHlsZS5qc1wiOiAzNDdcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18od2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkpO1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0cmV0dXJuIG1hcFtyZXFdIHx8IChmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIikgfSgpKTtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMzMzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3N0eWxlcyBub25yZWN1cnNpdmUgXi4qLXN0eWxlXFwuanMkXG4gKiogbW9kdWxlIGlkID0gMzMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpdGVtOiAnYWRkcl9pdG0gbGlzdC1ncm91cC1pdGVtICcsXG4gICAgZm9jdXNlZDogJ2ZvY3VzZWQnXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvQXV0b2NvbXBsZXRlSXRlbVRlbXBsYXRlLXN0eWxlLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYnV0dG9uczogJ2NvbC1zbS1vZmZzZXQtMiBjb2wtc20tMTAgYnRuLWdyb3VwJyxcbiAgICBidXR0b246ICdidG4nLFxuICAgIGJ1dHRvbkNvbnRhaW5lcjogXCJmb3JtLWdyb3VwXCIsXG4gICAgcHJpbWFyeTogJ2J0bi1wcmltYXJ5J1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9CdXR0b25zVGVtcGxhdGUtc3R5bGUuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBcImNoZWNrYm94XCI6IFwiY2hlY2tib3hcIixcbiAgICBcImNoZWNrZWRcIjogXCJjaGVja2VkXCJcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9DaGVja2JveFRlbXBsYXRlLXN0eWxlLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgXCJncm91cFwiOlwiZ3JvdXBcIlxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL0NoZWNrYm94ZXNHcm91cFRlbXBsYXRlLXN0eWxlLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFuZWw6IFwicGFuZWwgcGFuZWwtZGVmYXVsdCBjbGVhcmZpeFwiLFxuICAgIHBhbmVsVGl0bGU6ICdwYW5lbC10aXRsZSBjbGVhcmZpeCcsXG4gICAgcGFuZWxIZWFkaW5nOiAncGFuZWwtaGVhZGluZycsXG4gICAgcGFuZWxCb2R5OiBcInBhbmVsLWJvZHlcIixcbiAgICBncm91cDogXCJmb3JtLWdyb3VwXCIsXG4gICAgaW5saW5lOiBcImNsZWFyZml4XCJcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvQ29sbGVjdGlvbkNyZWF0ZVRlbXBsYXRlLXN0eWxlLmpzXG4gKiovIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhZGRCdG46ICdidG4gYnRuLXhzIGJ0bi1kZWZhdWx0JyxcbiAgICBpY29uQWRkOiBcImljb24tYWRkXCJcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvQ29sbGVjdGlvbk1peGluLXN0eWxlLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZmllbGQ6ICdmb3JtLWdyb3VwIGZpZWxkLW5hbWUgJyxcbiAgICBsYWJlbDogXCJjb2wtc20tMiBjb250cm9sLWxhYmVsXCIsXG4gICAgZXJyb3I6ICdlcnJvci1ibG9jayBoZWxwLWJsb2NrJyxcbiAgICBoZWxwOiAnaGVscC1ibG9jaycsXG4gICAgaGFzRXJyb3I6ICdoYXMtZXJyb3InLFxuICAgIGhhc1RpdGxlOiBcImNvbC1zbS0xMFwiLFxuICAgIG5vVGl0bGU6IFwiY29sLXNtLTEyXCJcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvRWRpdG9yVGVtcGxhdGUtc3R5bGUuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvL3VzZSB0byBiZSBmb3JtLWhvcml6b250YWxcbiAgICBmb3JtQ2xhc3M6ICcnXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvRm9ybVRlbXBsYXRlLXN0eWxlLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbGFiZWw6IFwiYnJmLXZhbHVlIGxpc3QtZ3JvdXAtaXRlbS10ZXh0XCJcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9JdGVtVG9TdHJpbmdUZW1wbGF0ZS1zdHlsZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGl0ZW06IFwiYnJmLXZhbHVlIGxpc3QtZ3JvdXAtaXRlbS10ZXh0XCJcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvTGlzdC1zdHlsZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vdmVVcDogJ2dseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi11cCBidG4tdXAnLFxuICAgIG1vdmVEb3duOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd24gYnRuLWRvd24nLFxuICAgIGRlbGV0ZTogJ2dseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlIGJ0bi1kZWxldGUnLFxuICAgIGl0ZW1WYWx1ZTogXCJpdGVtLXZhbHVlIGJ0bi1lZGl0XCIsXG4gICAgYnV0dG9uOiAnYnRuIGJ0bi14cyBidG4tZGVmYXVsdCcsXG4gICAgbGlzdEdyb3VwSXRlbTogJ2xpc3QtZ3JvdXAtaXRlbScsXG4gICAgaGFzRXJyb3I6ICdoYXMtZXJyb3InLFxuICAgIGhlbHA6IFwiaGVscC1ibG9ja1wiLFxuICAgIGNsaWNrYWJsZTogJ2NsaWNrYWJsZScsXG4gICAgY3RybEJ1dHRvbnM6J2J0bi1ncm91cCdcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvTGlzdEl0ZW1UZW1wbGF0ZS1zdHlsZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGl0ZW06XCJicmYta2V5IGxpc3QtZ3JvdXAtaXRlbS1oZWFkaW5nXCIsXG4gICAgaXRlbUlubmVyOlwiYnJmLXZhbHVlIGxpc3QtZ3JvdXAtaXRlbS10ZXh0XCIsXG4gICAgYnV0dG9uc0NsYXNzOididG4tZ3JvdXAgcHVsbC1yaWdodCcsXG4gICAgYnV0dG9uQ2FuY2VsOiAnYnRuIGJ0bi1kZWZhdWx0JyxcbiAgICBidXR0b25TYXZlOididG4tcHJpbWFyeSBidG4nXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL01peGVkLXN0eWxlLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbmFtZXNwYWNlOidtb2RhbCcsXG4gICAgYmFja2Ryb3A6XCJtb2RhbC1iYWNrZHJvcCBmYWRlIGluXCIsXG4gICAgZGlhbG9nOlwibW9kYWwtZGlhbG9nXCIsXG4gICAgY29udGVudDpcIm1vZGFsLWNvbnRlbnRcIixcbiAgICBjbG9zZTonY2xvc2UnLFxuICAgIGJvZHk6J21vZGFsLWJvZHkgY2xlYXJmaXgnLFxuICAgIGhlYWRlcjonbW9kYWwtaGVhZGVyJyxcbiAgICBmb290ZXI6XCJtb2RhbC1mb290ZXJcIixcbiAgICBvdmVybGF5OicnXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL01vZGFsVGVtcGxhdGUtc3R5bGUuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBuYW1lc3BhY2U6IFwicmFkaW9cIixcbiAgICBjaGVja2VkOiAnJyxcbiAgICB1bmNoZWNrZWQ6Jydcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvUmFkaW9JdGVtVGVtcGxhdGUtc3R5bGUuanNcbiAqKi8iLCJ2YXIgbWFwID0ge1xuXHRcIi4vQXV0b2NvbXBsZXRlLmxlc3NcIjogMzQ5LFxuXHRcIi4vTGlzdEl0ZW1UZW1wbGF0ZS5sZXNzXCI6IDM1Myxcblx0XCIuL1dpemFyZFByb2dyZXNzVGVtcGxhdGUubGVzc1wiOiAzNTUsXG5cdFwiLi9XaXphcmRUZW1wbGF0ZS5sZXNzXCI6IDM1N1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRyZXR1cm4gbWFwW3JlcV0gfHwgKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKSB9KCkpO1xufTtcbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAzNDg7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzIG5vbnJlY3Vyc2l2ZSBeLipcXC4obGVzc3xjc3MpJFxuICoqIG1vZHVsZSBpZCA9IDM0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vQXV0b2NvbXBsZXRlLmxlc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMmaW1wb3J0TG9hZGVycz0xJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fX1toYXNoOmJhc2U2NDo1XSEuLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL0F1dG9jb21wbGV0ZS5sZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMmaW1wb3J0TG9hZGVycz0xJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fX1toYXNoOmJhc2U2NDo1XSEuLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL0F1dG9jb21wbGV0ZS5sZXNzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL0F1dG9jb21wbGV0ZS5sZXNzXG4gKiogbW9kdWxlIGlkID0gMzQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5BdXRvY29tcGxldGVfX25hbWVzcGFjZV9fXzFOVDEtIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLkF1dG9jb21wbGV0ZV9fZm91bmRfX18zUHVMRCAuZm9ybS1jb250cm9sIHtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG59XFxuLkF1dG9jb21wbGV0ZV9fZm91bmRfX18zUHVMRCAuQXV0b2NvbXBsZXRlX19saXN0R3JvdXBfX18xQjlaNSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDEwMCU7XFxuICBsZWZ0OiAwO1xcbiAgei1pbmRleDogMTAwMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbn1cXG4uQXV0b2NvbXBsZXRlX19mb3VuZF9fXzNQdUxEIC5saXN0LWdyb3VwLWl0ZW06Zmlyc3QtY2hpbGQge1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcDogbm9uZTtcXG59XFxuLkF1dG9jb21wbGV0ZV9fZm91bmRfX18zUHVMRCAubGlzdC1ncm91cC1pdGVtIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLkF1dG9jb21wbGV0ZV9fZm91bmRfX18zUHVMRCAubGlzdC1ncm91cC1pdGVtOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxufVxcbi5BdXRvY29tcGxldGVfX2ZvdW5kX19fM1B1TEQgLmZvY3VzZWQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2RkZDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwibmFtZXNwYWNlXCI6IFwiQXV0b2NvbXBsZXRlX19uYW1lc3BhY2VfX18xTlQxLVwiLFxuXHRcImZvdW5kXCI6IFwiQXV0b2NvbXBsZXRlX19mb3VuZF9fXzNQdUxEXCIsXG5cdFwibGlzdEdyb3VwXCI6IFwiQXV0b2NvbXBsZXRlX19saXN0R3JvdXBfX18xQjlaNVwiXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vY3NzLWxvYWRlcj9tb2R1bGVzJmltcG9ydExvYWRlcnM9MSZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX19baGFzaDpiYXNlNjQ6NV0hLi4vc3Vic2NoZW1hL34vbGVzcy1sb2FkZXIhLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvQXV0b2NvbXBsZXRlLmxlc3NcbiAqKiBtb2R1bGUgaWQgPSAzNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMzUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcclxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XHJcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuXHJcblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xyXG5cclxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmV3TGlzdCkge1xyXG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xyXG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xyXG5cdFx0dmFyIGlkID0gaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXHJcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblx0cmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcclxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xyXG5cdFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcclxuXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xyXG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcclxuXHRpZihpZHggPj0gMCkge1xyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XHJcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XHJcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XHJcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcclxuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XHJcblx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcclxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXHJcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMmaW1wb3J0TG9hZGVycz0xJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fX1toYXNoOmJhc2U2NDo1XSEuLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL0xpc3RJdGVtVGVtcGxhdGUubGVzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vTGlzdEl0ZW1UZW1wbGF0ZS5sZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMmaW1wb3J0TG9hZGVycz0xJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fX1toYXNoOmJhc2U2NDo1XSEuLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL0xpc3RJdGVtVGVtcGxhdGUubGVzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3N0eWxlcy9MaXN0SXRlbVRlbXBsYXRlLmxlc3NcbiAqKiBtb2R1bGUgaWQgPSAzNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLkxpc3RJdGVtVGVtcGxhdGVfX2N0cmxCdXR0b25zX19fZlFYQ18ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1cHg7XFxuICByaWdodDogNXB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWluLXdpZHRoOiAxMHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbiAgY29sb3I6ICNmZmY7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG59XFxuLkxpc3RJdGVtVGVtcGxhdGVfX2xpc3RFZGl0b3JfX18zTGwxNCA+IHVsIHtcXG4gIG1hcmdpbi10b3A6IDEwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcImN0cmxCdXR0b25zXCI6IFwiTGlzdEl0ZW1UZW1wbGF0ZV9fY3RybEJ1dHRvbnNfX19mUVhDX1wiLFxuXHRcImxpc3RFZGl0b3JcIjogXCJMaXN0SXRlbVRlbXBsYXRlX19saXN0RWRpdG9yX19fM0xsMTRcIlxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2Nzcy1sb2FkZXI/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4uL3N1YnNjaGVtYS9+L2xlc3MtbG9hZGVyIS4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL0xpc3RJdGVtVGVtcGxhdGUubGVzc1xuICoqIG1vZHVsZSBpZCA9IDM1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZS5sZXNzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9tb2R1bGVzJmltcG9ydExvYWRlcnM9MSZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX19baGFzaDpiYXNlNjQ6NV0hLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9XaXphcmRQcm9ncmVzc1RlbXBsYXRlLmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZS5sZXNzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL1dpemFyZFByb2dyZXNzVGVtcGxhdGUubGVzc1xuICoqIG1vZHVsZSBpZCA9IDM1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZV9fbmFtZXNwYWNlX19fMXlwZW8ge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZy1ib3R0b206IDIuMnJlbTtcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXG4gIGRpc3BsYXk6IHRhYmxlO1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgcGFkZGluZy1yaWdodDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG4uV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZV9fdG9kb19fXzNSU2lMLFxcbi5XaXphcmRQcm9ncmVzc1RlbXBsYXRlX19kb2luZ19fXzN0c09mLFxcbi5XaXphcmRQcm9ncmVzc1RlbXBsYXRlX19kb25lX19fM2JXVEIge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbGluZS1oZWlnaHQ6IDQuNXJlbTtcXG4gIHBhZGRpbmc6IDAgMC43cmVtO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZGlzcGxheTogdGFibGUtY2VsbDtcXG59XFxuLldpemFyZFByb2dyZXNzVGVtcGxhdGVfX3RvZG9fX18zUlNpTCB7XFxuICBjb2xvcjogc2lsdmVyO1xcbiAgYm9yZGVyLWJvdHRvbTogNHB4IHNvbGlkIHNpbHZlcjtcXG59XFxuLldpemFyZFByb2dyZXNzVGVtcGxhdGVfX2RvaW5nX19fM3RzT2Yge1xcbiAgY29sb3I6IGJsYWNrO1xcbiAgYm9yZGVyLWJvdHRvbTogNHB4IHNvbGlkICMzM0MzRjA7XFxufVxcbi5XaXphcmRQcm9ncmVzc1RlbXBsYXRlX19kb25lX19fM2JXVEIge1xcbiAgY29sb3I6IGJsYWNrO1xcbiAgYm9yZGVyLWJvdHRvbTogNHB4IHNvbGlkICMzM0MzRjA7XFxufVxcbi5XaXphcmRQcm9ncmVzc1RlbXBsYXRlX190b2RvX19fM1JTaUwgc3BhbixcXG4uV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZV9fZG9pbmdfX18zdHNPZiBzcGFuLFxcbi5XaXphcmRQcm9ncmVzc1RlbXBsYXRlX19kb25lX19fM2JXVEIgc3BhbiB7XFxuICBwYWRkaW5nOiAwIDEuNXJlbTtcXG59XFxuLldpemFyZFByb2dyZXNzVGVtcGxhdGVfX3RvZG9fX18zUlNpTCBlbSxcXG4uV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZV9fZG9pbmdfX18zdHNPZiBlbSxcXG4uV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZV9fZG9uZV9fXzNiV1RCIGVtIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBmb250LXdlaWdodDogNzAwO1xcbiAgcGFkZGluZy1sZWZ0OiAxcmVtO1xcbn1cXG4uV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZV9fdG9kb19fXzNSU2lMOmJlZm9yZSxcXG4uV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZV9fZG9pbmdfX18zdHNPZjpiZWZvcmUsXFxuLldpemFyZFByb2dyZXNzVGVtcGxhdGVfX2RvbmVfX18zYldUQjpiZWZvcmUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYm90dG9tOiAtMy43cmVtO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBsZWZ0OiA1MCU7XFxufVxcbi5XaXphcmRQcm9ncmVzc1RlbXBsYXRlX19kb2luZ19fXzN0c09mOmhvdmVyOmJlZm9yZSxcXG4uV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZV9fZG9uZV9fXzNiV1RCOmhvdmVyOmJlZm9yZSB7XFxuICBjb2xvcjogIzBGQTBDRTtcXG59XFxuLldpemFyZFByb2dyZXNzVGVtcGxhdGVfX3RvZG9fX18zUlNpTDpob3ZlcjpiZWZvcmUge1xcbiAgY29sb3I6ICMyMDNjMzE7XFxufVxcbi5XaXphcmRQcm9ncmVzc1RlbXBsYXRlX190b2RvX19fM1JTaUw6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMjAyMlxcXCI7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBzaWx2ZXI7XFxuICBib3JkZXItY29sb3I6IHdoaXRlO1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICB3aWR0aDogMS4yZW07XFxuICBoZWlnaHQ6IDEuMmVtO1xcbiAgYm9yZGVyLXdpZHRoOiAwcHg7XFxuICBsaW5lLWhlaWdodDogMS4yZW07XFxuICBib3JkZXItcmFkaXVzOiAxLjJlbTtcXG59XFxuLldpemFyZFByb2dyZXNzVGVtcGxhdGVfX2RvaW5nX19fM3RzT2Y6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMjAyMlxcXCI7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzNDM0YwO1xcbiAgd2lkdGg6IDEuMmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMmVtO1xcbiAgYm9yZGVyLXJhZGl1czogMS4yZW07XFxufVxcbi5XaXphcmRQcm9ncmVzc1RlbXBsYXRlX19kb25lX19fM2JXVEI6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMjcxM1xcXCI7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzNDM0YwO1xcbiAgd2lkdGg6IDEuMmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMmVtO1xcbiAgYm9yZGVyLXJhZGl1czogMS4yZW07XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcIm5hbWVzcGFjZVwiOiBcIldpemFyZFByb2dyZXNzVGVtcGxhdGVfX25hbWVzcGFjZV9fXzF5cGVvXCIsXG5cdFwidG9kb1wiOiBcIldpemFyZFByb2dyZXNzVGVtcGxhdGVfX3RvZG9fX18zUlNpTFwiLFxuXHRcImRvaW5nXCI6IFwiV2l6YXJkUHJvZ3Jlc3NUZW1wbGF0ZV9fZG9pbmdfX18zdHNPZlwiLFxuXHRcImRvbmVcIjogXCJXaXphcmRQcm9ncmVzc1RlbXBsYXRlX19kb25lX19fM2JXVEJcIlxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2Nzcy1sb2FkZXI/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4uL3N1YnNjaGVtYS9+L2xlc3MtbG9hZGVyIS4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL1dpemFyZFByb2dyZXNzVGVtcGxhdGUubGVzc1xuICoqIG1vZHVsZSBpZCA9IDM1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vV2l6YXJkVGVtcGxhdGUubGVzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vV2l6YXJkVGVtcGxhdGUubGVzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9tb2R1bGVzJmltcG9ydExvYWRlcnM9MSZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX19baGFzaDpiYXNlNjQ6NV0hLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9XaXphcmRUZW1wbGF0ZS5sZXNzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvc3R5bGVzL1dpemFyZFRlbXBsYXRlLmxlc3NcbiAqKiBtb2R1bGUgaWQgPSAzNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLldpemFyZFRlbXBsYXRlX190cmFuc2l0aW9uQ29udGFpbmVyX19fMzZxTWMge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICBtaW4td2lkdGg6IDEwMCU7XFxufVxcbi5XaXphcmRUZW1wbGF0ZV9fdHJhbnNpdGlvbkNvbnRhaW5lcl9fXzM2cU1jIGZvcm0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1pbi13aWR0aDogMTAwJTtcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJ0cmFuc2l0aW9uQ29udGFpbmVyXCI6IFwiV2l6YXJkVGVtcGxhdGVfX3RyYW5zaXRpb25Db250YWluZXJfX18zNnFNY1wiXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL34vY3NzLWxvYWRlcj9tb2R1bGVzJmltcG9ydExvYWRlcnM9MSZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX19baGFzaDpiYXNlNjQ6NV0hLi4vc3Vic2NoZW1hL34vbGVzcy1sb2FkZXIhLi4vc3Vic2NoZW1hL3NyYy9zdHlsZXMvV2l6YXJkVGVtcGxhdGUubGVzc1xuICoqIG1vZHVsZSBpZCA9IDM1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgc3R5bGVDdHggPSByZXF1aXJlLmNvbnRleHQoJy4nLCBmYWxzZSwgL14uKi1zdHlsZVxcLmpzJC8pO1xudmFyIGxlc3NDdHggPSByZXF1aXJlLmNvbnRleHQoJy4nLCBmYWxzZSwgL14uKlxcLihsZXNzfGNzcykkLyk7XG5cbi8qKlxuICogVGhpcyBsb2FkcyB0aGUgc3R5bGUuanMgYW5kIHRoZW4gdGhlIGxlc3MvY3NzIGZpbGVzIG1lcmdpbmdcbiAqIHRoZSBzdHlsZXMgZnJvbSB0aGUgY3NzIGlmIHRoZXkgZXhpc3QuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gbGVzc0N0eC5rZXlzKCkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgICAgICB2YXIgbmtleSA9IGtleS5yZXBsYWNlKC9eXFwuXFwvKC4qKVxcLihsZXNzfGNzcykkLywgJyQxJyk7XG4gICAgICAgIHZhciBjb2JqID0gb2JqW25rZXldO1xuICAgICAgICB2YXIgU3R5bGUgPSBsZXNzQ3R4KGtleSk7XG4gICAgICAgIGlmIChjb2JqKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChza2V5KSB7XG4gICAgICAgICAgICAgICAgWydFbnRlcicsICdMZWF2ZScsICdBcHBlYXInXS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsa2V5ID0gay50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2JqID0gb2JqLnRyYW5zaXRpb25OYW1lIHx8IChvYmoudHJhbnNpdGlvbk5hbWUgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChTdHlsZVtgJHtza2V5fSR7a31gXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ialtsa2V5XSA9IFN0eWxlW2Ake3NrZXl9JHtrfWBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ialtgJHtsa2V5fUFjdGl2ZWBdID0gU3R5bGVbYCR7c2tleX0ke2t9QWN0aXZlYF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9LCBjb2JqW3NrZXldKVtgdHJhbnNpdGlvbkhlaWdodENsYXNzYF0gPSBTdHlsZVtgJHtza2V5fUhlaWdodGBdXG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW25rZXldID0gU3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIC8vRmlyc3QgZmluZCB0aGUgc3R5bGUuanMuXG4gICAgc3R5bGVDdHgua2V5cygpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgICAgb2JqW2tleS5yZXBsYWNlKC9eXFwuXFwvKC4qKS1zdHlsZVxcLmpzJC8sICckMScpXSA9IHN0eWxlQ3R4KGtleSk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSkpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90cmFuc2l0aW9uL2luZGV4LmpzXG4gKiovIiwidmFyIG1hcCA9IHtcblx0XCIuL3RyYW5zaXRpb25zLXN0eWxlLmpzXCI6IDM2MVxufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRyZXR1cm4gbWFwW3JlcV0gfHwgKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKSB9KCkpO1xufTtcbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAzNjA7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHJhbnNpdGlvbiBub25yZWN1cnNpdmUgXi4qLXN0eWxlXFwuanMkXG4gKiogbW9kdWxlIGlkID0gMzYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByb2xsVXA6IHtcbiAgICAgICAgdHJhbnNpdGlvbkFwcGVhclRpbWVvdXQ6IDgwMCxcbiAgICAgICAgdHJhbnNpdGlvbkVudGVyVGltZW91dDogODAwLFxuICAgICAgICB0cmFuc2l0aW9uTGVhdmVUaW1lb3V0OiA4MDBcbiAgICB9LFxuICAgIHNsaWRlTGVmdDoge1xuICAgICAgICB0cmFuc2l0aW9uQXBwZWFyVGltZW91dDogNTAwLFxuICAgICAgICB0cmFuc2l0aW9uRW50ZXJUaW1lb3V0OiA1MDAsXG4gICAgICAgIHRyYW5zaXRpb25MZWF2ZVRpbWVvdXQ6IDUwMFxuICAgIH0sXG4gICAgc2xpZGVSaWdodDoge1xuICAgICAgICB0cmFuc2l0aW9uQXBwZWFyVGltZW91dDogNTAwLFxuICAgICAgICB0cmFuc2l0aW9uRW50ZXJUaW1lb3V0OiA1MDAsXG4gICAgICAgIHRyYW5zaXRpb25MZWF2ZVRpbWVvdXQ6IDUwMFxuICAgIH1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90cmFuc2l0aW9uL3RyYW5zaXRpb25zLXN0eWxlLmpzXG4gKiovIiwidmFyIG1hcCA9IHtcblx0XCIuL3RyYW5zaXRpb25zLmxlc3NcIjogMzYzXG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHJldHVybiBtYXBbcmVxXSB8fCAoZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpIH0oKSk7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDM2MjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc3Vic2NoZW1hL3NyYy90cmFuc2l0aW9uIG5vbnJlY3Vyc2l2ZSBeLipcXC4obGVzc3xjc3MpJFxuICoqIG1vZHVsZSBpZCA9IDM2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vdHJhbnNpdGlvbnMubGVzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vdHJhbnNpdGlvbnMubGVzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9tb2R1bGVzJmltcG9ydExvYWRlcnM9MSZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX19baGFzaDpiYXNlNjQ6NV0hLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi90cmFuc2l0aW9ucy5sZXNzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9ucy5sZXNzXG4gKiogbW9kdWxlIGlkID0gMzYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50cmFuc2l0aW9uc19fcm9sbFVwTGVhdmVfX18zdkFOZCB7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTtcXG4gIG9wYWNpdHk6IDE7XFxufVxcbi50cmFuc2l0aW9uc19fcm9sbFVwTGVhdmVfX18zdkFOZC50cmFuc2l0aW9uc19fcm9sbFVwTGVhdmVBY3RpdmVfX193bnVMWCB7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAtMTAwJSk7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSA4MDBtcyBlYXNlLWluLW91dCwgdHJhbnNmb3JtIDgwMG1zIGVhc2UtaW4tb3V0O1xcbn1cXG4udHJhbnNpdGlvbnNfX3JvbGxVcEVudGVyX19fMzlNc08sXFxuLnRyYW5zaXRpb25zX19yb2xsVXBBcHBlYXJfX19ZSkEzTiB7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAtMTAwJSk7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG4udHJhbnNpdGlvbnNfX3JvbGxVcEVudGVyX19fMzlNc08udHJhbnNpdGlvbnNfX3JvbGxVcEVudGVyQWN0aXZlX19fTUVVZlosXFxuLnRyYW5zaXRpb25zX19yb2xsVXBBcHBlYXJfX19ZSkEzTi50cmFuc2l0aW9uc19fcm9sbFVwRW50ZXJBY3RpdmVfX19NRVVmWixcXG4udHJhbnNpdGlvbnNfX3JvbGxVcEVudGVyX19fMzlNc08udHJhbnNpdGlvbnNfX3JvbGxVcEFwcGVhckFjdGl2ZV9fX1EtSzJULFxcbi50cmFuc2l0aW9uc19fcm9sbFVwQXBwZWFyX19fWUpBM04udHJhbnNpdGlvbnNfX3JvbGxVcEFwcGVhckFjdGl2ZV9fX1EtSzJUIHtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApO1xcbiAgb3BhY2l0eTogMTtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgODAwbXMgZWFzZS1pbi1vdXQsIHRyYW5zZm9ybSA4MDBtcyBlYXNlLWluLW91dDtcXG59XFxuLnRyYW5zaXRpb25zX19yb2xsVXBIZWlnaHRfX19fdE5FYiB7XFxuICB0cmFuc2l0aW9uOiBoZWlnaHQgODAwbXMgZWFzZS1pbi1vdXQ7XFxufVxcbi50cmFuc2l0aW9uc19fc2xpZGVSaWdodExlYXZlX19fMjFOMGsge1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDUwMG1zIGVhc2UtaW4tb3V0O1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7XFxufVxcbi50cmFuc2l0aW9uc19fc2xpZGVSaWdodExlYXZlQWN0aXZlX19fMzNSTXAge1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTAwJSwgMCk7XFxufVxcbi50cmFuc2l0aW9uc19fc2xpZGVSaWdodEVudGVyX19fMmNUeDMsXFxuLnRyYW5zaXRpb25zX19zbGlkZVJpZ2h0QXBwZWFyX19fY1hqVzEge1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDUwMG1zIGVhc2UtaW4tb3V0O1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwMCUsIDApO1xcbn1cXG4udHJhbnNpdGlvbnNfX3NsaWRlUmlnaHRFbnRlckFjdGl2ZV9fXzFkdFplLFxcbi50cmFuc2l0aW9uc19fc2xpZGVSaWdodEFwcGVhckFjdGl2ZV9fXzJNanllIHtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApO1xcbn1cXG4udHJhbnNpdGlvbnNfX3NsaWRlUmlnaHRIZWlnaHRfX18xSUZBUSB7XFxuICB0cmFuc2l0aW9uOiBoZWlnaHQgNTAwbXMgZWFzZS1pbi1vdXQ7XFxufVxcbi50cmFuc2l0aW9uc19fc2xpZGVMZWZ0TGVhdmVfX18yOV9wNCB7XFxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gNTAwbXMgZWFzZS1pbi1vdXQ7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTtcXG59XFxuLnRyYW5zaXRpb25zX19zbGlkZUxlZnRMZWF2ZUFjdGl2ZV9fXzJDbDVEIHtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0xMDAlLCAwKTtcXG59XFxuLnRyYW5zaXRpb25zX19zbGlkZUxlZnRFbnRlcl9fX25UZXFBLFxcbi50cmFuc2l0aW9uc19fc2xpZGVMZWZ0QXBwZWFyX19fMVpBTmoge1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDUwMG1zIGVhc2UtaW4tb3V0O1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTAwJSwgMCk7XFxufVxcbi50cmFuc2l0aW9uc19fc2xpZGVMZWZ0RW50ZXJBY3RpdmVfX18zOGhydCxcXG4udHJhbnNpdGlvbnNfX3NsaWRlTGVmdEFwcGVhckFjdGl2ZV9fXzNMOFp5IHtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApO1xcbn1cXG4udHJhbnNpdGlvbnNfX3NsaWRlTGVmdEhlaWdodF9fXzNxQS15IHtcXG4gIHRyYW5zaXRpb246IGhlaWdodCA1MDBtcyBlYXNlLWluLW91dDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwicm9sbFVwTGVhdmVcIjogXCJ0cmFuc2l0aW9uc19fcm9sbFVwTGVhdmVfX18zdkFOZFwiLFxuXHRcInJvbGxVcExlYXZlQWN0aXZlXCI6IFwidHJhbnNpdGlvbnNfX3JvbGxVcExlYXZlQWN0aXZlX19fd251TFhcIixcblx0XCJyb2xsVXBFbnRlclwiOiBcInRyYW5zaXRpb25zX19yb2xsVXBFbnRlcl9fXzM5TXNPXCIsXG5cdFwicm9sbFVwQXBwZWFyXCI6IFwidHJhbnNpdGlvbnNfX3JvbGxVcEFwcGVhcl9fX1lKQTNOXCIsXG5cdFwicm9sbFVwRW50ZXJBY3RpdmVcIjogXCJ0cmFuc2l0aW9uc19fcm9sbFVwRW50ZXJBY3RpdmVfX19NRVVmWlwiLFxuXHRcInJvbGxVcEFwcGVhckFjdGl2ZVwiOiBcInRyYW5zaXRpb25zX19yb2xsVXBBcHBlYXJBY3RpdmVfX19RLUsyVFwiLFxuXHRcInJvbGxVcEhlaWdodFwiOiBcInRyYW5zaXRpb25zX19yb2xsVXBIZWlnaHRfX19fdE5FYlwiLFxuXHRcInNsaWRlUmlnaHRMZWF2ZVwiOiBcInRyYW5zaXRpb25zX19zbGlkZVJpZ2h0TGVhdmVfX18yMU4wa1wiLFxuXHRcInNsaWRlUmlnaHRMZWF2ZUFjdGl2ZVwiOiBcInRyYW5zaXRpb25zX19zbGlkZVJpZ2h0TGVhdmVBY3RpdmVfX18zM1JNcFwiLFxuXHRcInNsaWRlUmlnaHRFbnRlclwiOiBcInRyYW5zaXRpb25zX19zbGlkZVJpZ2h0RW50ZXJfX18yY1R4M1wiLFxuXHRcInNsaWRlUmlnaHRBcHBlYXJcIjogXCJ0cmFuc2l0aW9uc19fc2xpZGVSaWdodEFwcGVhcl9fX2NYalcxXCIsXG5cdFwic2xpZGVSaWdodEVudGVyQWN0aXZlXCI6IFwidHJhbnNpdGlvbnNfX3NsaWRlUmlnaHRFbnRlckFjdGl2ZV9fXzFkdFplXCIsXG5cdFwic2xpZGVSaWdodEFwcGVhckFjdGl2ZVwiOiBcInRyYW5zaXRpb25zX19zbGlkZVJpZ2h0QXBwZWFyQWN0aXZlX19fMk1qeWVcIixcblx0XCJzbGlkZVJpZ2h0SGVpZ2h0XCI6IFwidHJhbnNpdGlvbnNfX3NsaWRlUmlnaHRIZWlnaHRfX18xSUZBUVwiLFxuXHRcInNsaWRlTGVmdExlYXZlXCI6IFwidHJhbnNpdGlvbnNfX3NsaWRlTGVmdExlYXZlX19fMjlfcDRcIixcblx0XCJzbGlkZUxlZnRMZWF2ZUFjdGl2ZVwiOiBcInRyYW5zaXRpb25zX19zbGlkZUxlZnRMZWF2ZUFjdGl2ZV9fXzJDbDVEXCIsXG5cdFwic2xpZGVMZWZ0RW50ZXJcIjogXCJ0cmFuc2l0aW9uc19fc2xpZGVMZWZ0RW50ZXJfX19uVGVxQVwiLFxuXHRcInNsaWRlTGVmdEFwcGVhclwiOiBcInRyYW5zaXRpb25zX19zbGlkZUxlZnRBcHBlYXJfX18xWkFOalwiLFxuXHRcInNsaWRlTGVmdEVudGVyQWN0aXZlXCI6IFwidHJhbnNpdGlvbnNfX3NsaWRlTGVmdEVudGVyQWN0aXZlX19fMzhocnRcIixcblx0XCJzbGlkZUxlZnRBcHBlYXJBY3RpdmVcIjogXCJ0cmFuc2l0aW9uc19fc2xpZGVMZWZ0QXBwZWFyQWN0aXZlX19fM0w4WnlcIixcblx0XCJzbGlkZUxlZnRIZWlnaHRcIjogXCJ0cmFuc2l0aW9uc19fc2xpZGVMZWZ0SGVpZ2h0X19fM3FBLXlcIlxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2Nzcy1sb2FkZXI/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4uL3N1YnNjaGVtYS9+L2xlc3MtbG9hZGVyIS4uL3N1YnNjaGVtYS9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9ucy5sZXNzXG4gKiogbW9kdWxlIGlkID0gMzY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjdHggPSByZXF1aXJlLmNvbnRleHQoJy4vcmVzb2x2ZXJzJywgZmFsc2UsIC8oPyEuKmluZGV4LmpzJClcXC5qc3g/JC8pO1xubW9kdWxlLmV4cG9ydHMgPSBjdHgua2V5cygpLnJlZHVjZShmdW5jdGlvbiAocmV0LCBrZXkpIHtcbiAgICB2YXIgaW1wID0gY3R4KGtleSk7XG4gICAgcmV0W2tleS5yZXBsYWNlKC8uKlxcLyguKilcXC5qc3g/JC8sICckMScpXSA9IE9iamVjdC5rZXlzKGltcCkucmVkdWNlKGZ1bmN0aW9uIChvLCBrKSB7XG4gICAgICAgIG9ba10gPSBpbXBba107XG4gICAgICAgIHJldHVybiBvO1xuICAgIH0sIGltcC5kZWZhdWx0KTtcbiAgICByZXR1cm4gcmV0O1xufSwge30pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzLmpzXG4gKiovIiwidmFyIG1hcCA9IHtcblx0XCIuL2JsdXJWYWxpZGF0ZS5qc1wiOiAzNjcsXG5cdFwiLi9jaGFuZ2VWYWxpZGF0ZS5qc1wiOiAzNjksXG5cdFwiLi9jb25kaXRpb25hbC5qc1wiOiAzNzAsXG5cdFwiLi9jb250ZW50LmpzXCI6IDM3Mixcblx0XCIuL2RhdGFUeXBlLmpzXCI6IDM3Myxcblx0XCIuL2RvbVR5cGUuanNcIjogMzc0LFxuXHRcIi4vZXJyb3IuanNcIjogMzc1LFxuXHRcIi4vZXJyb3JFdmVudC5qc1wiOiAzNzYsXG5cdFwiLi9lcnJvcnMuanNcIjogMzc3LFxuXHRcIi4vZXZlbnQuanNcIjogMzc4LFxuXHRcIi4vZXhwcmVzc2lvbi5qc1wiOiAzNzksXG5cdFwiLi9maWVsZC5qc1wiOiAzODAsXG5cdFwiLi9maWVsZEF0dHJzLmpzXCI6IDM4Myxcblx0XCIuL2ZpZWxkcy5qc1wiOiAzODQsXG5cdFwiLi9maWVsZHNldC5qc1wiOiAzODUsXG5cdFwiLi9odG1sRm9yLmpzXCI6IDM4Nixcblx0XCIuL2lkLmpzXCI6IDM4Nyxcblx0XCIuL2luamVjdENsYXNzLmpzXCI6IDM4OCxcblx0XCIuL2luamVjdGVkQ2xhc3MuanNcIjogMzg5LFxuXHRcIi4vbGlzdGVuZXIuanNcIjogMzkwLFxuXHRcIi4vb3BlcmF0b3IuanNcIjogMzkxLFxuXHRcIi4vb3B0aW9ucy5qc1wiOiAzOTIsXG5cdFwiLi9wcm9jZXNzb3IuanNcIjogMzkzLFxuXHRcIi4vc2NoZW1hLmpzXCI6IDM5NCxcblx0XCIuL3N0eWxlLmpzXCI6IDM5NSxcblx0XCIuL3RhcmdldEV2ZW50LmpzXCI6IDM5Nixcblx0XCIuL3RlbXBsYXRlLmpzXCI6IDM4MSxcblx0XCIuL3RpdGxlLmpzXCI6IDM5Nyxcblx0XCIuL3RyYW5zaXRpb24uanNcIjogMzk4LFxuXHRcIi4vdHlwZS5qc1wiOiAzODIsXG5cdFwiLi90eXBlQ2xhc3MuanNcIjogMzk5LFxuXHRcIi4vdmFsaWRhdGUuanNcIjogMzY4LFxuXHRcIi4vdmFsdWUuanNcIjogNDAwLFxuXHRcIi4vdmFsdWVFdmVudC5qc1wiOiA0MDNcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18od2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkpO1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0cmV0dXJuIG1hcFtyZXFdIHx8IChmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIikgfSgpKTtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMzY2O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycyBub25yZWN1cnNpdmUgKD8hLippbmRleC5qcyQpXFwuanN4PyRcbiAqKiBtb2R1bGUgaWQgPSAzNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQge2xvYWRWYWxpZGF0b3JzfSBmcm9tICcuL3ZhbGlkYXRlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcblxuLyoqXG4gKiBCbHVyIHZhbGlkYXRlIGZvbGxvd3MgdGhlIGJlaGF2aW91clxuICpcbiAqIGlmIGEgZmllbGQgaGFzIG5vdCBjaGFuZ2VkIGFuZCBibHVycmVkIG5vIHZhbGlkYXRpb24uXG4gKiBpZiBhIGZpZWxkIGhhcyBjaGFuZ2VkIGFuZCBibHVycmVkIHZhbGlkYXRlLlxuICogaWYgYSB2YWxpZGF0ZSBsaXN0ZW5lciBpcyBjYWxsZWQgdmFsaWRhdGUuXG4gKlxuICogQHBhcmFtIENsYXp6XG4gKiBAcGFyYW0ga2V5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJsdXJWYWxpZGF0ZShDbGF6eiwga2V5KSB7XG5cbiAgICBDbGF6ei5jb250ZXh0VHlwZXMudmFsdWVNYW5hZ2VyID0gUHJvcFR5cGVzLnZhbHVlTWFuYWdlcjtcbiAgICBDbGF6ei5jb250ZXh0VHlwZXMubG9hZGVyID0gUHJvcFR5cGVzLmxvYWRlcjtcblxuXG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBmdW5jdGlvbiBibHVyVmFsaWRhdGUkcHJvcCh2YWxpZGF0ZSwga2V5LCBwcm9wcywgY29udGV4dCkge1xuICAgICAgICBpZiAodmFsaWRhdGUgPT0gbnVsbCkgcmV0dXJuIHZvaWQoMCk7XG4gICAgICAgIHZhbGlkYXRlID0gdHlwZW9mIHZhbGlkYXRlID09PSAnZnVuY3Rpb24nID8gdmFsaWRhdGUgOiB0aGlzOjpsb2FkVmFsaWRhdG9ycyh2YWxpZGF0ZSwga2V5LCBwcm9wcywgY29udGV4dCk7XG5cbiAgICAgICAgY29uc3Qge3BhdGh9ID0gcHJvcHM7XG5cbiAgICAgICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZSwgaGFzQmx1cnJlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlTGlzdGVuZXIgPSBjb250ZXh0LnZhbHVlTWFuYWdlci5hZGRWYWxpZGF0ZUxpc3RlbmVyKHBhdGgsICgpID0+dmFsaWRhdGUoKSkucmVtb3ZlO1xuXG5cbiAgICAgICAgdGhpcy5fdmFsaWRhdGVDaGFuZ2VMaXN0ZW5lcnMgPSBjb250ZXh0LnZhbHVlTWFuYWdlci5hZGRMaXN0ZW5lcihwYXRoLCAodmFsKT0+IHtcbiAgICAgICAgICAgIC8vZmlyZXMgb25DaGFuZ2Ugc28gaXRzIHRydWUuXG4gICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vYXQgc29tZSBwb2ludCBpdCBoYXMgYmx1cnJlZFxuICAgICAgICAgICAgaWYgKGhhc0JsdXJyZWQpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLCBmYWxzZSkucmVtb3ZlO1xuXG4gICAgICAgIC8vYmx1ciBldmVudCBpZiBpdHMgY2hhbmdlZCB3ZSB3aWxsIHZhbGlkYXRlLlxuICAgICAgICByZXR1cm4gdGhpczo6ZnVuY3Rpb24gaGFuZGxlQmx1cihlKSB7XG4gICAgICAgICAgICBoYXNCbHVycmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBDbGF6ejo6dGhpcy51bm1vdW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVDaGFuZ2VMaXN0ZW5lcnMgJiYgdGhpcy5fdmFsaWRhdGVDaGFuZ2VMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVMaXN0ZW5lciAmJiB0aGlzLl92YWxpZGF0ZUxpc3RlbmVyKCk7XG4gICAgfSk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvYmx1clZhbGlkYXRlLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IHt0b0FycmF5LCBub29wLCByZXNvbHZlS2V5fSBmcm9tICcuLi90dXRpbHMnO1xuXG5mdW5jdGlvbiBpbml0VmFsaWRhdG9ycyhudmFsKSB7XG4gICAgaWYgKHR5cGVvZiBudmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBudmFsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG52YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRWYWxpZGF0b3IobnZhbCkoe30pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkVmFsaWRhdG9yKG52YWwudHlwZSkobnZhbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkVmFsaWRhdG9ycyh2YWx1ZSwga2V5LCBwcm9wcywge2xvYWRlciwgdmFsdWVNYW5hZ2VyfSkge1xuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSB0b0FycmF5KHZhbHVlKS5tYXAoaW5pdFZhbGlkYXRvcnMsIGxvYWRlcilcbiAgICByZXR1cm4gKC4uLmFyZ3MpPT4ge1xuXG4gICAgICAgIGNvbnN0IHYgPSBhcmdzLmxlbmd0aCA9PT0gMCA/IHZhbHVlTWFuYWdlci5wYXRoKHByb3BzLnBhdGgpIDogYXJnc1swXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmFsaWRhdG9ycy5sZW5ndGg7XG4gICAgICAgIGxldCBlcnJvcnMgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHZhbGlkYXRvcnNbaV0odiwgdmFsdWVNYW5hZ2VyKTtcbiAgICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHVlTWFuYWdlci51cGRhdGVFcnJvcnMocHJvcHMucGF0aCwgZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9O1xuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhbGlkYXRlKENsYXp6LCBrZXkpIHtcbiAgICBDbGF6ei5jb250ZXh0VHlwZXMubG9hZGVyID0gUHJvcFR5cGVzLmxvYWRlcjtcbiAgICBDbGF6ei5jb250ZXh0VHlwZXMudmFsdWVNYW5hZ2VyID0gUHJvcFR5cGVzLnZhbHVlTWFuYWdlcjtcblxuICAgIENsYXp6Ojp0aGlzLnByb3BlcnR5KGtleSwgbG9hZFZhbGlkYXRvcnMpO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL3ZhbGlkYXRlLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7bG9hZFZhbGlkYXRvcnN9IGZyb20gJy4vdmFsaWRhdGUnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IHtub29wfSBmcm9tICcuLi90dXRpbHMnO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBvbiBjaGFuZ2UsIHVzZWQgaW4gY2hlY2tib3guICBBcyBpdCBuZWVkcyB2YWxpZGF0aW9uIHdpdGhvdXQgYmx1ci4gIEluIGNhc2VzIGxpa2UgdGV4dCxcbiAqIHRoZSBiZWhhdmlvdXIgaXMgZGlmZmVyZW50LlxuICpcbiAqIEBwYXJhbSBDbGF6elxuICogQHBhcmFtIGtleVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjaGFuZ2VWYWxpZGF0ZShDbGF6eiwga2V5KSB7XG5cbiAgICBDbGF6ei5jb250ZXh0VHlwZXMudmFsdWVNYW5hZ2VyID0gUHJvcFR5cGVzLnZhbHVlTWFuYWdlcjtcbiAgICBDbGF6ei5jb250ZXh0VHlwZXMubG9hZGVyID0gUHJvcFR5cGVzLmxvYWRlcjtcblxuXG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBmdW5jdGlvbiBibHVyVmFsaWRhdGUkcHJvcCh2YWxpZGF0ZSwga2V5LCBwcm9wcywgY29udGV4dCkge1xuICAgICAgICBpZiAodmFsaWRhdGUgPT0gbnVsbCkgcmV0dXJuIG5vb3A7XG4gICAgICAgIHZhbGlkYXRlID0gdHlwZW9mIHZhbGlkYXRlID09PSAnZnVuY3Rpb24nID8gdmFsaWRhdGUgOiB0aGlzOjpsb2FkVmFsaWRhdG9ycyh2YWxpZGF0ZSwga2V5LCBwcm9wcywgY29udGV4dCk7XG5cbiAgICAgICAgY29uc3Qge3BhdGh9ID0gcHJvcHM7XG5cbiAgICAgICAgdGhpcy5fdmFsaWRhdGVMaXN0ZW5lciA9IGNvbnRleHQudmFsdWVNYW5hZ2VyLmFkZFZhbGlkYXRlTGlzdGVuZXIocGF0aCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICkucmVtb3ZlO1xuXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQ2hhbmdlTGlzdGVuZXJzID0gY29udGV4dC52YWx1ZU1hbmFnZXIuYWRkTGlzdGVuZXIocGF0aCwgKHZhbCk9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWwpO1xuICAgICAgICB9LCB0aGlzLCBmYWxzZSkucmVtb3ZlO1xuXG4gICAgICAgIC8vYmx1ciBldmVudCBpZiBpdHMgY2hhbmdlZCB3ZSB3aWxsIHZhbGlkYXRlLlxuICAgICAgICByZXR1cm4gdmFsaWRhdGU7XG4gICAgfSk7XG5cbiAgICBDbGF6ejo6dGhpcy51bm1vdW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVDaGFuZ2VMaXN0ZW5lcnMgJiYgdGhpcy5fdmFsaWRhdGVDaGFuZ2VMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVMaXN0ZW5lciAmJiB0aGlzLl92YWxpZGF0ZUxpc3RlbmVyKCk7XG4gICAgfSk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvY2hhbmdlVmFsaWRhdGUuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IFVuaW5qZWN0ZWRDb25kaXRpb25hbCBmcm9tICcuLi9jb21wb25lbnRzL0NvbmRpdGlvbmFsLmpzeCc7XG5cbmV4cG9ydCBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICBvcGVyYXRvcjogXCJ0cnV0aHlcIixcbiAgICBDb25kaXRpb25hbDogVW5pbmplY3RlZENvbmRpdGlvbmFsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHZhbHVlLCBrZXksIHByb3BzLCB7aW5qZWN0b3J9KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgQ29uZGl0aW9uYWwgPSBpbmplY3Rvci5pbmplY3Qoc2V0dGluZ3MuQ29uZGl0aW9uYWwpO1xuICAgIGNvbnN0IGNvbmRpdGlvbmFsID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHsuLi5zZXR0aW5ncywgQ29uZGl0aW9uYWwsIG9wZXJhdG9yOiB2YWx1ZX0gOiB7XG4gICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICBDb25kaXRpb25hbCxcbiAgICAgICAgLi4udmFsdWVcbiAgICB9O1xuICAgIHJldHVybiBjb25kaXRpb25hbDtcbn1cbi8qKlxuICogQ29uZmlndXJlcyB0aGUgY29uZmlndXJhYmxlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gQ2xhenpcbiAqIEBwYXJhbSBrZXlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uZGl0aW9uYWwoQ2xhenosIGtleSkge1xuXG4gICAgQ2xhenouY29udGV4dFR5cGVzLmluamVjdG9yID0gUHJvcFR5cGVzLmluamVjdG9yO1xuXG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBub3JtYWxpemUpO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2NvbmRpdGlvbmFsLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnQsIENoaWxkcmVufSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4vLi4vUHJvcFR5cGVzJztcbmltcG9ydCBDU1NUcmFuc2l0aW9uR3JvdXAgZnJvbSAnLi4vdHJhbnNpdGlvbi9SZWFjdENTU1JlcGxhY2VUcmFuc2l0aW9uLmpzeCc7XG5pbXBvcnQge0ZSRUVaRV9PQkp9IGZyb20gJy4uL3R1dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbmRpdGlvbmFsIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29udGV4dFR5cGVzID0gUHJvcFR5cGVzLmNvbnRleHRUeXBlcztcbiAgICBzdGF0aWMgZGlzcGxheU5hbWUgPSBcIkNvbmRpdGlvbmFsXCI7XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb3BlcmF0b3I6IFwiIT1cIixcbiAgICAgICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBsaXN0ZW46ICcuJyxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICB9O1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgcGF0aCBvZiB0aGUgY29tcG9uZW50XG4gICAgICAgICAqL1xuICAgICAgICBwYXRoOiBQcm9wVHlwZXMucGF0aCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSAgdG8gdXNlIHRvbyBjb21wYXJlIGFnYWluc3QgIGlmIG5vdCBnaXZlbiwgdGhhblxuICAgICAgICAgKiBpdCB3aWxsIGJlIGEgY29tcGFyZSBhZ2FpbnN0IG51bGwuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXRoIHRvIGxpc3RlbiB0byBjYW4gYmUgZW1wdHksXG4gICAgICAgICAqIGluIHdoaWNoIGNhc2Ugd2lsbCBsb29rIGZvclxuICAgICAgICAgKiBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBwYXRoLlxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdGVuOiBQcm9wVHlwZXMubGlzdGVuZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZW1wbGF0ZSB0byB1c2UgaWYgaXQgZXZhbHVhdGVzIHRvIHRydWVcbiAgICAgICAgICogSUUgLSBNb2RhbCwgU2hvd0hpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRlbXBsYXRlOiBQcm9wVHlwZXMudGVtcGxhdGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGVtcGxhdGUgdG8gdXNlIGlmIGl0IGV2YWx1YXRlcyB0byBmYWxzZVxuICAgICAgICAgKiBkZWZhdWx0cyB0byBhIG51bGwgc3BhblxuICAgICAgICAgKi9cbiAgICAgICAgZmFsc2VUZW1wbGF0ZTogUHJvcFR5cGVzLnRlbXBsYXRlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgdG8gdXNlICBhIG5hbWVkIHRyYW5zaXRpb24sb3IgYSBib29sZWFuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBpZiBhIHN0cmluZyB0aGF0IHN0cmluZyB3aWxsIGJlIHRoZSBcIm5hbWVcIiB0byB1c2UgdG8gYW5pbWF0ZS5cbiAgICAgICAgICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCB0aGFuIGl0IHdpbGwgcGFzc2VkIGFzIHByb3BzIHRvIHRoZSB0cmFuc2l0aW9uIGdyb3VwLlxuICAgICAgICAgKiBJZiA9PT0gdHJ1ZSB0aGFuIHRoZSBkZWZhdWx0IGFuaW1hdGlvbiB3aWxsIGJlIHVzZWQuXG4gICAgICAgICAqIElmID09PSBmYWxzZSB0aGFuIG5vIGFuaW1hdGlvbiBpcyB1c2VkXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uOiBQcm9wVHlwZXMudHJhbnNpdGlvbixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyB0byBjb21wYXJlIHRoZSB2YWx1ZSB0byB0aGUgbWF0Y2hlZCB2YWx1ZS5cbiAgICAgICAgICogSWYgb21taXR0ZWQgYW5kIGEgdmFsdWUgaXMgZ2l2ZW4gdGhhbiA9PT0gaXMgdXNlZC5cbiAgICAgICAgICogSWYgb21taXR0ZWQgYW5kIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIHRoYW4gYSAhKHZhbHVlID09IG51bGwpIGlzIHVzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBvcGVyYXRvcjogUHJvcFR5cGVzLm9wZXJhdG9yLFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdGVuIHRvIGFuIGVycm9yIHJhdGhlciB0aGFuIHRoZSBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCBsaXN0ZW4uXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcjogUHJvcFR5cGVzLmVycm9yLFxuICAgICAgICAvKipcbiAgICAgICAgICogUGF0aCB0byB1cGRhdGUgdG8gbWFrZSBjb25kaXRpb25hbCBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIGRpc21pc3M6IFByb3BUeXBlcy5wYXRoLFxuXG4gICAgICAgIGJ1dHRvbnM6IFByb3BUeXBlcy5idXR0b25zLFxuICAgICAgICBmaWVsZDpQcm9wVHlwZXMuYW55XG4gICAgfTtcblxuICAgIHJlbmRlclRlbXBsYXRlKCkge1xuICAgICAgICBjb25zdCBUZW1wbGF0ZSA9IHRoaXMucHJvcHMudGVtcGxhdGU7XG4gICAgICAgIGxldCB7dmFsdWUsIGxpc3RlbiwgZXJyb3IsIHRlbXBsYXRlLCBmYWxzZVRlbXBsYXRlLCBkaXNtaXNzLCBvcGVyYXRvciwgdHJhbnNpdGlvbixjaGlsZHJlbiwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKGRpc21pc3MpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB7ZGlzbWlzc30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZSA/XG4gICAgICAgICAgICA8VGVtcGxhdGUga2V5PSd0cnVlLWNvbmRpdGlvbmFsJyB7Li4ucHJvcHN9PntjaGlsZHJlbn08L1RlbXBsYXRlPiA6IGNoaWxkcmVuO1xuXG4gICAgfVxuXG4gICAgcmVuZGVyRmFsc2VUZW1wbGF0ZSgpIHtcbiAgICAgICAgY29uc3QgRmFsc2VUZW1wbGF0ZSA9IHRoaXMucHJvcHMuZmFsc2VUZW1wbGF0ZTtcblxuICAgICAgICBsZXQge3ZhbHVlLCBsaXN0ZW4sIGVycm9yLCB0ZW1wbGF0ZSwgZmFsc2VUZW1wbGF0ZSwgZGlzbWlzcywgb3BlcmF0b3IsIHRyYW5zaXRpb24sY2hpbGRyZW4sIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIEZhbHNlVGVtcGxhdGUgP1xuICAgICAgICAgICAgPEZhbHNlVGVtcGxhdGUga2V5PSdmYWxzZS1jb25kaXRpb25hbCcgey4uLnByb3BzfSA+e2NoaWxkcmVufTwvRmFsc2VUZW1wbGF0ZT4gOlxuICAgICAgICAgICAgPHNwYW4ga2V5PSdmYWxzZS1jb25kaXRpb25hbCcvPjtcbiAgICB9XG5cbiAgICByZW5kZXJDb250ZW50KCkge1xuXG4gICAgICAgIGNvbnN0IGlzTWF0Y2ggPSB0aGlzLnByb3BzLm9wZXJhdG9yKHRoaXMucHJvcHMubGlzdGVuLCB0aGlzLnByb3BzLnZhbHVlKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2lzTWF0Y2gnLCB0aGlzLnByb3BzLmxpc3RlbiwgdGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICAgIHJldHVybiBpc01hdGNoID8gdGhpcy5yZW5kZXJUZW1wbGF0ZSgpIDogdGhpcy5yZW5kZXJGYWxzZVRlbXBsYXRlKCk7XG5cbiAgICB9XG5cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckNvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gPENTU1RyYW5zaXRpb25Hcm91cCB7Li4udGhpcy5wcm9wcy50cmFuc2l0aW9ufT5cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckNvbnRlbnQoKX1cbiAgICAgICAgPC9DU1NUcmFuc2l0aW9uR3JvdXA+XG4gICAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9jb21wb25lbnRzL0NvbmRpdGlvbmFsLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQgVW5pbmplY3RlZENvbnRlbnQgZnJvbSAnLi4vdHlwZXMvQ29udGVudC5qc3gnO1xuXG5leHBvcnQgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgQ29udGVudDogVW5pbmplY3RlZENvbnRlbnRcbn07XG5leHBvcnQgZnVuY3Rpb24gbG9hZENvbnRlbnQoY29udGVudCwga2V5LCBwcm9wcywge2luamVjdG9yfSkge1xuXG4gICBjb25zdCBDb250ZW50ID0gIGluamVjdG9yLmluamVjdChzZXR0aW5ncy5Db250ZW50KTtcbiAgIHJldHVybiB7XG4gICAgICAgQ29udGVudDpDb250ZW50LFxuICAgICAgIGNvbnRlbnQ6Y29udGVudFxuICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250ZW50KENsYXp6LCBrZXkpIHtcblxuICAgIENsYXp6LmNvbnRleHRUeXBlcy5pbmplY3RvciA9IFByb3BUeXBlcy5pbmplY3RvcjtcbiAgICBDbGF6ejo6dGhpcy5wcm9wZXJ0eShrZXksIGxvYWRDb250ZW50KTtcblxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9jb250ZW50LmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29udmVydCB0aGUgZGF0YVR5cGUgcHJvcGVydHkgdG8gdGhlIHR5cGUgcHJvcGVydHkuICBPbmx5XG4gKiB1c2VmdWwgZm9yIG1ha2luZyBzY2hlbWEgY29udmVyc2lvbnMgZWFzaWVyLCBhbmQgYXZvaWQgY29uZmxpY3RzIHdpdGhcbiAqIHR5cGUgdHlwZXMuXG4gKlxuICogQHBhcmFtIENsYXp6XG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkYXRhVHlwZShDbGF6eiwga2V5LCBwcm9wVHlwZUtleXMpIHtcblxuICAgIC8vYXJyYXkgb2Yga2V5cyB0byBhbGxvdyBmb3IgcHJvcCB0eXBlIHJlbmFtZXMuICBUaGlzIHNob3VsZCBub3QgaGFwcGVuIG11Y2gsIGJ1dCB3ZSBoYXZlIGRhdGFUeXBlLT50eXBlIGNvbnZlcnNpb24uXG4gICAgcHJvcFR5cGVLZXlzLnNwbGljZShwcm9wVHlwZUtleXMuaW5kZXhPZihrZXkpLCAxLCAndHlwZScpO1xuXG5cbiAgICBDbGF6ejo6dGhpcy5leHRlbmRQcm90b3R5cGUoJ2NvbXBvbmVudFdpbGxNb3VudCcsIGZ1bmN0aW9uIGRhdGFUeXBlJHdpbGxNb3VudCgpIHtcbiAgICAgICAgdGhpcy5pbmplY3RlZC50eXBlID0gdGhpcy5wcm9wc1trZXldO1xuICAgIH0pO1xuXG4gICAgQ2xheno6OnRoaXMuZXh0ZW5kUHJvdG90eXBlKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJywgZnVuY3Rpb24gZGF0YVR5cGUkd2lsbFJlY2lldmVQcm9wcyhuZXdQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5wcm9wc1trZXldICE9PSBuZXdQcm9wc1trZXldKSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdGVkLnR5cGUgPSB0aGlzLnByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2RhdGFUeXBlLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQge0ZSRUVaRV9PQkp9IGZyb20gJy4uL3R1dGlscyc7XG5cbmNvbnN0IERPTSA9IFJlYWN0LkRPTSB8fCBGUkVFWkVfT0JKO1xuXG4vL0V4cG9zZSBmb3IgY29uZmlndXJhYmlsaXR5XG5leHBvcnQgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgdHlwZTogJ3NwYW4nXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFR5cGUodmFsLCBrZXksIHByb3BzLCB7bG9hZGVyLCBpbmplY3Rvcn0pIHtcblxuICAgIGNvbnN0IHt0eXBlLCAuLi5yZXN0fSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8ge1xuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgdHlwZTogdmFsXG4gICAgfSA6IHZhbCA9PSBudWxsID8gc2V0dGluZ3MgOiB7Li4uc2V0dGluZ3MsIC4uLnZhbH07XG5cbiAgICBpZiAoRE9NW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIGNvbnN0IFR5cGUgPSBsb2FkZXIubG9hZFR5cGUodHlwZSk7XG5cbiAgICBjb25zdCBpbmplY3RlZENsYXp6ID0gaW5qZWN0b3IuaW5qZWN0KFR5cGUsIG51bGwsIHJlc3QpO1xuICAgIHJldHVybiBpbmplY3RlZENsYXp6O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0eXBlKENsYXp6LCBrZXksIHByb3BMaXN0LCBPcmlnQ2xhenopIHtcblxuICAgIENsYXp6LmNvbnRleHRUeXBlcy5sb2FkZXIgPSBQcm9wVHlwZXMubG9hZGVyO1xuICAgIENsYXp6LmNvbnRleHRUeXBlcy5pbmplY3RvciA9IFByb3BUeXBlcy5pbmplY3RvcjtcblxuXG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBsb2FkVHlwZSk7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9kb21UeXBlLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCB7cmVzb2x2ZUtleX0gZnJvbSAnLi4vdHV0aWxzJztcblxuZnVuY3Rpb24gaGFuZGxlRXJyb3JMaXN0ZW5lcnModmFsdWUsIGtleSwgcHJvcHMsIHt2YWx1ZU1hbmFnZXJ9KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZUtleShwcm9wcy5wYXRoLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlTWFuYWdlci5hZGRFcnJvckxpc3RlbmVyKHJlc29sdmVkUGF0aCwgKGVycik9PiB7XG4gICAgICAgIHRoaXMuaW5qZWN0ZWRba2V5XSA9IGVyciAmJiBlcnJbMF0gJiYgZXJyWzBdLm1lc3NhZ2U7XG4gICAgICAgIHRoaXMubW91bnRlZCAmJiB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfSwgdGhpcywgdHJ1ZSkucmVtb3ZlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlcnJvcihDbGF6eiwga2V5KSB7XG4gICAgQ2xhenouY29udGV4dFR5cGVzLnZhbHVlTWFuYWdlciA9IFByb3BUeXBlcy52YWx1ZU1hbmFnZXI7XG5cbiAgICBDbGF6ejo6dGhpcy5saXN0ZW5lcihrZXksIGhhbmRsZUVycm9yTGlzdGVuZXJzKTtcblxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2Vycm9yLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7cmVzb2x2ZUtleX0gZnJvbSAnLi4vdHV0aWxzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcblxuZnVuY3Rpb24gZXJyb3JVcGRhdGUodmFsdWUsIGtleSwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCByZXNvbHZlZEtleSA9IHJlc29sdmVLZXkocHJvcHMucGF0aCwgdmFsdWUpO1xuICAgIHJldHVybiAodmFsKT0+IGNvbnRleHQudmFsdWVNYW5hZ2VyLnVwZGF0ZUVycm9ycyhyZXNvbHZlZEtleSwgdmFsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXJyb3JFdmVudChDbGF6eiwga2V5KSB7XG5cbiAgICBDbGF6ei5jb250ZXh0VHlwZXMudmFsdWVNYW5hZ2VyID0gUHJvcFR5cGVzLnZhbHVlTWFuYWdlcjtcblxuICAgIENsYXp6Ojp0aGlzLnByb3BlcnR5KGVycm9yVXBkYXRlKTtcblxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2Vycm9yRXZlbnQuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IHtyZXNvbHZlS2V5fSBmcm9tICcuLi90dXRpbHMnO1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcnNMaXN0ZW5lcnModmFsdWUsIGtleSwgcHJvcHMsIHt2YWx1ZU1hbmFnZXJ9KSB7XG4gICAgcmV0dXJuIHZhbHVlTWFuYWdlci5hZGRFcnJvckxpc3RlbmVyKHJlc29sdmVLZXkocHJvcHMucGF0aCwgdmFsdWUpLCAoZXJyLCBvbGQsIHBhdGgpPT4ge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLmluamVjdGVkW2tleV0gfHwgKHRoaXMuaW5qZWN0ZWRba2V5XSA9IHt9KTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyb3JzW3BhdGhdID0gZXJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGVycm9yc1twYXRoXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluamVjdGVkW2tleV0gPSAoT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGggPiAwKSA/IGVycm9ycyA6IG51bGw7XG4gICAgICAgIHRoaXMubW91bnRlZCAmJiB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfSwgdGhpcywgdHJ1ZSkucmVtb3ZlO1xufVxuXG4vKipcbiAqIExpc3RlbnMgdG8gZXJyb3JzIG9uIHRoZSBwYXRoIGFuZCByZXR1cm5zIHRoZW0uICBUaGlzIGlzIHNpbWlsYXIgdG8gcmVzb2x2ZXJzL2Vycm9yIGV4Y2VwdFxuICogdGhhdCBpdCBwcm92aWRlcyB0aGUgcGF0aCBhbmQgYWxsIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0gQ2xhenpcbiAqIEBwYXJhbSBrZXlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXJyb3JzKENsYXp6LCBrZXkpIHtcbiAgICBDbGF6ei5jb250ZXh0VHlwZXMudmFsdWVNYW5hZ2VyID0gUHJvcFR5cGVzLnZhbHVlTWFuYWdlcjtcblxuICAgIENsYXp6Ojp0aGlzLmxpc3RlbmVyKGtleSwgaGFuZGxlRXJyb3JzTGlzdGVuZXJzKTtcblxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2Vycm9ycy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQge25vb3B9IGZyb20gJy4uL3R1dGlscyc7XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBub29wO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXZlbnQoQ2xhenosIGtleSkge1xuICAgIENsYXp6Ojp0aGlzLnByb3BlcnR5KGtleSwgaGFuZGxlRXZlbnQpO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2V2ZW50LmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCBTdWJzdGl0dXRlTWl4aW4gZnJvbSAnLi4vdHlwZXMvU3Vic3RpdHV0ZU1peGluJztcbmltcG9ydCB7cmVzb2x2ZUtleSwgYXBwbHlGdW5jc30gZnJvbSAnLi4vdHV0aWxzJztcblxuZnVuY3Rpb24gaGFuZGxlRXhwcmVzc2lvbih2YWx1ZSwga2V5LCBwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICBjb25zdCBleHByZXNzaW9uVmFscyA9IHt9O1xuICAgIGNvbnN0IHt2YWx1ZU1hbmFnZXJ9ID0gY29udGV4dDtcbiAgICBjb25zdCB7bGlzdGVuLCBmb3JtYXR9ID0gU3Vic3RpdHV0ZU1peGluKHZhbHVlKTtcbiAgICBjb25zdCB7aW5qZWN0ZWR9ID0gdGhpcztcbiAgICBjb25zdCB7cGF0aH0gPSBwcm9wcztcbiAgICBjb25zdCByZXQgPSBsaXN0ZW4ucmVkdWNlKChmbiwgdik9PiB7XG4gICAgICAgIGlmICghKHYgaW4gZXhwcmVzc2lvblZhbHMpKSB7XG4gICAgICAgICAgICAvL29ubHkgbmVlZCB0byBsaXN0ZW4gdG8gYSB2YWx1ZSBvbmNlLlxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRLZXkgPSByZXNvbHZlS2V5KHBhdGgsIHYpO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5RnVuY3ModmFsdWVNYW5hZ2VyLmFkZExpc3RlbmVyKHJlc29sdmVkS2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodiBpbiBleHByZXNzaW9uVmFscykgfHwgZXhwcmVzc2lvblZhbHNbdl0gIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSB2YWx1ZXMgZG9uJ3QgY2FuZ2UgdGhlIHN0YXRlIGRvbid0IGNoYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblZhbHNbdl0gPSB2YWwgPT0gbnVsbCA/ICcnIDogdmFsO1xuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFtrZXldID0gZm9ybWF0KGV4cHJlc3Npb25WYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBudWxsLCB0cnVlKS5yZW1vdmUsIGZuKTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9LCBudWxsKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHByZXNzaW9uKENsYXp6LCBrZXkpIHtcblxuICAgIENsYXp6LmNvbnRleHRUeXBlcy52YWx1ZU1hbmFnZXIgPSBQcm9wVHlwZXMudmFsdWVNYW5hZ2VyO1xuXG4gICAgQ2xheno6OnRoaXMubGlzdGVuZXIoa2V5LCBoYW5kbGVFeHByZXNzaW9uKTtcblxuXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvZXhwcmVzc2lvbi5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQge0ZSRUVaRV9PQkp9IGZyb20gJy4uL3R1dGlscyc7XG5pbXBvcnQge2xvYWRUZW1wbGF0ZX0gZnJvbSAnLi90ZW1wbGF0ZSc7XG5pbXBvcnQge2xvYWRUeXBlfSBmcm9tICcuL3R5cGUnO1xuaW1wb3J0IHtsb2FkVmFsaWRhdG9yc30gZnJvbSAnLi92YWxpZGF0ZSc7XG5pbXBvcnQgQ29uZGl0aW9uYWwgZnJvbSAnLi4vY29tcG9uZW50cy9Db25kaXRpb25hbC5qc3gnO1xuXG5leHBvcnQgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgdHlwZTogJ1RleHQnLFxuICAgIHRlbXBsYXRlOiAnRWRpdG9yVGVtcGxhdGUnXG59O1xuXG5mdW5jdGlvbiBiYXJlKHZhbHVlKSB7XG5cbiAgICBjb25zdCB7dHlwZSwgdGVtcGxhdGUsIC4uLnJlc3R9ID0gdmFsdWU7XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5mdW5jdGlvbiBzcHJlYWRhYmxlKHZhbHVlLCBrZXkgPSAndGVtcGxhdGUnKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEZSRUVaRV9PQko7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4ge1trZXldOiB2YWx1ZX1cbiAgICB9XG5cbiAgICBpZiAoKCFrZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBGUkVFWkVfT0JKO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpZWxkKENsYXp6LCBrZXksIHByb3BMaXN0KSB7XG5cbiAgICBjb25zdCBzZXR0cyA9IGJhcmUoc2V0dGluZ3MpO1xuXG4gICAgQ2xhenouY29udGV4dFR5cGVzLmxvYWRlciA9IFByb3BUeXBlcy5sb2FkZXI7XG4gICAgQ2xhenouY29udGV4dFR5cGVzLmluamVjdG9yID0gUHJvcFR5cGVzLmluamVjdG9yO1xuICAgIENsYXp6LmNvbnRleHRUeXBlcy52YWx1ZU1hbmFnZXIgPSBQcm9wVHlwZXMudmFsdWVNYW5hZ2VyO1xuXG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBmdW5jdGlvbiBmaWVsZCRwcm9wKHZhbHVlLCBrZXksIHByb3BzLCBjb250ZXh0LCBPcmlnQ2xhenopIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgey4uLmNvcHl9ID0gc2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb3B5O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB7Li4uc2V0dGluZ3MsIHR5cGU6IHZhbHVlfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghdmFsdWUudHlwZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBzZXR0aW5ncy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS52YWxpZGF0b3JzID0gbG9hZFZhbGlkYXRvcnModmFsdWUudmFsaWRhdG9ycywga2V5LCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUuY29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuY29uZGl0aW9uYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmNvbmRpdGlvbmFsID0ge29wZXJhdG9yOiB2YWx1ZS5jb25kaXRpb25hbH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBUeXBlID0gbG9hZFR5cGUodmFsdWUudHlwZSwgbnVsbCwgbnVsbCwgY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgVGVtcGxhdGU7XG4gICAgICAgICAgICBpZiAodmFsdWUudGVtcGxhdGUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9ZWxzZSBpZiAodmFsdWUudGVtcGxhdGUpe1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IHsuLi5zcHJlYWRhYmxlKHNldHRpbmdzLnRlbXBsYXRlKSwgLi4uc3ByZWFkYWJsZShUeXBlLnRlbXBsYXRlKSwgLi4uc3ByZWFkYWJsZSh2YWx1ZS50ZW1wbGF0ZSl9O1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlID0gbG9hZFRlbXBsYXRlKGxvb2t1cCwga2V5LCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICB9ZWxzZSBpZiAoJ3RlbXBsYXRlJyBpbiBUeXBlKSB7XG4gICAgICAgICAgICAgICAgLy90ZW1wbGF0ZSBpcyBmYWxzZSB3aXRoIG5vIG92ZXJyaWRlLlxuICAgICAgICAgICAgICAgIGlmIChUeXBlLnRlbXBsYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBUZW1wbGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29rdXAgPSB7Li4uc3ByZWFkYWJsZShzZXR0aW5ncy50ZW1wbGF0ZSksIC4uLnNwcmVhZGFibGUoVHlwZS50ZW1wbGF0ZSl9O1xuICAgICAgICAgICAgICAgICAgICBUZW1wbGF0ZSA9IGxvYWRUZW1wbGF0ZShsb29rdXAsIGtleSwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGUgPSBsb2FkVGVtcGxhdGUoc2V0dGluZ3MudGVtcGxhdGUsIGtleSwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnNldHRzLFxuICAgICAgICAgICAgICAgIC4uLmJhcmUodmFsdWUpLFxuICAgICAgICAgICAgICAgIFR5cGUsXG4gICAgICAgICAgICAgICAgVGVtcGxhdGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cblxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2ZpZWxkLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCB7aW5oZXJpdHMsIGlzRnVuY3Rpb259IGZyb20gJy4uL3R1dGlscyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi93YXJuaW5nJztcblxuZXhwb3J0IGNvbnN0IHNldHRpbmdzID0ge1xuICAgIHByb3BUeXBlczoge1xuICAgICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5jc3NDbGFzcyxcbiAgICAgICAgaWQ6IFByb3BUeXBlcy5pZCxcbiAgICAgICAgZmllbGRDbGFzczogUHJvcFR5cGVzLmZpZWxkQ2xhc3NcbiAgICB9XG59O1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodGVtcGxhdGUsIF9zZXR0aW5ncyA9IHNldHRpbmdzKSB7XG5cbiAgICBpZiAodGVtcGxhdGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX3NldHRpbmdzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4ge3RlbXBsYXRlfVxuICAgIH1cbiAgICBpZiAodGVtcGxhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB7dGVtcGxhdGV9O1xuICAgIH1cblxuICAgIGlmICh0ZW1wbGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gX3NldHRpbmdzO1xuICAgIH1cblxuICAgIGlmICh0ZW1wbGF0ZS50ZW1wbGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5fc2V0dGluZ3MsXG4gICAgICAgIC4uLnRlbXBsYXRlXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFRlbXBsYXRlKHZhbHVlLCBrZXksIHByb3BzLCB7bG9hZGVyLCBpbmplY3Rvcn0pIHtcbiAgICBjb25zdCB7dGVtcGxhdGUsIHByb3BUeXBlcywgLi4ucmVzdH0gPSBub3JtYWxpemUodmFsdWUpO1xuXG4gICAgaWYgKHRlbXBsYXRlID09IG51bGwgfHwgdGVtcGxhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBUZW1wbGF0ZTtcbiAgICBpZiAoaXNGdW5jdGlvbih0ZW1wbGF0ZSkpIHtcbiAgICAgICAgVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBUZW1wbGF0ZSA9IGxvYWRlci5sb2FkVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICB3YXJuaW5nKFRlbXBsYXRlLCAnVGVtcGxhdGUgZm9yIG5hbWUgXCIlc1wiIGlzIG5vdCBkZWZpbmVkJywgdGVtcGxhdGUpO1xuICAgICAgICBpZiAoIVRlbXBsYXRlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICBUZW1wbGF0ZS5kaXNwbGF5TmFtZSA9IHRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IEluamVjdGVkVGVtcGxhdGUgPSBpbmplY3Rvci5pbmplY3QoVGVtcGxhdGUsIHByb3BUeXBlcywgcmVzdCk7XG5cbiAgICByZXR1cm4gSW5qZWN0ZWRUZW1wbGF0ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGVtcGxhdGUoQ2xhenosIGtleSkge1xuXG5cbiAgICBDbGF6ei5jb250ZXh0VHlwZXMubG9hZGVyID0gUHJvcFR5cGVzLmxvYWRlcjtcbiAgICBDbGF6ei5jb250ZXh0VHlwZXMuaW5qZWN0b3IgPSBQcm9wVHlwZXMuaW5qZWN0b3I7XG5cbiAgICBDbGF6ejo6dGhpcy5wcm9wZXJ0eShrZXksIGxvYWRUZW1wbGF0ZSk7XG5cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvdGVtcGxhdGUuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi4vd2FybmluZydcbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvcFR5cGVzID0ge1xuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMudGFyZ2V0RXZlbnQsXG4gICAgb25CbHVyOiBQcm9wVHlwZXMuYmx1clZhbGlkYXRlLFxuICAgIG9uS2V5RG93bjogUHJvcFR5cGVzLmV2ZW50LFxuICAgIG9uS2V5VXA6IFByb3BUeXBlcy5ldmVudCxcbiAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZXZlbnQsXG4gICAgb25QYXN0ZTogUHJvcFR5cGVzLmV2ZW50LFxuICAgIHZhbHVlOiBQcm9wVHlwZXMudmFsdWUsXG4gICAgaWQ6IFByb3BUeXBlcy5pZCxcbiAgICBuYW1lOiBQcm9wVHlwZXMuaHRtbEZvcixcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy50eXBlQ2xhc3MsXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZmllbGRBdHRyczogUHJvcFR5cGVzLmZpZWxkQXR0cnNcbn1cbi8vRXhwb3NlIGZvciBjb25maWd1cmFiaWxpdHlcbmV4cG9ydCBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICB0eXBlOiAnVGV4dCdcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkVHlwZSh2YWwsIGtleSwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQge3R5cGUsIHByb3BUeXBlcywgLi4ucmVzdH0gPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IHtcbiAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgIHR5cGU6IHZhbFxuICAgIH0gOiB2YWwgPT0gbnVsbCA/IHNldHRpbmdzIDogey4uLnNldHRpbmdzLCAuLi52YWx9O1xuXG4gICAgaWYgKCFwcm9wVHlwZXMpIHtcbiAgICAgICAgcHJvcFR5cGVzID0gZGVmYXVsdFByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wVHlwZXMgPSB7Li4uZGVmYXVsdFByb3BUeXBlcywgLi4ucHJvcFR5cGVzfTtcbiAgICB9XG4gICAgbGV0IFR5cGU7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBUeXBlID0gY29udGV4dC5sb2FkZXIubG9hZFR5cGUodHlwZSk7XG4gICAgICAgIHdhcm5pbmcoVHlwZSwgJ0NvdWxkIG5vdCBmaW5kIGEgdHlwZSBmb3IgJXMnLCB0eXBlKTtcblxuICAgICAgICBpZiAoIVR5cGUuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIFR5cGUuZGlzcGxheU5hbWUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IHR5cGU7XG4gICAgfVxuXG5cbiAgICBjb25zdCBpbmplY3RlZENsYXp6ID0gY29udGV4dC5pbmplY3Rvci5pbmplY3QoVHlwZSwgcHJvcFR5cGVzLCByZXN0LmRlZmF1bHRQcm9wcyk7XG5cbiAgICBpZiAoJ3RlbXBsYXRlJyBpbiBUeXBlKSB7XG4gICAgICAgIGluamVjdGVkQ2xhenoudGVtcGxhdGUgPSBUeXBlLnRlbXBsYXRlO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIGluamVjdGVkQ2xheno7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHR5cGUoQ2xhenosIGtleSwgcHJvcExpc3QsIE9yaWdDbGF6eikge1xuXG4gICAgQ2xhenouY29udGV4dFR5cGVzLmxvYWRlciA9IFByb3BUeXBlcy5sb2FkZXI7XG4gICAgQ2xhenouY29udGV4dFR5cGVzLmluamVjdG9yID0gUHJvcFR5cGVzLmluamVjdG9yO1xuXG5cbiAgICBDbGF6ejo6dGhpcy5wcm9wZXJ0eShrZXksIGxvYWRUeXBlKTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL3R5cGUuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHthcHBseUZ1bmNzfSBmcm9tICcuLi90dXRpbHMnO1xuXG5mdW5jdGlvbiBoYW5kbGVBdHRycyh2YWx1ZSwga2V5KSB7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAocHJvcEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgcHJvcEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vVGhpcyBtYXkgYmUgaW5kZXRlcm1pbmF0ZSwgZGVwZW5kaW5nIGlmIHNvbWV0aGluZyBzZXRzIGl0IGxhdGVyLlxuICAgICAgICB0aGlzLmluamVjdGVkW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmllbGRBdHRycyhDbGF6eiwga2V5LCBwcm9wS2V5cykge1xuXG5cblxuICAgIGNvbnN0IENsYXp6UCA9IENsYXp6LnByb3RvdHlwZTtcblxuICAgIENsYXp6UC5jb21wb25lbnRXaWxsTW91bnQgPSBhcHBseUZ1bmNzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpczo6aGFuZGxlQXR0cnModGhpcy5wcm9wc1trZXldLCBrZXkpO1xuICAgIH0sIENsYXp6UC5jb21wb25lbnRXaWxsTW91bnQpO1xuXG4gICAgQ2xhenpQLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBhcHBseUZ1bmNzKGZ1bmN0aW9uIChuZXdQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5wcm9wc1trZXldICE9PSBuZXdQcm9wc1trZXldKSB7XG4gICAgICAgICAgICB0aGlzOjpoYW5kbGVBdHRycyhuZXdQcm9wc1trZXldLCBrZXkpO1xuICAgICAgICB9XG4gICAgfSwgQ2xhenpQLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL2ZpZWxkQXR0cnMuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHt0b0FycmF5fSBmcm9tICcuLi90dXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRmllbGRzKGZpZWxkcykge1xuICAgIGlmIChmaWVsZHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBmaWVsZHMgPSB0b0FycmF5KGZpZWxkcyk7XG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaWVsZHMoQ2xhenosIGtleSkge1xuICAgIENsYXp6Ojp0aGlzLnByb3BlcnR5KGtleSwgbm9ybWFsaXplRmllbGRzKTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9maWVsZHMuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHtwdXNoLCB0b0FycmF5LGlzU3RyaW5nfSBmcm9tICcuLi90dXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRmllbGRzZXRzKGZpZWxkc2V0cywgZmllbGRzKSB7XG4gICAgaWYgKCEoZmllbGRzZXRzIHx8IGZpZWxkcykpIHJldHVybiB7fTtcbiAgICBmaWVsZHMgPSB0b0FycmF5KGZpZWxkcyk7XG4gICAgLy9maWVsZHMgdHJ1bXAgZmllbGRzZXRzXG4gICAgLy9vdGhlcndpc2UgcmVjdXJzZVxuICAgIGZpZWxkc2V0cyA9IHRvQXJyYXkoZmllbGRzZXRzKS5tYXAoKGYpPT4ge1xuICAgICAgICBpZiAoZi5maWVsZHMpIHtcbiAgICAgICAgICAgIHZhciB7Li4ucmVzdH0gPSBmO1xuICAgICAgICAgICAgcmVzdC5maWVsZHMgPSB0b0FycmF5KHJlc3QuZmllbGRzKTtcbiAgICAgICAgICAgIHB1c2goZmllbGRzLCByZXN0LmZpZWxkcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgICAgfSBlbHNlIGlmIChmLmZpZWxkc2V0cykge1xuICAgICAgICAgICAgdmFyIHtmaWVsZHNldHMsIC4uLnJlc3R9ID0gZjtcbiAgICAgICAgICAgIHJlc3QuZmllbGRzZXRzID0gbm9ybWFsaXplRmllbGRzZXRzKGZpZWxkc2V0cywgZmllbGRzKS5maWVsZHNldHM7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGYpIHx8IEFycmF5LmlzQXJyYXkoZikpIHtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzRmllbGRzID0gdG9BcnJheShmKTtcbiAgICAgICAgICAgIHB1c2goZmllbGRzLCBwcm9jZXNzRmllbGRzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmllbGRzOiBwcm9jZXNzRmllbGRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZi5maWVsZHNldHMpIHtcbiAgICAgICAgICAgIHZhciB7ZmllbGRzZXRzLCAuLi5yZXN0fSA9IGY7XG4gICAgICAgICAgICByZXN0LmZpZWxkc2V0cyA9IG5vcm1hbGl6ZUZpZWxkc2V0cyhmaWVsZHNldHMsIGZpZWxkcykuZmllbGRzZXRzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZjtcbi8vICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ2RvIG5vdCBrbm93IHdoYXQgJXMgdGhpcyBpcyAnLCBmKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmaWVsZHNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZpZWxkc2V0cyA9IFt7ZmllbGRzOiBmaWVsZHN9XTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRzZXRzLFxuICAgICAgICBmaWVsZHNcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWwodmFsdWUpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRmllbGRzZXRzKHZhbHVlLCBbXSk7XG59XG5mdW5jdGlvbiBmaWVsZHNldHMoQ2xhenosIGtleSkge1xuICAgIENsYXp6Ojp0aGlzLnByb3BlcnR5KGtleSwgbm9ybWFsKTtcbn1cbmZpZWxkc2V0cy5ub3JtYWxpemVGaWVsZHNldHMgPSBub3JtYWxpemVGaWVsZHNldHM7XG5leHBvcnQgZGVmYXVsdCBmaWVsZHNldHM7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9maWVsZHNldC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBpZFZhbHVlKHZhbHVlLCBrZXksIHByb3BzKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBwcm9wcy5pZCB8fCBwcm9wcy5wYXRoO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGh0bWxGb3IoQ2xhenosIGtleSkge1xuXG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBpZFZhbHVlKTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9odG1sRm9yLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGlkVmFsdWUodmFsdWUsIGtleSwgcHJvcHMpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHByb3BzLnBhdGg7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaWQoQ2xhenosIGtleSkge1xuXG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBpZFZhbHVlKTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9pZC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RDbGFzcyh2YWx1ZSwga2V5LCBwcm9wcywge2luamVjdG9yfSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAodmFsdWUuaW5qZWN0Q2xhc3MpIHtcbiAgICAgICAgY29uc3Qge2luamVjdENsYXNzLCBwcm9wVHlwZXMsIGluamVjdFByb3BzLCBzdHJpY3R9ICA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gaW5qZWN0b3IuaW5qZWN0KGluamVjdENsYXNzLCBwcm9wVHlwZXMsIGluamVjdFByb3BzLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIHJldHVybiBpbmplY3Rvci5pbmplY3QodmFsdWUpO1xuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluamVjdChDbGF6eiwga2V5KSB7XG5cbiAgICBDbGF6ei5jb250ZXh0VHlwZXMuaW5qZWN0b3IgPSBQcm9wVHlwZXMuaW5qZWN0b3I7XG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBpbmplY3RDbGFzcyk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvaW5qZWN0Q2xhc3MuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmplY3RlZCBjbGFzcyBhcyBhIHByb3BlcnR5IHRvIHRoZSBjaGlsZCBjbGFzcy5cbiAqIFVzZWZ1bCBmb3IgQ29udGVudC5cbiAqXG4gKiBAcGFyYW0gQ2xhenpcbiAqIEBwYXJhbSBrZXlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5qZWN0ZWQoQ2xhenosIGtleSkge1xuXG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDbGF6ejtcbiAgICB9KTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9pbmplY3RlZENsYXNzLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCB7cmVzb2x2ZUtleX0gZnJvbSAnLi4vdHV0aWxzJztcblxuZnVuY3Rpb24gaGFuZGxlTGlzdGVuZXJzKHZhbHVlLCBrZXksIHByb3BzLCBjb250ZXh0KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHJlc29sdmVLZXkocHJvcHMucGF0aCwgdmFsdWUpO1xuICAgIGNvbnN0IHtpbmplY3RlZH0gPSB0aGlzO1xuICAgIHJldHVybiBjb250ZXh0LnZhbHVlTWFuYWdlci5hZGRMaXN0ZW5lcihyZXNvbHZlZFBhdGgsICh2KT0+IHtcbiAgICAgICAgaW5qZWN0ZWRba2V5XSA9IHY7XG4gICAgICAgIHRoaXMubW91bnRlZCAmJiB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfSwgbnVsbCwgdHJ1ZSkucmVtb3ZlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0ZW4oQ2xhenosIGtleSkge1xuICAgIENsYXp6LmNvbnRleHRUeXBlcy52YWx1ZU1hbmFnZXIgPSBQcm9wVHlwZXMudmFsdWVNYW5hZ2VyO1xuXG4gICAgQ2xheno6OnRoaXMubGlzdGVuZXIoa2V5LCBoYW5kbGVMaXN0ZW5lcnMpO1xuXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvbGlzdGVuZXIuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuXG5jb25zdCBvcFJlID0gL14oPT18PT09fCE9fCE9PXw+PXw+fHRydXRoeXxmYWxzZXl8PHw8PXwoXFwhKT9cXC8oLiopXFwvKFtnaW15XSk/KSQvO1xuY29uc3QgZXEgPSBmdW5jdGlvbiAoY29tcGFyZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gY29tcGFyZVxufSwgZXFlcSA9IGZ1bmN0aW9uIChjb21wYXJlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gY29tcGFyZVxufSwgbmUgPSBmdW5jdGlvbiAoY29tcGFyZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gY29tcGFyZVxufSwgbmVlcSA9IGZ1bmN0aW9uIChjb21wYXJlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gY29tcGFyZVxufSwgZ3QgPSBmdW5jdGlvbiAoY29tcGFyZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPiBjb21wYXJlXG59LCBndGVxID0gZnVuY3Rpb24gKGNvbXBhcmUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID49IGNvbXBhcmVcbn0sIGx0ID0gZnVuY3Rpb24gKGNvbXBhcmUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgY29tcGFyZVxufSwgbHRlcSA9IGZ1bmN0aW9uIChjb21wYXJlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8PSBjb21wYXJlXG59LCB0cnV0aHkgPSBmdW5jdGlvbiAoY29tcGFyZSkge1xuICAgIHJldHVybiAhIWNvbXBhcmU7XG59LCBmYWxzZXkgPSBmdW5jdGlvbiAoY29tcGFyZSkge1xuICAgIHJldHVybiAhY29tcGFyZTtcbn07XG5cbmNvbnN0IG9wRmFjdG9yeSA9IChmdW5jdGlvbiBvcEZhY3RvcnkkZmFjdG9yeShzY29wZSkge1xuXG4gICAgcmV0dXJuIChvcGVyYXRvcik9PiB7XG4gICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RydXRoeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydXRoeTtcbiAgICAgICAgICAgIGNhc2UgJ2ZhbHNleSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNleTtcbiAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXE7XG4gICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBlcWVxO1xuICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZTtcbiAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lZXE7XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3Q7XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGd0ZXE7XG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbHQ7XG4gICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGx0ZXE7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG9wZXJhdG9yIFsnICsgb3BlcmF0b3IgKyAnXScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRPcGVyYXRvcihvcGVyYXRvciwga2V5LCBwcm9wcywgY29udGV4dCkge1xuXG4gICAgaWYgKG9wZXJhdG9yIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAoY29tcGFyZSwgdmFsdWUpID0+b3BlcmF0b3IudGVzdChjb21wYXJlLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3BlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wZXJhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgb3MgPSBvcFJlLmV4ZWMob3BlcmF0b3IpO1xuICAgICAgICBpZiAob3MpIHtcbiAgICAgICAgICAgIGlmIChvc1szXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBuZXcgUmVnRXhwKG9zWzNdLCBvc1s0XSk7XG4gICAgICAgICAgICAgICAgaWYgKG9zWzJdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlLCB2YWx1ZSkgPT4gb3BlcmF0b3IudGVzdChjb21wYXJlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNvbXBhcmUsIHZhbHVlKSA9PiAhb3BlcmF0b3IudGVzdChjb21wYXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3BGYWN0b3J5KG9wZXJhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmxvYWRlci5sb2FkT3BlcmF0b3Iob3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRvcjtcblxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcGVyYXRvcihDbGF6eiwga2V5KSB7XG4gICAgQ2xhenouY29udGV4dFR5cGVzLmxvYWRlciA9IFByb3BUeXBlcy5sb2FkZXI7XG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBsb2FkT3BlcmF0b3IpO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvb3BlcmF0b3IuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7dG9BcnJheX0gZnJvbSAnLi4vdHV0aWxzJztcblxuZnVuY3Rpb24gdG9PcHRpb25zKG52YWwpIHtcbiAgICBpZiAodHlwZW9mIG52YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7bGFiZWw6IG52YWwsIHZhbDogbnZhbH07XG4gICAgfVxuXG4gICAgaWYgKCgnbGFiZWwnIGluIG52YWwgKSAmJiAoJ3ZhbCcgaW4gbnZhbCkpIHtcbiAgICAgICAgcmV0dXJuIG52YWw7XG4gICAgfVxuICAgIGNvbnN0IHtsYWJlbCwgdmFsLCAuLi5yZXN0fSA9IG52YWw7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgICAgcmVzdC52YWwgPSBsYWJlbDtcbiAgICB9XG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgICByZXN0LmxhYmVsID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdDtcbn1cblxuZnVuY3Rpb24gYXNPcHRpb25zKHZhbCkge1xuICAgIHJldHVybiB0b0FycmF5KHZhbCkubWFwKHRvT3B0aW9ucyk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcHRpb25zKENsYXp6LCBrZXkpIHtcbiAgICBDbGF6ejo6dGhpcy5wcm9wZXJ0eShrZXksIGFzT3B0aW9ucyk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvb3B0aW9ucy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBsb2FkUHJvY2Vzc29yKHZhbHVlLCBrZXksIHByb3BzLCB7bG9hZGVyfSl7XG4gICAgcmV0dXJuIGxvYWRlci5sb2FkUHJvY2Vzc29yKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvY2Vzc29yKENsYXp6LCBrZXkpe1xuICAgIENsYXp6Ojp0aGlzLnByb3BlcnR5KGtleSwgbG9hZFByb2Nlc3Nvcik7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9wcm9jZXNzb3IuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IHt0b0FycmF5LCBGUkVFWkVfT0JKfSBmcm9tICcuLi90dXRpbHMnO1xuaW1wb3J0IHtub3JtYWxpemVGaWVsZHNldHN9IGZyb20gJy4vZmllbGRzZXQnO1xuaW1wb3J0IHtsb2FkVGVtcGxhdGV9IGZyb20gJy4vdGVtcGxhdGUnO1xuLyoqXG4gKiBTbyBhIHNjaGVtYSBjYW4gYmVcbiAqIEVYOiB7XG4gKiAgIGtleTonVGV4dCdcbiAqIH1cbiAqIG9yXG4gKiB7XG4gKiAgIHNjaGVtYTp7XG4gKiAgICAga2V5OidUZXh0J1xuICogICB9XG4gKiB9XG4gKiBvclxuICpcbiAqIHtcbiAqICAgc2NoZW1hOntcbiAqICAgIGYxOidUZXh0JyxcbiAqICAgIGYyOidUZXh0J1xuICogICB9LFxuICogICBmaWVsZHM6WydmMSddXG4gKlxuICogfVxuICogb3JcbiAqXG4gKiB7XG4gKiAgIHNjaGVtYTonSGVsbG8nXG4gKiB9XG4gKlxuICogb3JcbiAqXG4gKiAnSGVsbG8nXG4gKlxuICogQHBhcmFtIG9zY2hlbWFcbiAqIEBwYXJhbSBvZmllbGRzXG4gKiBAcGFyYW0gb2ZpZWxkc2V0c1xuICogQHBhcmFtIGxvYWRlclxuICogQHBhcmFtIG9yZXN0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvc2NoZW1hLCBvZmllbGRzLCBvZmllbGRzZXRzLCB7bG9hZGVyfSwgb3Jlc3QgPSBGUkVFWkVfT0JKKSB7XG4gICAgaWYgKG9zY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb3NjaGVtYTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9zY2hlbWEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemUobG9hZGVyLmxvYWRTY2hlbWEob3NjaGVtYSksIG9maWVsZHMsIG9maWVsZHNldHMsIGxvYWRlciwgb3Jlc3QpO1xuICAgIH1cbiAgICAvL3VzZSB0aGUgb3ZlcnJpZGVkIGZpZWxkc2V0cy5cbiAgICBpZiAob2ZpZWxkcyB8fCBvZmllbGRzZXRzKSB7XG5cbiAgICAgICAgaWYgKG9zY2hlbWEuc2NoZW1hKSB7XG4gICAgICAgICAgICBsZXQge2ZpZWxkcywgZmllbGRzZXRzLCBzY2hlbWEsIC4uLnJlc3R9ID0gb3NjaGVtYTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUobG9hZGVyLmxvYWRTY2hlbWEoc2NoZW1hKSwgb2ZpZWxkcywgb2ZpZWxkc2V0cywgbG9hZGVyLCByZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgICAuLi5ub3JtYWxpemVGaWVsZHNldHMob2ZpZWxkc2V0cywgb2ZpZWxkcyksXG4gICAgICAgICAgICAgICAgc2NoZW1hXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLm9yZXN0LFxuICAgICAgICAgICAgICAgIC4uLm5vcm1hbGl6ZUZpZWxkc2V0cyhvZmllbGRzZXRzLCBvZmllbGRzKSxcbiAgICAgICAgICAgICAgICBzY2hlbWE6IG9zY2hlbWFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3NjaGVtYS5maWVsZHMgfHwgb3NjaGVtYS5maWVsZHNldHMpIHtcbiAgICAgICAgbGV0IHtmaWVsZHMsIGZpZWxkc2V0cywgc2NoZW1hLCAuLi5yZXN0fSA9IG9zY2hlbWE7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShzY2hlbWEsIGZpZWxkcywgZmllbGRzZXRzLCBsb2FkZXIsIHJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgLi4ubm9ybWFsaXplRmllbGRzZXRzKG9zY2hlbWEuZmllbGRzZXRzLCBvc2NoZW1hLmZpZWxkcyksXG4gICAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL3NjaGVtYSB3aXRob3V0IGZpZWxkcywgb3IgZmllbGRzZXRzXG4gICAgaWYgKG9zY2hlbWEuc2NoZW1hKSB7XG4gICAgICAgIGxldCB7c2NoZW1hLCAuLi5yZXN0fSA9IG9zY2hlbWE7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy9vZmllbGRzIGFuZCBvZmllbGRzIHNob3VsZCBiZSBudWxsIGhlcmUuXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKHNjaGVtYSwgb2ZpZWxkcywgb2ZpZWxkc2V0cywgbG9hZGVyLCByZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICBmaWVsZHNldHM6IFt7ZmllbGRzfV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGZpZWxkcyA9IE9iamVjdC5rZXlzKG9zY2hlbWEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9yZXN0LFxuICAgICAgICBmaWVsZHMsXG4gICAgICAgIGZpZWxkc2V0czogW3tmaWVsZHN9XSxcbiAgICAgICAgc2NoZW1hOiBvc2NoZW1hXG4gICAgfTtcblxufVxuXG5leHBvcnQgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgdGVtcGxhdGU6ICdPYmplY3RUZW1wbGF0ZSdcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTY2hlbWEob3NjaGVtYSwga2V5LCBwcm9wcywgY29udGV4dCkge1xuICAgIGlmIChvc2NoZW1hID09IG51bGwpIHJldHVybiBvc2NoZW1hO1xuICAgIGNvbnN0IHNjaGVtYSA9IG5vcm1hbGl6ZShvc2NoZW1hLCBwcm9wcy5maWVsZHNldHMsIHByb3BzLmZpZWxkcywgY29udGV4dCk7XG4gICAgaWYgKHByb3BzLm9iamVjdFRlbXBsYXRlKSB7XG4gICAgICAgIHNjaGVtYS5UZW1wbGF0ZSA9IGxvYWRUZW1wbGF0ZShwcm9wcy5vYmplY3RUZW1wbGF0ZSwga2V5LCBwcm9wcywgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEudGVtcGxhdGUpIHtcbiAgICAgICAgc2NoZW1hLlRlbXBsYXRlID0gbG9hZFRlbXBsYXRlKHNjaGVtYS50ZW1wbGF0ZSwga2V5LCBwcm9wcywgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChwcm9wcy5mYWxsYmFja1RlbXBsYXRlKSB7XG4gICAgICAgIHNjaGVtYS5UZW1wbGF0ZSA9IGxvYWRUZW1wbGF0ZShwcm9wcy5mYWxsYmFja1RlbXBsYXRlLCBrZXksIHByb3BzLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWEuVGVtcGxhdGUgPSBsb2FkVGVtcGxhdGUoc2V0dGluZ3MudGVtcGxhdGUsICBrZXksIHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbn1cblxuZnVuY3Rpb24gc2NoZW1hKENsYXp6LCBrZXkpIHtcbiAgICBDbGF6ei5jb250ZXh0VHlwZXMubG9hZGVyID0gUHJvcFR5cGVzLmxvYWRlcjtcbiAgICBDbGF6ejo6dGhpcy5wcm9wZXJ0eShrZXksIG5vcm1hbGl6ZVNjaGVtYSk7XG59XG5cbnNjaGVtYS5ub3JtYWxpemVTY2hlbWEgPSBub3JtYWxpemVTY2hlbWE7XG5leHBvcnQgZGVmYXVsdCBzY2hlbWE7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvc2NoZW1hLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5cblxuLyoqXG4gKiBUYWtlcyB0aGUga2V5cyBvZiBhIHN0eWxlIG9iamVjdCBhbmQgY29udmVydHMgdGhlbSB0byBhbiBvYmplY3RcbiAqIHN1aXRhYmxlIHRvIGRlZmF1bHQgcHJvcHMgd2l0aCB0aGUgZGVmYXVsdCB2YWx1ZSBiZWluZyB0aGUgc3R5bGVzXG4gKiByZXNvbHZlZCBkZWZhdWx0IHN0eWxlLlxuICpcbiAqIEBwYXJhbSBzdHlsZXNcbiAqIEBwYXJhbSBwcm9wc1xuICogQHBhcmFtIHByZUZpeFxuICogQHBhcmFtIHBvc3RGaXhcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVUb1Byb3BzKHN0eWxlcywgcHJvcHMgPSB7fSwgcHJlRml4ID0gJycsIHBvc3RGaXggPSBcIkNsYXNzXCIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVzKS5yZWR1Y2UoKHJldCwga2V5KSA9PiB7XG4gICAgICAgIHJldFtgJHtwcmVGaXh9JHtrZXl9JHtwb3N0Rml4fWBdID0gc3R5bGVzW2tleV07XG4gICAgICAgIHJldHVybiByZXRcbiAgICB9LCBwcm9wcyk7XG59XG4vKipcbiAqIFNvIHN0eWxlcyB0cmllcyB0b2xvYWQgdmlhIGxvYWRlci5sb2FkU3R5bGUoQ2xhc3NOYW1lIG9yIHRoZSB2YWx1ZSBvZiB0aGUgc3R5bGUpIHdoaWNoXG4gKiBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5cbiAqXG4gKiBJdCB3aWxsIGl0ZXJhdGUgb3ZlciBzYWlkIG9iamVjdCBhbmQgcHJvcGVydGllcyB3aXRoIHRoZSBrZXkgYmVpbmcgcmVuYW1lZCAke2tleX1DbGFzc1xuICogYW5kIHRoZSB2YWx1ZSBiZWluZyBpbnN0YWxsZWQuXG4gKlxuICogSWYgYSB2YWx1ZSBpcyBwYXNzZWQgdG8gdGhlIG9iamVjdCwgZm9yIGEgZmllbGQsIHRoYW4gdGhhdCB2YWx1ZSBpcyB1c2VkLiAgUmF0aGVyXG4gKiB0aGFuIHRoZVxuICpcbiAqXG4gKiBAcGFyYW0gQ2xhenpcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSBwcm9wTGlzdFxuICogQHBhcmFtIE9yaWdDbGF6elxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdHlsZShDbGF6eiwga2V5LCBwcm9wTGlzdCwgT3JpZ0NsYXp6KSB7XG4gICAgQ2xhenouY29udGV4dFR5cGVzLmxvYWRlciA9IFByb3BUeXBlcy5sb2FkZXI7XG5cbiAgICBDbGF6ejo6dGhpcy5wcm9wZXJ0eShrZXksIGZ1bmN0aW9uIHN0eWxlJHJlc29sdmVyJHByb3BlcnR5KHZhbHVlLCBrZXksIHByb3BzLCB7bG9hZGVyfSkge1xuICAgICAgICBjb25zdCB7aW5qZWN0ZWR9ID0gdGhpcztcbiAgICAgICAgY29uc3QgU3R5bGUgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBsb2FkZXIubG9hZFN0eWxlKHZhbHVlIHx8IE9yaWdDbGF6ei5kaXNwbGF5TmFtZSB8fCBPcmlnQ2xhenoubmFtZSkgOiB2YWx1ZTtcbiAgICAgICAgaWYgKFN0eWxlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmogPSBzdHlsZVRvUHJvcHMoU3R5bGUsIHt9KTtcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpPT4ge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGluamVjdGVkW2tleV0gPSBwcm9wc1trZXldIHx8ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmplY3RlZFtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcExpc3QuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHByb3BMaXN0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBTdHlsZTtcbiAgICB9KTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy9zdHlsZS5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQgeyByZXNvbHZlS2V5IH0gZnJvbSAnLi4vdHV0aWxzJztcblxuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSwga2V5LCBwcm9wcywge3ZhbHVlTWFuYWdlcn0pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZUtleShwcm9wcy5wYXRoLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRhcmdldEV2ZW50JHJlc29sdmUoZSkge1xuICAgICAgICB2YWx1ZU1hbmFnZXIudXBkYXRlKHJlc29sdmVkUGF0aCwgZS50YXJnZXQudmFsdWUpXG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGFyZ2V0RXZlbnQoQ2xhenosIGtleSkge1xuXG4gICAgQ2xhenouY29udGV4dFR5cGVzLnZhbHVlTWFuYWdlciA9IFByb3BUeXBlcy52YWx1ZU1hbmFnZXI7XG5cbiAgICBDbGF6ejo6dGhpcy5wcm9wZXJ0eShrZXksIHJlc29sdmUpXG5cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy90YXJnZXRFdmVudC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQge3RpdGxlbGl6ZSB9IGZyb20gJy4uL3R1dGlscyc7XG5cbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUsIGtleSwgcHJvcHMpIHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gcHJvcHMubmFtZSB8fCBwcm9wcy5pZCB8fCBwcm9wcy5wYXRoIHx8ICcnO1xuXG4gICAgcmV0dXJuIHRpdGxlbGl6ZSh2YWwuc3BsaXQoL1xcLi8pLnBvcCgpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsdWVFdmVudChDbGF6eiwga2V5KSB7XG5cbiAgICBDbGF6ejo6dGhpcy5wcm9wZXJ0eShrZXksIHJlc29sdmUpO1xuXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvdGl0bGUuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCBUcmFuc2l0aW9uIGZyb20gJy4uL3RyYW5zaXRpb24vUmVhY3RDU1NSZXBsYWNlVHJhbnNpdGlvbi5qc3gnO1xuXG5leHBvcnQgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgdHJhbnNpdGlvbjogJ3JvbGxVcCcsXG4gICAgb246IFsnZW50ZXInLCAnbGVhdmUnXSxcbiAgICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uXG59O1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVUcmFuc2l0aW9uKHZhbHVlLCBrZXksIHByb3BzLCB7bG9hZGVyfSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZS50cmFuc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgPSB7dHJhbnNpdGlvbjogdmFsdWV9O1xuICAgIH1cblxuICAgIGNvbnN0IHt0cmFuc2l0aW9uLCAuLi5jb25maWd9ID0gIHsuLi5zZXR0aW5ncywgLi4udmFsdWV9O1xuXG4gICAgY29uc3Qge1xuICAgICAgICB0cmFuc2l0aW9uQXBwZWFyVGltZW91dCxcbiAgICAgICAgdHJhbnNpdGlvbkxlYXZlVGltZW91dCxcbiAgICAgICAgdHJhbnNpdGlvbkVudGVyVGltZW91dCxcbiAgICAgICAgb24sXG4gICAgICAgIHRyYW5zaXRpb25OYW1lOntlbnRlciwgZW50ZXJBY3RpdmUsIGFwcGVhciwgYXBwZWFyQWN0aXZlLCBsZWF2ZSwgbGVhdmVBY3RpdmV9LFxuICAgICAgICAuLi5yZXN0fSA9IHR5cGVvZiB0cmFuc2l0aW9uID09PSAnc3RyaW5nJyA/IHsuLi5jb25maWcsIC4uLmxvYWRlci5sb2FkVHJhbnNpdGlvbih0cmFuc2l0aW9uKX0gOiB0cmFuc2l0aW9uO1xuXG4gICAgY29uc3QgX29uID0gQXJyYXkuaXNBcnJheShvbikgPyBvbiA6IFtvbl07XG4gICAgY29uc3QgdHJhbnNpdGlvbk5hbWUgPSAocmVzdC50cmFuc2l0aW9uTmFtZSA9IHt9KTtcbiAgICAvL2VpdGhlciB0aGUgb3JpZ2luYWwgdmFsdWUgaGFzIHRoZSB0aW1lb3V0IG9yIHdlIGhhdmUgYW4gb25cbiAgICBpZiAodmFsdWUudHJhbnNpdGlvbkVudGVyVGltZW91dCB8fCBfb24uaW5kZXhPZignZW50ZXInKSAhPSAtMSkge1xuICAgICAgICByZXN0LnRyYW5zaXRpb25FbnRlclRpbWVvdXQgPSB0cmFuc2l0aW9uRW50ZXJUaW1lb3V0O1xuICAgICAgICB0cmFuc2l0aW9uTmFtZS5lbnRlciA9IGVudGVyO1xuICAgICAgICB0cmFuc2l0aW9uTmFtZS5lbnRlckFjdGl2ZSA9IGVudGVyQWN0aXZlO1xuICAgICAgICByZXN0LnRyYW5zaXRpb25FbnRlciA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdC50cmFuc2l0aW9uRW50ZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUudHJhbnNpdGlvbkFwcGVhclRpbWVvdXQgfHwgX29uLmluZGV4T2YoJ2FwcGVhcicpICE9IC0xKSB7XG4gICAgICAgIHJlc3QudHJhbnNpdGlvbkFwcGVhclRpbWVvdXQgPSB0cmFuc2l0aW9uQXBwZWFyVGltZW91dDtcbiAgICAgICAgdHJhbnNpdGlvbk5hbWUuYXBwZWFyID0gYXBwZWFyO1xuICAgICAgICB0cmFuc2l0aW9uTmFtZS5hcHBlYXJBY3RpdmUgPSBhcHBlYXJBY3RpdmU7XG4gICAgICAgIHJlc3QudHJhbnNpdGlvbkFwcGVhciA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdC50cmFuc2l0aW9uQXBwZWFyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnRyYW5zaXRpb25MZWF2ZVRpbWVvdXQgfHwgX29uLmluZGV4T2YoJ2xlYXZlJykgIT0gLTEpIHtcbiAgICAgICAgcmVzdC50cmFuc2l0aW9uTGVhdmVUaW1lb3V0ID0gdHJhbnNpdGlvbkxlYXZlVGltZW91dDtcbiAgICAgICAgdHJhbnNpdGlvbk5hbWUubGVhdmUgPSBsZWF2ZTtcbiAgICAgICAgdHJhbnNpdGlvbk5hbWUubGVhdmVBY3RpdmUgPSBsZWF2ZUFjdGl2ZTtcbiAgICAgICAgcmVzdC50cmFuc2l0aW9uTGVhdmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3QudHJhbnNpdGlvbkxlYXZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3Q7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb24oQ2xhenosIGtleSkge1xuICAgIENsYXp6LmNvbnRleHRUeXBlcy5sb2FkZXIgPSBQcm9wVHlwZXMubG9hZGVyO1xuICAgIENsYXp6Ojp0aGlzLnByb3BlcnR5KGtleSwgaGFuZGxlVHJhbnNpdGlvbik7XG59XG4vL2JlY2F1c2UgZXM2IG1vZHVsZXMuXG50cmFuc2l0aW9uLmhhbmRsZVRyYW5zaXRpb24gPSBoYW5kbGVUcmFuc2l0aW9uO1xuXG5leHBvcnQgZGVmYXVsdCB0cmFuc2l0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvcmVzb2x2ZXJzL3RyYW5zaXRpb24uanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHtpc1N0cmluZyxpc0FycmF5LCBzbGljZSwgaXNGdW5jdGlvbiwgcHVzaH0gZnJvbSAnLi4vdHV0aWxzJztcblxuZXhwb3J0IGNvbnN0IHNldHRpbmdzID0ge1xuICAgIGlucHV0Q2xhc3NOYW1lOidmb3JtLWNvbnRyb2wnXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3NlcyhjbGFzc2VzLCAuLi5yZXN0KSB7XG4gICAgaWYgKHJlc3QgPT0gbnVsbCB8fCByZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSByZXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBzdHIgPSByZXN0W2ldO1xuXG4gICAgICAgIGlmIChzdHIgPT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKGlzU3RyaW5nKHN0cikpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3RyLnNwbGl0KC9cXHMrPy8pO1xuXG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NlcyhjbGFzc2VzLCAuLi5wYXJ0cyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKHN0cikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChzdHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHN0cikpIHtcbiAgICAgICAgICAgIGFkZENsYXNzZXMoY2xhc3NlcywgLi4uc3RyKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc3RyKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3NlcyhjbGFzc2VzLCB0aGlzOjpzdHIoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzZXM7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgY2xhc3NlcyBmb3IgYSB0eXBlLlxuICogVGFrZXMgYSByZWFjdCBub2RlIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7UmVhY3Rub2RlfSBub2RlIC0gbm9kZSB0byBjcmVhdGUgZm9yLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb258QXJyYXk8U3RyaW5nfEZ1bmN0aW9ufEFycmF5Pn0gW2NsYXNlc10gLWNsYXNzZXMgdG8gYWRkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yVHlwZShPcmlnQ2xhenosIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFkZENsYXNzZXMoW10sIHZhbHVlIHx8IE9yaWdDbGF6ei5pbnB1dENsYXNzTmFtZSB8fCBzZXR0aW5ncy5pbnB1dENsYXNzTmFtZSkuam9pbignICcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0eXBlQ2xhc3MoQ2xhenosIGtleSwgcHJvcExpc3QsIE9yaWdDbGF6eikge1xuXG4gICAgQ2xheno6OnRoaXMucHJvcGVydHkoa2V5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZvclR5cGUoT3JpZ0NsYXp6LCB2YWx1ZSk7XG4gICAgfSk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvdHlwZUNsYXNzLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi4vUHJvcFR5cGVzJztcbmltcG9ydCB7cmVzb2x2ZUtleX0gZnJvbSAnLi4vdHV0aWxzJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC9sYW5nL2lzUGxhaW5PYmplY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVIYW5kbGVyKHZhbHVlLCBrZXksIGxvYWRlcil7XG4gICAgaWYgKHZhbHVlLnByb2Nlc3Nvcil7XG4gICAgICAgIGNvbnN0IHByb2Nlc3MgPSB0eXBlb2YgdmFsdWUucHJvY2Vzc29yID09ICdmdW5jdGlvbicgPyB2YWx1ZS5wcm9jZXNzb3I6IGxvYWRlci5sb2FkUHJvY2Vzc29yKHZhbHVlLnByb2Nlc3NvcikudmFsdWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB2YWx1ZSRwcm9jZXNzc29ySGFuZGxlcih2KXtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0ZWRba2V5XSA9IHByb2Nlc3Modik7XG4gICAgICAgICAgICB0aGlzLm1vdW50ZWQgJiYgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdmFsdWUkaGFuZGxlcih2KXtcbiAgICAgICAgdGhpcy5pbmplY3RlZFtrZXldID0gdjtcbiAgICAgICAgdGhpcy5tb3VudGVkICYmIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlTGlzdGVuZXJzKHZhbHVlLCBrZXksIHByb3BzLCB7dmFsdWVNYW5hZ2VyLCBsb2FkZXJ9KSB7XG4gICAgbGV0IHJlc29sdmVkUGF0aDtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc29sdmVkUGF0aCA9IHJlc29sdmVLZXkocHJvcHMucGF0aCwgdmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHNldHRpbmdzO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZUtleShwcm9wcy5wYXRoLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gey4uLnNldHRpbmdzLCAuLi52YWx1ZX1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVNYW5hZ2VyLmFkZExpc3RlbmVyKHJlc29sdmVkUGF0aCwgY3JlYXRlSGFuZGxlcih2YWx1ZSwga2V5LCBsb2FkZXIpLCB0aGlzLCB2YWx1ZS5pbml0KS5yZW1vdmU7XG59XG5cbmV4cG9ydCBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAvL2ZpcmUgdGhlIGxpc3RlbmVyIGltbWVkaWF0ZWx5LCBkbyBub3Qgd2FpdCBmb3IgYSBjaGFuZ2UuXG4gICAgaW5pdDogdHJ1ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsdWUoQ2xhenosIGtleSkge1xuICAgIENsYXp6LmNvbnRleHRUeXBlcy52YWx1ZU1hbmFnZXIgPSBQcm9wVHlwZXMudmFsdWVNYW5hZ2VyO1xuICAgIENsYXp6LmNvbnRleHRUeXBlcy5sb2FkZXIgPSBQcm9wVHlwZXMubG9hZGVyO1xuXG4gICAgQ2xheno6OnRoaXMubGlzdGVuZXIoa2V5LCBoYW5kbGVMaXN0ZW5lcnMpO1xuXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9yZXNvbHZlcnMvdmFsdWUuanNcbiAqKi8iLCJ2YXIgYmFzZUZvckluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUZvckluJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhc3N1bWVzIG9iamVjdHMgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3JcbiAqIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICB2YXIgQ3RvcjtcblxuICAvLyBFeGl0IGVhcmx5IGZvciBub24gYE9iamVjdGAgb2JqZWN0cy5cbiAgaWYgKCEoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RUYWcgJiYgIWlzQXJndW1lbnRzKHZhbHVlKSkgfHxcbiAgICAgICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NvbnN0cnVjdG9yJykgJiYgKEN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhKEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElFIDwgOSBpdGVyYXRlcyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuIElmIHRoZSBmaXJzdFxuICAvLyBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QncyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkXG4gIC8vIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgdmFyIHJlc3VsdDtcbiAgLy8gSW4gbW9zdCBlbnZpcm9ubWVudHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGJlZm9yZVxuICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICBiYXNlRm9ySW4odmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHQgPSBrZXk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvbGFuZy9pc1BsYWluT2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vYmFzZUZvcicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9ySW47XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3N1YnNjaGVtYS9+L2xvZGFzaC9pbnRlcm5hbC9iYXNlRm9ySW4uanNcbiAqKiBtb2R1bGUgaWQgPSA0MDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJy4uL1Byb3BUeXBlcyc7XG5pbXBvcnQge3Jlc29sdmVLZXl9IGZyb20gJy4uL3R1dGlscyc7XG5cbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUsIGtleSwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZUtleShwcm9wcy5wYXRoLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGNvbnRleHQudmFsdWVNYW5hZ2VyLnVwZGF0ZShyZXNvbHZlZFBhdGgsIHYpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsdWVFdmVudChDbGF6eiwga2V5KSB7XG5cbiAgICBDbGF6ei5jb250ZXh0VHlwZXMudmFsdWVNYW5hZ2VyID0gUHJvcFR5cGVzLnZhbHVlTWFuYWdlcjtcblxuICAgIENsYXp6Ojp0aGlzLnByb3BlcnR5KGtleSwgcmVzb2x2ZSk7XG5cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL3Jlc29sdmVycy92YWx1ZUV2ZW50LmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi93YXJuaW5nJztcbmltcG9ydCBtYXAgZnJvbSAnbG9kYXNoL2NvbGxlY3Rpb24vbWFwJztcbmltcG9ydCBkZWNvcmF0b3IgZnJvbSAnLi9kZWNvcmF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcm92aWRlckZhY3Rvcnkoe2RlZmF1bHRMb2FkZXJ9LCB0eXBlcyA9IFsndHlwZScsICd2YWxpZGF0b3InLCAndGVtcGxhdGUnLCAncHJvY2Vzc29yJywgJ29wZXJhdG9yJywgJ3RyYW5zaXRpb24nXSkge1xuICAgIGNvbnN0IHByb3ZpZGUgPSBkZWNvcmF0b3IocHJvdmlkZVByb3BlcnR5LCBwcm92aWRlQ2xhc3MpO1xuICAgIHByb3ZpZGUuZGVmYXVsdExvYWRlciA9IGRlZmF1bHRMb2FkZXI7XG5cblxuICAgIC8qKipcbiAgICAgKlxuICAgICAqIFRvIGFkZCBhIHR5cGVcbiAgICAgKlxuICAgICAqIEBwcm92aWRlci50eXBlKFwiU29tZXRoaW5nRWxzZVwiKVxuICAgICAqIEBmaWVsZFxuICAgICAqIGNsYXNzIE5ld1R5cGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICpcbiAqXG4gKiB9XG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEBwYXJhbSBwcm9wVHlwZVxuICAgICAqIEBwYXJhbSBsb2FkZXJcbiAgICAgKiBAcmV0dXJucyB7cHJvdmlkZUNsYXNzJGNvbmZpZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm92aWRlQ2xhc3ModHlwZSwgbmFtZSwgcHJvcFR5cGUsIGxvYWRlciA9IGRlZmF1bHRMb2FkZXIpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHJvdmlkZUNsYXNzJGNvbmZpZyh0YXJnZXQpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IHRhcmdldC5uYW1lO1xuICAgICAgICAgICAgdHlwZSA9IF90eXBlKHR5cGUpO1xuICAgICAgICAgICAgbG9hZGVyW3R5cGVdKG5hbWUsIHRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvdmlkZVNjaGVtYUNsYXNzKG5hbWUsIHByb3BUeXBlLCBsb2FkZXIgPSBkZWZhdWx0TG9hZGVyKSB7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByb3ZpZGVDbGFzcyRjb25maWcoVGFyZ2V0KSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBUYXJnZXQubmFtZTtcbiAgICAgICAgICAgIGxvYWRlci5hZGRTY2hlbWEobmFtZSwgbmV3IFRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gVGFyZ2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvdmlkZVByb3BlcnR5KHR5cGUsIG5hbWUsIHByb3BUeXBlLCBsb2FkZXIgPSBkZWZhdWx0TG9hZGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwcm92aWRlUHJvcGVydHkkY29uZmlnKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IHByb3BlcnR5O1xuXG4gICAgICAgICAgICB2YXIge3ZhbHVlLCBpbml0aWFsaXplciwgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSwgIC4uLnJlc3R9ID0gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICBsb2FkZXIuYWRkTG9hZGVyKHtcbiAgICAgICAgICAgICAgICBbIF90eXBlKHR5cGUsICdsb2FkJyldOiAobG9hZE5hbWUsIC4uLnJlc3QpPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZE5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzLCByZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgWyBfdHlwZSh0eXBlLCAnbGlzdCcsICdzJyldOiAoKT0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXN0LnNldCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN0O1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdHlwZSh0eXBlLCBwcmVmaXggPSAnYWRkJywgcG9zdGZpeCA9ICcnKSB7XG5cbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnbXVzdCBwcm92aWRlIGZvciBhIHR5cGUnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZWZpeCArICh0eXBlLnN1YnN0cmluZygwLCAxKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHJpbmcoMSkpICsgcG9zdGZpeDtcbiAgICB9XG5cbiAgICAvKiovXG5cbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpc1trZXldID0gZGVjb3JhdG9yKHByb3ZpZGVQcm9wZXJ0eS5iaW5kKG51bGwsIGtleSksIHByb3ZpZGVDbGFzcy5iaW5kKG51bGwsIGtleSkpO1xuICAgIH0sIHByb3ZpZGUpO1xuXG4gICAgcHJvdmlkZS5zY2hlbWEgPSBkZWNvcmF0b3IocHJvdmlkZUNsYXNzLmJpbmQobnVsbCwgJ3NjaGVtYScpLCBwcm92aWRlU2NoZW1hQ2xhc3MpO1xuICAgIHJldHVybiBwcm92aWRlO1xufVxuLypcblxuIGV4cG9ydCB2YXIgdHlwZSA9ICBkZWNvcmF0b3IocHJvdmlkZVByb3BlcnR5LmJpbmQobnVsbCwgJ3R5cGUnKSwgcHJvdmlkZUNsYXNzLmJpbmQobnVsbCwgJ3R5cGUnKSk7XG4gZXhwb3J0IHZhciB2YWxpZGF0b3IgPSAgZGVjb3JhdG9yKHByb3ZpZGVQcm9wZXJ0eS5iaW5kKG51bGwsICd2YWxpZGF0b3InKSwgcHJvdmlkZUNsYXNzLmJpbmQobnVsbCwgJ3ZhbGlkYXRvcicpKTtcbiBleHBvcnQgdmFyIHNjaGVtYSA9ICBkZWNvcmF0b3IocHJvdmlkZVByb3BlcnR5LmJpbmQobnVsbCwgJ3NjaGVtYScpLCBwcm92aWRlQ2xhc3MuYmluZChudWxsLCAnc2NoZW1hJykpO1xuIGV4cG9ydCB2YXIgdGVtcGxhdGUgPSAgZGVjb3JhdG9yKHByb3ZpZGVQcm9wZXJ0eS5iaW5kKG51bGwsICd0ZW1wbGF0ZScpLCBwcm92aWRlQ2xhc3MuYmluZChudWxsLCAndGVtcGxhdGUnKSk7XG4gZXhwb3J0IHZhciBwcm9jZXNzb3IgPSAgZGVjb3JhdG9yKHByb3ZpZGVQcm9wZXJ0eS5iaW5kKG51bGwsICdwcm9jZXNzb3InKSwgcHJvdmlkZUNsYXNzLmJpbmQobnVsbCwgJ3Byb2Nlc3NvcicpKTtcbiBleHBvcnQgdmFyIG9wZXJhdG9yID0gIGRlY29yYXRvcihwcm92aWRlUHJvcGVydHkuYmluZChudWxsLCAnb3BlcmF0b3InKSwgcHJvdmlkZUNsYXNzLmJpbmQobnVsbCwgJ29wZXJhdG9yJykpO1xuXG4gKi9cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9kZWNvcmF0b3JzL3Byb3ZpZGVGYWN0b3J5LmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7SGFzaEJ1aWxkZXJ9IGZyb20gJy4vaGFzaCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhY2hlZEluamVjdChpbmplY3Rvcikge1xuICAgIGxldCBjYWNoZTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVyIGdldHMgY2FsbGVkICBhIGJ1bmNoIG9mIHRpbWVzLFxuICAgICAqIHJhdGhlciB0aGFuIGluaXRpbmcgV2Vha01hcCBhIG1pbGxpb24gdGltZXMsXG4gICAgICogbGV0J3MganVzdCBkbyBpdCBpbiB0aGUgbWFpbiBpbmplY3QgbG9vcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9wVHlwZVxuICAgICAqIEBwYXJhbSByZXNvbHZlclxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVyKHByb3BUeXBlLCByZXNvbHZlcikge1xuICAgICAgICBpZiAocHJvcFR5cGUgJiYgcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIC8vaW52YWxpZGF0ZSBjYWNoZSB3aXRoIG5ldyByZXNvbHZlclxuICAgICAgICAgICAgY2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmplY3Rvci5yZXNvbHZlcihwcm9wVHlwZSwgcmVzb2x2ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluamVjdChDbGF6eiwgZXh0cmFQcm9wVHlwZXMsIGV4dHJhUHJvcHMsIHN0cmljdFByb3BzKSB7XG4gICAgICAgIGlmIChDbGF6eiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XG4gICAgICAgIH1cbiAgICAgICAgLy93ZSBuZWVkIHRvIGdlbmVyYXRlIHRoZSBoYXNoIHJlZ2FyZGxlc3Mgb2YgaGF2aW5nIGEgY2FjaGUuXG4gICAgICAgIGNvbnN0IGhhc2ggPSBuZXcgSGFzaEJ1aWxkZXIoc3RyaWN0UHJvcHMpLmFkZE9iamVjdChleHRyYVByb3BUeXBlcykuYWRkT2JqZWN0KGV4dHJhUHJvcHMpLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjdXI7XG4gICAgICAgIC8vbm8gY2FjaGUgc28gbm8gcG9pbnQgaW4gY2hlY2tpbmcgaXQuXG4gICAgICAgIGlmIChjYWNoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBjdXIgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjYWNoZS5zZXQoQ2xhenosIGN1cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXIgPSBjYWNoZS5nZXQoQ2xhenopO1xuICAgICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtsYXp6ID0gY3VyLmdldChoYXNoKTtcbiAgICAgICAgICAgICAgICBpZiAoa2xhenogIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrbGF6ejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ciA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQoQ2xhenosIGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdG9yLmluamVjdChDbGF6eiwgZXh0cmFQcm9wVHlwZXMsIGV4dHJhUHJvcHMsIHN0cmljdFByb3BzKTtcbiAgICAgICAgaW5qZWN0ZWQuZGlzcGxheU5hbWUgPSBgJHtpbmplY3RlZC5kaXNwbGF5TmFtZX0kJHtoYXNofWA7XG4gICAgICAgIGluamVjdGVkLiRoYXNoID0gaGFzaDtcbiAgICAgICAgY3VyLnNldChoYXNoLCBpbmplY3RlZCk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIHJldHVybiBpbmplY3RlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2l6ZSgpe1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzb2x2ZXIsXG4gICAgICAgIGluamVjdCxcbiAgICAgICAgc2l6ZVxuICAgIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9jYWNoZWRJbmplY3Rvci5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaGFzaChzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogc3RyaW5nICsgJyc7XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGlmICghc3RyaW5nKSByZXR1cm4gJycgKyBoYXNoO1xuICAgIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG4gICAgcmV0dXJuIChoYXNoKS50b1N0cmluZygxNik7XG59XG5leHBvcnQgY2xhc3MgSGFzaEJ1aWxkZXIge1xuICAgIGhhc2ggPSAwO1xuXG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMuYWRkKHN0cik7XG4gICAgfVxuXG4gICAgYWRkVmFsdWUodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHZhbCA9IHR5cGVvZiB2YWw7XG4gICAgICAgIGlmICh0dmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2ggKz0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR2YWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKCcnICsgdmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0dmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRGdW5jdGlvbih2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkT2JqZWN0KHZhbCk7XG4gICAgfVxuXG4gICAgYWRkT2JqZWN0KG9iaikge1xuICAgICAgICB0aGlzLmFkZENoYXIoJz0nKTtcbiAgICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkS2V5KGtleSkuYWRkVmFsdWUob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGFkZEtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ2hhcignLCcpLmFkZChrZXkpLmFkZENoYXIoJzonKTtcbiAgICB9XG5cbiAgICBhZGRGdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIHRoaXMuaGFzaCArPSBwYXJzZUludChoYXNoRnVuYyhmdW5jKSwgMTYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBhZGRDaGFyKHZhbCkge1xuICAgICAgICBsZXQgaGFzaCA9IHRoaXMuaGFzaDtcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgdmFsLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHRoaXMuaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYWRkKHN0cikge1xuICAgICAgICBzdHIgPSBzdHIgPT0gbnVsbCA/ICcnIDogc3RyICsgJyc7XG4gICAgICAgIGxldCBoYXNoID0gdGhpcy5oYXNoO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhhc2gpLnRvU3RyaW5nKDE2KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaEZ1bmMoZnVuYykge1xuICAgIHJldHVybiBmdW5jID09IG51bGwgPyAwIDogZnVuYy4kaGFzaCB8fCAoZnVuYy4kaGFzaCA9IGhhc2goZnVuYy50b1N0cmluZygpKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0ICBoYXNoO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3N1YnNjaGVtYS9zcmMvaGFzaC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQ29uZGl0aW9uYWwgZnJvbSAnLi9jb21wb25lbnRzL0NvbmRpdGlvbmFsLmpzeCc7XG5pbXBvcnQgRmllbGQgZnJvbSAnLi9jb21wb25lbnRzL0ZpZWxkLmpzeCc7XG5pbXBvcnQgRmllbGRTZXQgZnJvbSAnLi9jb21wb25lbnRzL0ZpZWxkU2V0LmpzeCc7XG5pbXBvcnQgTmV3Q2hpbGRDb250ZXh0IGZyb20gJy4vY29tcG9uZW50cy9OZXdDaGlsZENvbnRleHQuanN4JztcbmltcG9ydCBGb3JtIGZyb20gJy4vY29tcG9uZW50cy9Gb3JtLmpzeCc7XG5pbXBvcnQgRG9tIGZyb20gJy4vRG9tJztcbmltcG9ydCBldmVudGFibGUgZnJvbSAnLi9ldmVudGFibGUnO1xuaW1wb3J0IGxvYWRlckZhY3RvcnkgZnJvbSAnLi9sb2FkZXJGYWN0b3J5JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IHZhbGlkYXRvcnMgZnJvbSAnLi92YWxpZGF0b3JzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vd2FybmluZyc7XG5pbXBvcnQgKiBhcyB0dXRpbHMgZnJvbSAnLi90dXRpbHMnO1xuaW1wb3J0IFZhbHVlTWFuYWdlciBmcm9tICcuL1ZhbHVlTWFuYWdlcic7XG5pbXBvcnQgY3NzIGZyb20gJy4vY3NzJztcbmltcG9ydCAqIGFzIGRlY29yYXRvcnMgZnJvbSAnLi9kZWNvcmF0b3JzL2luZGV4JztcbmltcG9ydCB7aW5qZWN0b3JGYWN0b3J5fSBmcm9tICdzdWJzY2hlbWEtaW5qZWN0aW9uJztcbmltcG9ydCBjYWNoZWRJbmplY3RvciBmcm9tICcuL2NhY2hlZEluamVjdG9yJztcbmltcG9ydCBwcm92aWRlRmFjdG9yeSBmcm9tICcuL2RlY29yYXRvcnMvcHJvdmlkZUZhY3RvcnknO1xuZXhwb3J0IHtcbiAgICBDb25kaXRpb25hbCxcbiAgICBGaWVsZCxcbiAgICBGaWVsZFNldCxcbiAgICBGb3JtLFxuICAgIE5ld0NoaWxkQ29udGV4dCxcbiAgICBEb20sXG4gICAgUHJvcFR5cGVzLFxuICAgIFZhbHVlTWFuYWdlcixcbiAgICBjc3MsXG4gICAgZGVjb3JhdG9ycyxcbiAgICBldmVudGFibGUsXG4gICAgaW5qZWN0b3JGYWN0b3J5LFxuICAgIGxvYWRlckZhY3RvcnksXG4gICAgdHV0aWxzLFxuICAgIHZhbGlkYXRvcnMsXG4gICAgd2FybmluZyxcbiAgICBpbmplY3RvckZhY3RvcnksXG4gICAgY2FjaGVkSW5qZWN0b3IsXG4gICAgbmV3U3Vic2NoZW1hQ29udGV4dFxufTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBDb25kaXRpb25hbCxcbiAgICBGaWVsZCxcbiAgICBGaWVsZFNldCxcbiAgICBGb3JtLFxuICAgIE5ld0NoaWxkQ29udGV4dCxcbiAgICBEb20sXG4gICAgUHJvcFR5cGVzLFxuICAgIFZhbHVlTWFuYWdlcixcbiAgICBjc3MsXG4gICAgZGVjb3JhdG9ycyxcbiAgICBldmVudGFibGUsXG4gICAgY2FjaGVkSW5qZWN0b3IsXG4gICAgaW5qZWN0b3JGYWN0b3J5LFxuICAgIGxvYWRlckZhY3RvcnksXG4gICAgdHV0aWxzLFxuICAgIHZhbGlkYXRvcnMsXG4gICAgd2FybmluZyxcbiAgICBuZXdTdWJzY2hlbWFDb250ZXh0XG59XG5cbi8qKlxuICogVXNlZCB0byBpbml0aWFsaXplIG5ldyBzdWJzY2hlbWEgZm9yIHRlc3RpbmcuICBCdXQgYWxzbyB0byBvdmVycmlkZSBiZWhhdmlvdXJzIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0gZGVmYXVsdExvYWRlcnNcbiAqIEBwYXJhbSBkZWZhdWx0UmVzb2x2ZXJzXG4gKiBAcGFyYW0gZGVmYXVsdFByb3BUeXBlc1xuICogQHBhcmFtIGRlZmF1bHRJbmplY3RvckZhY3RvcnlcbiAqIEBwYXJhbSBTdWJzY2hlbWFcbiAqL1xuXG5mdW5jdGlvbiBuZXdTdWJzY2hlbWFDb250ZXh0KGRlZmF1bHRMb2FkZXJzID0gW10sIGRlZmF1bHRSZXNvbHZlcnMgPSB7fSwgZGVmYXVsdFByb3BUeXBlcyA9IFByb3BUeXBlcywgZGVmYXVsdEluamVjdG9yRmFjdG9yeSA9IGluamVjdG9yRmFjdG9yeSwgU3Vic2NoZW1hID0ge1xuICAgIENvbmRpdGlvbmFsLFxuICAgIEZpZWxkLFxuICAgIEZvcm0sXG4gICAgTmV3Q2hpbGRDb250ZXh0LFxuICAgIERvbSxcbiAgICBQcm9wVHlwZXMsXG4gICAgVmFsdWVNYW5hZ2VyLFxuICAgIGNzcyxcbiAgICBkZWNvcmF0b3JzLFxuICAgIGV2ZW50YWJsZSxcbiAgICBpbmplY3RvcixcbiAgICBsb2FkZXIsXG4gICAgbG9hZGVyRmFjdG9yeSxcbiAgICB0dXRpbHMsXG4gICAgdmFsaWRhdG9ycyxcbiAgICB3YXJuaW5nLFxuICAgIGluamVjdG9yRmFjdG9yeSxcbiAgICBjYWNoZWRJbmplY3RvclxuXG59KSB7XG4gICAgY29uc3Qge2xvYWRlciwgaW5qZWN0b3IsICAuLi5yZXN0fSA9IFN1YnNjaGVtYTtcblxuXG4gICAgY29uc3QgX2luamVjdG9yID0gZGVmYXVsdEluamVjdG9yRmFjdG9yeSgpO1xuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhkZWZhdWx0UmVzb2x2ZXJzKSkge1xuICAgICAgICBpZiAoa2V5IGluIGRlZmF1bHRQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgIF9pbmplY3Rvci5yZXNvbHZlcihkZWZhdWx0UHJvcFR5cGVzW2tleV0sIGRlZmF1bHRSZXNvbHZlcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdExvYWRlciA9IGxvYWRlckZhY3RvcnkoZGVmYXVsdExvYWRlcnMpO1xuICAgIGNvbnN0IGRlZmF1bHRJbmplY3RvciA9IGNhY2hlZEluamVjdG9yKF9pbmplY3Rvcik7XG5cbiAgICAvL0Zvcm0gbmVlZHMgdGhlc2UgdG8ga2ljayBvZmYgdGhlIHdob2xlIHRoaW5nLiAgSXRzIGRlZmF1bHRzIGNhbiBiZSBvdmVycmlkZW4gd2l0aFxuICAgIC8vIHByb3BlcnRpZXMuXG4gICAgcmVzdC5Gb3JtLmRlZmF1bHRQcm9wcy5sb2FkZXIgPSBkZWZhdWx0TG9hZGVyO1xuICAgIHJlc3QuRm9ybS5kZWZhdWx0UHJvcHMuaW5qZWN0b3IgPSBkZWZhdWx0SW5qZWN0b3I7XG4gICAgcmVzdC5sb2FkZXIgPSBkZWZhdWx0TG9hZGVyO1xuICAgIHJlc3QuaW5qZWN0b3IgPSBkZWZhdWx0SW5qZWN0b3I7XG4gICAgY29uc3Qge3Byb3ZpZGUsIC4uLmRlY3N9ID0gZGVjb3JhdG9ycztcbiAgICByZXN0LmRlY29yYXRvcnMgPSBkZWNzO1xuICAgIC8vcHJvdmlkZSBoYXMgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgc3RhdHVzIGxvYWRlci4gICB0aGlzIG1ha2VzIGl0IHdvcmsuXG4gICAgZGVjcy5wcm92aWRlID0gcHJvdmlkZUZhY3Rvcnkoe2RlZmF1bHRMb2FkZXJ9KTtcblxuICAgIHJldHVybiByZXN0O1xuXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9pbmRleC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAnLi8uLi9Qcm9wVHlwZXMnO1xuaW1wb3J0IFZhbHVlTWFuYWdlciBmcm9tICcuLy4uL1ZhbHVlTWFuYWdlcic7XG5pbXBvcnQgT2JqZWN0VHlwZSBmcm9tICcuLy4uL3R5cGVzL09iamVjdC5qc3gnO1xuaW1wb3J0IF9zZXQgZnJvbSAnbG9kYXNoL29iamVjdC9zZXQnO1xuaW1wb3J0IHtub29wfSBmcm9tICcuLy4uL3R1dGlscyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi93YXJuaW5nJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGRpc3BsYXlOYW1lID0gXCJGb3JtXCI7XG5cbiAgICBzdGF0aWMgY2hpbGRDb250ZXh0VHlwZXMgPSBQcm9wVHlwZXMuY29udGV4dFR5cGVzO1xuXG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgc2NoZW1hOiBQcm9wVHlwZXMuc2NoZW1hLmlzUmVxdWlyZWQsXG4gICAgICAgIGxvYWRlcjogUHJvcFR5cGVzLmxvYWRlcixcbiAgICAgICAgaW5qZWN0b3I6IFByb3BUeXBlcy5pbmplY3RvcixcbiAgICAgICAgdmFsdWVNYW5hZ2VyOiBQcm9wVHlwZXMudmFsdWVNYW5hZ2VyLFxuICAgICAgICB0ZW1wbGF0ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgbWV0aG9kOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBhY3Rpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGVuY3R5cGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG9uU3VibWl0OiBQcm9wVHlwZXMuZXZlbnQsXG4gICAgICAgIG5vVmFsaWRhdGU6IFByb3BUeXBlcy5ib29sXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGZhbGxiYWNrVGVtcGxhdGU6ICdGb3JtVGVtcGxhdGUnLFxuICAgICAgICBvblN1Ym1pdDogbm9vcCxcbiAgICAgICAgbm9WYWxpZGF0ZTogZmFsc2VcbiAgICB9O1xuXG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWVNYW5hZ2VyOiB0aGlzLnZhbHVlTWFuYWdlciwgbG9hZGVyOiB0aGlzLmxvYWRlciwgaW5qZWN0b3I6IHRoaXMuaW5qZWN0b3JcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCwgd2hhdGV2ZXIpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQsIHdoYXRldmVyKTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBwcm9wcy5sb2FkZXI7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBwcm9wcy5pbmplY3RvcjtcbiAgICAgICAgaWYgKCFwcm9wcy52YWx1ZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVNYW5hZ2VyID0gVmFsdWVNYW5hZ2VyKHRoaXMucHJvcHMudmFsdWUsIHRoaXMucHJvcHMuZXJyb3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVNYW5hZ2VyID0gcHJvcHMudmFsdWVNYW5hZ2VyO1xuICAgICAgICAgICAgaWYgKHByb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZU1hbmFnZXIuc2V0VmFsdWUodGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlTWFuYWdlci5zZXRFcnJvcnModGhpcy5wcm9wcy5lcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuT2JqZWN0V3JhcHBlciA9IHRoaXMuaW5qZWN0b3IuaW5qZWN0KE9iamVjdFR5cGUpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKG5ld1Byb3BzLmxvYWRlciAhPT0gdGhpcy5wcm9wcy5sb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3UHJvcHMubG9hZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdQcm9wcy52YWx1ZU1hbmFnZXIgIT09IHRoaXMucHJvcHMudmFsdWVNYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlTWFuYWdlciA9IG5ld1Byb3BzLnZhbHVlTWFuYWdlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnZhbHVlICE9PSBuZXdQcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZU1hbmFnZXIuc2V0VmFsdWUobmV3UHJvcHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmVycm9ycyAhPT0gbmV3UHJvcHMuZXJyb3JzKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlTWFuYWdlci5zZXRFcnJvcnMobmV3UHJvcHMuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5pbmplY3RvciAhPT0gbmV3UHJvcHMuaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBuZXdQcm9wcy5pbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMuT2JqZWN0V3JhcHBlciA9IHRoaXMuaW5qZWN0b3IuaW5qZWN0KE9iamVjdFR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlTWFuYWdlci5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGhhbmRsZVN1Ym1pdCA9IChlKT0+IHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciB2bSA9IHRoaXMudmFsdWVNYW5hZ2VyO1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMubm9WYWxpZGF0ZSkge1xuICAgICAgICAgICAgdm0udmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm0ub25TdWJtaXQoZSwgdm0uZ2V0RXJyb3JzKCksIHZtLmdldFZhbHVlKCksIHRoaXMucHJvcHMucGF0aCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU3VibWl0KGUsIHZtLmdldEVycm9ycygpLCB2bS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZXRFcnJvcnMgPSAoZXJyb3JzKT0+IHtcbiAgICAgICAgdGhpcy52YWx1ZU1hbmFnZXIuc2V0RXJyb3JzKGVycm9ycyk7XG4gICAgfTtcblxuXG4gICAgcmVuZGVyKCkge1xuXG4gICAgICAgIHZhciB7dmFsdWVNYW5hZ2VyLCBpbmplY3RvciwgbG9hZGVyLCB0ZW1wbGF0ZSwgb25TdWJtaXQsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IE9iamVjdFdyYXBwZXIgPSB0aGlzLk9iamVjdFdyYXBwZXI7XG4gICAgICAgIHJldHVybiA8T2JqZWN0V3JhcHBlciByZWY9XCJmb3JtXCIgey4uLnByb3BzfSBvYmplY3RUZW1wbGF0ZT17dGVtcGxhdGV9IG9uU3VibWl0PXt0aGlzLmhhbmRsZVN1Ym1pdH0vPlxuICAgIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc3Vic2NoZW1hL3NyYy9jb21wb25lbnRzL0Zvcm0uanN4XG4gKiovIiwidmFyIGlzSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0luZGV4JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0tleScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpLFxuICAgIHRvUGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3RvUGF0aCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBwYXRoYCBvbiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYFxuICogZG9lcyBub3QgZXhpc3QgaXQncyBjcmVhdGVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICogLy8gPT4gNFxuICpcbiAqIF8uc2V0KG9iamVjdCwgJ3hbMF0ueS56JywgNSk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICogLy8gPT4gNVxuICovXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHZhciBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG4gIHBhdGggPSAob2JqZWN0W3BhdGhLZXldICE9IG51bGwgfHwgaXNLZXkocGF0aCwgb2JqZWN0KSkgPyBbcGF0aEtleV0gOiB0b1BhdGgocGF0aCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgaWYgKGlzT2JqZWN0KG5lc3RlZCkpIHtcbiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgbmVzdGVkW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAobmVzdGVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBuZXN0ZWRba2V5XSA9IGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge307XG4gICAgICB9XG4gICAgfVxuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdWJzY2hlbWEvfi9sb2Rhc2gvb2JqZWN0L3NldC5qc1xuICoqIG1vZHVsZSBpZCA9IDQwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7aXNTdHJpbmcsaXNBcnJheSwgc2xpY2UsIGlzRnVuY3Rpb24sIHB1c2h9IGZyb20gJy4vdHV0aWxzJztcblxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3NlcyhjbGFzc2VzLCBzdHIpIHtcbiAgICBpZiAoc3RyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcoc3RyKSkge1xuICAgICAgICBwdXNoKGNsYXNzZXMsIHN0ci5zcGxpdCgvXFxzKz8vKSk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHN0cikpIHtcbiAgICAgICAgc3RyLmZvckVhY2goKHYpPT5hZGRDbGFzc2VzKGNsYXNzZXMsIHYpKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oc3RyKSkge1xuICAgICAgICBhZGRDbGFzc2VzKGNsYXNzZXMsIHN0ci5jYWxsKHRoaXMpKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmICghYXBpLmhhc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gbm9kZS5jbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyhub2RlLCBjbGFzc05hbWUpIHtcbiAgICBpZiAobm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgcmV0dXJuICEhY2xhc3NOYW1lICYmIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmNsYXNzTmFtZS5zcGxpdCgvXFxzKz8vKS5pbmRleE9mKGNsYXNzTmFtZSkgPiAtMTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAobm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gbm9kZS5jbGFzc05hbWUuc3BsaXQoL1xccys/LyksIGlkeDtcbiAgICAgICAgICAgIHdoaWxlICgoaWR4ID0gcGFydHMuaW5kZXhPZihjbGFzc05hbWUpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gcGFydHMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaGFzQ2xhc3MsXG4gICAgcmVtb3ZlQ2xhc3MsXG4gICAgYWRkQ2xhc3MsXG4gICAgYWRkQ2xhc3Nlc1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zdWJzY2hlbWEvc3JjL2Nzcy5qc1xuICoqLyIsIi8qISBoZWxsb2pzIHYxLjEyLjAgfCAoYykgMjAxMi0yMDE2IEFuZHJldyBEb2Rzb24gfCBNSVQgaHR0cHM6Ly9hZG9kc29uLmNvbS9oZWxsby5qcy9MSUNFTlNFICovXHJcbi8vIEVTNSBPYmplY3QuY3JlYXRlXG5pZiAoIU9iamVjdC5jcmVhdGUpIHtcblxuXHQvLyBTaGltLCBPYmplY3QgY3JlYXRlXG5cdC8vIEEgc2hpbSBmb3IgT2JqZWN0LmNyZWF0ZSgpLCBpdCBhZGRzIGEgcHJvdG90eXBlIHRvIGEgbmV3IG9iamVjdFxuXHRPYmplY3QuY3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuXG5cdFx0ZnVuY3Rpb24gRigpIHt9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24obykge1xuXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignT2JqZWN0LmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvbmx5IGFjY2VwdHMgb25lIHBhcmFtZXRlci4nKTtcblx0XHRcdH1cblxuXHRcdFx0Ri5wcm90b3R5cGUgPSBvO1xuXHRcdFx0cmV0dXJuIG5ldyBGKCk7XG5cdFx0fTtcblxuXHR9KSgpO1xuXG59XG5cbi8vIEVTNSBPYmplY3Qua2V5c1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uKG8sIGssIHIpIHtcblx0XHRyID0gW107XG5cdFx0Zm9yIChrIGluIG8pIHtcblx0XHRcdGlmIChyLmhhc093blByb3BlcnR5LmNhbGwobywgaykpXG5cdFx0XHRcdHIucHVzaChrKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblx0fTtcbn1cblxuLy8gRVM1IFtdLmluZGV4T2ZcbmlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihzKSB7XG5cblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGlmICh0aGlzW2pdID09PSBzKSB7XG5cdFx0XHRcdHJldHVybiBqO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAtMTtcblx0fTtcbn1cblxuLy8gRVM1IFtdLmZvckVhY2hcbmlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcblx0QXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmdW4vKiwgdGhpc0FyZyovKSB7XG5cblx0XHRpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHR9XG5cblx0XHR2YXIgdCA9IE9iamVjdCh0aGlzKTtcblx0XHR2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG5cdFx0aWYgKHR5cGVvZiBmdW4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHR9XG5cblx0XHR2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoaSBpbiB0KSB7XG5cdFx0XHRcdGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xufVxuXG4vLyBFUzUgW10uZmlsdGVyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcblx0QXJyYXkucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZ1biwgdGhpc0FyZykge1xuXG5cdFx0dmFyIGEgPSBbXTtcblx0XHR0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsLCBpLCB0KSB7XG5cdFx0XHRpZiAoZnVuLmNhbGwodGhpc0FyZyB8fCB2b2lkIDAsIHZhbCwgaSwgdCkpIHtcblx0XHRcdFx0YS5wdXNoKHZhbCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gYTtcblx0fTtcbn1cblxuLy8gUHJvZHVjdGlvbiBzdGVwcyBvZiBFQ01BLTI2MiwgRWRpdGlvbiA1LCAxNS40LjQuMTlcbi8vIFJlZmVyZW5jZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMTlcbmlmICghQXJyYXkucHJvdG90eXBlLm1hcCkge1xuXG5cdEFycmF5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmdW4sIHRoaXNBcmcpIHtcblxuXHRcdHZhciBhID0gW107XG5cdFx0dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaSwgdCkge1xuXHRcdFx0YS5wdXNoKGZ1bi5jYWxsKHRoaXNBcmcgfHwgdm9pZCAwLCB2YWwsIGksIHQpKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBhO1xuXHR9O1xufVxuXG4vLyBFUzUgaXNBcnJheVxuaWYgKCFBcnJheS5pc0FycmF5KSB7XG5cblx0Ly8gRnVuY3Rpb24gQXJyYXkuaXNBcnJheVxuXHRBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24obykge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cbn1cblxuLy8gVGVzdCBmb3IgbG9jYXRpb24uYXNzaWduXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHdpbmRvdy5sb2NhdGlvbiA9PT0gJ29iamVjdCcgJiYgIXdpbmRvdy5sb2NhdGlvbi5hc3NpZ24pIHtcblxuXHR3aW5kb3cubG9jYXRpb24uYXNzaWduID0gZnVuY3Rpb24odXJsKSB7XG5cdFx0d2luZG93LmxvY2F0aW9uID0gdXJsO1xuXHR9O1xuXG59XG5cbi8vIFRlc3QgZm9yIEZ1bmN0aW9uLmJpbmRcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcblxuXHQvLyBNRE5cblx0Ly8gUG9seWZpbGwgSUU4LCBkb2VzIG5vdCBzdXBwb3J0IG5hdGl2ZSBGdW5jdGlvbi5iaW5kXG5cdEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oYikge1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIEMoKSB7fVxuXG5cdFx0dmFyIGEgPSBbXS5zbGljZTtcblx0XHR2YXIgZiA9IGEuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIEQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBfdGhpcy5hcHBseSh0aGlzIGluc3RhbmNlb2YgQyA/IHRoaXMgOiBiIHx8IHdpbmRvdywgZi5jb25jYXQoYS5jYWxsKGFyZ3VtZW50cykpKTtcblx0XHR9O1xuXG5cdFx0Qy5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblx0XHRELnByb3RvdHlwZSA9IG5ldyBDKCk7XG5cblx0XHRyZXR1cm4gRDtcblx0fTtcblxufVxuXG4vKipcbiAqIEBoZWxsby5qc1xuICpcbiAqIEhlbGxvSlMgaXMgYSBjbGllbnQgc2lkZSBKYXZhc2NyaXB0IFNESyBmb3IgbWFraW5nIE9BdXRoMiBsb2dpbnMgYW5kIHN1YnNlcXVlbnQgUkVTVCBjYWxscy5cbiAqXG4gKiBAYXV0aG9yIEFuZHJldyBEb2Rzb25cbiAqIEB3ZWJzaXRlIGh0dHBzOi8vYWRvZHNvbi5jb20vaGVsbG8uanMvXG4gKlxuICogQGNvcHlyaWdodCBBbmRyZXcgRG9kc29uLCAyMDEyIC0gMjAxNVxuICogQGxpY2Vuc2UgTUlUOiBZb3UgYXJlIGZyZWUgdG8gdXNlIGFuZCBtb2RpZnkgdGhpcyBjb2RlIGZvciBhbnkgdXNlLCBvbiB0aGUgY29uZGl0aW9uIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIHJlbWFpbnMuXG4gKi9cblxudmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSkge1xuXHRyZXR1cm4gaGVsbG8udXNlKG5hbWUpO1xufTtcblxuaGVsbG8udXRpbHMgPSB7XG5cblx0Ly8gRXh0ZW5kIHRoZSBmaXJzdCBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgc2Vjb25kXG5cdGV4dGVuZDogZnVuY3Rpb24ociAvKiwgYVssIGJbLCAuLi5dXSAqLykge1xuXG5cdFx0Ly8gR2V0IHRoZSBhcmd1bWVudHMgYXMgYW4gYXJyYXkgYnV0IG9tbWl0IHRoZSBpbml0aWFsIGl0ZW1cblx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLmZvckVhY2goZnVuY3Rpb24oYSkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocikgJiYgQXJyYXkuaXNBcnJheShhKSkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyLCBhKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBPYmplY3QgJiYgYSBpbnN0YW5jZW9mIE9iamVjdCAmJiByICE9PSBhKSB7XG5cdFx0XHRcdGZvciAodmFyIHggaW4gYSkge1xuXHRcdFx0XHRcdHJbeF0gPSBoZWxsby51dGlscy5leHRlbmQoclt4XSwgYVt4XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG5cdFx0XHRcdFx0Ly8gQ2xvbmUgaXRcblx0XHRcdFx0XHRhID0gYS5zbGljZSgwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHIgPSBhO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHI7XG5cdH1cbn07XG5cbi8vIENvcmUgbGlicmFyeVxuaGVsbG8udXRpbHMuZXh0ZW5kKGhlbGxvLCB7XG5cblx0c2V0dGluZ3M6IHtcblxuXHRcdC8vIE9BdXRoMiBhdXRoZW50aWNhdGlvbiBkZWZhdWx0c1xuXHRcdHJlZGlyZWN0X3VyaTogd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVswXSxcblx0XHRyZXNwb25zZV90eXBlOiAndG9rZW4nLFxuXHRcdGRpc3BsYXk6ICdwb3B1cCcsXG5cdFx0c3RhdGU6ICcnLFxuXG5cdFx0Ly8gT0F1dGgxIHNoaW1cblx0XHQvLyBUaGUgcGF0aCB0byB0aGUgT0F1dGgxIHNlcnZlciBmb3Igc2lnbmluZyB1c2VyIHJlcXVlc3RzXG5cdFx0Ly8gV2FudCB0byByZWNyZWF0ZSB5b3VyIG93bj8gQ2hlY2tvdXQgaHR0cHM6Ly9naXRodWIuY29tL01yU3dpdGNoL25vZGUtb2F1dGgtc2hpbVxuXHRcdG9hdXRoX3Byb3h5OiAnaHR0cHM6Ly9hdXRoLXNlcnZlci5oZXJva3VhcHAuY29tL3Byb3h5JyxcblxuXHRcdC8vIEFQSSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuXHRcdHRpbWVvdXQ6IDIwMDAwLFxuXG5cdFx0Ly8gUG9wdXAgT3B0aW9uc1xuXHRcdHBvcHVwOiB7XG5cdFx0XHRyZXNpemFibGU6IDEsXG5cdFx0XHRzY3JvbGxiYXJzOiAxLFxuXHRcdFx0d2lkdGg6IDUwMCxcblx0XHRcdGhlaWdodDogNTUwXG5cdFx0fSxcblxuXHRcdC8vIERlZmF1bHQgc2NvcGVcblx0XHQvLyBNYW55IHNlcnZpY2VzIHJlcXVpcmUgYXRsZWFzdCBhIHByb2ZpbGUgc2NvcGUsXG5cdFx0Ly8gSGVsbG9KUyBhdXRvbWF0aWFsbHkgaW5jbHVkZXMgdGhlIHZhbHVlIG9mIHByb3ZpZGVyLnNjb3BlX21hcC5iYXNpY1xuXHRcdC8vIElmIHRoYXQncyBub3QgcmVxdWlyZWQgaXQgY2FuIGJlIHJlbW92ZWQgdmlhIGhlbGxvLnNldHRpbmdzLnNjb3BlLmxlbmd0aCA9IDA7XG5cdFx0c2NvcGU6IFsnYmFzaWMnXSxcblxuXHRcdC8vIFNjb3BlIE1hcHNcblx0XHQvLyBUaGlzIGlzIHRoZSBkZWZhdWx0IG1vZHVsZSBzY29wZSwgdGhlc2UgYXJlIHRoZSBkZWZhdWx0cyB3aGljaCBlYWNoIHNlcnZpY2UgaXMgbWFwcGVkIHRvby5cblx0XHQvLyBCeSBpbmNsdWRpbmcgdGhlbSBoZXJlIGl0IHByZXZlbnRzIHRoZSBzY29wZSBmcm9tIGJlaW5nIGFwcGxpZWQgYWNjaWRlbnRhbGx5XG5cdFx0c2NvcGVfbWFwOiB7XG5cdFx0XHRiYXNpYzogJydcblx0XHR9LFxuXG5cdFx0Ly8gRGVmYXVsdCBzZXJ2aWNlIC8gbmV0d29ya1xuXHRcdGRlZmF1bHRfc2VydmljZTogbnVsbCxcblxuXHRcdC8vIEZvcmNlIGF1dGhlbnRpY2F0aW9uXG5cdFx0Ly8gV2hlbiBoZWxsby5sb2dpbiBpcyBmaXJlZC5cblx0XHQvLyAobnVsbCk6IGlnbm9yZSBjdXJyZW50IHNlc3Npb24gZXhwaXJ5IGFuZCBjb250aW51ZSB3aXRoIGxvZ2luXG5cdFx0Ly8gKHRydWUpOiBpZ25vcmUgY3VycmVudCBzZXNzaW9uIGV4cGlyeSBhbmQgY29udGludWUgd2l0aCBsb2dpbiwgYXNrIGZvciB1c2VyIHRvIHJlYXV0aGVudGljYXRlXG5cdFx0Ly8gKGZhbHNlKTogaWYgdGhlIGN1cnJlbnQgc2Vzc2lvbiBsb29rcyBnb29kIGZvciB0aGUgcmVxdWVzdCBzY29wZXMgcmV0dXJuIHRoZSBjdXJyZW50IHNlc3Npb24uXG5cdFx0Zm9yY2U6IG51bGwsXG5cblx0XHQvLyBQYWdlIFVSTFxuXHRcdC8vIFdoZW4gJ2Rpc3BsYXk9cGFnZScgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIHdoZXJlIHRoZSB1c2VycyBwYWdlIHNob3VsZCBlbmQgdXAgYWZ0ZXIgcmVkaXJlY3RfdXJpXG5cdFx0Ly8gVGhzIGNvdWxkIGJlIHByb2JsZW1hdGljIGlmIHRoZSByZWRpcmVjdF91cmkgaXMgaW5kZWVkIHRoZSBmaW5hbCBwbGFjZSxcblx0XHQvLyBUeXBpY2FsbHkgdGhpcyBjaXJjdW12ZW50cyB0aGUgcHJvYmxlbSBvZiB0aGUgcmVkaXJlY3RfdXJsIGJlaW5nIGEgZHVtYiByZWxheSBwYWdlLlxuXHRcdHBhZ2VfdXJpOiB3aW5kb3cubG9jYXRpb24uaHJlZlxuXHR9LFxuXG5cdC8vIFNlcnZpY2UgY29uZmlndXJhdGlvbiBvYmplY3RzXG5cdHNlcnZpY2VzOiB7fSxcblxuXHQvLyBVc2Vcblx0Ly8gRGVmaW5lIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBIZWxsb0pTIGxpYnJhcnkgd2l0aCBhIGRlZmF1bHQgc2VydmljZVxuXHR1c2U6IGZ1bmN0aW9uKHNlcnZpY2UpIHtcblxuXHRcdC8vIENyZWF0ZSBzZWxmLCB3aGljaCBpbmhlcml0cyBmcm9tIGl0cyBwYXJlbnRcblx0XHR2YXIgc2VsZiA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG5cblx0XHQvLyBJbmhlcml0IHRoZSBwcm90b3R5cGUgZnJvbSBpdHMgcGFyZW50XG5cdFx0c2VsZi5zZXR0aW5ncyA9IE9iamVjdC5jcmVhdGUodGhpcy5zZXR0aW5ncyk7XG5cblx0XHQvLyBEZWZpbmUgdGhlIGRlZmF1bHQgc2VydmljZVxuXHRcdGlmIChzZXJ2aWNlKSB7XG5cdFx0XHRzZWxmLnNldHRpbmdzLmRlZmF1bHRfc2VydmljZSA9IHNlcnZpY2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEV2ZW50c1xuXHRcdHNlbGYudXRpbHMuRXZlbnQuY2FsbChzZWxmKTtcblxuXHRcdHJldHVybiBzZWxmO1xuXHR9LFxuXG5cdC8vIEluaXRpYWxpemVcblx0Ly8gRGVmaW5lIHRoZSBjbGllbnRfaWRzIGZvciB0aGUgZW5kcG9pbnQgc2VydmljZXNcblx0Ly8gQHBhcmFtIG9iamVjdCBvLCBjb250YWlucyBhIGtleSB2YWx1ZSBwYWlyLCBzZXJ2aWNlID0+IGNsaWVudElkXG5cdC8vIEBwYXJhbSBvYmplY3Qgb3B0cywgY29udGFpbnMgYSBrZXkgdmFsdWUgcGFpciBvZiBvcHRpb25zIHVzZWQgZm9yIGRlZmluaW5nIHRoZSBhdXRoZW50aWNhdGlvbiBkZWZhdWx0c1xuXHQvLyBAcGFyYW0gbnVtYmVyIHRpbWVvdXQsIHRpbWVvdXQgaW4gc2Vjb25kc1xuXHRpbml0OiBmdW5jdGlvbihzZXJ2aWNlcywgb3B0aW9ucykge1xuXG5cdFx0dmFyIHV0aWxzID0gdGhpcy51dGlscztcblxuXHRcdGlmICghc2VydmljZXMpIHtcblx0XHRcdHJldHVybiB0aGlzLnNlcnZpY2VzO1xuXHRcdH1cblxuXHRcdC8vIERlZmluZSBwcm92aWRlciBjcmVkZW50aWFsc1xuXHRcdC8vIFJlZm9ybWF0IHRoZSBJRCBmaWVsZFxuXHRcdGZvciAodmFyIHggaW4gc2VydmljZXMpIHtpZiAoc2VydmljZXMuaGFzT3duUHJvcGVydHkoeCkpIHtcblx0XHRcdGlmICh0eXBlb2YgKHNlcnZpY2VzW3hdKSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0c2VydmljZXNbeF0gPSB7aWQ6IHNlcnZpY2VzW3hdfTtcblx0XHRcdH1cblx0XHR9fVxuXG5cdFx0Ly8gTWVyZ2Ugc2VydmljZXMgaWYgdGhlcmUgYWxyZWFkeSBleGlzdHMgc29tZVxuXHRcdHV0aWxzLmV4dGVuZCh0aGlzLnNlcnZpY2VzLCBzZXJ2aWNlcyk7XG5cblx0XHQvLyBVcGRhdGUgdGhlIGRlZmF1bHQgc2V0dGluZ3Mgd2l0aCB0aGlzIG9uZS5cblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0dXRpbHMuZXh0ZW5kKHRoaXMuc2V0dGluZ3MsIG9wdGlvbnMpO1xuXG5cdFx0XHQvLyBEbyB0aGlzIGltbWVkaWF0bHkgaW5jYXNlIHRoZSBicm93c2VyIGNoYW5nZXMgdGhlIGN1cnJlbnQgcGF0aC5cblx0XHRcdGlmICgncmVkaXJlY3RfdXJpJyBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MucmVkaXJlY3RfdXJpID0gdXRpbHMudXJsKG9wdGlvbnMucmVkaXJlY3RfdXJpKS5ocmVmO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIExvZ2luXG5cdC8vIFVzaW5nIHRoZSBlbmRwb2ludFxuXHQvLyBAcGFyYW0gbmV0d29yayBzdHJpbmdpZnkgICAgICAgbmFtZSB0byBjb25uZWN0IHRvXG5cdC8vIEBwYXJhbSBvcHRpb25zIG9iamVjdCAgICAob3B0aW9uYWwpICB7ZGlzcGxheSBtb2RlLCBpcyBlaXRoZXIgbm9uZXxwb3B1cChkZWZhdWx0KXxwYWdlLCBzY29wZTogZW1haWwsYmlydGhkYXkscHVibGlzaCwgLi4gfVxuXHQvLyBAcGFyYW0gY2FsbGJhY2sgIGZ1bmN0aW9uICAob3B0aW9uYWwpICBmaXJlZCBvbiBzaWduaW5cblx0bG9naW46IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gQ3JlYXRlIGFuIG9iamVjdCB3aGljaCBpbmhlcml0cyBpdHMgcGFyZW50IGFzIHRoZSBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdHMgYSBuZXcgZXZlbnQgY2hhaW4uXG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdXRpbHMgPSBfdGhpcy51dGlscztcblx0XHR2YXIgZXJyb3IgPSB1dGlscy5lcnJvcjtcblx0XHR2YXIgcHJvbWlzZSA9IHV0aWxzLlByb21pc2UoKTtcblxuXHRcdC8vIEdldCBwYXJhbWV0ZXJzXG5cdFx0dmFyIHAgPSB1dGlscy5hcmdzKHtuZXR3b3JrOiAncycsIG9wdGlvbnM6ICdvJywgY2FsbGJhY2s6ICdmJ30sIGFyZ3VtZW50cyk7XG5cblx0XHQvLyBMb2NhbCB2YXJzXG5cdFx0dmFyIHVybDtcblxuXHRcdC8vIEdldCBhbGwgdGhlIGN1c3RvbSBvcHRpb25zIGFuZCBzdG9yZSB0byBiZSBhcHBlbmRlZCB0byB0aGUgcXVlcnlzdHJpbmdcblx0XHR2YXIgcXMgPSB1dGlscy5kaWZmS2V5KHAub3B0aW9ucywgX3RoaXMuc2V0dGluZ3MpO1xuXG5cdFx0Ly8gTWVyZ2Uvb3ZlcnJpZGUgb3B0aW9ucyB3aXRoIGFwcCBkZWZhdWx0c1xuXHRcdHZhciBvcHRzID0gcC5vcHRpb25zID0gdXRpbHMubWVyZ2UoX3RoaXMuc2V0dGluZ3MsIHAub3B0aW9ucyB8fCB7fSk7XG5cblx0XHQvLyBNZXJnZS9vdmVycmlkZSBvcHRpb25zIHdpdGggYXBwIGRlZmF1bHRzXG5cdFx0b3B0cy5wb3B1cCA9IHV0aWxzLm1lcmdlKF90aGlzLnNldHRpbmdzLnBvcHVwLCBwLm9wdGlvbnMucG9wdXAgfHwge30pO1xuXG5cdFx0Ly8gTmV0d29ya1xuXHRcdHAubmV0d29yayA9IHAubmV0d29yayB8fCBfdGhpcy5zZXR0aW5ncy5kZWZhdWx0X3NlcnZpY2U7XG5cblx0XHQvLyBCaW5kIGNhbGxiYWNrIHRvIGJvdGggcmVqZWN0IGFuZCBmdWxmaWxsIHN0YXRlc1xuXHRcdHByb21pc2UucHJveHkudGhlbihwLmNhbGxiYWNrLCBwLmNhbGxiYWNrKTtcblxuXHRcdC8vIFRyaWdnZXIgYW4gZXZlbnQgb24gdGhlIGdsb2JhbCBsaXN0ZW5lclxuXHRcdGZ1bmN0aW9uIGVtaXQocywgdmFsdWUpIHtcblx0XHRcdGhlbGxvLmVtaXQocywgdmFsdWUpO1xuXHRcdH1cblxuXHRcdHByb21pc2UucHJveHkudGhlbihlbWl0LmJpbmQodGhpcywgJ2F1dGgubG9naW4gYXV0aCcpLCBlbWl0LmJpbmQodGhpcywgJ2F1dGguZmFpbGVkIGF1dGgnKSk7XG5cblx0XHQvLyBJcyBvdXIgc2VydmljZSB2YWxpZD9cblx0XHRpZiAodHlwZW9mIChwLm5ldHdvcmspICE9PSAnc3RyaW5nJyB8fCAhKHAubmV0d29yayBpbiBfdGhpcy5zZXJ2aWNlcykpIHtcblx0XHRcdC8vIFRyaWdnZXIgdGhlIGRlZmF1bHQgbG9naW4uXG5cdFx0XHQvLyBBaGggd2UgZG9udCBoYXZlIG9uZS5cblx0XHRcdHJldHVybiBwcm9taXNlLnJlamVjdChlcnJvcignaW52YWxpZF9uZXR3b3JrJywgJ1RoZSBwcm92aWRlZCBuZXR3b3JrIHdhcyBub3QgcmVjb2duaXplZCcpKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvdmlkZXIgPSBfdGhpcy5zZXJ2aWNlc1twLm5ldHdvcmtdO1xuXG5cdFx0Ly8gQ3JlYXRlIGEgZ2xvYmFsIGxpc3RlbmVyIHRvIGNhcHR1cmUgZXZlbnRzIHRyaWdnZXJlZCBvdXQgb2Ygc2NvcGVcblx0XHR2YXIgY2FsbGJhY2tJZCA9IHV0aWxzLmdsb2JhbEV2ZW50KGZ1bmN0aW9uKHN0cikge1xuXG5cdFx0XHQvLyBUaGUgcmVzcG9uc2VIYW5kbGVyIHJldHVybnMgYSBzdHJpbmcsIGxldHMgc2F2ZSB0aGlzIGxvY2FsbHlcblx0XHRcdHZhciBvYmo7XG5cblx0XHRcdGlmIChzdHIpIHtcblx0XHRcdFx0b2JqID0gSlNPTi5wYXJzZShzdHIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG9iaiA9IGVycm9yKCdjYW5jZWxsZWQnLCAnVGhlIGF1dGhlbnRpY2F0aW9uIHdhcyBub3QgY29tcGxldGVkJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSB0aGVzZSByZXNwb25zZSB1c2luZyB0aGUgbG9jYWxcblx0XHRcdC8vIFRyaWdnZXIgb24gdGhlIHBhcmVudFxuXHRcdFx0aWYgKCFvYmouZXJyb3IpIHtcblxuXHRcdFx0XHQvLyBTYXZlIG9uIHRoZSBwYXJlbnQgd2luZG93IHRoZSBuZXcgY3JlZGVudGlhbHNcblx0XHRcdFx0Ly8gVGhpcyBmaXhlcyBhbiBJRTEwIGJ1ZyBpIHRoaW5rLi4uIGF0bGVhc3QgaXQgZG9lcyBmb3IgbWUuXG5cdFx0XHRcdHV0aWxzLnN0b3JlKG9iai5uZXR3b3JrLCBvYmopO1xuXG5cdFx0XHRcdC8vIEZ1bGZpbGwgYSBzdWNjZXNzZnVsIGxvZ2luXG5cdFx0XHRcdHByb21pc2UuZnVsZmlsbCh7XG5cdFx0XHRcdFx0bmV0d29yazogb2JqLm5ldHdvcmssXG5cdFx0XHRcdFx0YXV0aFJlc3BvbnNlOiBvYmpcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gUmVqZWN0IGEgc3VjY2Vzc2Z1bCBsb2dpblxuXHRcdFx0XHRwcm9taXNlLnJlamVjdChvYmopO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dmFyIHJlZGlyZWN0VXJpID0gdXRpbHMudXJsKG9wdHMucmVkaXJlY3RfdXJpKS5ocmVmO1xuXG5cdFx0Ly8gTWF5IGJlIGEgc3BhY2UtZGVsaW1pdGVkIGxpc3Qgb2YgbXVsdGlwbGUsIGNvbXBsZW1lbnRhcnkgdHlwZXNcblx0XHR2YXIgcmVzcG9uc2VUeXBlID0gcHJvdmlkZXIub2F1dGgucmVzcG9uc2VfdHlwZSB8fCBvcHRzLnJlc3BvbnNlX3R5cGU7XG5cblx0XHQvLyBGYWxsYmFjayB0byB0b2tlbiBpZiB0aGUgbW9kdWxlIGhhc24ndCBkZWZpbmVkIGEgZ3JhbnQgdXJsXG5cdFx0aWYgKC9cXGJjb2RlXFxiLy50ZXN0KHJlc3BvbnNlVHlwZSkgJiYgIXByb3ZpZGVyLm9hdXRoLmdyYW50KSB7XG5cdFx0XHRyZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUucmVwbGFjZSgvXFxiY29kZVxcYi8sICd0b2tlbicpO1xuXHRcdH1cblxuXHRcdC8vIFF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzLCB3ZSBtYXkgcGFzcyBvdXIgb3duIGFyZ3VtZW50cyB0byBmb3JtIHRoZSBxdWVyeXN0cmluZ1xuXHRcdHAucXMgPSB1dGlscy5tZXJnZShxcywge1xuXHRcdFx0Y2xpZW50X2lkOiBlbmNvZGVVUklDb21wb25lbnQocHJvdmlkZXIuaWQpLFxuXHRcdFx0cmVzcG9uc2VfdHlwZTogZW5jb2RlVVJJQ29tcG9uZW50KHJlc3BvbnNlVHlwZSksXG5cdFx0XHRyZWRpcmVjdF91cmk6IGVuY29kZVVSSUNvbXBvbmVudChyZWRpcmVjdFVyaSksXG5cdFx0XHRkaXNwbGF5OiBvcHRzLmRpc3BsYXksXG5cdFx0XHRzdGF0ZToge1xuXHRcdFx0XHRjbGllbnRfaWQ6IHByb3ZpZGVyLmlkLFxuXHRcdFx0XHRuZXR3b3JrOiBwLm5ldHdvcmssXG5cdFx0XHRcdGRpc3BsYXk6IG9wdHMuZGlzcGxheSxcblx0XHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrSWQsXG5cdFx0XHRcdHN0YXRlOiBvcHRzLnN0YXRlLFxuXHRcdFx0XHRyZWRpcmVjdF91cmk6IHJlZGlyZWN0VXJpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBHZXQgY3VycmVudCBzZXNzaW9uIGZvciBtZXJnaW5nIHNjb3BlcywgYW5kIGZvciBxdWljayBhdXRoIHJlc3BvbnNlXG5cdFx0dmFyIHNlc3Npb24gPSB1dGlscy5zdG9yZShwLm5ldHdvcmspO1xuXG5cdFx0Ly8gU2NvcGVzIChhdXRoZW50aWNhdGlvbiBwZXJtaXNpb25zKVxuXHRcdC8vIEVuc3VyZSB0aGlzIGlzIGEgc3RyaW5nIC0gSUUgaGFzIGEgcHJvYmxlbSBtb3ZpbmcgQXJyYXlzIGJldHdlZW4gd2luZG93c1xuXHRcdC8vIEFwcGVuZCB0aGUgc2V0dXAgc2NvcGVcblx0XHR2YXIgU0NPUEVfU1BMSVQgPSAvWyxcXHNdKy87XG5cblx0XHQvLyBJbmNsdWRlIGRlZmF1bHQgc2NvcGUgc2V0dGluZ3MgKGNsb25lZCkuXG5cdFx0dmFyIHNjb3BlID0gX3RoaXMuc2V0dGluZ3Muc2NvcGUgPyBbX3RoaXMuc2V0dGluZ3Muc2NvcGUudG9TdHJpbmcoKV0gOiBbXTtcblxuXHRcdC8vIEV4dGVuZCB0aGUgcHJvdmlkZXJzIHNjb3BlIGxpc3Qgd2l0aCB0aGUgZGVmYXVsdFxuXHRcdHZhciBzY29wZU1hcCA9IHV0aWxzLm1lcmdlKF90aGlzLnNldHRpbmdzLnNjb3BlX21hcCwgcHJvdmlkZXIuc2NvcGUgfHwge30pO1xuXG5cdFx0Ly8gQWRkIHVzZXIgZGVmaW5lZCBzY29wZXMuLi5cblx0XHRpZiAob3B0cy5zY29wZSkge1xuXHRcdFx0c2NvcGUucHVzaChvcHRzLnNjb3BlLnRvU3RyaW5nKCkpO1xuXHRcdH1cblxuXHRcdC8vIEFwcGVuZCBzY29wZXMgZnJvbSBhIHByZXZpb3VzIHNlc3Npb24uXG5cdFx0Ly8gVGhpcyBoZWxwcyBrZWVwIGFwcCBjcmVkZW50aWFscyBjb25zdGFudCxcblx0XHQvLyBBdm9pZGluZyBoYXZpbmcgdG8ga2VlcCB0YWJzIG9uIHdoYXQgc2NvcGVzIGFyZSBhdXRob3JpemVkXG5cdFx0aWYgKHNlc3Npb24gJiYgJ3Njb3BlJyBpbiBzZXNzaW9uICYmIHNlc3Npb24uc2NvcGUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcblx0XHRcdHNjb3BlLnB1c2goc2Vzc2lvbi5zY29wZSk7XG5cdFx0fVxuXG5cdFx0Ly8gSm9pbiBhbmQgU3BsaXQgYWdhaW5cblx0XHRzY29wZSA9IHNjb3BlLmpvaW4oJywnKS5zcGxpdChTQ09QRV9TUExJVCk7XG5cblx0XHQvLyBGb3JtYXQgcmVtb3ZlIGR1cGxpY2F0ZXMgYW5kIGVtcHR5IHZhbHVlc1xuXHRcdHNjb3BlID0gdXRpbHMudW5pcXVlKHNjb3BlKS5maWx0ZXIoZmlsdGVyRW1wdHkpO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgdGhlIHNjb3BlcyB0byB0aGUgc3RhdGUgd2l0aCB0aGUgbmFtZXMgdGhhdCB0aGV5IHdlcmUgcmVxdWVzdGVkIHdpdGguXG5cdFx0cC5xcy5zdGF0ZS5zY29wZSA9IHNjb3BlLmpvaW4oJywnKTtcblxuXHRcdC8vIE1hcCBzY29wZXMgdG8gdGhlIHByb3ZpZGVycyBuYW1pbmcgY29udmVudGlvblxuXHRcdHNjb3BlID0gc2NvcGUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdC8vIERvZXMgdGhpcyBoYXZlIGEgbWFwcGluZz9cblx0XHRcdHJldHVybiAoaXRlbSBpbiBzY29wZU1hcCkgPyBzY29wZU1hcFtpdGVtXSA6IGl0ZW07XG5cdFx0fSk7XG5cblx0XHQvLyBTdHJpbmdpZnkgYW5kIEFycmF5aWZ5IHNvIHRoYXQgZG91YmxlIG1hcHBlZCBzY29wZXMgYXJlIGdpdmVuIHRoZSBjaGFuY2UgdG8gYmUgZm9ybWF0dGVkXG5cdFx0c2NvcGUgPSBzY29wZS5qb2luKCcsJykuc3BsaXQoU0NPUEVfU1BMSVQpO1xuXG5cdFx0Ly8gQWdhaW4uLi5cblx0XHQvLyBGb3JtYXQgcmVtb3ZlIGR1cGxpY2F0ZXMgYW5kIGVtcHR5IHZhbHVlc1xuXHRcdHNjb3BlID0gdXRpbHMudW5pcXVlKHNjb3BlKS5maWx0ZXIoZmlsdGVyRW1wdHkpO1xuXG5cdFx0Ly8gSm9pbiB3aXRoIHRoZSBleHBlY3RlZCBzY29wZSBkZWxpbWl0ZXIgaW50byBhIHN0cmluZ1xuXHRcdHAucXMuc2NvcGUgPSBzY29wZS5qb2luKHByb3ZpZGVyLnNjb3BlX2RlbGltIHx8ICcsJyk7XG5cblx0XHQvLyBJcyB0aGUgdXNlciBhbHJlYWR5IHNpZ25lZCBpbiB3aXRoIHRoZSBhcHByb3ByaWF0ZSBzY29wZXMsIHZhbGlkIGFjY2Vzc190b2tlbj9cblx0XHRpZiAob3B0cy5mb3JjZSA9PT0gZmFsc2UpIHtcblxuXHRcdFx0aWYgKHNlc3Npb24gJiYgJ2FjY2Vzc190b2tlbicgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uLmFjY2Vzc190b2tlbiAmJiAnZXhwaXJlcycgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uLmV4cGlyZXMgPiAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDFlMykpIHtcblx0XHRcdFx0Ly8gV2hhdCBpcyBkaWZmZXJlbnQgYWJvdXQgdGhlIHNjb3BlcyBpbiB0aGUgc2Vzc2lvbiB2cyB0aGUgc2NvcGVzIGluIHRoZSBuZXcgbG9naW4/XG5cdFx0XHRcdHZhciBkaWZmID0gdXRpbHMuZGlmZigoc2Vzc2lvbi5zY29wZSB8fCAnJykuc3BsaXQoU0NPUEVfU1BMSVQpLCAocC5xcy5zdGF0ZS5zY29wZSB8fCAnJykuc3BsaXQoU0NPUEVfU1BMSVQpKTtcblx0XHRcdFx0aWYgKGRpZmYubGVuZ3RoID09PSAwKSB7XG5cblx0XHRcdFx0XHQvLyBPSyB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRcdHByb21pc2UuZnVsZmlsbCh7XG5cdFx0XHRcdFx0XHR1bmNoYW5nZWQ6IHRydWUsXG5cdFx0XHRcdFx0XHRuZXR3b3JrOiBwLm5ldHdvcmssXG5cdFx0XHRcdFx0XHRhdXRoUmVzcG9uc2U6IHNlc3Npb25cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIE5vdGhpbmcgaGFzIGNoYW5nZWRcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFBhZ2UgVVJMXG5cdFx0aWYgKG9wdHMuZGlzcGxheSA9PT0gJ3BhZ2UnICYmIG9wdHMucGFnZV91cmkpIHtcblx0XHRcdC8vIEFkZCBhIHBhZ2UgbG9jYXRpb24sIHBsYWNlIHRvIGVuZHVwIGFmdGVyIHNlc3Npb24gaGFzIGF1dGhlbnRpY2F0ZWRcblx0XHRcdHAucXMuc3RhdGUucGFnZV91cmkgPSB1dGlscy51cmwob3B0cy5wYWdlX3VyaSkuaHJlZjtcblx0XHR9XG5cblx0XHQvLyBCZXNwb2tlXG5cdFx0Ly8gT3ZlcnJpZGUgbG9naW4gcXVlcnlzdHJpbmdzIGZyb20gYXV0aF9vcHRpb25zXG5cdFx0aWYgKCdsb2dpbicgaW4gcHJvdmlkZXIgJiYgdHlwZW9mIChwcm92aWRlci5sb2dpbikgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIEZvcm1hdCB0aGUgcGFyYW1hdGVycyBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVycyBmb3JtYXR0aW5nIGZ1bmN0aW9uXG5cdFx0XHRwcm92aWRlci5sb2dpbihwKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgT0F1dGggdG8gc3RhdGVcblx0XHQvLyBXaGVyZSB0aGUgc2VydmljZSBpcyBnb2luZyB0byB0YWtlIGFkdmFudGFnZSBvZiB0aGUgb2F1dGhfcHJveHlcblx0XHRpZiAoIS9cXGJ0b2tlblxcYi8udGVzdChyZXNwb25zZVR5cGUpIHx8XG5cdFx0cGFyc2VJbnQocHJvdmlkZXIub2F1dGgudmVyc2lvbiwgMTApIDwgMiB8fFxuXHRcdChvcHRzLmRpc3BsYXkgPT09ICdub25lJyAmJiBwcm92aWRlci5vYXV0aC5ncmFudCAmJiBzZXNzaW9uICYmIHNlc3Npb24ucmVmcmVzaF90b2tlbikpIHtcblxuXHRcdFx0Ly8gQWRkIHRoZSBvYXV0aCBlbmRwb2ludHNcblx0XHRcdHAucXMuc3RhdGUub2F1dGggPSBwcm92aWRlci5vYXV0aDtcblxuXHRcdFx0Ly8gQWRkIHRoZSBwcm94eSB1cmxcblx0XHRcdHAucXMuc3RhdGUub2F1dGhfcHJveHkgPSBvcHRzLm9hdXRoX3Byb3h5O1xuXG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBzdGF0ZSB0byBhIHN0cmluZ1xuXHRcdHAucXMuc3RhdGUgPSBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkocC5xcy5zdGF0ZSkpO1xuXG5cdFx0Ly8gVVJMXG5cdFx0aWYgKHBhcnNlSW50KHByb3ZpZGVyLm9hdXRoLnZlcnNpb24sIDEwKSA9PT0gMSkge1xuXG5cdFx0XHQvLyBUdXJuIHRoZSByZXF1ZXN0IHRvIHRoZSBPQXV0aCBQcm94eSBmb3IgMy1sZWdnZWQgYXV0aFxuXHRcdFx0dXJsID0gdXRpbHMucXMob3B0cy5vYXV0aF9wcm94eSwgcC5xcywgZW5jb2RlRnVuY3Rpb24pO1xuXHRcdH1cblxuXHRcdC8vIFJlZnJlc2ggdG9rZW5cblx0XHRlbHNlIGlmIChvcHRzLmRpc3BsYXkgPT09ICdub25lJyAmJiBwcm92aWRlci5vYXV0aC5ncmFudCAmJiBzZXNzaW9uICYmIHNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuXG5cdFx0XHQvLyBBZGQgdGhlIHJlZnJlc2hfdG9rZW4gdG8gdGhlIHJlcXVlc3Rcblx0XHRcdHAucXMucmVmcmVzaF90b2tlbiA9IHNlc3Npb24ucmVmcmVzaF90b2tlbjtcblxuXHRcdFx0Ly8gRGVmaW5lIHRoZSByZXF1ZXN0IHBhdGhcblx0XHRcdHVybCA9IHV0aWxzLnFzKG9wdHMub2F1dGhfcHJveHksIHAucXMsIGVuY29kZUZ1bmN0aW9uKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR1cmwgPSB1dGlscy5xcyhwcm92aWRlci5vYXV0aC5hdXRoLCBwLnFzLCBlbmNvZGVGdW5jdGlvbik7XG5cdFx0fVxuXG5cdFx0Ly8gQnJvYWRjYXN0IHRoaXMgZXZlbnQgYXMgYW4gYXV0aDppbml0XG5cdFx0ZW1pdCgnYXV0aC5pbml0JywgcCk7XG5cblx0XHQvLyBFeGVjdXRlXG5cdFx0Ly8gVHJpZ2dlciBob3cgd2Ugd2FudCBzZWxmIGRpc3BsYXllZFxuXHRcdGlmIChvcHRzLmRpc3BsYXkgPT09ICdub25lJykge1xuXHRcdFx0Ly8gU2lnbi1pbiBpbiB0aGUgYmFja2dyb3VuZCwgaWZyYW1lXG5cdFx0XHR1dGlscy5pZnJhbWUodXJsLCByZWRpcmVjdFVyaSk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJpZ2dlcmluZyBwb3B1cD9cblx0XHRlbHNlIGlmIChvcHRzLmRpc3BsYXkgPT09ICdwb3B1cCcpIHtcblxuXHRcdFx0dmFyIHBvcHVwID0gdXRpbHMucG9wdXAodXJsLCByZWRpcmVjdFVyaSwgb3B0cy5wb3B1cCk7XG5cblx0XHRcdHZhciB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwLmNsb3NlZCkge1xuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwodGltZXIpO1xuXHRcdFx0XHRcdGlmICghcHJvbWlzZS5zdGF0ZSkge1xuXG5cdFx0XHRcdFx0XHR2YXIgcmVzcG9uc2UgPSBlcnJvcignY2FuY2VsbGVkJywgJ0xvZ2luIGhhcyBiZWVuIGNhbmNlbGxlZCcpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXBvcHVwKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gZXJyb3IoJ2Jsb2NrZWQnLCAnUG9wdXAgd2FzIGJsb2NrZWQnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmVzcG9uc2UubmV0d29yayA9IHAubmV0d29yaztcblxuXHRcdFx0XHRcdFx0cHJvbWlzZS5yZWplY3QocmVzcG9uc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSwgMTAwKTtcblx0XHR9XG5cblx0XHRlbHNlIHtcblx0XHRcdHdpbmRvdy5sb2NhdGlvbiA9IHVybDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvbWlzZS5wcm94eTtcblxuXHRcdGZ1bmN0aW9uIGVuY29kZUZ1bmN0aW9uKHMpIHtyZXR1cm4gczt9XG5cblx0XHRmdW5jdGlvbiBmaWx0ZXJFbXB0eShzKSB7cmV0dXJuICEhczt9XG5cdH0sXG5cblx0Ly8gUmVtb3ZlIGFueSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHNlcnZpY2Vcblx0Ly8gQHBhcmFtIHN0cmluZyBuYW1lIG9mIHRoZSBzZXJ2aWNlXG5cdC8vIEBwYXJhbSBmdW5jdGlvbiBjYWxsYmFja1xuXHRsb2dvdXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdXRpbHMgPSBfdGhpcy51dGlscztcblx0XHR2YXIgZXJyb3IgPSB1dGlscy5lcnJvcjtcblxuXHRcdC8vIENyZWF0ZSBhIG5ldyBwcm9taXNlXG5cdFx0dmFyIHByb21pc2UgPSB1dGlscy5Qcm9taXNlKCk7XG5cblx0XHR2YXIgcCA9IHV0aWxzLmFyZ3Moe25hbWU6J3MnLCBvcHRpb25zOiAnbycsIGNhbGxiYWNrOiAnZid9LCBhcmd1bWVudHMpO1xuXG5cdFx0cC5vcHRpb25zID0gcC5vcHRpb25zIHx8IHt9O1xuXG5cdFx0Ly8gQWRkIGNhbGxiYWNrIHRvIGV2ZW50c1xuXHRcdHByb21pc2UucHJveHkudGhlbihwLmNhbGxiYWNrLCBwLmNhbGxiYWNrKTtcblxuXHRcdC8vIFRyaWdnZXIgYW4gZXZlbnQgb24gdGhlIGdsb2JhbCBsaXN0ZW5lclxuXHRcdGZ1bmN0aW9uIGVtaXQocywgdmFsdWUpIHtcblx0XHRcdGhlbGxvLmVtaXQocywgdmFsdWUpO1xuXHRcdH1cblxuXHRcdHByb21pc2UucHJveHkudGhlbihlbWl0LmJpbmQodGhpcywgJ2F1dGgubG9nb3V0IGF1dGgnKSwgZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpKTtcblxuXHRcdC8vIE5ldHdvcmtcblx0XHRwLm5hbWUgPSBwLm5hbWUgfHwgdGhpcy5zZXR0aW5ncy5kZWZhdWx0X3NlcnZpY2U7XG5cdFx0cC5hdXRoUmVzcG9uc2UgPSB1dGlscy5zdG9yZShwLm5hbWUpO1xuXG5cdFx0aWYgKHAubmFtZSAmJiAhKHAubmFtZSBpbiBfdGhpcy5zZXJ2aWNlcykpIHtcblxuXHRcdFx0cHJvbWlzZS5yZWplY3QoZXJyb3IoJ2ludmFsaWRfbmV0d29yaycsICdUaGUgbmV0d29yayB3YXMgdW5yZWNvZ25pemVkJykpO1xuXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHAubmFtZSAmJiBwLmF1dGhSZXNwb25zZSkge1xuXG5cdFx0XHQvLyBEZWZpbmUgdGhlIGNhbGxiYWNrXG5cdFx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihvcHRzKSB7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gdGhlIHN0b3JlXG5cdFx0XHRcdHV0aWxzLnN0b3JlKHAubmFtZSwgbnVsbCk7XG5cblx0XHRcdFx0Ly8gRW1pdCBldmVudHMgYnkgZGVmYXVsdFxuXHRcdFx0XHRwcm9taXNlLmZ1bGZpbGwoaGVsbG8udXRpbHMubWVyZ2Uoe25ldHdvcms6cC5uYW1lfSwgb3B0cyB8fCB7fSkpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gUnVuIGFuIGFzeW5jIG9wZXJhdGlvbiB0byByZW1vdmUgdGhlIHVzZXJzIHNlc3Npb25cblx0XHRcdHZhciBfb3B0cyA9IHt9O1xuXHRcdFx0aWYgKHAub3B0aW9ucy5mb3JjZSkge1xuXHRcdFx0XHR2YXIgbG9nb3V0ID0gX3RoaXMuc2VydmljZXNbcC5uYW1lXS5sb2dvdXQ7XG5cdFx0XHRcdGlmIChsb2dvdXQpIHtcblx0XHRcdFx0XHQvLyBDb252ZXJ0IGxvZ291dCB0byBVUkwgc3RyaW5nLFxuXHRcdFx0XHRcdC8vIElmIG5vIHN0cmluZyBpcyByZXR1cm5lZCwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgaGFuZGxlIHRoZSBsb2dvdXQgYXN5bmMgc3R5bGVcblx0XHRcdFx0XHRpZiAodHlwZW9mIChsb2dvdXQpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRsb2dvdXQgPSBsb2dvdXQoY2FsbGJhY2ssIHApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElmIGxvZ291dCBpcyBhIHN0cmluZyB0aGVuIGFzc3VtZSBVUkwgYW5kIG9wZW4gaW4gaWZyYW1lLlxuXHRcdFx0XHRcdGlmICh0eXBlb2YgKGxvZ291dCkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHR1dGlscy5pZnJhbWUobG9nb3V0KTtcblx0XHRcdFx0XHRcdF9vcHRzLmZvcmNlID0gbnVsbDtcblx0XHRcdFx0XHRcdF9vcHRzLm1lc3NhZ2UgPSAnTG9nb3V0IHN1Y2Nlc3Mgb24gcHJvdmlkZXJzIHNpdGUgd2FzIGluZGV0ZXJtaW5hdGUnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChsb2dvdXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgaGFuZGxlIHRoZSByZXNwb25zZS5cblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnByb3h5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgbG9jYWwgY3JlZGVudGlhbHNcblx0XHRcdGNhbGxiYWNrKF9vcHRzKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRwcm9taXNlLnJlamVjdChlcnJvcignaW52YWxpZF9zZXNzaW9uJywgJ1RoZXJlIHdhcyBubyBzZXNzaW9uIHRvIHJlbW92ZScpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvbWlzZS5wcm94eTtcblx0fSxcblxuXHQvLyBSZXR1cm5zIGFsbCB0aGUgc2Vzc2lvbnMgdGhhdCBhcmUgc3Vic2NyaWJlZCB0b29cblx0Ly8gQHBhcmFtIHN0cmluZyBvcHRpb25hbCwgbmFtZSBvZiB0aGUgc2VydmljZSB0byBnZXQgaW5mb3JtYXRpb24gYWJvdXQuXG5cdGdldEF1dGhSZXNwb25zZTogZnVuY3Rpb24oc2VydmljZSkge1xuXG5cdFx0Ly8gSWYgdGhlIHNlcnZpY2UgZG9lc24ndCBleGlzdFxuXHRcdHNlcnZpY2UgPSBzZXJ2aWNlIHx8IHRoaXMuc2V0dGluZ3MuZGVmYXVsdF9zZXJ2aWNlO1xuXG5cdFx0aWYgKCFzZXJ2aWNlIHx8ICEoc2VydmljZSBpbiB0aGlzLnNlcnZpY2VzKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMudXRpbHMuc3RvcmUoc2VydmljZSkgfHwgbnVsbDtcblx0fSxcblxuXHQvLyBFdmVudHM6IHBsYWNlaG9sZGVyIGZvciB0aGUgZXZlbnRzXG5cdGV2ZW50czoge31cbn0pO1xuXG4vLyBDb3JlIHV0aWxpdGllc1xuaGVsbG8udXRpbHMuZXh0ZW5kKGhlbGxvLnV0aWxzLCB7XG5cblx0Ly8gRXJyb3Jcblx0ZXJyb3I6IGZ1bmN0aW9uKGNvZGUsIG1lc3NhZ2UpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXJyb3I6IHtcblx0XHRcdFx0Y29kZTogY29kZSxcblx0XHRcdFx0bWVzc2FnZTogbWVzc2FnZVxuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gQXBwZW5kIHRoZSBxdWVyeXN0cmluZyB0byBhIHVybFxuXHQvLyBAcGFyYW0gc3RyaW5nIHVybFxuXHQvLyBAcGFyYW0gb2JqZWN0IHBhcmFtZXRlcnNcblx0cXM6IGZ1bmN0aW9uKHVybCwgcGFyYW1zLCBmb3JtYXRGdW5jdGlvbikge1xuXG5cdFx0aWYgKHBhcmFtcykge1xuXG5cdFx0XHQvLyBTZXQgZGVmYXVsdCBmb3JtYXR0aW5nIGZ1bmN0aW9uXG5cdFx0XHRmb3JtYXRGdW5jdGlvbiA9IGZvcm1hdEZ1bmN0aW9uIHx8IGVuY29kZVVSSUNvbXBvbmVudDtcblxuXHRcdFx0Ly8gT3ZlcnJpZGUgdGhlIGl0ZW1zIGluIHRoZSBVUkwgd2hpY2ggYWxyZWFkeSBleGlzdFxuXHRcdFx0Zm9yICh2YXIgeCBpbiBwYXJhbXMpIHtcblx0XHRcdFx0dmFyIHN0ciA9ICcoW1xcXFw/XFxcXCZdKScgKyB4ICsgJz1bXlxcXFwmXSonO1xuXHRcdFx0XHR2YXIgcmVnID0gbmV3IFJlZ0V4cChzdHIpO1xuXHRcdFx0XHRpZiAodXJsLm1hdGNoKHJlZykpIHtcblx0XHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZShyZWcsICckMScgKyB4ICsgJz0nICsgZm9ybWF0RnVuY3Rpb24ocGFyYW1zW3hdKSk7XG5cdFx0XHRcdFx0ZGVsZXRlIHBhcmFtc1t4XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc0VtcHR5KHBhcmFtcykpIHtcblx0XHRcdHJldHVybiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nKSArIHRoaXMucGFyYW0ocGFyYW1zLCBmb3JtYXRGdW5jdGlvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVybDtcblx0fSxcblxuXHQvLyBQYXJhbVxuXHQvLyBFeHBsb2RlL2VuY29kZSB0aGUgcGFyYW1ldGVycyBvZiBhbiBVUkwgc3RyaW5nL29iamVjdFxuXHQvLyBAcGFyYW0gc3RyaW5nIHMsIHN0cmluZyB0byBkZWNvZGVcblx0cGFyYW06IGZ1bmN0aW9uKHMsIGZvcm1hdEZ1bmN0aW9uKSB7XG5cdFx0dmFyIGI7XG5cdFx0dmFyIGEgPSB7fTtcblx0XHR2YXIgbTtcblxuXHRcdGlmICh0eXBlb2YgKHMpID09PSAnc3RyaW5nJykge1xuXG5cdFx0XHRmb3JtYXRGdW5jdGlvbiA9IGZvcm1hdEZ1bmN0aW9uIHx8IGRlY29kZVVSSUNvbXBvbmVudDtcblxuXHRcdFx0bSA9IHMucmVwbGFjZSgvXltcXCNcXD9dLywgJycpLm1hdGNoKC8oW149XFwvXFwmXSspPShbXlxcJl0rKS9nKTtcblx0XHRcdGlmIChtKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGIgPSBtW2ldLm1hdGNoKC8oW149XSspPSguKikvKTtcblx0XHRcdFx0XHRhW2JbMV1dID0gZm9ybWF0RnVuY3Rpb24oYlsyXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXG5cdFx0XHRmb3JtYXRGdW5jdGlvbiA9IGZvcm1hdEZ1bmN0aW9uIHx8IGVuY29kZVVSSUNvbXBvbmVudDtcblxuXHRcdFx0dmFyIG8gPSBzO1xuXG5cdFx0XHRhID0gW107XG5cblx0XHRcdGZvciAodmFyIHggaW4gbykge2lmIChvLmhhc093blByb3BlcnR5KHgpKSB7XG5cdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KHgpKSB7XG5cdFx0XHRcdFx0YS5wdXNoKFt4LCBvW3hdID09PSAnPycgPyAnPycgOiBmb3JtYXRGdW5jdGlvbihvW3hdKV0uam9pbignPScpKTtcblx0XHRcdFx0fVxuXHRcdFx0fX1cblxuXHRcdFx0cmV0dXJuIGEuam9pbignJicpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBMb2NhbCBzdG9yYWdlIGZhY2FkZVxuXHRzdG9yZTogKGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGEgPSBbJ2xvY2FsU3RvcmFnZScsICdzZXNzaW9uU3RvcmFnZSddO1xuXHRcdHZhciBpID0gLTE7XG5cdFx0dmFyIHByZWZpeCA9ICd0ZXN0JztcblxuXHRcdC8vIFNldCBMb2NhbFN0b3JhZ2Vcblx0XHR2YXIgbG9jYWxTdG9yYWdlO1xuXG5cdFx0d2hpbGUgKGFbKytpXSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSW4gQ2hyb21lIHdpdGggY29va2llcyBibG9ja2VkLCBjYWxsaW5nIGxvY2FsU3RvcmFnZSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRcdFx0bG9jYWxTdG9yYWdlID0gd2luZG93W2FbaV1dO1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbShwcmVmaXggKyBpLCBpKTtcblx0XHRcdFx0bG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocHJlZml4ICsgaSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0bG9jYWxTdG9yYWdlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWxvY2FsU3RvcmFnZSkge1xuXG5cdFx0XHR2YXIgY2FjaGUgPSBudWxsO1xuXG5cdFx0XHRsb2NhbFN0b3JhZ2UgPSB7XG5cdFx0XHRcdGdldEl0ZW06IGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0XHRwcm9wID0gcHJvcCArICc9Jztcblx0XHRcdFx0XHR2YXIgbSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIF9tID0gbVtpXS5yZXBsYWNlKC8oXlxccyt8XFxzKyQpLywgJycpO1xuXHRcdFx0XHRcdFx0aWYgKF9tICYmIF9tLmluZGV4T2YocHJvcCkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIF9tLnN1YnN0cihwcm9wLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGNhY2hlO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHNldEl0ZW06IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG5cdFx0XHRcdFx0Y2FjaGUgPSB2YWx1ZTtcblx0XHRcdFx0XHRkb2N1bWVudC5jb29raWUgPSBwcm9wICsgJz0nICsgdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIEZpbGwgdGhlIGNhY2hlIHVwXG5cdFx0XHRjYWNoZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdoZWxsbycpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHZhciBqc29uID0ge307XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaGVsbG8nKSkgfHwge307XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge31cblxuXHRcdFx0cmV0dXJuIGpzb247XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0KGpzb24pIHtcblx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdoZWxsbycsIEpTT04uc3RyaW5naWZ5KGpzb24pKTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0IGxvY2FsIHN0b3JhZ2Vcblx0XHRyZXR1cm4gZnVuY3Rpb24obmFtZSwgdmFsdWUsIGRheXMpIHtcblxuXHRcdFx0Ly8gTG9jYWwgc3RvcmFnZVxuXHRcdFx0dmFyIGpzb24gPSBnZXQoKTtcblxuXHRcdFx0aWYgKG5hbWUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4ganNvbltuYW1lXSB8fCBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobmFtZSAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGRlbGV0ZSBqc29uW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0anNvbltuYW1lXSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG5hbWUpIHtcblx0XHRcdFx0anNvbltuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiBqc29uO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXQoanNvbik7XG5cblx0XHRcdHJldHVybiBqc29uIHx8IG51bGw7XG5cdFx0fTtcblxuXHR9KSgpLFxuXG5cdC8vIENyZWF0ZSBhbmQgQXBwZW5kIG5ldyBET00gZWxlbWVudHNcblx0Ly8gQHBhcmFtIG5vZGUgc3RyaW5nXG5cdC8vIEBwYXJhbSBhdHRyIG9iamVjdCBsaXRlcmFsXG5cdC8vIEBwYXJhbSBkb20vc3RyaW5nXG5cdGFwcGVuZDogZnVuY3Rpb24obm9kZSwgYXR0ciwgdGFyZ2V0KSB7XG5cblx0XHR2YXIgbiA9IHR5cGVvZiAobm9kZSkgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlKSA6IG5vZGU7XG5cblx0XHRpZiAodHlwZW9mIChhdHRyKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGlmICgndGFnTmFtZScgaW4gYXR0cikge1xuXHRcdFx0XHR0YXJnZXQgPSBhdHRyO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIHggaW4gYXR0cikge2lmIChhdHRyLmhhc093blByb3BlcnR5KHgpKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiAoYXR0clt4XSkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciB5IGluIGF0dHJbeF0pIHtpZiAoYXR0clt4XS5oYXNPd25Qcm9wZXJ0eSh5KSkge1xuXHRcdFx0XHRcdFx0XHRuW3hdW3ldID0gYXR0clt4XVt5XTtcblx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHggPT09ICdodG1sJykge1xuXHRcdFx0XHRcdFx0bi5pbm5lckhUTUwgPSBhdHRyW3hdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElFIGRvZXNuJ3QgbGlrZSB1cyBzZXR0aW5nIG1ldGhvZHMgd2l0aCBzZXRBdHRyaWJ1dGVcblx0XHRcdFx0XHRlbHNlIGlmICghL15vbi8udGVzdCh4KSkge1xuXHRcdFx0XHRcdFx0bi5zZXRBdHRyaWJ1dGUoeCwgYXR0clt4XSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0blt4XSA9IGF0dHJbeF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0YXJnZXQgPT09ICdib2R5Jykge1xuXHRcdFx0KGZ1bmN0aW9uIHNlbGYoKSB7XG5cdFx0XHRcdGlmIChkb2N1bWVudC5ib2R5KSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KHNlbGYsIDE2KTtcblx0XHRcdFx0fVxuXHRcdFx0fSkoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mICh0YXJnZXQpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKG4pO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgKHRhcmdldCkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YXJnZXQpWzBdLmFwcGVuZENoaWxkKG4pO1xuXHRcdH1cblxuXHRcdHJldHVybiBuO1xuXHR9LFxuXG5cdC8vIEFuIGVhc3kgd2F5IHRvIGNyZWF0ZSBhIGhpZGRlbiBpZnJhbWVcblx0Ly8gQHBhcmFtIHN0cmluZyBzcmNcblx0aWZyYW1lOiBmdW5jdGlvbihzcmMpIHtcblx0XHR0aGlzLmFwcGVuZCgnaWZyYW1lJywge3NyYzogc3JjLCBzdHlsZToge3Bvc2l0aW9uOidhYnNvbHV0ZScsIGxlZnQ6ICctMTAwMHB4JywgYm90dG9tOiAwLCBoZWlnaHQ6ICcxcHgnLCB3aWR0aDogJzFweCd9fSwgJ2JvZHknKTtcblx0fSxcblxuXHQvLyBSZWN1cnNpdmUgbWVyZ2UgdHdvIG9iamVjdHMgaW50byBvbmUsIHNlY29uZCBwYXJhbWV0ZXIgb3ZlcmlkZXMgdGhlIGZpcnN0XG5cdC8vIEBwYXJhbSBhIGFycmF5XG5cdG1lcmdlOiBmdW5jdGlvbigvKiBBcmdzOiBhLCBiLCBjLCAuLiBuICovKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdGFyZ3MudW5zaGlmdCh7fSk7XG5cdFx0cmV0dXJuIHRoaXMuZXh0ZW5kLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHR9LFxuXG5cdC8vIE1ha2VzIGl0IGVhc2llciB0byBhc3NpZ24gcGFyYW1ldGVycywgd2hlcmUgc29tZSBhcmUgb3B0aW9uYWxcblx0Ly8gQHBhcmFtIG8gb2JqZWN0XG5cdC8vIEBwYXJhbSBhIGFyZ3VtZW50c1xuXHRhcmdzOiBmdW5jdGlvbihvLCBhcmdzKSB7XG5cblx0XHR2YXIgcCA9IHt9O1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgdCA9IG51bGw7XG5cdFx0dmFyIHggPSBudWxsO1xuXG5cdFx0Ly8gJ3gnIGlzIHRoZSBmaXJzdCBrZXkgaW4gdGhlIGxpc3Qgb2Ygb2JqZWN0IHBhcmFtZXRlcnNcblx0XHRmb3IgKHggaW4gbykge2lmIChvLmhhc093blByb3BlcnR5KHgpKSB7XG5cdFx0XHRicmVhaztcblx0XHR9fVxuXG5cdFx0Ly8gUGFzc2luZyBpbiBoYXNoIG9iamVjdCBvZiBhcmd1bWVudHM/XG5cdFx0Ly8gV2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IGNhbid0IGJlIGFuIG9iamVjdFxuXHRcdGlmICgoYXJncy5sZW5ndGggPT09IDEpICYmICh0eXBlb2YgKGFyZ3NbMF0pID09PSAnb2JqZWN0JykgJiYgb1t4XSAhPSAnbyEnKSB7XG5cblx0XHRcdC8vIENvdWxkIHRoaXMgb2JqZWN0IHN0aWxsIGJlbG9uZyB0byBhIHByb3BlcnR5P1xuXHRcdFx0Ly8gQ2hlY2sgdGhlIG9iamVjdCBrZXlzIGlmIHRoZXkgbWF0Y2ggYW55IG9mIHRoZSBwcm9wZXJ0eSBrZXlzXG5cdFx0XHRmb3IgKHggaW4gYXJnc1swXSkge2lmIChvLmhhc093blByb3BlcnR5KHgpKSB7XG5cdFx0XHRcdC8vIERvZXMgdGhpcyBrZXkgZXhpc3QgaW4gdGhlIHByb3BlcnR5IGxpc3Q/XG5cdFx0XHRcdGlmICh4IGluIG8pIHtcblx0XHRcdFx0XHQvLyBZZXMgdGhpcyBrZXkgZG9lcyBleGlzdCBzbyBpdHMgbW9zdCBsaWtlbHkgdGhpcyBmdW5jdGlvbiBoYXMgYmVlbiBpbnZva2VkIHdpdGggYW4gb2JqZWN0IHBhcmFtZXRlclxuXHRcdFx0XHRcdC8vIFJldHVybiBmaXJzdCBhcmd1bWVudCBhcyB0aGUgaGFzaCBvZiBhbGwgYXJndW1lbnRzXG5cdFx0XHRcdFx0cmV0dXJuIGFyZ3NbMF07XG5cdFx0XHRcdH1cblx0XHRcdH19XG5cdFx0fVxuXG5cdFx0Ly8gRWxzZSBsb29wIHRocm91Z2ggYW5kIGFjY291bnQgZm9yIHRoZSBtaXNzaW5nIG9uZXMuXG5cdFx0Zm9yICh4IGluIG8pIHtpZiAoby5oYXNPd25Qcm9wZXJ0eSh4KSkge1xuXG5cdFx0XHR0ID0gdHlwZW9mIChhcmdzW2ldKTtcblxuXHRcdFx0aWYgKCh0eXBlb2YgKG9beF0pID09PSAnZnVuY3Rpb24nICYmIG9beF0udGVzdChhcmdzW2ldKSkgfHwgKHR5cGVvZiAob1t4XSkgPT09ICdzdHJpbmcnICYmIChcblx0XHRcdChvW3hdLmluZGV4T2YoJ3MnKSA+IC0xICYmIHQgPT09ICdzdHJpbmcnKSB8fFxuXHRcdFx0KG9beF0uaW5kZXhPZignbycpID4gLTEgJiYgdCA9PT0gJ29iamVjdCcpIHx8XG5cdFx0XHQob1t4XS5pbmRleE9mKCdpJykgPiAtMSAmJiB0ID09PSAnbnVtYmVyJykgfHxcblx0XHRcdChvW3hdLmluZGV4T2YoJ2EnKSA+IC0xICYmIHQgPT09ICdvYmplY3QnKSB8fFxuXHRcdFx0KG9beF0uaW5kZXhPZignZicpID4gLTEgJiYgdCA9PT0gJ2Z1bmN0aW9uJylcblx0XHRcdCkpXG5cdFx0XHQpIHtcblx0XHRcdFx0cFt4XSA9IGFyZ3NbaSsrXTtcblx0XHRcdH1cblxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIChvW3hdKSA9PT0gJ3N0cmluZycgJiYgb1t4XS5pbmRleE9mKCchJykgPiAtMSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fX1cblxuXHRcdHJldHVybiBwO1xuXHR9LFxuXG5cdC8vIFJldHVybnMgYSBVUkwgaW5zdGFuY2Vcblx0dXJsOiBmdW5jdGlvbihwYXRoKSB7XG5cblx0XHQvLyBJZiB0aGUgcGF0aCBpcyBlbXB0eVxuXHRcdGlmICghcGF0aCkge1xuXHRcdFx0cmV0dXJuIHdpbmRvdy5sb2NhdGlvbjtcblx0XHR9XG5cblx0XHQvLyBDaHJvbWUgYW5kIEZpcmVGb3ggc3VwcG9ydCBuZXcgVVJMKCkgdG8gZXh0cmFjdCBVUkwgb2JqZWN0c1xuXHRcdGVsc2UgaWYgKHdpbmRvdy5VUkwgJiYgVVJMIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgVVJMLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0cmV0dXJuIG5ldyBVUkwocGF0aCwgd2luZG93LmxvY2F0aW9uKTtcblx0XHR9XG5cblx0XHQvLyBVZ2x5IHNoaW0sIGl0IHdvcmtzIVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdFx0XHRhLmhyZWYgPSBwYXRoO1xuXHRcdFx0cmV0dXJuIGEuY2xvbmVOb2RlKGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlmZjogZnVuY3Rpb24oYSwgYikge1xuXHRcdHJldHVybiBiLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRyZXR1cm4gYS5pbmRleE9mKGl0ZW0pID09PSAtMTtcblx0XHR9KTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIGRpZmZlcmVudCBoYXNoIG9mIHByb3BlcnRpZXMgdW5pcXVlIHRvIGBhYCwgYW5kIG5vdCBpbiBgYmBcblx0ZGlmZktleTogZnVuY3Rpb24oYSwgYikge1xuXHRcdGlmIChhIHx8ICFiKSB7XG5cdFx0XHR2YXIgciA9IHt9O1xuXHRcdFx0Zm9yICh2YXIgeCBpbiBhKSB7XG5cdFx0XHRcdC8vIERvZXMgdGhlIHByb3BlcnR5IG5vdCBleGlzdD9cblx0XHRcdFx0aWYgKCEoeCBpbiBiKSkge1xuXHRcdFx0XHRcdHJbeF0gPSBhW3hdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByO1xuXHRcdH1cblxuXHRcdHJldHVybiBhO1xuXHR9LFxuXG5cdC8vIFVuaXF1ZVxuXHQvLyBSZW1vdmUgZHVwbGljYXRlIGFuZCBudWxsIHZhbHVlcyBmcm9tIGFuIGFycmF5XG5cdC8vIEBwYXJhbSBhIGFycmF5XG5cdHVuaXF1ZTogZnVuY3Rpb24oYSkge1xuXHRcdGlmICghQXJyYXkuaXNBcnJheShhKSkgeyByZXR1cm4gW107IH1cblxuXHRcdHJldHVybiBhLmZpbHRlcihmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuXHRcdFx0Ly8gSXMgdGhpcyB0aGUgZmlyc3QgbG9jYXRpb24gb2YgaXRlbVxuXHRcdFx0cmV0dXJuIGEuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG5cdFx0fSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24ob2JqKSB7XG5cblx0XHQvLyBTY2FsYXJcblx0XHRpZiAoIW9iailcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0Ly8gQXJyYXlcblx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRyZXR1cm4gIW9iai5sZW5ndGg7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiAob2JqKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdC8vIE9iamVjdFxuXHRcdFx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvL2pzY3M6ZGlzYWJsZVxuXG5cdC8qIVxuXHQgKiogIFRoZW5hYmxlIC0tIEVtYmVkZGFibGUgTWluaW11bSBTdHJpY3RseS1Db21wbGlhbnQgUHJvbWlzZXMvQSsgMS4xLjEgVGhlbmFibGVcblx0ICoqICBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBSYWxmIFMuIEVuZ2Vsc2NoYWxsIDxodHRwOi8vZW5nZWxzY2hhbGwuY29tPlxuXHQgKiogIExpY2Vuc2VkIHVuZGVyIFRoZSBNSVQgTGljZW5zZSA8aHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD5cblx0ICoqICBTb3VyY2UtQ29kZSBkaXN0cmlidXRlZCBvbiA8aHR0cDovL2dpdGh1Yi5jb20vcnNlL3RoZW5hYmxlPlxuXHQgKi9cblx0UHJvbWlzZTogKGZ1bmN0aW9uKCl7XG5cdFx0LyogIHByb21pc2Ugc3RhdGVzIFtQcm9taXNlcy9BKyAyLjFdICAqL1xuXHRcdHZhciBTVEFURV9QRU5ESU5HICAgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG5cdFx0dmFyIFNUQVRFX0ZVTEZJTExFRCA9IDE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yXSAgKi9cblx0XHR2YXIgU1RBVEVfUkVKRUNURUQgID0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjNdICAqL1xuXG5cdFx0LyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xuXHRcdHZhciBhcGkgPSBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcblx0XHRcdC8qICBvcHRpb25hbGx5IHN1cHBvcnQgbm9uLWNvbnN0cnVjdG9yL3BsYWluLWZ1bmN0aW9uIGNhbGwgICovXG5cdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgYXBpKSlcblx0XHRcdFx0cmV0dXJuIG5ldyBhcGkoZXhlY3V0b3IpO1xuXG5cdFx0XHQvKiAgaW5pdGlhbGl6ZSBvYmplY3QgICovXG5cdFx0XHR0aGlzLmlkICAgICAgICAgICA9IFwiVGhlbmFibGUvMS4wLjZcIjtcblx0XHRcdHRoaXMuc3RhdGUgICAgICAgID0gU1RBVEVfUEVORElORzsgLyogIGluaXRpYWwgc3RhdGUgICovXG5cdFx0XHR0aGlzLmZ1bGZpbGxWYWx1ZSA9IHVuZGVmaW5lZDsgICAgIC8qICBpbml0aWFsIHZhbHVlICAqLyAgICAgLyogIFtQcm9taXNlcy9BKyAxLjMsIDIuMS4yLjJdICAqL1xuXHRcdFx0dGhpcy5yZWplY3RSZWFzb24gPSB1bmRlZmluZWQ7ICAgICAvKiAgaW5pdGlhbCByZWFzb24gKi8gICAgIC8qICBbUHJvbWlzZXMvQSsgMS41LCAyLjEuMy4yXSAgKi9cblx0XHRcdHRoaXMub25GdWxmaWxsZWQgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cdFx0XHR0aGlzLm9uUmVqZWN0ZWQgICA9IFtdOyAgICAgICAgICAgIC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuXG5cdFx0XHQvKiAgcHJvdmlkZSBvcHRpb25hbCBpbmZvcm1hdGlvbi1oaWRpbmcgcHJveHkgICovXG5cdFx0XHR0aGlzLnByb3h5ID0ge1xuXHRcdFx0XHR0aGVuOiB0aGlzLnRoZW4uYmluZCh0aGlzKVxuXHRcdFx0fTtcblxuXHRcdFx0LyogIHN1cHBvcnQgb3B0aW9uYWwgZXhlY3V0b3IgZnVuY3Rpb24gICovXG5cdFx0XHRpZiAodHlwZW9mIGV4ZWN1dG9yID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHRcdGV4ZWN1dG9yLmNhbGwodGhpcywgdGhpcy5mdWxmaWxsLmJpbmQodGhpcyksIHRoaXMucmVqZWN0LmJpbmQodGhpcykpO1xuXHRcdH07XG5cblx0XHQvKiAgcHJvbWlzZSBBUEkgbWV0aG9kcyAgKi9cblx0XHRhcGkucHJvdG90eXBlID0ge1xuXHRcdFx0LyogIHByb21pc2UgcmVzb2x2aW5nIG1ldGhvZHMgICovXG5cdFx0XHRmdWxmaWxsOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfRlVMRklMTEVELCBcImZ1bGZpbGxWYWx1ZVwiLCB2YWx1ZSk7IH0sXG5cdFx0XHRyZWplY3Q6ICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfUkVKRUNURUQsICBcInJlamVjdFJlYXNvblwiLCB2YWx1ZSk7IH0sXG5cblx0XHRcdC8qICBcIlRoZSB0aGVuIE1ldGhvZFwiIFtQcm9taXNlcy9BKyAxLjEsIDEuMiwgMi4yXSAgKi9cblx0XHRcdHRoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHRcdFx0XHR2YXIgY3VyciA9IHRoaXM7XG5cdFx0XHRcdHZhciBuZXh0ID0gbmV3IGFwaSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjddICAqL1xuXHRcdFx0XHRjdXJyLm9uRnVsZmlsbGVkLnB1c2goXG5cdFx0XHRcdFx0cmVzb2x2ZXIob25GdWxmaWxsZWQsIG5leHQsIFwiZnVsZmlsbFwiKSk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIvMi4yLjZdICAqL1xuXHRcdFx0XHRjdXJyLm9uUmVqZWN0ZWQucHVzaChcblx0XHRcdFx0XHRyZXNvbHZlcihvblJlamVjdGVkLCAgbmV4dCwgXCJyZWplY3RcIiApKTsgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMy8yLjIuNl0gICovXG5cdFx0XHRcdGV4ZWN1dGUoY3Vycik7XG5cdFx0XHRcdHJldHVybiBuZXh0LnByb3h5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcsIDMuM10gICovXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qICBkZWxpdmVyIGFuIGFjdGlvbiAgKi9cblx0XHR2YXIgZGVsaXZlciA9IGZ1bmN0aW9uIChjdXJyLCBzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9QRU5ESU5HKSB7XG5cdFx0XHRcdGN1cnIuc3RhdGUgPSBzdGF0ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMSwgMi4xLjMuMV0gICovXG5cdFx0XHRcdGN1cnJbbmFtZV0gPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMiwgMi4xLjMuMl0gICovXG5cdFx0XHRcdGV4ZWN1dGUoY3Vycik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3Vycjtcblx0XHR9O1xuXG5cdFx0LyogIGV4ZWN1dGUgYWxsIGhhbmRsZXJzICAqL1xuXHRcdHZhciBleGVjdXRlID0gZnVuY3Rpb24gKGN1cnIpIHtcblx0XHRcdGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQpXG5cdFx0XHRcdGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgXCJvbkZ1bGZpbGxlZFwiLCBjdXJyLmZ1bGZpbGxWYWx1ZSk7XG5cdFx0XHRlbHNlIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9SRUpFQ1RFRClcblx0XHRcdFx0ZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCBcIm9uUmVqZWN0ZWRcIiwgIGN1cnIucmVqZWN0UmVhc29uKTtcblx0XHR9O1xuXG5cdFx0LyogIGV4ZWN1dGUgcGFydGljdWxhciBzZXQgb2YgaGFuZGxlcnMgICovXG5cdFx0dmFyIGV4ZWN1dGVfaGFuZGxlcnMgPSBmdW5jdGlvbiAoY3VyciwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbCBwcm9jZXNzOiB0cnVlICovXG5cdFx0XHQvKiBnbG9iYWwgc2V0SW1tZWRpYXRlOiB0cnVlICovXG5cdFx0XHQvKiBnbG9iYWwgc2V0VGltZW91dDogdHJ1ZSAqL1xuXG5cdFx0XHQvKiAgc2hvcnQtY2lyY3VpdCBwcm9jZXNzaW5nICAqL1xuXHRcdFx0aWYgKGN1cnJbbmFtZV0ubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8qICBpdGVyYXRlIG92ZXIgYWxsIGhhbmRsZXJzLCBleGFjdGx5IG9uY2UgICovXG5cdFx0XHR2YXIgaGFuZGxlcnMgPSBjdXJyW25hbWVdO1xuXHRcdFx0Y3VycltuYW1lXSA9IFtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMywgMi4yLjMuM10gICovXG5cdFx0XHR2YXIgZnVuYyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHRoYW5kbGVyc1tpXSh2YWx1ZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjVdICAqL1xuXHRcdFx0fTtcblxuXHRcdFx0LyogIGV4ZWN1dGUgcHJvY2VkdXJlIGFzeW5jaHJvbm91c2x5ICAqLyAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjQsIDMuMV0gICovXG5cdFx0XHRpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09IFwiZnVuY3Rpb25cIilcblx0XHRcdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jKTtcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIilcblx0XHRcdFx0c2V0SW1tZWRpYXRlKGZ1bmMpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmMsIDApO1xuXHRcdH07XG5cblx0XHQvKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cblx0XHR2YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiAoY2IsIG5leHQsIG1ldGhvZCkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjEsIDIuMi43LjMsIDIuMi43LjRdICAqL1xuXHRcdFx0XHRcdG5leHRbbWV0aG9kXS5jYWxsKG5leHQsIHZhbHVlKTsgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4zLCAyLjIuNy40XSAgKi9cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdDtcblx0XHRcdFx0XHR0cnkgeyByZXN1bHQgPSBjYih2YWx1ZSk7IH0gICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMSwgMi4yLjMuMSwgMi4yLjUsIDMuMl0gICovXG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdG5leHQucmVqZWN0KGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjJdICAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXNvbHZlKG5leHQsIHJlc3VsdCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8qICBcIlByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcIiAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuM10gICovXG5cdFx0dmFyIHJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgeCkge1xuXHRcdFx0LyogIHNhbml0eSBjaGVjayBhcmd1bWVudHMgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuXHRcdFx0aWYgKHByb21pc2UgPT09IHggfHwgcHJvbWlzZS5wcm94eSA9PT0geCkge1xuXHRcdFx0XHRwcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFwiY2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogIHN1cmdpY2FsbHkgY2hlY2sgZm9yIGEgXCJ0aGVuXCIgbWV0aG9kXG5cdFx0XHRcdChtYWlubHkgdG8ganVzdCBjYWxsIHRoZSBcImdldHRlclwiIG9mIFwidGhlblwiIG9ubHkgb25jZSkgICovXG5cdFx0XHR2YXIgdGhlbjtcblx0XHRcdGlmICgodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR0cnkgeyB0aGVuID0geC50aGVuOyB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjEsIDMuNV0gICovXG5cdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0cHJvbWlzZS5yZWplY3QoZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjJdICAqL1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuXHRcdFx0XHRhbmQgc2ltaWxhciBcInRoZW5hYmxlc1wiIFtQcm9taXNlcy9BKyAyLjMuM10gICovXG5cdFx0XHRpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvKiAgY2FsbCByZXRyaWV2ZWQgXCJ0aGVuXCIgbWV0aG9kICovICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zXSAgKi9cblx0XHRcdFx0XHR0aGVuLmNhbGwoeCxcblx0XHRcdFx0XHRcdC8qICByZXNvbHZlUHJvbWlzZSAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMV0gICovXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiAoeSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocmVzb2x2ZWQpIHJldHVybjsgcmVzb2x2ZWQgPSB0cnVlOyAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG5cdFx0XHRcdFx0XHRcdGlmICh5ID09PSB4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMy42XSAgKi9cblx0XHRcdFx0XHRcdFx0XHRwcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFwiY2lyY3VsYXIgdGhlbmFibGUgY2hhaW5cIikpO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShwcm9taXNlLCB5KTtcblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdC8qICByZWplY3RQcm9taXNlICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMl0gICovXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiAocikge1xuXHRcdFx0XHRcdFx0XHRpZiAocmVzb2x2ZWQpIHJldHVybjsgcmVzb2x2ZWQgPSB0cnVlOyAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG5cdFx0XHRcdFx0XHRcdHByb21pc2UucmVqZWN0KHIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRpZiAoIXJlc29sdmVkKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cblx0XHRcdFx0XHRcdHByb21pc2UucmVqZWN0KGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuNF0gICovXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiAgaGFuZGxlIG90aGVyIHZhbHVlcyAgKi9cblx0XHRcdHByb21pc2UuZnVsZmlsbCh4KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy40LCAyLjMuMy40XSAgKi9cblx0XHR9O1xuXG5cdFx0LyogIGV4cG9ydCBBUEkgICovXG5cdFx0cmV0dXJuIGFwaTtcblx0fSkoKSxcblxuXHQvL2pzY3M6ZW5hYmxlXG5cblx0Ly8gRXZlbnRcblx0Ly8gQSBjb250cnVjdG9yIHN1cGVyY2xhc3MgZm9yIGFkZGluZyBldmVudCBtZW50aG9kcywgb24sIG9mZiwgZW1pdC5cblx0RXZlbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHNlcGFyYXRvciA9IC9bXFxzXFwsXSsvO1xuXG5cdFx0Ly8gSWYgdGhpcyBkb2Vzbid0IHN1cHBvcnQgZ2V0UHJvdG90eXBlIHRoZW4gd2UgY2FuJ3QgZ2V0IHByb3RvdHlwZS5ldmVudHMgb2YgdGhlIHBhcmVudFxuXHRcdC8vIFNvIGxldHMgZ2V0IHRoZSBjdXJyZW50IGluc3RhbmNlIGV2ZW50cywgYW5kIGFkZCB0aG9zZSB0byBhIHBhcmVudCBwcm9wZXJ0eVxuXHRcdHRoaXMucGFyZW50ID0ge1xuXHRcdFx0ZXZlbnRzOiB0aGlzLmV2ZW50cyxcblx0XHRcdGZpbmRFdmVudHM6IHRoaXMuZmluZEV2ZW50cyxcblx0XHRcdHBhcmVudDogdGhpcy5wYXJlbnQsXG5cdFx0XHR1dGlsczogdGhpcy51dGlsc1xuXHRcdH07XG5cblx0XHR0aGlzLmV2ZW50cyA9IHt9O1xuXG5cdFx0Ly8gT24sIHN1YnNjcmliZSB0byBldmVudHNcblx0XHQvLyBAcGFyYW0gZXZ0ICAgc3RyaW5nXG5cdFx0Ly8gQHBhcmFtIGNhbGxiYWNrICBmdW5jdGlvblxuXHRcdHRoaXMub24gPSBmdW5jdGlvbihldnQsIGNhbGxiYWNrKSB7XG5cblx0XHRcdGlmIChjYWxsYmFjayAmJiB0eXBlb2YgKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR2YXIgYSA9IGV2dC5zcGxpdChzZXBhcmF0b3IpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0XHRcdC8vIEhhcyB0aGlzIGV2ZW50IGFscmVhZHkgYmVlbiBmaXJlZCBvbiB0aGlzIGluc3RhbmNlP1xuXHRcdFx0XHRcdHRoaXMuZXZlbnRzW2FbaV1dID0gW2NhbGxiYWNrXS5jb25jYXQodGhpcy5ldmVudHNbYVtpXV0gfHwgW10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHQvLyBPZmYsIHVuc3Vic2NyaWJlIHRvIGV2ZW50c1xuXHRcdC8vIEBwYXJhbSBldnQgICBzdHJpbmdcblx0XHQvLyBAcGFyYW0gY2FsbGJhY2sgIGZ1bmN0aW9uXG5cdFx0dGhpcy5vZmYgPSBmdW5jdGlvbihldnQsIGNhbGxiYWNrKSB7XG5cblx0XHRcdHRoaXMuZmluZEV2ZW50cyhldnQsIGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cdFx0XHRcdGlmICghY2FsbGJhY2sgfHwgdGhpcy5ldmVudHNbbmFtZV1baW5kZXhdID09PSBjYWxsYmFjaykge1xuXHRcdFx0XHRcdHRoaXMuZXZlbnRzW25hbWVdW2luZGV4XSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0Ly8gRW1pdFxuXHRcdC8vIFRyaWdnZXJzIGFueSBzdWJzY3JpYmVkIGV2ZW50c1xuXHRcdHRoaXMuZW1pdCA9IGZ1bmN0aW9uKGV2dCAvKiwgZGF0YSwgLi4uICovKSB7XG5cblx0XHRcdC8vIEdldCBhcmd1bWVudHMgYXMgYW4gQXJyYXksIGtub2NrIG9mZiB0aGUgZmlyc3Qgb25lXG5cdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0XHRhcmdzLnB1c2goZXZ0KTtcblxuXHRcdFx0Ly8gSGFuZGxlclxuXHRcdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXG5cdFx0XHRcdC8vIFJlcGxhY2UgdGhlIGxhc3QgcHJvcGVydHkgd2l0aCB0aGUgZXZlbnQgbmFtZVxuXHRcdFx0XHRhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSAobmFtZSA9PT0gJyonID8gZXZ0IDogbmFtZSk7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlclxuXHRcdFx0XHR0aGlzLmV2ZW50c1tuYW1lXVtpbmRleF0uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBGaW5kIHRoZSBjYWxsYmFja3Mgd2hpY2ggbWF0Y2ggdGhlIGNvbmRpdGlvbiBhbmQgY2FsbFxuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdHdoaWxlIChfdGhpcyAmJiBfdGhpcy5maW5kRXZlbnRzKSB7XG5cblx0XHRcdFx0Ly8gRmluZCBldmVudHMgd2hpY2ggbWF0Y2hcblx0XHRcdFx0X3RoaXMuZmluZEV2ZW50cyhldnQgKyAnLConLCBoYW5kbGVyKTtcblx0XHRcdFx0X3RoaXMgPSBfdGhpcy5wYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHQvL1xuXHRcdC8vIEVhc3kgZnVuY3Rpb25zXG5cdFx0dGhpcy5lbWl0QWZ0ZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aGlzLmVtaXQuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuXHRcdFx0fSwgMCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHR0aGlzLmZpbmRFdmVudHMgPSBmdW5jdGlvbihldnQsIGNhbGxiYWNrKSB7XG5cblx0XHRcdHZhciBhID0gZXZ0LnNwbGl0KHNlcGFyYXRvcik7XG5cblx0XHRcdGZvciAodmFyIG5hbWUgaW4gdGhpcy5ldmVudHMpIHtpZiAodGhpcy5ldmVudHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblxuXHRcdFx0XHRpZiAoYS5pbmRleE9mKG5hbWUpID4gLTEpIHtcblxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudHNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0XHRcdFx0Ly8gRG9lcyB0aGUgZXZlbnQgaGFuZGxlciBleGlzdD9cblx0XHRcdFx0XHRcdGlmICh0aGlzLmV2ZW50c1tuYW1lXVtpXSkge1xuXHRcdFx0XHRcdFx0XHQvLyBFbWl0IG9uIHRoZSBsb2NhbCBpbnN0YW5jZSBvZiB0aGlzXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgaSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9fVxuXHRcdH07XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBHbG9iYWwgRXZlbnRzXG5cdC8vIEF0dGFjaCB0aGUgY2FsbGJhY2sgdG8gdGhlIHdpbmRvdyBvYmplY3Rcblx0Ly8gUmV0dXJuIGl0cyB1bmlxdWUgcmVmZXJlbmNlXG5cdGdsb2JhbEV2ZW50OiBmdW5jdGlvbihjYWxsYmFjaywgZ3VpZCkge1xuXHRcdC8vIElmIHRoZSBndWlkIGhhcyBub3QgYmVlbiBzdXBwbGllZCB0aGVuIGNyZWF0ZSBhIG5ldyBvbmUuXG5cdFx0Z3VpZCA9IGd1aWQgfHwgJ19oZWxsb2pzXycgKyBwYXJzZUludChNYXRoLnJhbmRvbSgpICogMWUxMiwgMTApLnRvU3RyaW5nKDM2KTtcblxuXHRcdC8vIERlZmluZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cblx0XHR3aW5kb3dbZ3VpZF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuXHRcdFx0XHRcdGRlbGV0ZSB3aW5kb3dbZ3VpZF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJldHVybiBndWlkO1xuXHR9LFxuXG5cdC8vIFRyaWdnZXIgYSBjbGllbnRzaWRlIHBvcHVwXG5cdC8vIFRoaXMgaGFzIGJlZW4gYXVnbWVudGVkIHRvIHN1cHBvcnQgUGhvbmVHYXBcblx0cG9wdXA6IGZ1bmN0aW9uKHVybCwgcmVkaXJlY3RVcmksIG9wdGlvbnMpIHtcblxuXHRcdHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNdWx0aSBTY3JlZW4gUG9wdXAgUG9zaXRpb25pbmcgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2ODYxMDUwKVxuXHRcdC8vIENyZWRpdDogaHR0cDovL3d3dy54dGYuZGsvMjAxMS8wOC9jZW50ZXItbmV3LXBvcHVwLXdpbmRvdy1ldmVuLW9uLmh0bWxcblx0XHQvLyBGaXhlcyBkdWFsLXNjcmVlbiBwb3NpdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICBNb3N0IGJyb3dzZXJzICAgICAgRmlyZWZveFxuXG5cdFx0aWYgKG9wdGlvbnMuaGVpZ2h0KSB7XG5cdFx0XHR2YXIgZHVhbFNjcmVlblRvcCA9IHdpbmRvdy5zY3JlZW5Ub3AgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5Ub3AgOiBzY3JlZW4udG9wO1xuXHRcdFx0dmFyIGhlaWdodCA9IHNjcmVlbi5oZWlnaHQgfHwgd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG5cdFx0XHRvcHRpb25zLnRvcCA9IHBhcnNlSW50KChoZWlnaHQgLSBvcHRpb25zLmhlaWdodCkgLyAyLCAxMCkgKyBkdWFsU2NyZWVuVG9wO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLndpZHRoKSB7XG5cdFx0XHR2YXIgZHVhbFNjcmVlbkxlZnQgPSB3aW5kb3cuc2NyZWVuTGVmdCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlbkxlZnQgOiBzY3JlZW4ubGVmdDtcblx0XHRcdHZhciB3aWR0aCA9IHNjcmVlbi53aWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cdFx0XHRvcHRpb25zLmxlZnQgPSBwYXJzZUludCgod2lkdGggLSBvcHRpb25zLndpZHRoKSAvIDIsIDEwKSArIGR1YWxTY3JlZW5MZWZ0O1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgb3B0aW9ucyBpbnRvIGFuIGFycmF5XG5cdFx0dmFyIG9wdGlvbnNBcnJheSA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9uc1tuYW1lXTtcblx0XHRcdG9wdGlvbnNBcnJheS5wdXNoKG5hbWUgKyAodmFsdWUgIT09IG51bGwgPyAnPScgKyB2YWx1ZSA6ICcnKSk7XG5cdFx0fSk7XG5cblx0XHQvLyBDYWxsIHRoZSBvcGVuKCkgZnVuY3Rpb24gd2l0aCB0aGUgaW5pdGlhbCBwYXRoXG5cdFx0Ly9cblx0XHQvLyBPQXV0aCByZWRpcmVjdCwgZml4ZXMgVVJJIGZyYWdtZW50cyBmcm9tIGJlaW5nIGxvc3QgaW4gU2FmYXJpXG5cdFx0Ly8gKFVSSSBGcmFnbWVudHMgd2l0aGluIDMwMiBMb2NhdGlvbiBVUkkgYXJlIGxvc3Qgb3ZlciBIVFRQUylcblx0XHQvLyBMb2FkaW5nIHRoZSByZWRpcmVjdC5odG1sIGJlZm9yZSB0cmlnZ2VyaW5nIHRoZSBPQXV0aCBGbG93IHNlZW1zIHRvIGZpeCBpdC5cblx0XHQvL1xuXHRcdC8vIEZpcmVmb3ggIGRlY29kZXMgVVJMIGZyYWdtZW50cyB3aGVuIGNhbGxpbmcgbG9jYXRpb24uaGFzaC5cblx0XHQvLyAgLSBUaGlzIGlzIGJhZCBpZiB0aGUgdmFsdWUgY29udGFpbnMgYnJlYWsgcG9pbnRzIHdoaWNoIGFyZSBlc2NhcGVkXG5cdFx0Ly8gIC0gSGVuY2UgdGhlIHVybCBtdXN0IGJlIGVuY29kZWQgdHdpY2UgYXMgaXQgY29udGFpbnMgYnJlYWtwb2ludHMuXG5cdFx0aWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgIT09IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPT09IC0xKSB7XG5cdFx0XHR1cmwgPSByZWRpcmVjdFVyaSArICcjb2F1dGhfcmVkaXJlY3Q9JyArIGVuY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQodXJsKSk7XG5cdFx0fVxuXG5cdFx0dmFyIHBvcHVwID0gd2luZG93Lm9wZW4oXG5cdFx0XHR1cmwsXG5cdFx0XHQnX2JsYW5rJyxcblx0XHRcdG9wdGlvbnNBcnJheS5qb2luKCcsJylcblx0XHQpO1xuXG5cdFx0aWYgKHBvcHVwICYmIHBvcHVwLmZvY3VzKSB7XG5cdFx0XHRwb3B1cC5mb2N1cygpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwb3B1cDtcblx0fSxcblxuXHQvLyBPQXV0aCBhbmQgQVBJIHJlc3BvbnNlIGhhbmRsZXJcblx0cmVzcG9uc2VIYW5kbGVyOiBmdW5jdGlvbih3aW5kb3csIHBhcmVudCkge1xuXG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgcDtcblx0XHR2YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cblx0XHQvLyBJcyB0aGlzIGFuIGF1dGggcmVsYXkgbWVzc2FnZSB3aGljaCBuZWVkcyB0byBjYWxsIHRoZSBwcm94eT9cblx0XHRwID0gX3RoaXMucGFyYW0obG9jYXRpb24uc2VhcmNoKTtcblxuXHRcdC8vIE9BdXRoMiBvciBPQXV0aDEgc2VydmVyIHJlc3BvbnNlP1xuXHRcdGlmIChwICYmIHAuc3RhdGUgJiYgKHAuY29kZSB8fCBwLm9hdXRoX3Rva2VuKSkge1xuXG5cdFx0XHR2YXIgc3RhdGUgPSBKU09OLnBhcnNlKHAuc3RhdGUpO1xuXG5cdFx0XHQvLyBBZGQgdGhpcyBwYXRoIGFzIHRoZSByZWRpcmVjdF91cmlcblx0XHRcdHAucmVkaXJlY3RfdXJpID0gc3RhdGUucmVkaXJlY3RfdXJpIHx8IGxvY2F0aW9uLmhyZWYucmVwbGFjZSgvW1xcP1xcI10uKiQvLCAnJyk7XG5cblx0XHRcdC8vIFJlZGlyZWN0IHRvIHRoZSBob3N0XG5cdFx0XHR2YXIgcGF0aCA9IHN0YXRlLm9hdXRoX3Byb3h5ICsgJz8nICsgX3RoaXMucGFyYW0ocCk7XG5cblx0XHRcdGxvY2F0aW9uLmFzc2lnbihwYXRoKTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNhdmUgc2Vzc2lvbiwgZnJvbSByZWRpcmVjdGVkIGF1dGhlbnRpY2F0aW9uXG5cdFx0Ly8gI2FjY2Vzc190b2tlbiBoYXMgY29tZSBpbj9cblx0XHQvL1xuXHRcdC8vIEZBQ0VCT09LIGlzIHJldHVybmluZyBhdXRoIGVycm9ycyB3aXRoaW4gYXMgYSBxdWVyeV9zdHJpbmcuLi4gdGhhdHMgYSBzdGlja2xlciBmb3IgY29uc2lzdGVuY3kuXG5cdFx0Ly8gU291bmRDbG91ZCBpcyB0aGUgc3RhdGUgaW4gdGhlIHF1ZXJ5c3RyaW5nIGFuZCB0aGUgdG9rZW4gaW4gdGhlIGhhc2h0YWcsIHNvIHdlJ2xsIG1peCB0aGUgdHdvIHRvZ2V0aGVyXG5cblx0XHRwID0gX3RoaXMubWVyZ2UoX3RoaXMucGFyYW0obG9jYXRpb24uc2VhcmNoIHx8ICcnKSwgX3RoaXMucGFyYW0obG9jYXRpb24uaGFzaCB8fCAnJykpO1xuXG5cdFx0Ly8gSWYgcC5zdGF0ZVxuXHRcdGlmIChwICYmICdzdGF0ZScgaW4gcCkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYW55IGFkZGl0aW9uIGluZm9ybWF0aW9uXG5cdFx0XHQvLyBFLmcuIHAuc3RhdGUgPSAnZmFjZWJvb2sucGFnZSc7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgYSA9IEpTT04ucGFyc2UocC5zdGF0ZSk7XG5cdFx0XHRcdF90aGlzLmV4dGVuZChwLCBhKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgc3RhdGUgcGFyYW1ldGVyJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2Vzc190b2tlbj9cblx0XHRcdGlmICgoJ2FjY2Vzc190b2tlbicgaW4gcCAmJiBwLmFjY2Vzc190b2tlbikgJiYgcC5uZXR3b3JrKSB7XG5cblx0XHRcdFx0aWYgKCFwLmV4cGlyZXNfaW4gfHwgcGFyc2VJbnQocC5leHBpcmVzX2luLCAxMCkgPT09IDApIHtcblx0XHRcdFx0XHQvLyBJZiBwLmV4cGlyZXNfaW4gaXMgdW5zZXQsIHNldCB0byAwXG5cdFx0XHRcdFx0cC5leHBpcmVzX2luID0gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHAuZXhwaXJlc19pbiA9IHBhcnNlSW50KHAuZXhwaXJlc19pbiwgMTApO1xuXHRcdFx0XHRwLmV4cGlyZXMgPSAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDFlMykgKyAocC5leHBpcmVzX2luIHx8ICg2MCAqIDYwICogMjQgKiAzNjUpKTtcblxuXHRcdFx0XHQvLyBMZXRzIHVzZSB0aGUgXCJzdGF0ZVwiIHRvIGFzc2lnbiBpdCB0byBvbmUgb2Ygb3VyIG5ldHdvcmtzXG5cdFx0XHRcdGF1dGhDYWxsYmFjayhwLCB3aW5kb3csIHBhcmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEVycm9yPT9cblx0XHRcdC8vICZlcnJvcl9kZXNjcmlwdGlvbj0/XG5cdFx0XHQvLyAmc3RhdGU9P1xuXHRcdFx0ZWxzZSBpZiAoKCdlcnJvcicgaW4gcCAmJiBwLmVycm9yKSAmJiBwLm5ldHdvcmspIHtcblxuXHRcdFx0XHRwLmVycm9yID0ge1xuXHRcdFx0XHRcdGNvZGU6IHAuZXJyb3IsXG5cdFx0XHRcdFx0bWVzc2FnZTogcC5lcnJvcl9tZXNzYWdlIHx8IHAuZXJyb3JfZGVzY3JpcHRpb25cblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMZXQgdGhlIHN0YXRlIGhhbmRsZXIgaGFuZGxlIGl0XG5cdFx0XHRcdGF1dGhDYWxsYmFjayhwLCB3aW5kb3csIHBhcmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFQSSBjYWxsLCBvciBhIGNhbmNlbGxlZCBsb2dpblxuXHRcdFx0Ly8gUmVzdWx0IGlzIHNlcmlhbGl6ZWQgSlNPTiBzdHJpbmdcblx0XHRcdGVsc2UgaWYgKHAuY2FsbGJhY2sgJiYgcC5jYWxsYmFjayBpbiBwYXJlbnQpIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyIGEgZnVuY3Rpb24gaW4gdGhlIHBhcmVudFxuXHRcdFx0XHR2YXIgcmVzID0gJ3Jlc3VsdCcgaW4gcCAmJiBwLnJlc3VsdCA/IEpTT04ucGFyc2UocC5yZXN1bHQpIDogZmFsc2U7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgY2FsbGJhY2sgb24gdGhlIHBhcmVudFxuXHRcdFx0XHRwYXJlbnRbcC5jYWxsYmFja10ocmVzKTtcblx0XHRcdFx0Y2xvc2VXaW5kb3coKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBwYWdlIGlzIHN0aWxsIG9wZW5cblx0XHRcdGlmIChwLnBhZ2VfdXJpKSB7XG5cdFx0XHRcdGxvY2F0aW9uLmFzc2lnbihwLnBhZ2VfdXJpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPQXV0aCByZWRpcmVjdCwgZml4ZXMgVVJJIGZyYWdtZW50cyBmcm9tIGJlaW5nIGxvc3QgaW4gU2FmYXJpXG5cdFx0Ly8gKFVSSSBGcmFnbWVudHMgd2l0aGluIDMwMiBMb2NhdGlvbiBVUkkgYXJlIGxvc3Qgb3ZlciBIVFRQUylcblx0XHQvLyBMb2FkaW5nIHRoZSByZWRpcmVjdC5odG1sIGJlZm9yZSB0cmlnZ2VyaW5nIHRoZSBPQXV0aCBGbG93IHNlZW1zIHRvIGZpeCBpdC5cblx0XHRlbHNlIGlmICgnb2F1dGhfcmVkaXJlY3QnIGluIHApIHtcblxuXHRcdFx0bG9jYXRpb24uYXNzaWduKGRlY29kZVVSSUNvbXBvbmVudChwLm9hdXRoX3JlZGlyZWN0KSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gVHJpZ2dlciBhIGNhbGxiYWNrIHRvIGF1dGhlbnRpY2F0ZVxuXHRcdGZ1bmN0aW9uIGF1dGhDYWxsYmFjayhvYmosIHdpbmRvdywgcGFyZW50KSB7XG5cblx0XHRcdHZhciBjYiA9IG9iai5jYWxsYmFjaztcblx0XHRcdHZhciBuZXR3b3JrID0gb2JqLm5ldHdvcms7XG5cblx0XHRcdC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrIG9uIHRoZSBwYXJlbnRcblx0XHRcdF90aGlzLnN0b3JlKG5ldHdvcmssIG9iaik7XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwYWdlIHJlcXVlc3QgaXQgaGFzIG5vIHBhcmVudCBvciBvcGVuZXIgd2luZG93IHRvIGhhbmRsZSBjYWxsYmFja3Ncblx0XHRcdGlmICgoJ2Rpc3BsYXknIGluIG9iaikgJiYgb2JqLmRpc3BsYXkgPT09ICdwYWdlJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBmcm9tIHNlc3Npb24gb2JqZWN0XG5cdFx0XHRpZiAocGFyZW50ICYmIGNiICYmIGNiIGluIHBhcmVudCkge1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZGVsZXRlIG9iai5jYWxsYmFjaztcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge31cblxuXHRcdFx0XHQvLyBVcGRhdGUgc3RvcmVcblx0XHRcdFx0X3RoaXMuc3RvcmUobmV0d29yaywgb2JqKTtcblxuXHRcdFx0XHQvLyBDYWxsIHRoZSBnbG9iYWxFdmVudCBmdW5jdGlvbiBvbiB0aGUgcGFyZW50XG5cdFx0XHRcdC8vIEl0J3Mgc2FmZXIgdG8gcGFzcyBiYWNrIGEgc3RyaW5nIHRvIHRoZSBwYXJlbnQsXG5cdFx0XHRcdC8vIFJhdGhlciB0aGFuIGFuIG9iamVjdC9hcnJheSAoYmV0dGVyIGZvciBJRTgpXG5cdFx0XHRcdHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cGFyZW50W2NiXShzdHIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Ly8gRXJyb3IgdGhyb3duIHdoaWxzdCBleGVjdXRpbmcgcGFyZW50IGNhbGxiYWNrXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y2xvc2VXaW5kb3coKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjbG9zZVdpbmRvdygpIHtcblxuXHRcdFx0aWYgKHdpbmRvdy5mcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0Ly8gSW5zaWRlIGFuIGlmcmFtZSwgcmVtb3ZlIGZyb20gcGFyZW50XG5cdFx0XHRcdHBhcmVudC5kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHdpbmRvdy5mcmFtZUVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIENsb3NlIHRoaXMgY3VycmVudCB3aW5kb3dcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR3aW5kb3cuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge31cblxuXHRcdFx0XHQvLyBJT1MgYnVnIHdvbnQgbGV0IHVzIGNsb3NlIGEgcG9wdXAgaWYgc3RpbGwgbG9hZGluZ1xuXHRcdFx0XHRpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0d2luZG93LmNsb3NlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEV2ZW50c1xuLy8gRXh0ZW5kIHRoZSBoZWxsbyBvYmplY3Qgd2l0aCBpdHMgb3duIGV2ZW50IGluc3RhbmNlXG5oZWxsby51dGlscy5FdmVudC5jYWxsKGhlbGxvKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1vbml0b3Jpbmcgc2Vzc2lvbiBzdGF0ZVxuLy8gQ2hlY2sgZm9yIHNlc3Npb24gY2hhbmdlc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uKGhlbGxvKSB7XG5cblx0Ly8gTW9uaXRvciBmb3IgYSBjaGFuZ2UgaW4gc3RhdGUgYW5kIGZpcmVcblx0dmFyIG9sZFNlc3Npb25zID0ge307XG5cblx0Ly8gSGFzaCBvZiBleHBpcmVkIHRva2Vuc1xuXHR2YXIgZXhwaXJlZCA9IHt9O1xuXG5cdC8vIExpc3RlbiB0byBvdGhlciB0cmlnZ2VycyB0byBBdXRoIGV2ZW50cywgdXNlIHRoZXNlIHRvIHVwZGF0ZSB0aGlzXG5cdGhlbGxvLm9uKCdhdXRoLmxvZ2luLCBhdXRoLmxvZ291dCcsIGZ1bmN0aW9uKGF1dGgpIHtcblx0XHRpZiAoYXV0aCAmJiB0eXBlb2YgKGF1dGgpID09PSAnb2JqZWN0JyAmJiBhdXRoLm5ldHdvcmspIHtcblx0XHRcdG9sZFNlc3Npb25zW2F1dGgubmV0d29ya10gPSBoZWxsby51dGlscy5zdG9yZShhdXRoLm5ldHdvcmspIHx8IHt9O1xuXHRcdH1cblx0fSk7XG5cblx0KGZ1bmN0aW9uIHNlbGYoKSB7XG5cblx0XHR2YXIgQ1VSUkVOVF9USU1FID0gKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxZTMpO1xuXHRcdHZhciBlbWl0ID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG5cdFx0XHRoZWxsby5lbWl0KCdhdXRoLicgKyBldmVudE5hbWUsIHtcblx0XHRcdFx0bmV0d29yazogbmFtZSxcblx0XHRcdFx0YXV0aFJlc3BvbnNlOiBzZXNzaW9uXG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0Ly8gTG9vcCB0aHJvdWdoIHRoZSBzZXJ2aWNlc1xuXHRcdGZvciAodmFyIG5hbWUgaW4gaGVsbG8uc2VydmljZXMpIHtpZiAoaGVsbG8uc2VydmljZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblxuXHRcdFx0aWYgKCFoZWxsby5zZXJ2aWNlc1tuYW1lXS5pZCkge1xuXHRcdFx0XHQvLyBXZSBoYXZlbid0IGF0dGFjaGVkIGFuIElEIHNvIGRvbnQgbGlzdGVuLlxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IHNlc3Npb25cblx0XHRcdHZhciBzZXNzaW9uID0gaGVsbG8udXRpbHMuc3RvcmUobmFtZSkgfHwge307XG5cdFx0XHR2YXIgcHJvdmlkZXIgPSBoZWxsby5zZXJ2aWNlc1tuYW1lXTtcblx0XHRcdHZhciBvbGRTZXNzID0gb2xkU2Vzc2lvbnNbbmFtZV0gfHwge307XG5cblx0XHRcdC8vIExpc3RlbiBmb3IgZ2xvYmFsRXZlbnRzIHRoYXQgZGlkIG5vdCBnZXQgdHJpZ2dlcmVkIGZyb20gdGhlIGNoaWxkXG5cdFx0XHRpZiAoc2Vzc2lvbiAmJiAnY2FsbGJhY2snIGluIHNlc3Npb24pIHtcblxuXHRcdFx0XHQvLyBUbyBkbyByZW1vdmUgZnJvbSBzZXNzaW9uIG9iamVjdC4uLlxuXHRcdFx0XHR2YXIgY2IgPSBzZXNzaW9uLmNhbGxiYWNrO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGRlbGV0ZSBzZXNzaW9uLmNhbGxiYWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7fVxuXG5cdFx0XHRcdC8vIFVwZGF0ZSBzdG9yZVxuXHRcdFx0XHQvLyBSZW1vdmluZyB0aGUgY2FsbGJhY2tcblx0XHRcdFx0aGVsbG8udXRpbHMuc3RvcmUobmFtZSwgc2Vzc2lvbik7XG5cblx0XHRcdFx0Ly8gRW1pdCBnbG9iYWwgZXZlbnRzXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0d2luZG93W2NiXShzZXNzaW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge31cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVmcmVzaCB0b2tlblxuXHRcdFx0aWYgKHNlc3Npb24gJiYgKCdleHBpcmVzJyBpbiBzZXNzaW9uKSAmJiBzZXNzaW9uLmV4cGlyZXMgPCBDVVJSRU5UX1RJTUUpIHtcblxuXHRcdFx0XHQvLyBJZiBhdXRvIHJlZnJlc2ggaXMgcG9zc2libGVcblx0XHRcdFx0Ly8gRWl0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzXG5cdFx0XHRcdHZhciByZWZyZXNoID0gcHJvdmlkZXIucmVmcmVzaCB8fCBzZXNzaW9uLnJlZnJlc2hfdG9rZW47XG5cblx0XHRcdFx0Ly8gSGFzIHRoZSByZWZyZXNoIGJlZW4gcnVuIHJlY2VudGx5P1xuXHRcdFx0XHRpZiAocmVmcmVzaCAmJiAoIShuYW1lIGluIGV4cGlyZWQpIHx8IGV4cGlyZWRbbmFtZV0gPCBDVVJSRU5UX1RJTUUpKSB7XG5cdFx0XHRcdFx0Ly8gVHJ5IHRvIHJlc2lnbmluXG5cdFx0XHRcdFx0aGVsbG8uZW1pdCgnbm90aWNlJywgbmFtZSArICcgaGFzIGV4cGlyZWQgdHJ5aW5nIHRvIHJlc2lnbmluJyk7XG5cdFx0XHRcdFx0aGVsbG8ubG9naW4obmFtZSwge2Rpc3BsYXk6ICdub25lJywgZm9yY2U6IGZhbHNlfSk7XG5cblx0XHRcdFx0XHQvLyBVcGRhdGUgZXhwaXJlZCwgZXZlcnkgMTAgbWludXRlc1xuXHRcdFx0XHRcdGV4cGlyZWRbbmFtZV0gPSBDVVJSRU5UX1RJTUUgKyA2MDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEb2VzIHRoaXMgcHJvdmlkZXIgbm90IHN1cHBvcnQgcmVmcmVzaFxuXHRcdFx0XHRlbHNlIGlmICghcmVmcmVzaCAmJiAhKG5hbWUgaW4gZXhwaXJlZCkpIHtcblx0XHRcdFx0XHQvLyBMYWJlbCB0aGUgZXZlbnRcblx0XHRcdFx0XHRlbWl0KCdleHBpcmVkJyk7XG5cdFx0XHRcdFx0ZXhwaXJlZFtuYW1lXSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBzZXNzaW9uIGhhcyBleHBpcmVkIHRoZW4gd2UgZG9udCB3YW50IHRvIHN0b3JlIGl0cyB2YWx1ZSB1bnRpbCBpdCBjYW4gYmUgZXN0YWJsaXNoZWQgdGhhdCBpdHMgYmVlbiB1cGRhdGVkXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYXMgc2Vzc2lvbiBjaGFuZ2VkP1xuXHRcdFx0ZWxzZSBpZiAob2xkU2Vzcy5hY2Nlc3NfdG9rZW4gPT09IHNlc3Npb24uYWNjZXNzX3Rva2VuICYmXG5cdFx0XHRvbGRTZXNzLmV4cGlyZXMgPT09IHNlc3Npb24uZXhwaXJlcykge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXNzX3Rva2VuIGhhcyBiZWVuIHJlbW92ZWRcblx0XHRcdGVsc2UgaWYgKCFzZXNzaW9uLmFjY2Vzc190b2tlbiAmJiBvbGRTZXNzLmFjY2Vzc190b2tlbikge1xuXHRcdFx0XHRlbWl0KCdsb2dvdXQnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXNzX3Rva2VuIGhhcyBiZWVuIGNyZWF0ZWRcblx0XHRcdGVsc2UgaWYgKHNlc3Npb24uYWNjZXNzX3Rva2VuICYmICFvbGRTZXNzLmFjY2Vzc190b2tlbikge1xuXHRcdFx0XHRlbWl0KCdsb2dpbicpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2Nlc3NfdG9rZW4gaGFzIGJlZW4gdXBkYXRlZFxuXHRcdFx0ZWxzZSBpZiAoc2Vzc2lvbi5leHBpcmVzICE9PSBvbGRTZXNzLmV4cGlyZXMpIHtcblx0XHRcdFx0ZW1pdCgndXBkYXRlJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZWQgc3RvcmVkIHNlc3Npb25cblx0XHRcdG9sZFNlc3Npb25zW25hbWVdID0gc2Vzc2lvbjtcblxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBleHBpcmVkIGZsYWdzXG5cdFx0XHRpZiAobmFtZSBpbiBleHBpcmVkKSB7XG5cdFx0XHRcdGRlbGV0ZSBleHBpcmVkW25hbWVdO1xuXHRcdFx0fVxuXHRcdH19XG5cblx0XHQvLyBDaGVjayBlcnJvciBldmVudHNcblx0XHRzZXRUaW1lb3V0KHNlbGYsIDEwMDApO1xuXHR9KSgpO1xuXG59KShoZWxsbyk7XG5cbi8vIEVPRiBDT1JFIGxpYlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQVBJXG4vLyBAcGFyYW0gcGF0aCAgICBzdHJpbmdcbi8vIEBwYXJhbSBxdWVyeSAgIG9iamVjdCAob3B0aW9uYWwpXG4vLyBAcGFyYW0gbWV0aG9kICBzdHJpbmcgKG9wdGlvbmFsKVxuLy8gQHBhcmFtIGRhdGEgICAgb2JqZWN0IChvcHRpb25hbClcbi8vIEBwYXJhbSB0aW1lb3V0IGludGVnZXIgKG9wdGlvbmFsKVxuLy8gQHBhcmFtIGNhbGxiYWNrICBmdW5jdGlvbiAob3B0aW9uYWwpXG5cbmhlbGxvLmFwaSA9IGZ1bmN0aW9uKCkge1xuXG5cdC8vIFNob3J0aGFuZFxuXHR2YXIgX3RoaXMgPSB0aGlzO1xuXHR2YXIgdXRpbHMgPSBfdGhpcy51dGlscztcblx0dmFyIGVycm9yID0gdXRpbHMuZXJyb3I7XG5cblx0Ly8gQ29uc3RydWN0IGEgbmV3IFByb21pc2Ugb2JqZWN0XG5cdHZhciBwcm9taXNlID0gdXRpbHMuUHJvbWlzZSgpO1xuXG5cdC8vIEFyZ3VtZW50c1xuXHR2YXIgcCA9IHV0aWxzLmFyZ3Moe3BhdGg6ICdzIScsIHF1ZXJ5OiAnbycsIG1ldGhvZDogJ3MnLCBkYXRhOiAnbycsIHRpbWVvdXQ6ICdpJywgY2FsbGJhY2s6ICdmJ30sIGFyZ3VtZW50cyk7XG5cblx0Ly8gTWV0aG9kXG5cdHAubWV0aG9kID0gKHAubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEhlYWRlcnNcblx0cC5oZWFkZXJzID0gcC5oZWFkZXJzIHx8IHt9O1xuXG5cdC8vIFF1ZXJ5XG5cdHAucXVlcnkgPSBwLnF1ZXJ5IHx8IHt9O1xuXG5cdC8vIElmIGdldCwgcHV0IGFsbCBwYXJhbWV0ZXJzIGludG8gcXVlcnlcblx0aWYgKHAubWV0aG9kID09PSAnZ2V0JyB8fCBwLm1ldGhvZCA9PT0gJ2RlbGV0ZScpIHtcblx0XHR1dGlscy5leHRlbmQocC5xdWVyeSwgcC5kYXRhKTtcblx0XHRwLmRhdGEgPSB7fTtcblx0fVxuXG5cdHZhciBkYXRhID0gcC5kYXRhID0gcC5kYXRhIHx8IHt9O1xuXG5cdC8vIENvbXBsZXRlZCBldmVudCBjYWxsYmFja1xuXHRwcm9taXNlLnRoZW4ocC5jYWxsYmFjaywgcC5jYWxsYmFjayk7XG5cblx0Ly8gUmVtb3ZlIHRoZSBuZXR3b3JrIGZyb20gcGF0aCwgZS5nLiBmYWNlYm9vazovbWUvZnJpZW5kc1xuXHQvLyBSZXN1bHRzIGluIHsgbmV0d29yayA6IGZhY2Vib29rLCBwYXRoIDogbWUvZnJpZW5kcyB9XG5cdGlmICghcC5wYXRoKSB7XG5cdFx0cmV0dXJuIHByb21pc2UucmVqZWN0KGVycm9yKCdpbnZhbGlkX3BhdGgnLCAnTWlzc2luZyB0aGUgcGF0aCBwYXJhbWV0ZXIgZnJvbSB0aGUgcmVxdWVzdCcpKTtcblx0fVxuXG5cdHAucGF0aCA9IHAucGF0aC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcblx0dmFyIGEgPSAocC5wYXRoLnNwbGl0KC9bXFwvXFw6XS8sIDIpIHx8IFtdKVswXS50b0xvd2VyQ2FzZSgpO1xuXG5cdGlmIChhIGluIF90aGlzLnNlcnZpY2VzKSB7XG5cdFx0cC5uZXR3b3JrID0gYTtcblx0XHR2YXIgcmVnID0gbmV3IFJlZ0V4cCgnXicgKyBhICsgJzo/XFwvPycpO1xuXHRcdHAucGF0aCA9IHAucGF0aC5yZXBsYWNlKHJlZywgJycpO1xuXHR9XG5cblx0Ly8gTmV0d29yayAmIFByb3ZpZGVyXG5cdC8vIERlZmluZSB0aGUgbmV0d29yayB0aGF0IHRoaXMgcmVxdWVzdCBpcyBtYWRlIGZvclxuXHRwLm5ldHdvcmsgPSBfdGhpcy5zZXR0aW5ncy5kZWZhdWx0X3NlcnZpY2UgPSBwLm5ldHdvcmsgfHwgX3RoaXMuc2V0dGluZ3MuZGVmYXVsdF9zZXJ2aWNlO1xuXHR2YXIgbyA9IF90aGlzLnNlcnZpY2VzW3AubmV0d29ya107XG5cblx0Ly8gSU5WQUxJRFxuXHQvLyBJcyB0aGVyZSBubyBzZXJ2aWNlIGJ5IHRoZSBnaXZlbiBuZXR3b3JrIG5hbWU/XG5cdGlmICghbykge1xuXHRcdHJldHVybiBwcm9taXNlLnJlamVjdChlcnJvcignaW52YWxpZF9uZXR3b3JrJywgJ0NvdWxkIG5vdCBtYXRjaCB0aGUgc2VydmljZSByZXF1ZXN0ZWQ6ICcgKyBwLm5ldHdvcmspKTtcblx0fVxuXG5cdC8vIFBBVEhcblx0Ly8gQXMgbG9uZyBhcyB0aGUgcGF0aCBpc24ndCBmbGFnZ2VkIGFzIHVuYXZhaWFibGUsIGUuZy4gcGF0aCA9PSBmYWxzZVxuXG5cdGlmICghKCEocC5tZXRob2QgaW4gbykgfHwgIShwLnBhdGggaW4gb1twLm1ldGhvZF0pIHx8IG9bcC5tZXRob2RdW3AucGF0aF0gIT09IGZhbHNlKSkge1xuXHRcdHJldHVybiBwcm9taXNlLnJlamVjdChlcnJvcignaW52YWxpZF9wYXRoJywgJ1RoZSBwcm92aWRlZCBwYXRoIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHNlbGVjdGVkIG5ldHdvcmsnKSk7XG5cdH1cblxuXHQvLyBQUk9YWVxuXHQvLyBPQXV0aDEgY2FsbHMgYWx3YXlzIG5lZWQgYSBwcm94eVxuXG5cdGlmICghcC5vYXV0aF9wcm94eSkge1xuXHRcdHAub2F1dGhfcHJveHkgPSBfdGhpcy5zZXR0aW5ncy5vYXV0aF9wcm94eTtcblx0fVxuXG5cdGlmICghKCdwcm94eScgaW4gcCkpIHtcblx0XHRwLnByb3h5ID0gcC5vYXV0aF9wcm94eSAmJiBvLm9hdXRoICYmIHBhcnNlSW50KG8ub2F1dGgudmVyc2lvbiwgMTApID09PSAxO1xuXHR9XG5cblx0Ly8gVElNRU9VVFxuXHQvLyBBZG9wdCB0aW1lb3V0IGZyb20gZ2xvYmFsIHNldHRpbmdzIGJ5IGRlZmF1bHRcblxuXHRpZiAoISgndGltZW91dCcgaW4gcCkpIHtcblx0XHRwLnRpbWVvdXQgPSBfdGhpcy5zZXR0aW5ncy50aW1lb3V0O1xuXHR9XG5cblx0Ly8gRm9ybWF0IHJlc3BvbnNlXG5cdC8vIFdoZXRoZXIgdG8gcnVuIHRoZSByYXcgcmVzcG9uc2UgdGhyb3VnaCBwb3N0IHByb2Nlc3NpbmcuXG5cdGlmICghKCdmb3JtYXRSZXNwb25zZScgaW4gcCkpIHtcblx0XHRwLmZvcm1hdFJlc3BvbnNlID0gdHJ1ZTtcblx0fVxuXG5cdC8vIEdldCB0aGUgY3VycmVudCBzZXNzaW9uXG5cdC8vIEFwcGVuZCB0aGUgYWNjZXNzX3Rva2VuIHRvIHRoZSBxdWVyeVxuXHRwLmF1dGhSZXNwb25zZSA9IF90aGlzLmdldEF1dGhSZXNwb25zZShwLm5ldHdvcmspO1xuXHRpZiAocC5hdXRoUmVzcG9uc2UgJiYgcC5hdXRoUmVzcG9uc2UuYWNjZXNzX3Rva2VuKSB7XG5cdFx0cC5xdWVyeS5hY2Nlc3NfdG9rZW4gPSBwLmF1dGhSZXNwb25zZS5hY2Nlc3NfdG9rZW47XG5cdH1cblxuXHR2YXIgdXJsID0gcC5wYXRoO1xuXHR2YXIgbTtcblxuXHQvLyBTdG9yZSB0aGUgcXVlcnkgYXMgb3B0aW9uc1xuXHQvLyBUaGlzIGlzIHVzZWQgdG8gcG9wdWxhdGUgdGhlIHJlcXVlc3Qgb2JqZWN0IGJlZm9yZSB0aGUgZGF0YSBpcyBhdWdtZW50ZWQgYnkgdGhlIHByZXdyYXAgaGFuZGxlcnMuXG5cdHAub3B0aW9ucyA9IHV0aWxzLmNsb25lKHAucXVlcnkpO1xuXG5cdC8vIENsb25lIHRoZSBkYXRhIG9iamVjdFxuXHQvLyBQcmV2ZW50IHRoaXMgc2NyaXB0IG92ZXJ3cml0aW5nIHRoZSBkYXRhIG9mIHRoZSBpbmNvbWluZyBvYmplY3QuXG5cdC8vIEVuc3VyZSB0aGF0IGV2ZXJ5dGltZSB3ZSBydW4gYW4gaXRlcmF0aW9uIHRoZSBjYWxsYmFja3MgaGF2ZW4ndCByZW1vdmVkIHNvbWUgZGF0YVxuXHRwLmRhdGEgPSB1dGlscy5jbG9uZShkYXRhKTtcblxuXHQvLyBVUkwgTWFwcGluZ1xuXHQvLyBJcyB0aGVyZSBhIG1hcCBmb3IgdGhlIGdpdmVuIFVSTD9cblx0dmFyIGFjdGlvbnMgPSBvW3snZGVsZXRlJzogJ2RlbCd9W3AubWV0aG9kXSB8fCBwLm1ldGhvZF0gfHwge307XG5cblx0Ly8gRXh0cmFwb2xhdGUgdGhlIFF1ZXJ5U3RyaW5nXG5cdC8vIFByb3ZpZGUgYSBjbGVhbiBwYXRoXG5cdC8vIE1vdmUgdGhlIHF1ZXJ5c3RyaW5nIGludG8gdGhlIGRhdGFcblx0aWYgKHAubWV0aG9kID09PSAnZ2V0Jykge1xuXG5cdFx0dmFyIHF1ZXJ5ID0gdXJsLnNwbGl0KC9bXFw/I10vKVsxXTtcblx0XHRpZiAocXVlcnkpIHtcblx0XHRcdHV0aWxzLmV4dGVuZChwLnF1ZXJ5LCB1dGlscy5wYXJhbShxdWVyeSkpO1xuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIHF1ZXJ5IHBhcnQgZnJvbSB0aGUgVVJMXG5cdFx0XHR1cmwgPSB1cmwucmVwbGFjZSgvXFw/Lio/KCN8JCkvLCAnJDEnKTtcblx0XHR9XG5cdH1cblxuXHQvLyBJcyB0aGUgaGFzaCBmcmFnbWVudCBkZWZpbmVkXG5cdGlmICgobSA9IHVybC5tYXRjaCgvIyguKykvLCAnJykpKSB7XG5cdFx0dXJsID0gdXJsLnNwbGl0KCcjJylbMF07XG5cdFx0cC5wYXRoID0gbVsxXTtcblx0fVxuXHRlbHNlIGlmICh1cmwgaW4gYWN0aW9ucykge1xuXHRcdHAucGF0aCA9IHVybDtcblx0XHR1cmwgPSBhY3Rpb25zW3VybF07XG5cdH1cblx0ZWxzZSBpZiAoJ2RlZmF1bHQnIGluIGFjdGlvbnMpIHtcblx0XHR1cmwgPSBhY3Rpb25zWydkZWZhdWx0J107XG5cdH1cblxuXHQvLyBSZWRpcmVjdCBIYW5kbGVyXG5cdC8vIFRoaXMgZGVmaW5lcyBmb3IgdGhlIEZvcm0rSWZyYW1lK0hhc2ggaGFjayB3aGVyZSB0byByZXR1cm4gdGhlIHJlc3VsdHMgdG9vLlxuXHRwLnJlZGlyZWN0X3VyaSA9IF90aGlzLnNldHRpbmdzLnJlZGlyZWN0X3VyaTtcblxuXHQvLyBEZWZpbmUgRm9ybWF0SGFuZGxlclxuXHQvLyBUaGUgcmVxdWVzdCBjYW4gYmUgcHJvY2VzZWQgaW4gYSBtdWx0aXR1ZGUgb2Ygd2F5c1xuXHQvLyBIZXJlJ3MgdGhlIG9wdGlvbnMgLSBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIgYW5kIGVuZHBvaW50XG5cdHAueGhyID0gby54aHI7XG5cdHAuanNvbnAgPSBvLmpzb25wO1xuXHRwLmZvcm0gPSBvLmZvcm07XG5cblx0Ly8gTWFrZSByZXF1ZXN0XG5cdGlmICh0eXBlb2YgKHVybCkgPT09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBEb2VzIHNlbGYgaGF2ZSBpdHMgb3duIGNhbGxiYWNrP1xuXHRcdHVybChwLCBnZXRQYXRoKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBFbHNlIHRoZSBVUkwgaXMgYSBzdHJpbmdcblx0XHRnZXRQYXRoKHVybCk7XG5cdH1cblxuXHRyZXR1cm4gcHJvbWlzZS5wcm94eTtcblxuXHQvLyBJZiB1cmwgbmVlZHMgYSBiYXNlXG5cdC8vIFdyYXAgZXZlcnl0aGluZyBpblxuXHRmdW5jdGlvbiBnZXRQYXRoKHVybCkge1xuXG5cdFx0Ly8gRm9ybWF0IHRoZSBzdHJpbmcgaWYgaXQgbmVlZHMgaXRcblx0XHR1cmwgPSB1cmwucmVwbGFjZSgvXFxAXFx7KFthLXpcXF9cXC1dKykoXFx8Lio/KT9cXH0vZ2ksIGZ1bmN0aW9uKG0sIGtleSwgZGVmYXVsdHMpIHtcblx0XHRcdHZhciB2YWwgPSBkZWZhdWx0cyA/IGRlZmF1bHRzLnJlcGxhY2UoL15cXHwvLCAnJykgOiAnJztcblx0XHRcdGlmIChrZXkgaW4gcC5xdWVyeSkge1xuXHRcdFx0XHR2YWwgPSBwLnF1ZXJ5W2tleV07XG5cdFx0XHRcdGRlbGV0ZSBwLnF1ZXJ5W2tleV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChwLmRhdGEgJiYga2V5IGluIHAuZGF0YSkge1xuXHRcdFx0XHR2YWwgPSBwLmRhdGFba2V5XTtcblx0XHRcdFx0ZGVsZXRlIHAuZGF0YVtrZXldO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIWRlZmF1bHRzKSB7XG5cdFx0XHRcdHByb21pc2UucmVqZWN0KGVycm9yKCdtaXNzaW5nX2F0dHJpYnV0ZScsICdUaGUgYXR0cmlidXRlICcgKyBrZXkgKyAnIGlzIG1pc3NpbmcgZnJvbSB0aGUgcmVxdWVzdCcpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9KTtcblxuXHRcdC8vIEFkZCBiYXNlXG5cdFx0aWYgKCF1cmwubWF0Y2goL15odHRwcz86XFwvXFwvLykpIHtcblx0XHRcdHVybCA9IG8uYmFzZSArIHVybDtcblx0XHR9XG5cblx0XHQvLyBEZWZpbmUgdGhlIHJlcXVlc3QgVVJMXG5cdFx0cC51cmwgPSB1cmw7XG5cblx0XHQvLyBNYWtlIHRoZSBIVFRQIHJlcXVlc3Qgd2l0aCB0aGUgY3VyYXRlZCByZXF1ZXN0IG9iamVjdFxuXHRcdC8vIENBTExCQUNLIEhBTkRMRVJcblx0XHQvLyBAIHJlc3BvbnNlIG9iamVjdFxuXHRcdC8vIEAgc3RhdHVzQ29kZSBpbnRlZ2VyIGlmIGF2YWlsYWJsZVxuXHRcdHV0aWxzLnJlcXVlc3QocCwgZnVuY3Rpb24ociwgaGVhZGVycykge1xuXG5cdFx0XHQvLyBJcyB0aGlzIGEgcmF3IHJlc3BvbnNlP1xuXHRcdFx0aWYgKCFwLmZvcm1hdFJlc3BvbnNlKSB7XG5cdFx0XHRcdC8vIEJhZCByZXF1ZXN0PyBlcnJvciBzdGF0dXNDb2RlIG9yIG90aGVyd2lzZSBjb250YWlucyBhbiBlcnJvciByZXNwb25zZSB2aXMgSlNPTlA/XG5cdFx0XHRcdGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcgPyAoaGVhZGVycy5zdGF0dXNDb2RlID49IDQwMCkgOiAodHlwZW9mIHIgPT09ICdvYmplY3QnICYmICdlcnJvcicgaW4gcikpIHtcblx0XHRcdFx0XHRwcm9taXNlLnJlamVjdChyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRwcm9taXNlLmZ1bGZpbGwocik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3VsZCB0aGlzIGJlIGFuIG9iamVjdFxuXHRcdFx0aWYgKHIgPT09IHRydWUpIHtcblx0XHRcdFx0ciA9IHtzdWNjZXNzOnRydWV9O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIXIpIHtcblx0XHRcdFx0ciA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZGVsZXRlIGNhbGxiYWNrIG5lZWRzIGEgYmV0dGVyIHJlc3BvbnNlXG5cdFx0XHRpZiAocC5tZXRob2QgPT09ICdkZWxldGUnKSB7XG5cdFx0XHRcdHIgPSAoIXIgfHwgdXRpbHMuaXNFbXB0eShyKSkgPyB7c3VjY2Vzczp0cnVlfSA6IHI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZPUk1BVCBSRVNQT05TRT9cblx0XHRcdC8vIERvZXMgc2VsZiByZXF1ZXN0IGhhdmUgYSBjb3JyZXNwb25kaW5nIGZvcm1hdHRlclxuXHRcdFx0aWYgKG8ud3JhcCAmJiAoKHAucGF0aCBpbiBvLndyYXApIHx8ICgnZGVmYXVsdCcgaW4gby53cmFwKSkpIHtcblx0XHRcdFx0dmFyIHdyYXAgPSAocC5wYXRoIGluIG8ud3JhcCA/IHAucGF0aCA6ICdkZWZhdWx0Jyk7XG5cdFx0XHRcdHZhciB0aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHQvLyBGT1JNQVQgUkVTUE9OU0Vcblx0XHRcdFx0dmFyIGIgPSBvLndyYXBbd3JhcF0ociwgaGVhZGVycywgcCk7XG5cblx0XHRcdFx0Ly8gSGFzIHRoZSByZXNwb25zZSBiZWVuIHV0dGVybHkgb3ZlcndyaXR0ZW4/XG5cdFx0XHRcdC8vIFR5cGljYWxseSBzZWxmIGF1Z21lbnRzIHRoZSBleGlzdGluZyBvYmplY3QuLiBidXQgZm9yIHRob3NlIHJhcmUgb2NjYXNzaW9uc1xuXHRcdFx0XHRpZiAoYikge1xuXHRcdFx0XHRcdHIgPSBiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElzIHRoZXJlIGEgbmV4dF9wYWdlIGRlZmluZWQgaW4gdGhlIHJlc3BvbnNlP1xuXHRcdFx0aWYgKHIgJiYgJ3BhZ2luZycgaW4gciAmJiByLnBhZ2luZy5uZXh0KSB7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSByZWxhdGl2ZSBwYXRoIGlmIGl0IGlzIG1pc3NpbmcgZnJvbSB0aGUgcGFnaW5nL25leHQgcGF0aFxuXHRcdFx0XHRpZiAoci5wYWdpbmcubmV4dFswXSA9PT0gJz8nKSB7XG5cdFx0XHRcdFx0ci5wYWdpbmcubmV4dCA9IHAucGF0aCArIHIucGFnaW5nLm5leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgcmVsYXRpdmUgcGF0aCBoYXMgYmVlbiBkZWZpbmVkLCBsZXRzIG1hcmt1cCB0aGUgaGFuZGxlciBpbiB0aGUgSGFzaEZyYWdtZW50XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHIucGFnaW5nLm5leHQgKz0gJyMnICsgcC5wYXRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIERpc3BhdGNoIHRvIGxpc3RlbmVyc1xuXHRcdFx0Ly8gRW1pdCBldmVudHMgd2hpY2ggcGVydGFpbiB0byB0aGUgZm9ybWF0dGVkIHJlc3BvbnNlXG5cdFx0XHRpZiAoIXIgfHwgJ2Vycm9yJyBpbiByKSB7XG5cdFx0XHRcdHByb21pc2UucmVqZWN0KHIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHByb21pc2UuZnVsZmlsbChyKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufTtcblxuLy8gQVBJIHV0aWxpdGllc1xuaGVsbG8udXRpbHMuZXh0ZW5kKGhlbGxvLnV0aWxzLCB7XG5cblx0Ly8gTWFrZSBhbiBIVFRQIHJlcXVlc3Rcblx0cmVxdWVzdDogZnVuY3Rpb24ocCwgY2FsbGJhY2spIHtcblxuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIGVycm9yID0gX3RoaXMuZXJyb3I7XG5cblx0XHQvLyBUaGlzIGhhcyB0byBnbyB0aHJvdWdoIGEgUE9TVCByZXF1ZXN0XG5cdFx0aWYgKCFfdGhpcy5pc0VtcHR5KHAuZGF0YSkgJiYgISgnRmlsZUxpc3QnIGluIHdpbmRvdykgJiYgX3RoaXMuaGFzQmluYXJ5KHAuZGF0YSkpIHtcblxuXHRcdFx0Ly8gRGlzYWJsZSBYSFIgYW5kIEpTT05QXG5cdFx0XHRwLnhociA9IGZhbHNlO1xuXHRcdFx0cC5qc29ucCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoZSBicm93c2VyIGFuZCBzZXJ2aWNlIHN1cHBvcnQgQ09SU1xuXHRcdHZhciBjb3JzID0gdGhpcy5yZXF1ZXN0X2NvcnMoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBJZiBpdCBkb2VzIHRoZW4gcnVuIHRoaXMuLi5cblx0XHRcdHJldHVybiAoKHAueGhyID09PSB1bmRlZmluZWQpIHx8IChwLnhociAmJiAodHlwZW9mIChwLnhocikgIT09ICdmdW5jdGlvbicgfHwgcC54aHIocCwgcC5xdWVyeSkpKSk7XG5cdFx0fSk7XG5cblx0XHRpZiAoY29ycykge1xuXG5cdFx0XHRmb3JtYXRVcmwocCwgZnVuY3Rpb24odXJsKSB7XG5cblx0XHRcdFx0dmFyIHggPSBfdGhpcy54aHIocC5tZXRob2QsIHVybCwgcC5oZWFkZXJzLCBwLmRhdGEsIGNhbGxiYWNrKTtcblx0XHRcdFx0eC5vbnByb2dyZXNzID0gcC5vbnByb2dyZXNzIHx8IG51bGw7XG5cblx0XHRcdFx0Ly8gV2luZG93cyBQaG9uZSBkb2VzIG5vdCBzdXBwb3J0IHhoci51cGxvYWQsIHNlZSAjNzRcblx0XHRcdFx0Ly8gRmVhdHVyZSBkZXRlY3Rcblx0XHRcdFx0aWYgKHgudXBsb2FkICYmIHAub251cGxvYWRwcm9ncmVzcykge1xuXHRcdFx0XHRcdHgudXBsb2FkLm9ucHJvZ3Jlc3MgPSBwLm9udXBsb2FkcHJvZ3Jlc3M7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSB0aGUgcXVlcnkgb2JqZWN0XG5cdFx0Ly8gRWFjaCByZXF1ZXN0IG1vZGlmaWVzIHRoZSBxdWVyeSBvYmplY3QgYW5kIG5lZWRzIHRvIGJlIHRhcmVkIGFmdGVyIGVhY2ggb25lLlxuXHRcdHZhciBfcXVlcnkgPSBwLnF1ZXJ5O1xuXG5cdFx0cC5xdWVyeSA9IF90aGlzLmNsb25lKHAucXVlcnkpO1xuXG5cdFx0Ly8gQXNzaWduIGEgbmV3IGNhbGxiYWNrSURcblx0XHRwLmNhbGxiYWNrSUQgPSBfdGhpcy5nbG9iYWxFdmVudCgpO1xuXG5cdFx0Ly8gSlNPTlBcblx0XHRpZiAocC5qc29ucCAhPT0gZmFsc2UpIHtcblxuXHRcdFx0Ly8gQ2xvbmUgdGhlIHF1ZXJ5IG9iamVjdFxuXHRcdFx0cC5xdWVyeS5jYWxsYmFjayA9IHAuY2FsbGJhY2tJRDtcblxuXHRcdFx0Ly8gSWYgdGhlIEpTT05QIGlzIGEgZnVuY3Rpb24gdGhlbiBydW4gaXRcblx0XHRcdGlmICh0eXBlb2YgKHAuanNvbnApID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHAuanNvbnAocCwgcC5xdWVyeSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExldHMgdXNlIEpTT05QIGlmIHRoZSBtZXRob2QgaXMgJ2dldCdcblx0XHRcdGlmIChwLm1ldGhvZCA9PT0gJ2dldCcpIHtcblxuXHRcdFx0XHRmb3JtYXRVcmwocCwgZnVuY3Rpb24odXJsKSB7XG5cdFx0XHRcdFx0X3RoaXMuanNvbnAodXJsLCBjYWxsYmFjaywgcC5jYWxsYmFja0lELCBwLnRpbWVvdXQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBub3QgY29tcGF0aWJsZSByZXNldCBxdWVyeVxuXHRcdFx0XHRwLnF1ZXJ5ID0gX3F1ZXJ5O1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlJ3JlIG9uIHRvIHRoZSBvbGQgc2Nob29sLCBpZnJhbWUgaGFja3MgYW5kIEpTT05QXG5cdFx0aWYgKHAuZm9ybSAhPT0gZmFsc2UpIHtcblxuXHRcdFx0Ly8gQWRkIHNvbWUgYWRkaXRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzIHRvIHRoZSBVUkxcblx0XHRcdC8vIFdlJ3JlIHByZXR0eSBzdHVmZmVkIGlmIHRoZSBlbmRwb2ludCBkb2Vzbid0IGxpa2UgdGhlc2Vcblx0XHRcdHAucXVlcnkucmVkaXJlY3RfdXJpID0gcC5yZWRpcmVjdF91cmk7XG5cdFx0XHRwLnF1ZXJ5LnN0YXRlID0gSlNPTi5zdHJpbmdpZnkoe2NhbGxiYWNrOnAuY2FsbGJhY2tJRH0pO1xuXG5cdFx0XHR2YXIgb3B0cztcblxuXHRcdFx0aWYgKHR5cGVvZiAocC5mb3JtKSA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHRcdC8vIEZvcm1hdCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRvcHRzID0gcC5mb3JtKHAsIHAucXVlcnkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocC5tZXRob2QgPT09ICdwb3N0JyAmJiBvcHRzICE9PSBmYWxzZSkge1xuXG5cdFx0XHRcdGZvcm1hdFVybChwLCBmdW5jdGlvbih1cmwpIHtcblx0XHRcdFx0XHRfdGhpcy5wb3N0KHVybCwgcC5kYXRhLCBvcHRzLCBjYWxsYmFjaywgcC5jYWxsYmFja0lELCBwLnRpbWVvdXQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTm9uZSBvZiB0aGUgbWV0aG9kcyB3ZXJlIHN1Y2Nlc3NmdWwgdGhyb3cgYW4gZXJyb3Jcblx0XHRjYWxsYmFjayhlcnJvcignaW52YWxpZF9yZXF1ZXN0JywgJ1RoZXJlIHdhcyBubyBtZWNoYW5pc20gZm9yIGhhbmRsaW5nIHRoaXMgcmVxdWVzdCcpKTtcblxuXHRcdHJldHVybjtcblxuXHRcdC8vIEZvcm1hdCBVUkxcblx0XHQvLyBDb25zdHJ1Y3RzIHRoZSByZXF1ZXN0IFVSTCwgb3B0aW9uYWxseSB3cmFwcyB0aGUgVVJMIHRocm91Z2ggYSBjYWxsIHRvIGEgcHJveHkgc2VydmVyXG5cdFx0Ly8gUmV0dXJucyB0aGUgZm9ybWF0dGVkIFVSTFxuXHRcdGZ1bmN0aW9uIGZvcm1hdFVybChwLCBjYWxsYmFjaykge1xuXG5cdFx0XHQvLyBBcmUgd2Ugc2lnbmluZyB0aGUgcmVxdWVzdD9cblx0XHRcdHZhciBzaWduO1xuXG5cdFx0XHQvLyBPQXV0aDFcblx0XHRcdC8vIFJlbW92ZSB0aGUgdG9rZW4gZnJvbSB0aGUgcXVlcnkgYmVmb3JlIHNpZ25pbmdcblx0XHRcdGlmIChwLmF1dGhSZXNwb25zZSAmJiBwLmF1dGhSZXNwb25zZS5vYXV0aCAmJiBwYXJzZUludChwLmF1dGhSZXNwb25zZS5vYXV0aC52ZXJzaW9uLCAxMCkgPT09IDEpIHtcblxuXHRcdFx0XHQvLyBPQVVUSCBTSUdOSU5HIFBST1hZXG5cdFx0XHRcdHNpZ24gPSBwLnF1ZXJ5LmFjY2Vzc190b2tlbjtcblxuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIGFjY2Vzc190b2tlblxuXHRcdFx0XHRkZWxldGUgcC5xdWVyeS5hY2Nlc3NfdG9rZW47XG5cblx0XHRcdFx0Ly8gRW5mb3JlIHVzZSBvZiBQcm94eVxuXHRcdFx0XHRwLnByb3h5ID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUE9TVCBib2R5IHRvIHF1ZXJ5c3RyaW5nXG5cdFx0XHRpZiAocC5kYXRhICYmIChwLm1ldGhvZCA9PT0gJ2dldCcgfHwgcC5tZXRob2QgPT09ICdkZWxldGUnKSkge1xuXHRcdFx0XHQvLyBBdHRhY2ggdGhlIHAuZGF0YSB0byB0aGUgcXVlcnlzdHJpbmcuXG5cdFx0XHRcdF90aGlzLmV4dGVuZChwLnF1ZXJ5LCBwLmRhdGEpO1xuXHRcdFx0XHRwLmRhdGEgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb25zdHJ1Y3QgdGhlIHBhdGhcblx0XHRcdHZhciBwYXRoID0gX3RoaXMucXMocC51cmwsIHAucXVlcnkpO1xuXG5cdFx0XHQvLyBQcm94eSB0aGUgcmVxdWVzdCB0aHJvdWdoIGEgc2VydmVyXG5cdFx0XHQvLyBVc2VkIGZvciBzaWduaW5nIE9BdXRoMVxuXHRcdFx0Ly8gQW5kIGNpcmN1bXZlbnRpbmcgc2VydmljZXMgd2l0aG91dCBBY2Nlc3MtQ29udHJvbCBIZWFkZXJzXG5cdFx0XHRpZiAocC5wcm94eSkge1xuXHRcdFx0XHQvLyBVc2UgdGhlIHByb3h5IGFzIGEgcGF0aFxuXHRcdFx0XHRwYXRoID0gX3RoaXMucXMocC5vYXV0aF9wcm94eSwge1xuXHRcdFx0XHRcdHBhdGg6IHBhdGgsXG5cdFx0XHRcdFx0YWNjZXNzX3Rva2VuOiBzaWduIHx8ICcnLFxuXG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHByb21wdCB0aGUgcmVxdWVzdCB0byBiZSBzaWduZWQgYXMgdGhvdWdoIGl0IGlzIE9BdXRoMVxuXHRcdFx0XHRcdHRoZW46IHAucHJveHlfcmVzcG9uc2VfdHlwZSB8fCAocC5tZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gJ2dldCcgPyAncmVkaXJlY3QnIDogJ3Byb3h5JyksXG5cdFx0XHRcdFx0bWV0aG9kOiBwLm1ldGhvZC50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdHN1cHByZXNzX3Jlc3BvbnNlX2NvZGVzOiB0cnVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjYWxsYmFjayhwYXRoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gVGVzdCB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBDT1JTIHJlc3BvbnNlXG5cdHJlcXVlc3RfY29yczogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgJiYgY2FsbGJhY2soKTtcblx0fSxcblxuXHQvLyBSZXR1cm4gdGhlIHR5cGUgb2YgRE9NIG9iamVjdFxuXHRkb21JbnN0YW5jZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuXHRcdHZhciB0ZXN0ID0gJ0hUTUwnICsgKHR5cGUgfHwgJycpLnJlcGxhY2UoXG5cdFx0XHQvXlthLXpdLyxcblx0XHRcdGZ1bmN0aW9uKG0pIHtcblx0XHRcdFx0cmV0dXJuIG0udG9VcHBlckNhc2UoKTtcblx0XHRcdH1cblxuXHRcdCkgKyAnRWxlbWVudCc7XG5cblx0XHRpZiAoIWRhdGEpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAod2luZG93W3Rlc3RdKSB7XG5cdFx0XHRyZXR1cm4gZGF0YSBpbnN0YW5jZW9mIHdpbmRvd1t0ZXN0XTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAod2luZG93LkVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBkYXRhIGluc3RhbmNlb2Ygd2luZG93LkVsZW1lbnQgJiYgKCF0eXBlIHx8IChkYXRhLnRhZ05hbWUgJiYgZGF0YS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUpKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gKCEoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCB8fCBkYXRhIGluc3RhbmNlb2YgQXJyYXkgfHwgZGF0YSBpbnN0YW5jZW9mIFN0cmluZyB8fCBkYXRhIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBkYXRhLnRhZ05hbWUgJiYgZGF0YS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGUgYSBjbG9uZSBvZiBhbiBvYmplY3Rcblx0Y2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuXHRcdC8vIERvZXMgbm90IGNsb25lIERPTSBlbGVtZW50cywgbm9yIEJpbmFyeSBkYXRhLCBlLmcuIEJsb2JzLCBGaWxlbGlzdHNcblx0XHRpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiAob2JqKSAhPT0gJ29iamVjdCcgfHwgb2JqIGluc3RhbmNlb2YgRGF0ZSB8fCAnbm9kZU5hbWUnIGluIG9iaiB8fCB0aGlzLmlzQmluYXJ5KG9iaikgfHwgKHR5cGVvZiBGb3JtRGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmogaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuXHRcdFx0Ly8gQ2xvbmUgZWFjaCBpdGVtIGluIHRoZSBhcnJheVxuXHRcdFx0cmV0dXJuIG9iai5tYXAodGhpcy5jbG9uZS5iaW5kKHRoaXMpKTtcblx0XHR9XG5cblx0XHQvLyBCdXQgZG9lcyBjbG9uZSBldmVyeXRoaW5nIGVsc2UuXG5cdFx0dmFyIGNsb25lID0ge307XG5cdFx0Zm9yICh2YXIgeCBpbiBvYmopIHtcblx0XHRcdGNsb25lW3hdID0gdGhpcy5jbG9uZShvYmpbeF0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHQvLyBYSFI6IHVzZXMgQ09SUyB0byBtYWtlIHJlcXVlc3RzXG5cdHhocjogZnVuY3Rpb24obWV0aG9kLCB1cmwsIGhlYWRlcnMsIGRhdGEsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgciA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdHZhciBlcnJvciA9IHRoaXMuZXJyb3I7XG5cblx0XHQvLyBCaW5hcnk/XG5cdFx0dmFyIGJpbmFyeSA9IGZhbHNlO1xuXHRcdGlmIChtZXRob2QgPT09ICdibG9iJykge1xuXHRcdFx0YmluYXJ5ID0gbWV0aG9kO1xuXHRcdFx0bWV0aG9kID0gJ0dFVCc7XG5cdFx0fVxuXG5cdFx0bWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBYaHIucmVzcG9uc2VUeXBlICdqc29uJyBpcyBub3Qgc3VwcG9ydGVkIGluIGFueSBvZiB0aGUgdmVuZG9ycyB5ZXQuXG5cdFx0ci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIganNvbiA9IHIucmVzcG9uc2U7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZShyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoX2UpIHtcblx0XHRcdFx0aWYgKHIuc3RhdHVzID09PSA0MDEpIHtcblx0XHRcdFx0XHRqc29uID0gZXJyb3IoJ2FjY2Vzc19kZW5pZWQnLCByLnN0YXR1c1RleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBoZWFkZXJzID0gaGVhZGVyc1RvSlNPTihyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcblx0XHRcdGhlYWRlcnMuc3RhdHVzQ29kZSA9IHIuc3RhdHVzO1xuXG5cdFx0XHRjYWxsYmFjayhqc29uIHx8IChtZXRob2QgPT09ICdHRVQnID8gZXJyb3IoJ2VtcHR5X3Jlc3BvbnNlJywgJ0NvdWxkIG5vdCBnZXQgcmVzb3VyY2UnKSA6IHt9KSwgaGVhZGVycyk7XG5cdFx0fTtcblxuXHRcdHIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBqc29uID0gci5yZXNwb25zZVRleHQ7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZShyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoX2UpIHt9XG5cblx0XHRcdGNhbGxiYWNrKGpzb24gfHwgZXJyb3IoJ2FjY2Vzc19kZW5pZWQnLCAnQ291bGQgbm90IGdldCByZXNvdXJjZScpKTtcblx0XHR9O1xuXG5cdFx0dmFyIHg7XG5cblx0XHQvLyBTaG91bGQgd2UgYWRkIHRoZSBxdWVyeSB0byB0aGUgVVJMP1xuXHRcdGlmIChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0RFTEVURScpIHtcblx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdH1cblx0XHRlbHNlIGlmIChkYXRhICYmIHR5cGVvZiAoZGF0YSkgIT09ICdzdHJpbmcnICYmICEoZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBGaWxlKSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSkge1xuXHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFuZCBhZGQgZm9ybURhdGFcblx0XHRcdHZhciBmID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRmb3IgKHggaW4gZGF0YSkgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoeCkpIHtcblx0XHRcdFx0aWYgKGRhdGFbeF0gaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG5cdFx0XHRcdFx0aWYgKCdmaWxlcycgaW4gZGF0YVt4XSAmJiBkYXRhW3hdLmZpbGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdGYuYXBwZW5kKHgsIGRhdGFbeF0uZmlsZXNbMF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChkYXRhW3hdIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdGYuYXBwZW5kKHgsIGRhdGFbeF0sIGRhdGEubmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Zi5hcHBlbmQoeCwgZGF0YVt4XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZGF0YSA9IGY7XG5cdFx0fVxuXG5cdFx0Ly8gT3BlbiB0aGUgcGF0aCwgYXN5bmNcblx0XHRyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuXG5cdFx0aWYgKGJpbmFyeSkge1xuXHRcdFx0aWYgKCdyZXNwb25zZVR5cGUnIGluIHIpIHtcblx0XHRcdFx0ci5yZXNwb25zZVR5cGUgPSBiaW5hcnk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGFueSBiZXNwb2tlIGhlYWRlcnNcblx0XHRpZiAoaGVhZGVycykge1xuXHRcdFx0Zm9yICh4IGluIGhlYWRlcnMpIHtcblx0XHRcdFx0ci5zZXRSZXF1ZXN0SGVhZGVyKHgsIGhlYWRlcnNbeF0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHIuc2VuZChkYXRhKTtcblxuXHRcdHJldHVybiByO1xuXG5cdFx0Ly8gSGVhZGVycyBhcmUgcmV0dXJuZWQgYXMgYSBzdHJpbmdcblx0XHRmdW5jdGlvbiBoZWFkZXJzVG9KU09OKHMpIHtcblx0XHRcdHZhciByID0ge307XG5cdFx0XHR2YXIgcmVnID0gLyhbYS16XFwtXSspOlxccz8oLiopOz8vZ2k7XG5cdFx0XHR2YXIgbTtcblx0XHRcdHdoaWxlICgobSA9IHJlZy5leGVjKHMpKSkge1xuXHRcdFx0XHRyW21bMV1dID0gbVsyXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHI7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEpTT05QXG5cdC8vIEluamVjdHMgYSBzY3JpcHQgdGFnIGludG8gdGhlIERPTSB0byBiZSBleGVjdXRlZCBhbmQgYXBwZW5kcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHRoZSB3aW5kb3cgb2JqZWN0XG5cdC8vIEBwYXJhbSBzdHJpbmcvZnVuY3Rpb24gcGF0aEZ1bmMgZWl0aGVyIGEgc3RyaW5nIG9mIHRoZSBVUkwgb3IgYSBjYWxsYmFjayBmdW5jdGlvbiBwYXRoRnVuYyhxdWVyeXN0cmluZ2hhc2gsIGNvbnRpbnVlRnVuYyk7XG5cdC8vIEBwYXJhbSBmdW5jdGlvbiBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gY29tcGxldGlvbjtcblx0anNvbnA6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGNhbGxiYWNrSUQsIHRpbWVvdXQpIHtcblxuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIGVycm9yID0gX3RoaXMuZXJyb3I7XG5cblx0XHQvLyBDaGFuZ2UgdGhlIG5hbWUgb2YgdGhlIGNhbGxiYWNrXG5cdFx0dmFyIGJvb2wgPSAwO1xuXHRcdHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0XHR2YXIgb3BlcmFGaXg7XG5cdFx0dmFyIHJlc3VsdCA9IGVycm9yKCdzZXJ2ZXJfZXJyb3InLCAnc2VydmVyX2Vycm9yJyk7XG5cdFx0dmFyIGNiID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIShib29sKyspKSB7XG5cdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKHJlc3VsdCk7XG5cdFx0XHRcdFx0aGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdFx0XHR9LCAwKTtcblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHQvLyBBZGQgY2FsbGJhY2sgdG8gdGhlIHdpbmRvdyBvYmplY3Rcblx0XHRjYWxsYmFja0lEID0gX3RoaXMuZ2xvYmFsRXZlbnQoZnVuY3Rpb24oanNvbikge1xuXHRcdFx0cmVzdWx0ID0ganNvbjtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBNYXJrIGNhbGxiYWNrIGFzIGRvbmVcblx0XHR9LCBjYWxsYmFja0lEKTtcblxuXHRcdC8vIFRoZSBVUkwgaXMgYSBmdW5jdGlvbiBmb3Igc29tZSBjYXNlcyBhbmQgYXMgc3VjaFxuXHRcdC8vIERldGVybWluZSBpdHMgdmFsdWUgd2l0aCBhIGNhbGxiYWNrIGNvbnRhaW5pbmcgdGhlIG5ldyBwYXJhbWV0ZXJzIG9mIHRoaXMgZnVuY3Rpb24uXG5cdFx0dXJsID0gdXJsLnJlcGxhY2UobmV3IFJlZ0V4cCgnPVxcXFw/KCZ8JCknKSwgJz0nICsgY2FsbGJhY2tJRCArICckMScpO1xuXG5cdFx0Ly8gQnVpbGQgc2NyaXB0IHRhZ1xuXHRcdHZhciBzY3JpcHQgPSBfdGhpcy5hcHBlbmQoJ3NjcmlwdCcsIHtcblx0XHRcdGlkOiBjYWxsYmFja0lELFxuXHRcdFx0bmFtZTogY2FsbGJhY2tJRCxcblx0XHRcdHNyYzogdXJsLFxuXHRcdFx0YXN5bmM6IHRydWUsXG5cdFx0XHRvbmxvYWQ6IGNiLFxuXHRcdFx0b25lcnJvcjogY2IsXG5cdFx0XHRvbnJlYWR5c3RhdGVjaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoL2xvYWRlZHxjb21wbGV0ZS9pLnRlc3QodGhpcy5yZWFkeVN0YXRlKSkge1xuXHRcdFx0XHRcdGNiKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIE9wZXJhIGZpeCBlcnJvclxuXHRcdC8vIFByb2JsZW06IElmIGFuIGVycm9yIG9jY3VycyB3aXRoIHNjcmlwdCBsb2FkaW5nIE9wZXJhIGZhaWxzIHRvIHRyaWdnZXIgdGhlIHNjcmlwdC5vbmVycm9yIGhhbmRsZXIgd2Ugc3BlY2lmaWVkXG5cdFx0Ly9cblx0XHQvLyBGaXg6XG5cdFx0Ly8gQnkgc2V0dGluZyB0aGUgcmVxdWVzdCB0byBzeW5jaHJvbm91cyB3ZSBjYW4gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciB3aGVuIGFsbCBlbHNlIGZhaWxzLlxuXHRcdC8vIFRoaXMgYWN0aW9uIHdpbGwgYmUgaWdub3JlZCBpZiB3ZSd2ZSBhbHJlYWR5IGNhbGxlZCB0aGUgY2FsbGJhY2sgaGFuZGxlciBcImNiXCIgd2l0aCBhIHN1Y2Nlc3NmdWwgb25sb2FkIGV2ZW50XG5cdFx0aWYgKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignb3BlcmEnKSA+IC0xKSB7XG5cdFx0XHRvcGVyYUZpeCA9IF90aGlzLmFwcGVuZCgnc2NyaXB0Jywge1xuXHRcdFx0XHR0ZXh0OiAnZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFwnJyArIGNhbGxiYWNrSUQgKyAnXFwnKS5vbmVycm9yKCk7J1xuXHRcdFx0fSk7XG5cdFx0XHRzY3JpcHQuYXN5bmMgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgdGltZW91dFxuXHRcdGlmICh0aW1lb3V0KSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVzdWx0ID0gZXJyb3IoJ3RpbWVvdXQnLCAndGltZW91dCcpO1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0fSwgdGltZW91dCk7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogYWRkIGZpeCBmb3IgSUUsXG5cdFx0Ly8gSG93ZXZlcjogdW5hYmxlIHJlY3JlYXRlIHRoZSBidWcgb2YgZmlyaW5nIG9mZiB0aGUgb25yZWFkeXN0YXRlY2hhbmdlIGJlZm9yZSB0aGUgc2NyaXB0IGNvbnRlbnQgaGFzIGJlZW4gZXhlY3V0ZWQgYW5kIHRoZSB2YWx1ZSBvZiBcInJlc3VsdFwiIGhhcyBiZWVuIGRlZmluZWQuXG5cdFx0Ly8gSW5qZWN0IHNjcmlwdCB0YWcgaW50byB0aGUgaGVhZCBlbGVtZW50XG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG5cdFx0Ly8gQXBwZW5kIE9wZXJhIEZpeCB0byBydW4gYWZ0ZXIgb3VyIHNjcmlwdFxuXHRcdGlmIChvcGVyYUZpeCkge1xuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChvcGVyYUZpeCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFBvc3Rcblx0Ly8gU2VuZCBpbmZvcm1hdGlvbiB0byBhIHJlbW90ZSBsb2NhdGlvbiB1c2luZyB0aGUgcG9zdCBtZWNoYW5pc21cblx0Ly8gQHBhcmFtIHN0cmluZyB1cmkgcGF0aFxuXHQvLyBAcGFyYW0gb2JqZWN0IGRhdGEsIGtleSB2YWx1ZSBkYXRhIHRvIHNlbmRcblx0Ly8gQHBhcmFtIGZ1bmN0aW9uIGNhbGxiYWNrLCBmdW5jdGlvbiB0byBleGVjdXRlIGluIHJlc3BvbnNlXG5cdHBvc3Q6IGZ1bmN0aW9uKHVybCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2ssIGNhbGxiYWNrSUQsIHRpbWVvdXQpIHtcblxuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIGVycm9yID0gX3RoaXMuZXJyb3I7XG5cdFx0dmFyIGRvYyA9IGRvY3VtZW50O1xuXG5cdFx0Ly8gVGhpcyBoYWNrIG5lZWRzIGEgZm9ybVxuXHRcdHZhciBmb3JtID0gbnVsbDtcblx0XHR2YXIgcmVlbmFibGVBZnRlclN1Ym1pdCA9IFtdO1xuXHRcdHZhciBuZXdmb3JtO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgeCA9IG51bGw7XG5cdFx0dmFyIGJvb2wgPSAwO1xuXHRcdHZhciBjYiA9IGZ1bmN0aW9uKHIpIHtcblx0XHRcdGlmICghKGJvb2wrKykpIHtcblx0XHRcdFx0Y2FsbGJhY2socik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFdoYXQgaXMgdGhlIG5hbWUgb2YgdGhlIGNhbGxiYWNrIHRvIGNvbnRhaW5cblx0XHQvLyBXZSdsbCBhbHNvIHVzZSB0aGlzIHRvIG5hbWUgdGhlIGlmcmFtZVxuXHRcdF90aGlzLmdsb2JhbEV2ZW50KGNiLCBjYWxsYmFja0lEKTtcblxuXHRcdC8vIEJ1aWxkIHRoZSBpZnJhbWUgd2luZG93XG5cdFx0dmFyIHdpbjtcblx0XHR0cnkge1xuXHRcdFx0Ly8gSUU3IGhhY2ssIG9ubHkgbGV0cyB1cyBkZWZpbmUgdGhlIG5hbWUgaGVyZSwgbm90IGxhdGVyLlxuXHRcdFx0d2luID0gZG9jLmNyZWF0ZUVsZW1lbnQoJzxpZnJhbWUgbmFtZT1cIicgKyBjYWxsYmFja0lEICsgJ1wiPicpO1xuXHRcdH1cblx0XHRjYXRjaCAoZSkge1xuXHRcdFx0d2luID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdH1cblxuXHRcdHdpbi5uYW1lID0gY2FsbGJhY2tJRDtcblx0XHR3aW4uaWQgPSBjYWxsYmFja0lEO1xuXHRcdHdpbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG5cdFx0Ly8gT3ZlcnJpZGUgY2FsbGJhY2sgbWVjaGFuaXNtLiBUcmlnZ2dlciBhIHJlc3BvbnNlIG9ubG9hZC9vbmVycm9yXG5cdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYWxsYmFja29ubG9hZCkge1xuXHRcdFx0Ly8gT25sb2FkIGlzIGJlaW5nIGZpcmVkIHR3aWNlXG5cdFx0XHR3aW4ub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNiKHtcblx0XHRcdFx0XHRyZXNwb25zZTogJ3Bvc3RlZCcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ0NvbnRlbnQgd2FzIHBvc3RlZCdcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmICh0aW1lb3V0KSB7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYihlcnJvcigndGltZW91dCcsICdUaGUgcG9zdCBvcGVyYXRpb24gdGltZWQgb3V0JykpO1xuXHRcdFx0fSwgdGltZW91dCk7XG5cdFx0fVxuXG5cdFx0ZG9jLmJvZHkuYXBwZW5kQ2hpbGQod2luKTtcblxuXHRcdC8vIElmIHdlIGFyZSBqdXN0IHBvc3RpbmcgYSBzaW5nbGUgaXRlbVxuXHRcdGlmIChfdGhpcy5kb21JbnN0YW5jZSgnZm9ybScsIGRhdGEpKSB7XG5cdFx0XHQvLyBHZXQgdGhlIHBhcmVudCBmb3JtXG5cdFx0XHRmb3JtID0gZGF0YS5mb3JtO1xuXG5cdFx0XHQvLyBMb29wIHRocm91Z2ggYW5kIGRpc2FibGUgYWxsIG9mIGl0cyBzaWJsaW5nc1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGZvcm0uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGZvcm0uZWxlbWVudHNbaV0gIT09IGRhdGEpIHtcblx0XHRcdFx0XHRmb3JtLmVsZW1lbnRzW2ldLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBNb3ZlIHRoZSBmb2N1cyB0byB0aGUgZm9ybVxuXHRcdFx0ZGF0YSA9IGZvcm07XG5cdFx0fVxuXG5cdFx0Ly8gUG9zdGluZyBhIGZvcm1cblx0XHRpZiAoX3RoaXMuZG9tSW5zdGFuY2UoJ2Zvcm0nLCBkYXRhKSkge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIGZvcm0gZWxlbWVudFxuXHRcdFx0Zm9ybSA9IGRhdGE7XG5cblx0XHRcdC8vIERvZXMgdGhpcyBmb3JtIG5lZWQgdG8gYmUgYSBtdWx0aXBhcnQgZm9ybT9cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICghZm9ybS5lbGVtZW50c1tpXS5kaXNhYmxlZCAmJiBmb3JtLmVsZW1lbnRzW2ldLnR5cGUgPT09ICdmaWxlJykge1xuXHRcdFx0XHRcdGZvcm0uZW5jb2RpbmcgPSBmb3JtLmVuY3R5cGUgPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc7XG5cdFx0XHRcdFx0Zm9ybS5lbGVtZW50c1tpXS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCAnZmlsZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gSXRzIG5vdCBhIGZvcm0gZWxlbWVudCxcblx0XHRcdC8vIFRoZXJlZm9yZSBpdCBtdXN0IGJlIGEgSlNPTiBvYmplY3Qgb2YgS2V5PT5WYWx1ZSBvciBLZXk9PkVsZW1lbnRcblx0XHRcdC8vIElmIGFueW9uZSBvZiB0aG9zZSB2YWx1ZXMgYXJlIGEgaW5wdXQgdHlwZT1maWxlIHdlIHNoYWxsIHNoYWxsIGluc2VydCBpdHMgc2libGluZ3MgaW50byB0aGUgZm9ybSBmb3Igd2hpY2ggaXQgYmVsb25ncy5cblx0XHRcdGZvciAoeCBpbiBkYXRhKSBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSh4KSkge1xuXHRcdFx0XHQvLyBJcyB0aGlzIGFuIGlucHV0IEVsZW1lbnQ/XG5cdFx0XHRcdGlmIChfdGhpcy5kb21JbnN0YW5jZSgnaW5wdXQnLCBkYXRhW3hdKSAmJiBkYXRhW3hdLnR5cGUgPT09ICdmaWxlJykge1xuXHRcdFx0XHRcdGZvcm0gPSBkYXRhW3hdLmZvcm07XG5cdFx0XHRcdFx0Zm9ybS5lbmNvZGluZyA9IGZvcm0uZW5jdHlwZSA9ICdtdWx0aXBhcnQvZm9ybS1kYXRhJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBEbyBJZiB0aGVyZSBpcyBubyBkZWZpbmVkIGZvcm0gZWxlbWVudCwgbGV0cyBjcmVhdGUgb25lLlxuXHRcdFx0aWYgKCFmb3JtKSB7XG5cdFx0XHRcdC8vIEJ1aWxkIGZvcm1cblx0XHRcdFx0Zm9ybSA9IGRvYy5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG5cdFx0XHRcdGRvYy5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXHRcdFx0XHRuZXdmb3JtID0gZm9ybTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGlucHV0O1xuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgdG8gdGhlIGZvcm0gaWYgdGhleSBkb250IGV4aXN0XG5cdFx0XHRmb3IgKHggaW4gZGF0YSkgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoeCkpIHtcblxuXHRcdFx0XHQvLyBJcyB0aGlzIGFuIGVsZW1lbnQ/XG5cdFx0XHRcdHZhciBlbCA9IChfdGhpcy5kb21JbnN0YW5jZSgnaW5wdXQnLCBkYXRhW3hdKSB8fCBfdGhpcy5kb21JbnN0YW5jZSgndGV4dEFyZWEnLCBkYXRhW3hdKSB8fCBfdGhpcy5kb21JbnN0YW5jZSgnc2VsZWN0JywgZGF0YVt4XSkpO1xuXG5cdFx0XHRcdC8vIElzIHRoaXMgbm90IGFuIGlucHV0IGVsZW1lbnQsIG9yIG9uZSB0aGF0IGV4aXN0cyBvdXRzaWRlIHRoZSBmb3JtLlxuXHRcdFx0XHRpZiAoIWVsIHx8IGRhdGFbeF0uZm9ybSAhPT0gZm9ybSkge1xuXG5cdFx0XHRcdFx0Ly8gRG9lcyBhbiBlbGVtZW50IGhhdmUgdGhlIHNhbWUgbmFtZT9cblx0XHRcdFx0XHR2YXIgaW5wdXRzID0gZm9ybS5lbGVtZW50c1t4XTtcblx0XHRcdFx0XHRpZiAoaW5wdXQpIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBpdC5cblx0XHRcdFx0XHRcdGlmICghKGlucHV0cyBpbnN0YW5jZW9mIE5vZGVMaXN0KSkge1xuXHRcdFx0XHRcdFx0XHRpbnB1dHMgPSBbaW5wdXRzXTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpbnB1dHNbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbnB1dHNbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGFuIGlucHV0IGVsZW1lbnRcblx0XHRcdFx0XHRpbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXHRcdFx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdoaWRkZW4nKTtcblx0XHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCB4KTtcblxuXHRcdFx0XHRcdC8vIERvZXMgaXQgaGF2ZSBhIHZhbHVlIGF0dHJpYnV0ZT9cblx0XHRcdFx0XHRpZiAoZWwpIHtcblx0XHRcdFx0XHRcdGlucHV0LnZhbHVlID0gZGF0YVt4XS52YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoX3RoaXMuZG9tSW5zdGFuY2UobnVsbCwgZGF0YVt4XSkpIHtcblx0XHRcdFx0XHRcdGlucHV0LnZhbHVlID0gZGF0YVt4XS5pbm5lckhUTUwgfHwgZGF0YVt4XS5pbm5lclRleHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aW5wdXQudmFsdWUgPSBkYXRhW3hdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSXQgaXMgYW4gZWxlbWVudCwgd2hpY2ggZXhpc3RzIHdpdGhpbiB0aGUgZm9ybSwgYnV0IHRoZSBuYW1lIGlzIHdyb25nXG5cdFx0XHRcdGVsc2UgaWYgKGVsICYmIGRhdGFbeF0ubmFtZSAhPT0geCkge1xuXHRcdFx0XHRcdGRhdGFbeF0uc2V0QXR0cmlidXRlKCduYW1lJywgeCk7XG5cdFx0XHRcdFx0ZGF0YVt4XS5uYW1lID0geDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBEaXNhYmxlIGVsZW1lbnRzIGZyb20gd2l0aGluIHRoZSBmb3JtIGlmIHRoZXkgd2VyZW4ndCBzcGVjaWZpZWRcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdFx0aW5wdXQgPSBmb3JtLmVsZW1lbnRzW2ldO1xuXG5cdFx0XHRcdC8vIERvZXMgdGhlIHNhbWUgbmFtZSBhbmQgdmFsdWUgZXhpc3QgaW4gdGhlIHBhcmVudFxuXHRcdFx0XHRpZiAoIShpbnB1dC5uYW1lIGluIGRhdGEpICYmIGlucHV0LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRcdC8vIERpc2FibGVcblx0XHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG5cblx0XHRcdFx0XHQvLyBBZGQgcmUtZW5hYmxlIHRvIGNhbGxiYWNrXG5cdFx0XHRcdFx0cmVlbmFibGVBZnRlclN1Ym1pdC5wdXNoKGlucHV0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgdGFyZ2V0IG9mIHRoZSBmb3JtXG5cdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ21ldGhvZCcsICdQT1NUJyk7XG5cdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsIGNhbGxiYWNrSUQpO1xuXHRcdGZvcm0udGFyZ2V0ID0gY2FsbGJhY2tJRDtcblxuXHRcdC8vIFVwZGF0ZSB0aGUgZm9ybSBVUkxcblx0XHRmb3JtLnNldEF0dHJpYnV0ZSgnYWN0aW9uJywgdXJsKTtcblxuXHRcdC8vIFN1Ym1pdCB0aGUgZm9ybVxuXHRcdC8vIFNvbWUgcmVhc29uIHRoaXMgbmVlZHMgdG8gYmUgb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnQgd2luZG93IGV4ZWN1dGlvblxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3JtLnN1Ym1pdCgpO1xuXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFJlbW92ZSB0aGUgaWZyYW1lIGZyb20gdGhlIHBhZ2UuXG5cdFx0XHRcdFx0Ly93aW4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3aW4pO1xuXHRcdFx0XHRcdC8vIFJlbW92ZSB0aGUgZm9ybVxuXHRcdFx0XHRcdGlmIChuZXdmb3JtKSB7XG5cdFx0XHRcdFx0XHRuZXdmb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobmV3Zm9ybSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0hlbGxvSlM6IGNvdWxkIG5vdCByZW1vdmUgaWZyYW1lJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlZSkge31cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHRoZSBkaXNhYmxlZCBmb3JtXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmVlbmFibGVBZnRlclN1Ym1pdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChyZWVuYWJsZUFmdGVyU3VibWl0W2ldKSB7XG5cdFx0XHRcdFx0XHRyZWVuYWJsZUFmdGVyU3VibWl0W2ldLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRyZWVuYWJsZUFmdGVyU3VibWl0W2ldLmRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LCAwKTtcblx0XHR9LCAxMDApO1xuXHR9LFxuXG5cdC8vIFNvbWUgb2YgdGhlIHByb3ZpZGVycyByZXF1aXJlIHRoYXQgb25seSBtdWx0aXBhcnQgaXMgdXNlZCB3aXRoIG5vbi1iaW5hcnkgZm9ybXMuXG5cdC8vIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHdoZXRoZXIgdGhlIGZvcm0gY29udGFpbnMgYmluYXJ5IGRhdGFcblx0aGFzQmluYXJ5OiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0Zm9yICh2YXIgeCBpbiBkYXRhKSBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSh4KSkge1xuXHRcdFx0aWYgKHRoaXMuaXNCaW5hcnkoZGF0YVt4XSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8vIERldGVybWluZXMgaWYgYSB2YXJpYWJsZSBFaXRoZXIgSXMgb3IgbGlrZSBhIEZvcm1JbnB1dCBoYXMgdGhlIHZhbHVlIG9mIGEgQmxvYlxuXG5cdGlzQmluYXJ5OiBmdW5jdGlvbihkYXRhKSB7XG5cblx0XHRyZXR1cm4gZGF0YSBpbnN0YW5jZW9mIE9iamVjdCAmJiAoXG5cdFx0KHRoaXMuZG9tSW5zdGFuY2UoJ2lucHV0JywgZGF0YSkgJiYgZGF0YS50eXBlID09PSAnZmlsZScpIHx8XG5cdFx0KCdGaWxlTGlzdCcgaW4gd2luZG93ICYmIGRhdGEgaW5zdGFuY2VvZiB3aW5kb3cuRmlsZUxpc3QpIHx8XG5cdFx0KCdGaWxlJyBpbiB3aW5kb3cgJiYgZGF0YSBpbnN0YW5jZW9mIHdpbmRvdy5GaWxlKSB8fFxuXHRcdCgnQmxvYicgaW4gd2luZG93ICYmIGRhdGEgaW5zdGFuY2VvZiB3aW5kb3cuQmxvYikpO1xuXG5cdH0sXG5cblx0Ly8gQ29udmVydCBEYXRhLVVSSSB0byBCbG9iIHN0cmluZ1xuXHR0b0Jsb2I6IGZ1bmN0aW9uKGRhdGFVUkkpIHtcblx0XHR2YXIgcmVnID0gL15kYXRhXFw6KFteOyxdKyhcXDtjaGFyc2V0PVteOyxdKyk/KShcXDtiYXNlNjQpPywvaTtcblx0XHR2YXIgbSA9IGRhdGFVUkkubWF0Y2gocmVnKTtcblx0XHRpZiAoIW0pIHtcblx0XHRcdHJldHVybiBkYXRhVVJJO1xuXHRcdH1cblxuXHRcdHZhciBiaW5hcnkgPSBhdG9iKGRhdGFVUkkucmVwbGFjZShyZWcsICcnKSk7XG5cdFx0dmFyIGFycmF5ID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGFycmF5LnB1c2goYmluYXJ5LmNoYXJDb2RlQXQoaSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXSwge3R5cGU6IG1bMV19KTtcblx0fVxuXG59KTtcblxuLy8gRVhUUkE6IENvbnZlcnQgRm9ybUVsZW1lbnQgdG8gSlNPTiBmb3IgUE9TVGluZ1xuLy8gV3JhcHBlcnMgdG8gYWRkIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSB0byBleGlzdGluZyBmdW5jdGlvbnNcbihmdW5jdGlvbihoZWxsbykge1xuXG5cdC8vIENvcHkgb3JpZ2luYWwgZnVuY3Rpb25cblx0dmFyIGFwaSA9IGhlbGxvLmFwaTtcblx0dmFyIHV0aWxzID0gaGVsbG8udXRpbHM7XG5cblx0dXRpbHMuZXh0ZW5kKHV0aWxzLCB7XG5cblx0XHQvLyBEYXRhVG9KU09OXG5cdFx0Ly8gVGhpcyB0YWtlcyBhIEZvcm1FbGVtZW50fE5vZGVMaXN0fElucHV0RWxlbWVudHxNaXhlZE9iamVjdHMgYW5kIGNvbnZlcnMgdGhlIGRhdGEgb2JqZWN0IHRvIEpTT04uXG5cdFx0ZGF0YVRvSlNPTjogZnVuY3Rpb24ocCkge1xuXG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0dmFyIHcgPSB3aW5kb3c7XG5cdFx0XHR2YXIgZGF0YSA9IHAuZGF0YTtcblxuXHRcdFx0Ly8gSXMgZGF0YSBhIGZvcm0gb2JqZWN0XG5cdFx0XHRpZiAoX3RoaXMuZG9tSW5zdGFuY2UoJ2Zvcm0nLCBkYXRhKSkge1xuXHRcdFx0XHRkYXRhID0gX3RoaXMubm9kZUxpc3RUb0pTT04oZGF0YS5lbGVtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgnTm9kZUxpc3QnIGluIHcgJiYgZGF0YSBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG5cdFx0XHRcdGRhdGEgPSBfdGhpcy5ub2RlTGlzdFRvSlNPTihkYXRhKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKF90aGlzLmRvbUluc3RhbmNlKCdpbnB1dCcsIGRhdGEpKSB7XG5cdFx0XHRcdGRhdGEgPSBfdGhpcy5ub2RlTGlzdFRvSlNPTihbZGF0YV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJcyBkYXRhIGEgYmxvYiwgRmlsZSwgRmlsZUxpc3Q/XG5cdFx0XHRpZiAoKCdGaWxlJyBpbiB3ICYmIGRhdGEgaW5zdGFuY2VvZiB3LkZpbGUpIHx8XG5cdFx0XHRcdCgnQmxvYicgaW4gdyAmJiBkYXRhIGluc3RhbmNlb2Ygdy5CbG9iKSB8fFxuXHRcdFx0XHQoJ0ZpbGVMaXN0JyBpbiB3ICYmIGRhdGEgaW5zdGFuY2VvZiB3LkZpbGVMaXN0KSkge1xuXHRcdFx0XHRkYXRhID0ge2ZpbGU6IGRhdGF9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29wIHRocm91Z2ggZGF0YSBpZiBpdCdzIG5vdCBmb3JtIGRhdGEgaXQgbXVzdCBub3cgYmUgYSBKU09OIG9iamVjdFxuXHRcdFx0aWYgKCEoJ0Zvcm1EYXRhJyBpbiB3ICYmIGRhdGEgaW5zdGFuY2VvZiB3LkZvcm1EYXRhKSkge1xuXG5cdFx0XHRcdGZvciAodmFyIHggaW4gZGF0YSkgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoeCkpIHtcblxuXHRcdFx0XHRcdGlmICgnRmlsZUxpc3QnIGluIHcgJiYgZGF0YVt4XSBpbnN0YW5jZW9mIHcuRmlsZUxpc3QpIHtcblx0XHRcdFx0XHRcdGlmIChkYXRhW3hdLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRkYXRhW3hdID0gZGF0YVt4XVswXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoX3RoaXMuZG9tSW5zdGFuY2UoJ2lucHV0JywgZGF0YVt4XSkgJiYgZGF0YVt4XS50eXBlID09PSAnZmlsZScpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChfdGhpcy5kb21JbnN0YW5jZSgnaW5wdXQnLCBkYXRhW3hdKSB8fFxuXHRcdFx0XHRcdFx0X3RoaXMuZG9tSW5zdGFuY2UoJ3NlbGVjdCcsIGRhdGFbeF0pIHx8XG5cdFx0XHRcdFx0XHRfdGhpcy5kb21JbnN0YW5jZSgndGV4dEFyZWEnLCBkYXRhW3hdKSkge1xuXHRcdFx0XHRcdFx0ZGF0YVt4XSA9IGRhdGFbeF0udmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKF90aGlzLmRvbUluc3RhbmNlKG51bGwsIGRhdGFbeF0pKSB7XG5cdFx0XHRcdFx0XHRkYXRhW3hdID0gZGF0YVt4XS5pbm5lckhUTUwgfHwgZGF0YVt4XS5pbm5lclRleHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHAuZGF0YSA9IGRhdGE7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9LFxuXG5cdFx0Ly8gTm9kZUxpc3RUb0pTT05cblx0XHQvLyBHaXZlbiBhIGxpc3Qgb2YgZWxlbWVudHMgZXh0cmFwb2xhdGUgdGhlaXIgdmFsdWVzIGFuZCByZXR1cm4gYXMgYSBqc29uIG9iamVjdFxuXHRcdG5vZGVMaXN0VG9KU09OOiBmdW5jdGlvbihub2RlbGlzdCkge1xuXG5cdFx0XHR2YXIganNvbiA9IHt9O1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBkYXRhIHN0cmluZ1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2RlbGlzdC5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHRcdHZhciBpbnB1dCA9IG5vZGVsaXN0W2ldO1xuXG5cdFx0XHRcdC8vIElmIHRoZSBuYW1lIG9mIHRoZSBpbnB1dCBpcyBlbXB0eSBvciBkaWFibGVkLCBkb250IGFkZCBpdC5cblx0XHRcdFx0aWYgKGlucHV0LmRpc2FibGVkIHx8ICFpbnB1dC5uYW1lKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJcyB0aGlzIGEgZmlsZSwgZG9lcyB0aGUgYnJvd3NlciBub3Qgc3VwcG9ydCAnZmlsZXMnIGFuZCAnRm9ybURhdGEnP1xuXHRcdFx0XHRpZiAoaW5wdXQudHlwZSA9PT0gJ2ZpbGUnKSB7XG5cdFx0XHRcdFx0anNvbltpbnB1dC5uYW1lXSA9IGlucHV0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGpzb25baW5wdXQubmFtZV0gPSBpbnB1dC52YWx1ZSB8fCBpbnB1dC5pbm5lckhUTUw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGpzb247XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBSZXBsYWNlIGl0XG5cdGhlbGxvLmFwaSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gR2V0IGFyZ3VtZW50c1xuXHRcdHZhciBwID0gdXRpbHMuYXJncyh7cGF0aDogJ3MhJywgbWV0aG9kOiAncycsIGRhdGE6J28nLCB0aW1lb3V0OiAnaScsIGNhbGxiYWNrOiAnZid9LCBhcmd1bWVudHMpO1xuXG5cdFx0Ly8gQ2hhbmdlIGZvciBpbnRvIGEgZGF0YSBvYmplY3Rcblx0XHRpZiAocC5kYXRhKSB7XG5cdFx0XHR1dGlscy5kYXRhVG9KU09OKHApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcGkuY2FsbCh0aGlzLCBwKTtcblx0fTtcblxufSkoaGVsbG8pO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gU2F2ZSBhbnkgYWNjZXNzIHRva2VuIHRoYXQgaXMgaW4gdGhlIGN1cnJlbnQgcGFnZSBVUkxcbi8vIEhhbmRsZSBhbnkgcmVzcG9uc2Ugc29saWNpdGVkIHRocm91Z2ggaWZyYW1lIGhhc2ggdGFnIGZvbGxvd2luZyBhbiBBUEkgcmVxdWVzdFxuLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuaGVsbG8udXRpbHMucmVzcG9uc2VIYW5kbGVyKHdpbmRvdywgd2luZG93Lm9wZW5lciB8fCB3aW5kb3cucGFyZW50KTtcblxuLy8gU2NyaXB0IHRvIHN1cHBvcnQgQ2hyb21lQXBwc1xuLy8gVGhpcyBvdmVyaWRlcyB0aGUgaGVsbG8udXRpbHMucG9wdXAgbWV0aG9kIHRvIHN1cHBvcnQgY2hyb21lLmlkZW50aXR5LmxhdW5jaFdlYkF1dGhGbG93XG4vLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9hcHBzL2FwcF9pZGVudGl0eSNub25cblxuLy8gSXMgdGhpcyBhIGNocm9tZSBhcHA/XG5cbmlmICh0eXBlb2YgY2hyb21lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY2hyb21lLmlkZW50aXR5ID09PSAnb2JqZWN0JyAmJiBjaHJvbWUuaWRlbnRpdHkubGF1bmNoV2ViQXV0aEZsb3cpIHtcblxuXHQoZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBTd2FwIHRoZSBwb3B1cCBtZXRob2Rcblx0XHRoZWxsby51dGlscy5wb3B1cCA9IGZ1bmN0aW9uKHVybCkge1xuXG5cdFx0XHRyZXR1cm4gX29wZW4odXJsLCB0cnVlKTtcblxuXHRcdH07XG5cblx0XHQvLyBTd2FwIHRoZSBoaWRkZW4gaWZyYW1lIG1ldGhvZFxuXHRcdGhlbGxvLnV0aWxzLmlmcmFtZSA9IGZ1bmN0aW9uKHVybCkge1xuXG5cdFx0XHRfb3Blbih1cmwsIGZhbHNlKTtcblxuXHRcdH07XG5cblx0XHQvLyBTd2FwIHRoZSByZXF1ZXN0X2NvcnMgbWV0aG9kXG5cdFx0aGVsbG8udXRpbHMucmVxdWVzdF9jb3JzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuXHRcdFx0Y2FsbGJhY2soKTtcblxuXHRcdFx0Ly8gQWx3YXlzIHJ1biBhcyBDT1JTXG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvLyBTd2FwIHRoZSBzdG9yYWdlIG1ldGhvZFxuXHRcdHZhciBfY2FjaGUgPSB7fTtcblx0XHRjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoJ2hlbGxvJywgZnVuY3Rpb24ocikge1xuXHRcdFx0Ly8gVXBkYXRlIHRoZSBjYWNoZVxuXHRcdFx0X2NhY2hlID0gci5oZWxsbyB8fCB7fTtcblx0XHR9KTtcblxuXHRcdGhlbGxvLnV0aWxzLnN0b3JlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblxuXHRcdFx0Ly8gR2V0IGFsbFxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIF9jYWNoZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gX2NhY2hlW25hbWVdIHx8IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldFxuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdF9jYWNoZVtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHRjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe2hlbGxvOiBfY2FjaGV9KTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZWxldGVcblx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRkZWxldGUgX2NhY2hlW25hbWVdO1xuXHRcdFx0XHRjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe2hlbGxvOiBfY2FjaGV9KTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIE9wZW4gZnVuY3Rpb25cblx0XHRmdW5jdGlvbiBfb3Blbih1cmwsIGludGVyYWN0aXZlKSB7XG5cblx0XHRcdC8vIExhdW5jaFxuXHRcdFx0dmFyIHJlZiA9IHtcblx0XHRcdFx0Y2xvc2VkOiBmYWxzZVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gTGF1bmNoIHRoZSB3ZWJBdXRoRmxvd1xuXHRcdFx0Y2hyb21lLmlkZW50aXR5LmxhdW5jaFdlYkF1dGhGbG93KHtcblx0XHRcdFx0dXJsOiB1cmwsXG5cdFx0XHRcdGludGVyYWN0aXZlOiBpbnRlcmFjdGl2ZVxuXHRcdFx0fSwgZnVuY3Rpb24ocmVzcG9uc2VVcmwpIHtcblxuXHRcdFx0XHQvLyBEaWQgdGhlIHVzZXIgY2FuY2VsIHRoaXMgcHJlbWF0dXJlbHlcblx0XHRcdFx0aWYgKHJlc3BvbnNlVXJsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZWYuY2xvc2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTcGxpdCBhcHBhcnQgdGhlIFVSTFxuXHRcdFx0XHR2YXIgYSA9IGhlbGxvLnV0aWxzLnVybChyZXNwb25zZVVybCk7XG5cblx0XHRcdFx0Ly8gVGhlIGxvY2F0aW9uIGNhbiBiZSBhdWdtZW50ZWQgaW4gdG8gYSBsb2NhdGlvbiBvYmplY3QgbGlrZSBzby4uLlxuXHRcdFx0XHQvLyBXZSBkb250IGhhdmUgd2luZG93IG9wZXJhdGlvbnMgb24gdGhlIHBvcHVwIHNvIGxldHMgY3JlYXRlIHNvbWVcblx0XHRcdFx0dmFyIF9wb3B1cCA9IHtcblx0XHRcdFx0XHRsb2NhdGlvbjoge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGFuZ2UgdGhlIGxvY2F0aW9uIG9mIHRoZSBwb3B1cFxuXHRcdFx0XHRcdFx0YXNzaWduOiBmdW5jdGlvbih1cmwpIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhIHNlY29uZGFyeSByZWFzc2lnblxuXHRcdFx0XHRcdFx0XHQvLyBJbiB0aGUgY2FzZSBvZiBPQXV0aDFcblx0XHRcdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGlzIGluIG5vbi1pbnRlcmFjdGl2ZSBtb2RlLlxuXHRcdFx0XHRcdFx0XHRfb3Blbih1cmwsIGZhbHNlKTtcblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdHNlYXJjaDogYS5zZWFyY2gsXG5cdFx0XHRcdFx0XHRoYXNoOiBhLmhhc2gsXG5cdFx0XHRcdFx0XHRocmVmOiBhLmhyZWZcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGNsb3NlOiBmdW5jdGlvbigpIHt9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gVGhlbiB0aGlzIFVSTCBjb250YWlucyBpbmZvcm1hdGlvbiB3aGljaCBIZWxsb0pTIG11c3QgcHJvY2Vzc1xuXHRcdFx0XHQvLyBVUkwgc3RyaW5nXG5cdFx0XHRcdC8vIFdpbmRvdyAtIGFueSBhY3Rpb24gc3VjaCBhcyB3aW5kb3cgcmVsb2NhdGlvbiBnb2VzIGhlcmVcblx0XHRcdFx0Ly8gT3BlbmVyIC0gdGhlIHBhcmVudCB3aW5kb3cgd2hpY2ggb3BlbmVkIHRoaXMsIGFrYSB0aGlzIHNjcmlwdFxuXG5cdFx0XHRcdGhlbGxvLnV0aWxzLnJlc3BvbnNlSGFuZGxlcihfcG9wdXAsIHdpbmRvdyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRoZSByZWZlcmVuY2Vcblx0XHRcdHJldHVybiByZWY7XG5cdFx0fVxuXG5cdH0pKCk7XG59XG5cbi8vIFBob25lZ2FwIG92ZXJyaWRlIGZvciBoZWxsby5waG9uZWdhcC5qc1xuKGZ1bmN0aW9uKCkge1xuXG5cdC8vIElzIHRoaXMgYSBwaG9uZWdhcCBpbXBsZW1lbnRhdGlvbj9cblx0aWYgKCEoL15maWxlOlxcL3szfVteXFwvXS8udGVzdCh3aW5kb3cubG9jYXRpb24uaHJlZikgJiYgd2luZG93LmNvcmRvdmEpKSB7XG5cdFx0Ly8gQ29yZG92YSBpcyBub3QgaW5jbHVkZWQuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gQXVnbWVudCB0aGUgaGlkZGVuIGlmcmFtZSBtZXRob2Rcblx0aGVsbG8udXRpbHMuaWZyYW1lID0gZnVuY3Rpb24odXJsLCByZWRpcmVjdFVyaSkge1xuXHRcdGhlbGxvLnV0aWxzLnBvcHVwKHVybCwgcmVkaXJlY3RVcmksIHtoaWRkZW46ICd5ZXMnfSk7XG5cdH07XG5cblx0Ly8gQXVnbWVudCB0aGUgcG9wdXBcblx0dmFyIHV0aWxQb3B1cCA9IGhlbGxvLnV0aWxzLnBvcHVwO1xuXG5cdC8vIFJlcGxhY2UgcG9wdXBcblx0aGVsbG8udXRpbHMucG9wdXAgPSBmdW5jdGlvbih1cmwsIHJlZGlyZWN0VXJpLCBvcHRpb25zKSB7XG5cblx0XHQvLyBSdW4gdGhlIHN0YW5kYXJkXG5cdFx0dmFyIHBvcHVwID0gdXRpbFBvcHVwLmNhbGwodGhpcywgdXJsLCByZWRpcmVjdFVyaSwgb3B0aW9ucyk7XG5cblx0XHQvLyBDcmVhdGUgYSBmdW5jdGlvbiBmb3IgcmVvcGVuaW5nIHRoZSBwb3B1cCwgYW5kIGFzc2lnbmluZyBldmVudHMgdG8gdGhlIG5ldyBwb3B1cCBvYmplY3Rcblx0XHQvLyBQaG9uZUdhcCBzdXBwb3J0XG5cdFx0Ly8gQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGxpc3RlbiB0byB0aGUgY2hhbmdlIGluIHRoZSBwb3B1cCB3aW5kb3dzIFVSTFxuXHRcdC8vIFRoaXMgbXVzdCBhcHBlYXIgYmVmb3JlIHBvcHVwLmZvY3VzKCk7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChwb3B1cCAmJiBwb3B1cC5hZGRFdmVudExpc3RlbmVyKSB7XG5cblx0XHRcdFx0Ly8gR2V0IHRoZSBvcmlnaW4gb2YgdGhlIHJlZGlyZWN0IFVSSVxuXG5cdFx0XHRcdHZhciBhID0gaGVsbG8udXRpbHMudXJsKHJlZGlyZWN0VXJpKTtcblx0XHRcdFx0dmFyIHJlZGlyZWN0VXJpT3JpZ2luID0gYS5vcmlnaW4gfHwgKGEucHJvdG9jb2wgKyAnLy8nICsgYS5ob3N0bmFtZSk7XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIEluQXBwQnJvd3NlciB3aW5kb3dcblxuXHRcdFx0XHRwb3B1cC5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBmdW5jdGlvbihlKSB7XG5cblx0XHRcdFx0XHR2YXIgdXJsID0gZS51cmw7XG5cblx0XHRcdFx0XHQvLyBJcyB0aGlzIHRoZSBwYXRoLCBhcyBnaXZlbiBieSB0aGUgcmVkaXJlY3RVcmk/XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgdGhlIG5ldyBVUkwgYWdhaW5zIHRoZSByZWRpcmVjdFVyaU9yaWdpbi5cblx0XHRcdFx0XHQvLyBBY2NvcmRpbmcgdG8gIzYzIGEgdXNlciBjb3VsZCBjbGljayAnY2FuY2VsJyBpbiBzb21lIGRpYWxvZyBib3hlcyAuLi4uXG5cdFx0XHRcdFx0Ly8gVGhlIHBvcHVwIHJlZGlyZWN0cyB0byBhbm90aGVyIHBhZ2Ugd2l0aCB0aGUgc2FtZSBvcmlnaW4sIHlldCB3ZSBzdGlsbCB3aXNoIGl0IHRvIGNsb3NlLlxuXG5cdFx0XHRcdFx0aWYgKHVybC5pbmRleE9mKHJlZGlyZWN0VXJpT3JpZ2luKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFNwbGl0IGFwcGFydCB0aGUgVVJMXG5cdFx0XHRcdFx0dmFyIGEgPSBoZWxsby51dGlscy51cmwodXJsKTtcblxuXHRcdFx0XHRcdC8vIFdlIGRvbnQgaGF2ZSB3aW5kb3cgb3BlcmF0aW9ucyBvbiB0aGUgcG9wdXAgc28gbGV0cyBjcmVhdGUgc29tZVxuXHRcdFx0XHRcdC8vIFRoZSBsb2NhdGlvbiBjYW4gYmUgYXVnbWVudGVkIGluIHRvIGEgbG9jYXRpb24gb2JqZWN0IGxpa2Ugc28uLi5cblxuXHRcdFx0XHRcdHZhciBfcG9wdXAgPSB7XG5cdFx0XHRcdFx0XHRsb2NhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHQvLyBDaGFuZ2UgdGhlIGxvY2F0aW9uIG9mIHRoZSBwb3B1cFxuXHRcdFx0XHRcdFx0XHRhc3NpZ246IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBVbmZvdXJ0dW5hdGx5IGFuIGFwcCBpcyBtYXkgbm90IGNoYW5nZSB0aGUgbG9jYXRpb24gb2YgYSBJbkFwcEJyb3dzZXIgd2luZG93LlxuXHRcdFx0XHRcdFx0XHRcdC8vIFNvIHRvIHNoaW0gdGhpcywganVzdCBvcGVuIGEgbmV3IG9uZS5cblx0XHRcdFx0XHRcdFx0XHRwb3B1cC5leGVjdXRlU2NyaXB0KHtjb2RlOiAnd2luZG93LmxvY2F0aW9uLmhyZWYgPSBcIicgKyBsb2NhdGlvbiArICc7XCInfSk7XG5cdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0c2VhcmNoOiBhLnNlYXJjaCxcblx0XHRcdFx0XHRcdFx0aGFzaDogYS5oYXNoLFxuXHRcdFx0XHRcdFx0XHRocmVmOiBhLmhyZWZcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRjbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwb3B1cC5jbG9zZSkge1xuXHRcdFx0XHRcdFx0XHRcdHBvcHVwLmNsb3NlKCk7XG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBvcHVwLmNsb3NlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNhdGNoIChfZSkge31cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvLyBUaGVuIHRoaXMgVVJMIGNvbnRhaW5zIGluZm9ybWF0aW9uIHdoaWNoIEhlbGxvSlMgbXVzdCBwcm9jZXNzXG5cdFx0XHRcdFx0Ly8gVVJMIHN0cmluZ1xuXHRcdFx0XHRcdC8vIFdpbmRvdyAtIGFueSBhY3Rpb24gc3VjaCBhcyB3aW5kb3cgcmVsb2NhdGlvbiBnb2VzIGhlcmVcblx0XHRcdFx0XHQvLyBPcGVuZXIgLSB0aGUgcGFyZW50IHdpbmRvdyB3aGljaCBvcGVuZWQgdGhpcywgYWthIHRoaXMgc2NyaXB0XG5cblx0XHRcdFx0XHRoZWxsby51dGlscy5yZXNwb25zZUhhbmRsZXIoX3BvcHVwLCB3aW5kb3cpO1xuXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAoZSkge31cblxuXHRcdHJldHVybiBwb3B1cDtcblx0fTtcblxufSkoKTtcblxuKGZ1bmN0aW9uKGhlbGxvKSB7XG5cblx0Ly8gT0F1dGgxXG5cdHZhciBPQXV0aDFTZXR0aW5ncyA9IHtcblx0XHR2ZXJzaW9uOiAnMS4wJyxcblx0XHRhdXRoOiAnaHR0cHM6Ly93d3cuZHJvcGJveC5jb20vMS9vYXV0aC9hdXRob3JpemUnLFxuXHRcdHJlcXVlc3Q6ICdodHRwczovL2FwaS5kcm9wYm94LmNvbS8xL29hdXRoL3JlcXVlc3RfdG9rZW4nLFxuXHRcdHRva2VuOiAnaHR0cHM6Ly9hcGkuZHJvcGJveC5jb20vMS9vYXV0aC9hY2Nlc3NfdG9rZW4nXG5cdH07XG5cblx0Ly8gT0F1dGgyIFNldHRpbmdzXG5cdHZhciBPQXV0aDJTZXR0aW5ncyA9IHtcblx0XHR2ZXJzaW9uOiAyLFxuXHRcdGF1dGg6ICdodHRwczovL3d3dy5kcm9wYm94LmNvbS8xL29hdXRoMi9hdXRob3JpemUnLFxuXHRcdGdyYW50OiAnaHR0cHM6Ly9hcGkuZHJvcGJveC5jb20vMS9vYXV0aDIvdG9rZW4nXG5cdH07XG5cblx0Ly8gSW5pdGlhdGUgdGhlIERyb3Bib3ggbW9kdWxlXG5cdGhlbGxvLmluaXQoe1xuXG5cdFx0ZHJvcGJveDoge1xuXG5cdFx0XHRuYW1lOiAnRHJvcGJveCcsXG5cblx0XHRcdG9hdXRoOiBPQXV0aDJTZXR0aW5ncyxcblxuXHRcdFx0bG9naW46IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0Ly8gT0F1dGgyIG5vbi1zdGFuZGFyZCBhZGp1c3RtZW50c1xuXHRcdFx0XHRwLnFzLnNjb3BlID0gJyc7XG5cdFx0XHRcdGRlbGV0ZSBwLnFzLmRpc3BsYXk7XG5cblx0XHRcdFx0Ly8gU2hvdWxkIHRoaXMgYmUgcnVuIGFzIE9BdXRoMT9cblx0XHRcdFx0Ly8gSWYgdGhlIHJlZGlyZWN0X3VyaSBpcyBpcyBIVFRQIChub24tc2VjdXJlKSB0aGVuIGl0cyByZXF1aXJlZCB0byByZXZlcnQgdG8gdGhlIE9BdXRoMSBlbmRwb2ludHNcblx0XHRcdFx0dmFyIHJlZGlyZWN0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHAucXMucmVkaXJlY3RfdXJpKTtcblx0XHRcdFx0aWYgKHJlZGlyZWN0LmluZGV4T2YoJ2h0dHA6JykgPT09IDAgJiYgcmVkaXJlY3QuaW5kZXhPZignaHR0cDovL2xvY2FsaG9zdC8nKSAhPT0gMCkge1xuXG5cdFx0XHRcdFx0Ly8gT3ZlcnJpZGUgdGhlIGRyb3Bib3ggT0F1dGggc2V0dGluZ3MuXG5cdFx0XHRcdFx0aGVsbG8uc2VydmljZXMuZHJvcGJveC5vYXV0aCA9IE9BdXRoMVNldHRpbmdzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIE92ZXJyaWRlIHRoZSBkcm9wYm94IE9BdXRoIHNldHRpbmdzLlxuXHRcdFx0XHRcdGhlbGxvLnNlcnZpY2VzLmRyb3Bib3gub2F1dGggPSBPQXV0aDJTZXR0aW5ncztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoZSBkcm9wYm94IGxvZ2luIHdpbmRvdyBpcyBhIGRpZmZlcmVudCBzaXplXG5cdFx0XHRcdHAub3B0aW9ucy5wb3B1cC53aWR0aCA9IDEwMDA7XG5cdFx0XHRcdHAub3B0aW9ucy5wb3B1cC5oZWlnaHQgPSAxMDAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Lypcblx0XHRcdFx0RHJvcGJveCBkb2VzIG5vdCBhbGxvdyBpbnNlY3VyZSBIVFRQIFVSSSdzIGluIHRoZSByZWRpcmVjdF91cmkgZmllbGRcblx0XHRcdFx0Li4ub3RoZXJ3aXNlIEknZCBsb3ZlIHRvIHVzZSBPQXV0aDJcblxuXHRcdFx0XHRGb2xsb3cgcmVxdWVzdCBodHRwczovL2ZvcnVtcy5kcm9wYm94LmNvbS90b3BpYy5waHA/aWQ9MTA2NTA1XG5cblx0XHRcdFx0cC5xcy5yZXNwb25zZV90eXBlID0gJ2NvZGUnO1xuXHRcdFx0XHRvYXV0aDoge1xuXHRcdFx0XHRcdHZlcnNpb246IDIsXG5cdFx0XHRcdFx0YXV0aDogJ2h0dHBzOi8vd3d3LmRyb3Bib3guY29tLzEvb2F1dGgyL2F1dGhvcml6ZScsXG5cdFx0XHRcdFx0Z3JhbnQ6ICdodHRwczovL2FwaS5kcm9wYm94LmNvbS8xL29hdXRoMi90b2tlbidcblx0XHRcdFx0fVxuXHRcdFx0Ki9cblxuXHRcdFx0Ly8gQVBJIEJhc2UgVVJMXG5cdFx0XHRiYXNlOiAnaHR0cHM6Ly9hcGkuZHJvcGJveC5jb20vMS8nLFxuXG5cdFx0XHQvLyBCZXNwb2tlIHNldHRpbmc6IHRoaXMgaXMgc3RhdGVzIHdoZXRoZXIgdG8gdXNlIHRoZSBjdXN0b20gZW52aXJvbm1lbnQgb2YgRHJvcGJveCBvciB0byB1c2UgdGhlaXIgb3duIGVudmlyb25tZW50XG5cdFx0XHQvLyBCZWNhdXNlIGl0J3Mgbm90b3Jpb3VzbHkgZGlmZmljdWx0IGZvciBEcm9wYm94IHRvbyBwcm92aWRlIGFjY2VzcyBmcm9tIG90aGVyIHdlYnNlcnZpY2VzLCB0aGlzIGRlZmF1bHRzIHRvIFNhbmRib3hcblx0XHRcdHJvb3Q6ICdzYW5kYm94JyxcblxuXHRcdFx0Ly8gTWFwIEdFVCByZXF1ZXN0c1xuXHRcdFx0Z2V0OiB7XG5cdFx0XHRcdG1lOiAnYWNjb3VudC9pbmZvJyxcblxuXHRcdFx0XHQvLyBIdHRwczovL3d3dy5kcm9wYm94LmNvbS9kZXZlbG9wZXJzL2NvcmUvZG9jcyNtZXRhZGF0YVxuXHRcdFx0XHQnbWUvZmlsZXMnOiByZXEoJ21ldGFkYXRhL2F1dG8vQHtwYXJlbnR8fScpLFxuXHRcdFx0XHQnbWUvZm9sZGVyJzogcmVxKCdtZXRhZGF0YS9hdXRvL0B7aWR9JyksXG5cdFx0XHRcdCdtZS9mb2xkZXJzJzogcmVxKCdtZXRhZGF0YS9hdXRvLycpLFxuXG5cdFx0XHRcdCdkZWZhdWx0JzogZnVuY3Rpb24ocCwgY2FsbGJhY2spIHtcblx0XHRcdFx0XHRpZiAocC5wYXRoLm1hdGNoKCdodHRwczovL2FwaS1jb250ZW50LmRyb3Bib3guY29tLzEvZmlsZXMvJykpIHtcblx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBmaWxlLCByZXR1cm4gYmluYXJ5IGRhdGFcblx0XHRcdFx0XHRcdHAubWV0aG9kID0gJ2Jsb2InO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhbGxiYWNrKHAucGF0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHBvc3Q6IHtcblx0XHRcdFx0J21lL2ZpbGVzJzogZnVuY3Rpb24ocCwgY2FsbGJhY2spIHtcblxuXHRcdFx0XHRcdHZhciBwYXRoID0gcC5kYXRhLnBhcmVudDtcblx0XHRcdFx0XHR2YXIgZmlsZU5hbWUgPSBwLmRhdGEubmFtZTtcblxuXHRcdFx0XHRcdHAuZGF0YSA9IHtcblx0XHRcdFx0XHRcdGZpbGU6IHAuZGF0YS5maWxlXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIERvZXMgdGhpcyBoYXZlIGEgZGF0YS11cmkgdG8gdXBsb2FkIGFzIGEgZmlsZT9cblx0XHRcdFx0XHRpZiAodHlwZW9mIChwLmRhdGEuZmlsZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHRwLmRhdGEuZmlsZSA9IGhlbGxvLnV0aWxzLnRvQmxvYihwLmRhdGEuZmlsZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2soJ2h0dHBzOi8vYXBpLWNvbnRlbnQuZHJvcGJveC5jb20vMS9maWxlc19wdXQvYXV0by8nICsgcGF0aCArICcvJyArIGZpbGVOYW1lKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQnbWUvZm9sZGVycyc6IGZ1bmN0aW9uKHAsIGNhbGxiYWNrKSB7XG5cblx0XHRcdFx0XHR2YXIgbmFtZSA9IHAuZGF0YS5uYW1lO1xuXHRcdFx0XHRcdHAuZGF0YSA9IHt9O1xuXG5cdFx0XHRcdFx0Y2FsbGJhY2soJ2ZpbGVvcHMvY3JlYXRlX2ZvbGRlcj9yb290PUB7cm9vdHxzYW5kYm94fSYnICsgaGVsbG8udXRpbHMucGFyYW0oe1xuXHRcdFx0XHRcdFx0cGF0aDogbmFtZVxuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gTWFwIERFTEVURSByZXF1ZXN0c1xuXHRcdFx0ZGVsOiB7XG5cdFx0XHRcdCdtZS9maWxlcyc6ICdmaWxlb3BzL2RlbGV0ZT9yb290PUB7cm9vdHxzYW5kYm94fSZwYXRoPUB7aWR9Jyxcblx0XHRcdFx0J21lL2ZvbGRlcic6ICdmaWxlb3BzL2RlbGV0ZT9yb290PUB7cm9vdHxzYW5kYm94fSZwYXRoPUB7aWR9J1xuXHRcdFx0fSxcblxuXHRcdFx0d3JhcDoge1xuXHRcdFx0XHRtZTogZnVuY3Rpb24obykge1xuXHRcdFx0XHRcdGZvcm1hdEVycm9yKG8pO1xuXHRcdFx0XHRcdGlmICghby51aWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG8ubmFtZSA9IG8uZGlzcGxheV9uYW1lO1xuXHRcdFx0XHRcdHZhciBtID0gby5uYW1lLnNwbGl0KCcgJyk7XG5cdFx0XHRcdFx0by5maXJzdF9uYW1lID0gbS5zaGlmdCgpO1xuXHRcdFx0XHRcdG8ubGFzdF9uYW1lID0gbS5qb2luKCcgJyk7XG5cdFx0XHRcdFx0by5pZCA9IG8udWlkO1xuXHRcdFx0XHRcdGRlbGV0ZSBvLnVpZDtcblx0XHRcdFx0XHRkZWxldGUgby5kaXNwbGF5X25hbWU7XG5cdFx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0J2RlZmF1bHQnOiBmdW5jdGlvbihvLCBoZWFkZXJzLCByZXEpIHtcblx0XHRcdFx0XHRmb3JtYXRFcnJvcihvKTtcblx0XHRcdFx0XHRpZiAoby5pc19kaXIgJiYgby5jb250ZW50cykge1xuXHRcdFx0XHRcdFx0by5kYXRhID0gby5jb250ZW50cztcblx0XHRcdFx0XHRcdGRlbGV0ZSBvLmNvbnRlbnRzO1xuXG5cdFx0XHRcdFx0XHRvLmRhdGEuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0ucm9vdCA9IG8ucm9vdDtcblx0XHRcdFx0XHRcdFx0Zm9ybWF0RmlsZShpdGVtLCBoZWFkZXJzLCByZXEpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9ybWF0RmlsZShvLCBoZWFkZXJzLCByZXEpO1xuXG5cdFx0XHRcdFx0aWYgKG8uaXNfZGVsZXRlZCkge1xuXHRcdFx0XHRcdFx0by5zdWNjZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRG9lc24ndCByZXR1cm4gdGhlIENPUlMgaGVhZGVyc1xuXHRcdFx0eGhyOiBmdW5jdGlvbihwKSB7XG5cblx0XHRcdFx0Ly8gVGhlIHByb3h5IHN1cHBvcnRzIGFsbG93LWNyb3NzLW9yaWdpbi1yZXNvdXJjZVxuXHRcdFx0XHQvLyBBbGFzIHRoYXQncyB0aGUgb25seSB0aGluZyB3ZSdyZSB1c2luZy5cblx0XHRcdFx0aWYgKHAuZGF0YSAmJiBwLmRhdGEuZmlsZSkge1xuXHRcdFx0XHRcdHZhciBmaWxlID0gcC5kYXRhLmZpbGU7XG5cdFx0XHRcdFx0aWYgKGZpbGUpIHtcblx0XHRcdFx0XHRcdGlmIChmaWxlLmZpbGVzKSB7XG5cdFx0XHRcdFx0XHRcdHAuZGF0YSA9IGZpbGUuZmlsZXNbMF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0cC5kYXRhID0gZmlsZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocC5tZXRob2QgPT09ICdkZWxldGUnKSB7XG5cdFx0XHRcdFx0cC5tZXRob2QgPSAncG9zdCc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdGZvcm06IGZ1bmN0aW9uKHAsIHFzKSB7XG5cdFx0XHRcdGRlbGV0ZSBxcy5zdGF0ZTtcblx0XHRcdFx0ZGVsZXRlIHFzLnJlZGlyZWN0X3VyaTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGZvcm1hdEVycm9yKG8pIHtcblx0XHRpZiAobyAmJiAnZXJyb3InIGluIG8pIHtcblx0XHRcdG8uZXJyb3IgPSB7XG5cdFx0XHRcdGNvZGU6ICdzZXJ2ZXJfZXJyb3InLFxuXHRcdFx0XHRtZXNzYWdlOiBvLmVycm9yLm1lc3NhZ2UgfHwgby5lcnJvclxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRGaWxlKG8sIGhlYWRlcnMsIHJlcSkge1xuXG5cdFx0aWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0JyB8fFxuXHRcdFx0KHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBvIGluc3RhbmNlb2YgQmxvYikgfHxcblx0XHRcdCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIG8gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcblx0XHRcdC8vIFRoaXMgaXMgYSBmaWxlLCBsZXQgaXQgdGhyb3VnaCB1bmZvcm1hdHRlZFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgnZXJyb3InIGluIG8pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGF0aCA9IChvLnJvb3QgIT09ICdhcHBfZm9sZGVyJyA/IG8ucm9vdCA6ICcnKSArIG8ucGF0aC5yZXBsYWNlKC9cXCYvZywgJyUyNicpO1xuXHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8vLCAnJyk7XG5cdFx0aWYgKG8udGh1bWJfZXhpc3RzKSB7XG5cdFx0XHRvLnRodW1ibmFpbCA9IHJlcS5vYXV0aF9wcm94eSArICc/cGF0aD0nICtcblx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCgnaHR0cHM6Ly9hcGktY29udGVudC5kcm9wYm94LmNvbS8xL3RodW1ibmFpbHMvYXV0by8nICsgcGF0aCArICc/Zm9ybWF0PWpwZWcmc2l6ZT1tJykgKyAnJmFjY2Vzc190b2tlbj0nICsgcmVxLm9wdGlvbnMuYWNjZXNzX3Rva2VuO1xuXHRcdH1cblxuXHRcdG8udHlwZSA9IChvLmlzX2RpciA/ICdmb2xkZXInIDogby5taW1lX3R5cGUpO1xuXHRcdG8ubmFtZSA9IG8ucGF0aC5yZXBsYWNlKC8uKlxcLy9nLCAnJyk7XG5cdFx0aWYgKG8uaXNfZGlyKSB7XG5cdFx0XHRvLmZpbGVzID0gcGF0aC5yZXBsYWNlKC9eXFwvLywgJycpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG8uZG93bmxvYWRMaW5rID0gaGVsbG8uc2V0dGluZ3Mub2F1dGhfcHJveHkgKyAnP3BhdGg9JyArXG5cdFx0XHRlbmNvZGVVUklDb21wb25lbnQoJ2h0dHBzOi8vYXBpLWNvbnRlbnQuZHJvcGJveC5jb20vMS9maWxlcy9hdXRvLycgKyBwYXRoKSArICcmYWNjZXNzX3Rva2VuPScgKyByZXEub3B0aW9ucy5hY2Nlc3NfdG9rZW47XG5cdFx0XHRvLmZpbGUgPSAnaHR0cHM6Ly9hcGktY29udGVudC5kcm9wYm94LmNvbS8xL2ZpbGVzL2F1dG8vJyArIHBhdGg7XG5cdFx0fVxuXG5cdFx0aWYgKCFvLmlkKSB7XG5cdFx0XHRvLmlkID0gby5wYXRoLnJlcGxhY2UoL15cXC8vLCAnJyk7XG5cdFx0fVxuXG5cdFx0Ly8gTy5tZWRpYSA9ICdodHRwczovL2FwaS1jb250ZW50LmRyb3Bib3guY29tLzEvZmlsZXMvJyArIHBhdGg7XG5cdH1cblxuXHRmdW5jdGlvbiByZXEoc3RyKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHAsIGNiKSB7XG5cdFx0XHRkZWxldGUgcC5xdWVyeS5saW1pdDtcblx0XHRcdGNiKHN0cik7XG5cdFx0fTtcblx0fVxuXG59KShoZWxsbyk7XG5cbihmdW5jdGlvbihoZWxsbykge1xuXG5cdGhlbGxvLmluaXQoe1xuXG5cdFx0ZmFjZWJvb2s6IHtcblxuXHRcdFx0bmFtZTogJ0ZhY2Vib29rJyxcblxuXHRcdFx0Ly8gU0VFIGh0dHBzOi8vZGV2ZWxvcGVycy5mYWNlYm9vay5jb20vZG9jcy9mYWNlYm9vay1sb2dpbi9tYW51YWxseS1idWlsZC1hLWxvZ2luLWZsb3cvdjIuMVxuXHRcdFx0b2F1dGg6IHtcblx0XHRcdFx0dmVyc2lvbjogMixcblx0XHRcdFx0YXV0aDogJ2h0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS9kaWFsb2cvb2F1dGgvJyxcblx0XHRcdFx0Z3JhbnQ6ICdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS9vYXV0aC9hY2Nlc3NfdG9rZW4nXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBBdXRob3JpemF0aW9uIHNjb3Blc1xuXHRcdFx0c2NvcGU6IHtcblx0XHRcdFx0YmFzaWM6ICdwdWJsaWNfcHJvZmlsZScsXG5cdFx0XHRcdGVtYWlsOiAnZW1haWwnLFxuXHRcdFx0XHRzaGFyZTogJ3VzZXJfcG9zdHMnLFxuXHRcdFx0XHRiaXJ0aGRheTogJ3VzZXJfYmlydGhkYXknLFxuXHRcdFx0XHRldmVudHM6ICd1c2VyX2V2ZW50cycsXG5cdFx0XHRcdHBob3RvczogJ3VzZXJfcGhvdG9zJyxcblx0XHRcdFx0dmlkZW9zOiAndXNlcl92aWRlb3MnLFxuXHRcdFx0XHRmcmllbmRzOiAndXNlcl9mcmllbmRzJyxcblx0XHRcdFx0ZmlsZXM6ICd1c2VyX3Bob3Rvcyx1c2VyX3ZpZGVvcycsXG5cdFx0XHRcdHB1Ymxpc2hfZmlsZXM6ICd1c2VyX3Bob3Rvcyx1c2VyX3ZpZGVvcyxwdWJsaXNoX2FjdGlvbnMnLFxuXHRcdFx0XHRwdWJsaXNoOiAncHVibGlzaF9hY3Rpb25zJyxcblxuXHRcdFx0XHQvLyBEZXByZWNhdGVkIGluIHYyLjBcblx0XHRcdFx0Ly8gQ3JlYXRlX2V2ZW50XHQ6ICdjcmVhdGVfZXZlbnQnLFxuXG5cdFx0XHRcdG9mZmxpbmVfYWNjZXNzOiAnJ1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVmcmVzaCB0aGUgYWNjZXNzX3Rva2VuXG5cdFx0XHRyZWZyZXNoOiB0cnVlLFxuXG5cdFx0XHRsb2dpbjogZnVuY3Rpb24ocCkge1xuXG5cdFx0XHRcdC8vIFJlYXV0aGVudGljYXRlXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5mYWNlYm9vay5jb20vZG9jcy9mYWNlYm9vay1sb2dpbi9yZWF1dGhlbnRpY2F0aW9uXG5cdFx0XHRcdGlmIChwLm9wdGlvbnMuZm9yY2UpIHtcblx0XHRcdFx0XHRwLnFzLmF1dGhfdHlwZSA9ICdyZWF1dGhlbnRpY2F0ZSc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgZmFjZWJvb2sgbG9naW4gd2luZG93IGlzIGEgZGlmZmVyZW50IHNpemUuXG5cdFx0XHRcdHAub3B0aW9ucy5wb3B1cC53aWR0aCA9IDU4MDtcblx0XHRcdFx0cC5vcHRpb25zLnBvcHVwLmhlaWdodCA9IDQwMDtcblx0XHRcdH0sXG5cblx0XHRcdGxvZ291dDogZnVuY3Rpb24oY2FsbGJhY2ssIG9wdGlvbnMpIHtcblx0XHRcdFx0Ly8gQXNzaWduIGNhbGxiYWNrIHRvIGEgZ2xvYmFsIGhhbmRsZXJcblx0XHRcdFx0dmFyIGNhbGxiYWNrSUQgPSBoZWxsby51dGlscy5nbG9iYWxFdmVudChjYWxsYmFjayk7XG5cdFx0XHRcdHZhciByZWRpcmVjdCA9IGVuY29kZVVSSUNvbXBvbmVudChoZWxsby5zZXR0aW5ncy5yZWRpcmVjdF91cmkgKyAnPycgKyBoZWxsby51dGlscy5wYXJhbSh7Y2FsbGJhY2s6Y2FsbGJhY2tJRCwgcmVzdWx0OiBKU09OLnN0cmluZ2lmeSh7Zm9yY2U6dHJ1ZX0pLCBzdGF0ZTogJ3t9J30pKTtcblx0XHRcdFx0dmFyIHRva2VuID0gKG9wdGlvbnMuYXV0aFJlc3BvbnNlIHx8IHt9KS5hY2Nlc3NfdG9rZW47XG5cdFx0XHRcdGhlbGxvLnV0aWxzLmlmcmFtZSgnaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL2xvZ291dC5waHA/bmV4dD0nICsgcmVkaXJlY3QgKyAnJmFjY2Vzc190b2tlbj0nICsgdG9rZW4pO1xuXG5cdFx0XHRcdC8vIFBvc3NpYmxlIHJlc3BvbnNlczpcblx0XHRcdFx0Ly8gU3RyaW5nIFVSTFx0LSBoZWxsby5sb2dvdXQgc2hvdWxkIGhhbmRsZSB0aGUgbG9nb3V0XG5cdFx0XHRcdC8vIFVuZGVmaW5lZFx0LSB0aGlzIGZ1bmN0aW9uIHdpbGwgaGFuZGxlIHRoZSBjYWxsYmFja1xuXHRcdFx0XHQvLyBUcnVlIC0gdGhyb3cgYSBzdWNjZXNzLCB0aGlzIGNhbGxiYWNrIGlzbid0IGhhbmRsaW5nIHRoZSBjYWxsYmFja1xuXHRcdFx0XHQvLyBGYWxzZSAtIHRocm93IGEgZXJyb3Jcblx0XHRcdFx0aWYgKCF0b2tlbikge1xuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzbid0IGEgdG9rZW4sIHRoZSBhYm92ZSB3b250IHJldHVybiBhIHJlc3BvbnNlLCBzbyBsZXRzIHRyaWdnZXIgYSByZXNwb25zZVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQVBJIEJhc2UgVVJMXG5cdFx0XHRiYXNlOiAnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vdjIuNC8nLFxuXG5cdFx0XHQvLyBNYXAgR0VUIHJlcXVlc3RzXG5cdFx0XHRnZXQ6IHtcblx0XHRcdFx0bWU6ICdtZT9maWVsZHM9ZW1haWwsZmlyc3RfbmFtZSxsYXN0X25hbWUsbmFtZSx0aW1lem9uZSx2ZXJpZmllZCcsXG5cdFx0XHRcdCdtZS9mcmllbmRzJzogJ21lL2ZyaWVuZHMnLFxuXHRcdFx0XHQnbWUvZm9sbG93aW5nJzogJ21lL2ZyaWVuZHMnLFxuXHRcdFx0XHQnbWUvZm9sbG93ZXJzJzogJ21lL2ZyaWVuZHMnLFxuXHRcdFx0XHQnbWUvc2hhcmUnOiAnbWUvZmVlZCcsXG5cdFx0XHRcdCdtZS9saWtlJzogJ21lL2xpa2VzJyxcblx0XHRcdFx0J21lL2ZpbGVzJzogJ21lL2FsYnVtcycsXG5cdFx0XHRcdCdtZS9hbGJ1bXMnOiAnbWUvYWxidW1zP2ZpZWxkcz1jb3Zlcl9waG90byxuYW1lJyxcblx0XHRcdFx0J21lL2FsYnVtJzogJ0B7aWR9L3Bob3Rvcz9maWVsZHM9cGljdHVyZScsXG5cdFx0XHRcdCdtZS9waG90b3MnOiAnbWUvcGhvdG9zJyxcblx0XHRcdFx0J21lL3Bob3RvJzogJ0B7aWR9Jyxcblx0XHRcdFx0J2ZyaWVuZC9hbGJ1bXMnOiAnQHtpZH0vYWxidW1zJyxcblx0XHRcdFx0J2ZyaWVuZC9waG90b3MnOiAnQHtpZH0vcGhvdG9zJ1xuXG5cdFx0XHRcdC8vIFBhZ2luYXRpb25cblx0XHRcdFx0Ly8gSHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS9kb2NzL3JlZmVyZW5jZS9hcGkvcGFnaW5hdGlvbi9cblx0XHRcdH0sXG5cblx0XHRcdC8vIE1hcCBQT1NUIHJlcXVlc3RzXG5cdFx0XHRwb3N0OiB7XG5cdFx0XHRcdCdtZS9zaGFyZSc6ICdtZS9mZWVkJyxcblx0XHRcdFx0J21lL3Bob3RvJzogJ0B7aWR9J1xuXG5cdFx0XHRcdC8vIEh0dHBzOi8vZGV2ZWxvcGVycy5mYWNlYm9vay5jb20vZG9jcy9ncmFwaC1hcGkvcmVmZXJlbmNlL3YyLjIvb2JqZWN0L2xpa2VzL1xuXHRcdFx0fSxcblxuXHRcdFx0d3JhcDoge1xuXHRcdFx0XHRtZTogZm9ybWF0VXNlcixcblx0XHRcdFx0J21lL2ZyaWVuZHMnOiBmb3JtYXRGcmllbmRzLFxuXHRcdFx0XHQnbWUvZm9sbG93aW5nJzogZm9ybWF0RnJpZW5kcyxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6IGZvcm1hdEZyaWVuZHMsXG5cdFx0XHRcdCdtZS9hbGJ1bXMnOiBmb3JtYXQsXG5cdFx0XHRcdCdtZS9waG90b3MnOiBmb3JtYXQsXG5cdFx0XHRcdCdtZS9maWxlcyc6IGZvcm1hdCxcblx0XHRcdFx0J2RlZmF1bHQnOiBmb3JtYXRcblx0XHRcdH0sXG5cblx0XHRcdC8vIFNwZWNpYWwgcmVxdWlyZW1lbnRzIGZvciBoYW5kbGluZyBYSFJcblx0XHRcdHhocjogZnVuY3Rpb24ocCwgcXMpIHtcblx0XHRcdFx0aWYgKHAubWV0aG9kID09PSAnZ2V0JyB8fCBwLm1ldGhvZCA9PT0gJ3Bvc3QnKSB7XG5cdFx0XHRcdFx0cXMuc3VwcHJlc3NfcmVzcG9uc2VfY29kZXMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSXMgdGhpcyBhIHBvc3Qgd2l0aCBhIGRhdGEtdXJpP1xuXHRcdFx0XHRpZiAocC5tZXRob2QgPT09ICdwb3N0JyAmJiBwLmRhdGEgJiYgdHlwZW9mIChwLmRhdGEuZmlsZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Ly8gQ29udmVydCB0aGUgRGF0YS1VUkkgdG8gYSBCbG9iXG5cdFx0XHRcdFx0cC5kYXRhLmZpbGUgPSBoZWxsby51dGlscy50b0Jsb2IocC5kYXRhLmZpbGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBTcGVjaWFsIHJlcXVpcmVtZW50cyBmb3IgaGFuZGxpbmcgSlNPTlAgZmFsbGJhY2tcblx0XHRcdGpzb25wOiBmdW5jdGlvbihwLCBxcykge1xuXHRcdFx0XHR2YXIgbSA9IHAubWV0aG9kO1xuXHRcdFx0XHRpZiAobSAhPT0gJ2dldCcgJiYgIWhlbGxvLnV0aWxzLmhhc0JpbmFyeShwLmRhdGEpKSB7XG5cdFx0XHRcdFx0cC5kYXRhLm1ldGhvZCA9IG07XG5cdFx0XHRcdFx0cC5tZXRob2QgPSAnZ2V0Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChwLm1ldGhvZCA9PT0gJ2RlbGV0ZScpIHtcblx0XHRcdFx0XHRxcy5tZXRob2QgPSAnZGVsZXRlJztcblx0XHRcdFx0XHRwLm1ldGhvZCA9ICdwb3N0Jztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gU3BlY2lhbCByZXF1aXJlbWVudHMgZm9yIGlmcmFtZSBmb3JtIGhhY2tcblx0XHRcdGZvcm06IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHQvLyBGaXJlIHRoZSBjYWxsYmFjayBvbmxvYWRcblx0XHRcdFx0XHRjYWxsYmFja29ubG9hZDogdHJ1ZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0dmFyIGJhc2UgPSAnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJztcblxuXHRmdW5jdGlvbiBmb3JtYXRVc2VyKG8pIHtcblx0XHRpZiAoby5pZCkge1xuXHRcdFx0by50aHVtYm5haWwgPSBvLnBpY3R1cmUgPSAnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJyArIG8uaWQgKyAnL3BpY3R1cmUnO1xuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0RnJpZW5kcyhvKSB7XG5cdFx0aWYgKCdkYXRhJyBpbiBvKSB7XG5cdFx0XHRvLmRhdGEuZm9yRWFjaChmb3JtYXRVc2VyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdChvLCBoZWFkZXJzLCByZXEpIHtcblx0XHRpZiAodHlwZW9mIG8gPT09ICdib29sZWFuJykge1xuXHRcdFx0byA9IHtzdWNjZXNzOiBvfTtcblx0XHR9XG5cblx0XHRpZiAobyAmJiAnZGF0YScgaW4gbykge1xuXHRcdFx0dmFyIHRva2VuID0gcmVxLnF1ZXJ5LmFjY2Vzc190b2tlbjtcblxuXHRcdFx0aWYgKCEoby5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRcdHZhciBkYXRhID0gby5kYXRhO1xuXHRcdFx0XHRkZWxldGUgby5kYXRhO1xuXHRcdFx0XHRvLmRhdGEgPSBbZGF0YV07XG5cdFx0XHR9XG5cblx0XHRcdG8uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcblxuXHRcdFx0XHRpZiAoZC5waWN0dXJlKSB7XG5cdFx0XHRcdFx0ZC50aHVtYm5haWwgPSBkLnBpY3R1cmU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkLnBpY3R1cmVzID0gKGQuaW1hZ2VzIHx8IFtdKVxuXHRcdFx0XHRcdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhLndpZHRoIC0gYi53aWR0aDtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoZC5jb3Zlcl9waG90byAmJiBkLmNvdmVyX3Bob3RvLmlkKSB7XG5cdFx0XHRcdFx0ZC50aHVtYm5haWwgPSBiYXNlICsgZC5jb3Zlcl9waG90by5pZCArICcvcGljdHVyZT9hY2Nlc3NfdG9rZW49JyArIHRva2VuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGQudHlwZSA9PT0gJ2FsYnVtJykge1xuXHRcdFx0XHRcdGQuZmlsZXMgPSBkLnBob3RvcyA9IGJhc2UgKyBkLmlkICsgJy9waG90b3MnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGQuY2FuX3VwbG9hZCkge1xuXHRcdFx0XHRcdGQudXBsb2FkX2xvY2F0aW9uID0gYmFzZSArIGQuaWQgKyAnL3Bob3Rvcyc7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cbn0pKGhlbGxvKTtcblxuKGZ1bmN0aW9uKGhlbGxvKSB7XG5cblx0aGVsbG8uaW5pdCh7XG5cblx0XHRmbGlja3I6IHtcblxuXHRcdFx0bmFtZTogJ0ZsaWNrcicsXG5cblx0XHRcdC8vIEVuc3VyZSB0aGF0IHlvdSBkZWZpbmUgYW4gb2F1dGhfcHJveHlcblx0XHRcdG9hdXRoOiB7XG5cdFx0XHRcdHZlcnNpb246ICcxLjBhJyxcblx0XHRcdFx0YXV0aDogJ2h0dHBzOi8vd3d3LmZsaWNrci5jb20vc2VydmljZXMvb2F1dGgvYXV0aG9yaXplP3Blcm1zPXJlYWQnLFxuXHRcdFx0XHRyZXF1ZXN0OiAnaHR0cHM6Ly93d3cuZmxpY2tyLmNvbS9zZXJ2aWNlcy9vYXV0aC9yZXF1ZXN0X3Rva2VuJyxcblx0XHRcdFx0dG9rZW46ICdodHRwczovL3d3dy5mbGlja3IuY29tL3NlcnZpY2VzL29hdXRoL2FjY2Vzc190b2tlbidcblx0XHRcdH0sXG5cblx0XHRcdC8vIEFQSSBiYXNlIFVSTFxuXHRcdFx0YmFzZTogJ2h0dHBzOi8vYXBpLmZsaWNrci5jb20vc2VydmljZXMvcmVzdCcsXG5cblx0XHRcdC8vIE1hcCBHRVQgcmVzcXVlc3RzXG5cdFx0XHRnZXQ6IHtcblx0XHRcdFx0bWU6IHNpZ24oJ2ZsaWNrci5wZW9wbGUuZ2V0SW5mbycpLFxuXHRcdFx0XHQnbWUvZnJpZW5kcyc6IHNpZ24oJ2ZsaWNrci5jb250YWN0cy5nZXRMaXN0Jywge3Blcl9wYWdlOidAe2xpbWl0fDUwfSd9KSxcblx0XHRcdFx0J21lL2ZvbGxvd2luZyc6IHNpZ24oJ2ZsaWNrci5jb250YWN0cy5nZXRMaXN0Jywge3Blcl9wYWdlOidAe2xpbWl0fDUwfSd9KSxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6IHNpZ24oJ2ZsaWNrci5jb250YWN0cy5nZXRMaXN0Jywge3Blcl9wYWdlOidAe2xpbWl0fDUwfSd9KSxcblx0XHRcdFx0J21lL2FsYnVtcyc6IHNpZ24oJ2ZsaWNrci5waG90b3NldHMuZ2V0TGlzdCcsIHtwZXJfcGFnZTonQHtsaW1pdHw1MH0nfSksXG5cdFx0XHRcdCdtZS9hbGJ1bSc6IHNpZ24oJ2ZsaWNrci5waG90b3NldHMuZ2V0UGhvdG9zJywge3Bob3Rvc2V0X2lkOiAnQHtpZH0nfSksXG5cdFx0XHRcdCdtZS9waG90b3MnOiBzaWduKCdmbGlja3IucGVvcGxlLmdldFBob3RvcycsIHtwZXJfcGFnZTonQHtsaW1pdHw1MH0nfSlcblx0XHRcdH0sXG5cblx0XHRcdHdyYXA6IHtcblx0XHRcdFx0bWU6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdFx0XHRmb3JtYXRFcnJvcihvKTtcblx0XHRcdFx0XHRvID0gY2hlY2tSZXNwb25zZShvLCAncGVyc29uJyk7XG5cdFx0XHRcdFx0aWYgKG8uaWQpIHtcblx0XHRcdFx0XHRcdGlmIChvLnJlYWxuYW1lKSB7XG5cdFx0XHRcdFx0XHRcdG8ubmFtZSA9IG8ucmVhbG5hbWUuX2NvbnRlbnQ7XG5cdFx0XHRcdFx0XHRcdHZhciBtID0gby5uYW1lLnNwbGl0KCcgJyk7XG5cdFx0XHRcdFx0XHRcdG8uZmlyc3RfbmFtZSA9IG0uc2hpZnQoKTtcblx0XHRcdFx0XHRcdFx0by5sYXN0X25hbWUgPSBtLmpvaW4oJyAnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0by50aHVtYm5haWwgPSBnZXRCdWRkeUljb24obywgJ2wnKTtcblx0XHRcdFx0XHRcdG8ucGljdHVyZSA9IGdldEJ1ZGR5SWNvbihvLCAnbCcpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdCdtZS9mcmllbmRzJzogZm9ybWF0RnJpZW5kcyxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6IGZvcm1hdEZyaWVuZHMsXG5cdFx0XHRcdCdtZS9mb2xsb3dpbmcnOiBmb3JtYXRGcmllbmRzLFxuXHRcdFx0XHQnbWUvYWxidW1zJzogZnVuY3Rpb24obykge1xuXHRcdFx0XHRcdGZvcm1hdEVycm9yKG8pO1xuXHRcdFx0XHRcdG8gPSBjaGVja1Jlc3BvbnNlKG8sICdwaG90b3NldHMnKTtcblx0XHRcdFx0XHRwYWdpbmcobyk7XG5cdFx0XHRcdFx0aWYgKG8ucGhvdG9zZXQpIHtcblx0XHRcdFx0XHRcdG8uZGF0YSA9IG8ucGhvdG9zZXQ7XG5cdFx0XHRcdFx0XHRvLmRhdGEuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0ubmFtZSA9IGl0ZW0udGl0bGUuX2NvbnRlbnQ7XG5cdFx0XHRcdFx0XHRcdGl0ZW0ucGhvdG9zID0gJ2h0dHBzOi8vYXBpLmZsaWNrci5jb20vc2VydmljZXMvcmVzdCcgKyBnZXRBcGlVcmwoJ2ZsaWNrci5waG90b3NldHMuZ2V0UGhvdG9zJywge3Bob3Rvc2V0X2lkOiBpdGVtLmlkfSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0ZGVsZXRlIG8ucGhvdG9zZXQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0J21lL3Bob3Rvcyc6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdFx0XHRmb3JtYXRFcnJvcihvKTtcblx0XHRcdFx0XHRyZXR1cm4gZm9ybWF0UGhvdG9zKG8pO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdCdkZWZhdWx0JzogZnVuY3Rpb24obykge1xuXHRcdFx0XHRcdGZvcm1hdEVycm9yKG8pO1xuXHRcdFx0XHRcdHJldHVybiBmb3JtYXRQaG90b3Mobyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHhocjogZmFsc2UsXG5cblx0XHRcdGpzb25wOiBmdW5jdGlvbihwLCBxcykge1xuXHRcdFx0XHRpZiAocC5tZXRob2QgPT0gJ2dldCcpIHtcblx0XHRcdFx0XHRkZWxldGUgcXMuY2FsbGJhY2s7XG5cdFx0XHRcdFx0cXMuanNvbmNhbGxiYWNrID0gcC5jYWxsYmFja0lEO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBnZXRBcGlVcmwobWV0aG9kLCBleHRyYVBhcmFtcywgc2tpcE5ldHdvcmspIHtcblx0XHR2YXIgdXJsID0gKChza2lwTmV0d29yaykgPyAnJyA6ICdmbGlja3I6JykgK1xuXHRcdFx0Jz9tZXRob2Q9JyArIG1ldGhvZCArXG5cdFx0XHQnJmFwaV9rZXk9JyArIGhlbGxvLnNlcnZpY2VzLmZsaWNrci5pZCArXG5cdFx0XHQnJmZvcm1hdD1qc29uJztcblx0XHRmb3IgKHZhciBwYXJhbSBpbiBleHRyYVBhcmFtcykge1xuXHRcdFx0aWYgKGV4dHJhUGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtKSkge1xuXHRcdFx0XHR1cmwgKz0gJyYnICsgcGFyYW0gKyAnPScgKyBleHRyYVBhcmFtc1twYXJhbV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVybDtcblx0fVxuXG5cdC8vIFRoaXMgaXMgbm90IGV4YWN0bHkgbmVhdCBidXQgYXZvaWQgdG8gY2FsbFxuXHQvLyBUaGUgbWV0aG9kICdmbGlja3IudGVzdC5sb2dpbicgZm9yIGVhY2ggYXBpIGNhbGxcblxuXHRmdW5jdGlvbiB3aXRoVXNlcihjYikge1xuXHRcdHZhciBhdXRoID0gaGVsbG8uZ2V0QXV0aFJlc3BvbnNlKCdmbGlja3InKTtcblx0XHRjYihhdXRoICYmIGF1dGgudXNlcl9uc2lkID8gYXV0aC51c2VyX25zaWQgOiBudWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNpZ24odXJsLCBwYXJhbXMpIHtcblx0XHRpZiAoIXBhcmFtcykge1xuXHRcdFx0cGFyYW1zID0ge307XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHAsIGNhbGxiYWNrKSB7XG5cdFx0XHR3aXRoVXNlcihmdW5jdGlvbih1c2VySWQpIHtcblx0XHRcdFx0cGFyYW1zLnVzZXJfaWQgPSB1c2VySWQ7XG5cdFx0XHRcdGNhbGxiYWNrKGdldEFwaVVybCh1cmwsIHBhcmFtcywgdHJ1ZSkpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJ1ZGR5SWNvbihwcm9maWxlLCBzaXplKSB7XG5cdFx0dmFyIHVybCA9ICdodHRwczovL3d3dy5mbGlja3IuY29tL2ltYWdlcy9idWRkeWljb24uZ2lmJztcblx0XHRpZiAocHJvZmlsZS5uc2lkICYmIHByb2ZpbGUuaWNvbnNlcnZlciAmJiBwcm9maWxlLmljb25mYXJtKSB7XG5cdFx0XHR1cmwgPSAnaHR0cHM6Ly9mYXJtJyArIHByb2ZpbGUuaWNvbmZhcm0gKyAnLnN0YXRpY2ZsaWNrci5jb20vJyArXG5cdFx0XHRcdHByb2ZpbGUuaWNvbnNlcnZlciArICcvJyArXG5cdFx0XHRcdCdidWRkeWljb25zLycgKyBwcm9maWxlLm5zaWQgK1xuXHRcdFx0XHQoKHNpemUpID8gJ18nICsgc2l6ZSA6ICcnKSArICcuanBnJztcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJsO1xuXHR9XG5cblx0Ly8gU2VlOiBodHRwczovL3d3dy5mbGlja3IuY29tL3NlcnZpY2VzL2FwaS9taXNjLnVybHMuaHRtbFxuXHRmdW5jdGlvbiBjcmVhdGVQaG90b1VybChpZCwgZmFybSwgc2VydmVyLCBzZWNyZXQsIHNpemUpIHtcblx0XHRzaXplID0gKHNpemUpID8gJ18nICsgc2l6ZSA6ICcnO1xuXHRcdHJldHVybiAnaHR0cHM6Ly9mYXJtJyArIGZhcm0gKyAnLnN0YXRpY2ZsaWNrci5jb20vJyArIHNlcnZlciArICcvJyArIGlkICsgJ18nICsgc2VjcmV0ICsgc2l6ZSArICcuanBnJztcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdFVzZXIobykge1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0RXJyb3Iobykge1xuXHRcdGlmIChvICYmIG8uc3RhdCAmJiBvLnN0YXQudG9Mb3dlckNhc2UoKSAhPSAnb2snKSB7XG5cdFx0XHRvLmVycm9yID0ge1xuXHRcdFx0XHRjb2RlOiAnaW52YWxpZF9yZXF1ZXN0Jyxcblx0XHRcdFx0bWVzc2FnZTogby5tZXNzYWdlXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdFBob3RvcyhvKSB7XG5cdFx0aWYgKG8ucGhvdG9zZXQgfHwgby5waG90b3MpIHtcblx0XHRcdHZhciBzZXQgPSAoJ3Bob3Rvc2V0JyBpbiBvKSA/ICdwaG90b3NldCcgOiAncGhvdG9zJztcblx0XHRcdG8gPSBjaGVja1Jlc3BvbnNlKG8sIHNldCk7XG5cdFx0XHRwYWdpbmcobyk7XG5cdFx0XHRvLmRhdGEgPSBvLnBob3RvO1xuXHRcdFx0ZGVsZXRlIG8ucGhvdG87XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG8uZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGhvdG8gPSBvLmRhdGFbaV07XG5cdFx0XHRcdHBob3RvLm5hbWUgPSBwaG90by50aXRsZTtcblx0XHRcdFx0cGhvdG8ucGljdHVyZSA9IGNyZWF0ZVBob3RvVXJsKHBob3RvLmlkLCBwaG90by5mYXJtLCBwaG90by5zZXJ2ZXIsIHBob3RvLnNlY3JldCwgJycpO1xuXHRcdFx0XHRwaG90by5waWN0dXJlcyA9IGNyZWF0ZVBpY3R1cmVzKHBob3RvLmlkLCBwaG90by5mYXJtLCBwaG90by5zZXJ2ZXIsIHBob3RvLnNlY3JldCk7XG5cdFx0XHRcdHBob3RvLnNvdXJjZSA9IGNyZWF0ZVBob3RvVXJsKHBob3RvLmlkLCBwaG90by5mYXJtLCBwaG90by5zZXJ2ZXIsIHBob3RvLnNlY3JldCwgJ2InKTtcblx0XHRcdFx0cGhvdG8udGh1bWJuYWlsID0gY3JlYXRlUGhvdG9VcmwocGhvdG8uaWQsIHBob3RvLmZhcm0sIHBob3RvLnNlcnZlciwgcGhvdG8uc2VjcmV0LCAnbScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0Ly8gU2VlOiBodHRwczovL3d3dy5mbGlja3IuY29tL3NlcnZpY2VzL2FwaS9taXNjLnVybHMuaHRtbFxuXHRmdW5jdGlvbiBjcmVhdGVQaWN0dXJlcyhpZCwgZmFybSwgc2VydmVyLCBzZWNyZXQpIHtcblxuXHRcdHZhciBOT19MSU1JVCA9IDIwNDg7XG5cdFx0dmFyIHNpemVzID0gW1xuXHRcdFx0e2lkOiAndCcsIG1heDogMTAwfSxcblx0XHRcdHtpZDogJ20nLCBtYXg6IDI0MH0sXG5cdFx0XHR7aWQ6ICduJywgbWF4OiAzMjB9LFxuXHRcdFx0e2lkOiAnJywgbWF4OiA1MDB9LFxuXHRcdFx0e2lkOiAneicsIG1heDogNjQwfSxcblx0XHRcdHtpZDogJ2MnLCBtYXg6IDgwMH0sXG5cdFx0XHR7aWQ6ICdiJywgbWF4OiAxMDI0fSxcblx0XHRcdHtpZDogJ2gnLCBtYXg6IDE2MDB9LFxuXHRcdFx0e2lkOiAnaycsIG1heDogMjA0OH0sXG5cdFx0XHR7aWQ6ICdvJywgbWF4OiBOT19MSU1JVH1cblx0XHRdO1xuXG5cdFx0cmV0dXJuIHNpemVzLm1hcChmdW5jdGlvbihzaXplKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzb3VyY2U6IGNyZWF0ZVBob3RvVXJsKGlkLCBmYXJtLCBzZXJ2ZXIsIHNlY3JldCwgc2l6ZS5pZCksXG5cblx0XHRcdFx0Ly8gTm90ZTogdGhpcyBpcyBhIGd1ZXNzIHRoYXQncyBhbG1vc3QgY2VydGFpbiB0byBiZSB3cm9uZyAodW5sZXNzIHNxdWFyZSBzb3VyY2UpXG5cdFx0XHRcdHdpZHRoOiBzaXplLm1heCxcblx0XHRcdFx0aGVpZ2h0OiBzaXplLm1heFxuXHRcdFx0fTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrUmVzcG9uc2Uobywga2V5KSB7XG5cblx0XHRpZiAoa2V5IGluIG8pIHtcblx0XHRcdG8gPSBvW2tleV07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCEoJ2Vycm9yJyBpbiBvKSkge1xuXHRcdFx0by5lcnJvciA9IHtcblx0XHRcdFx0Y29kZTogJ2ludmFsaWRfcmVxdWVzdCcsXG5cdFx0XHRcdG1lc3NhZ2U6IG8ubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGdldCBkYXRhIGZyb20gRmxpY2tyJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdEZyaWVuZHMobykge1xuXHRcdGZvcm1hdEVycm9yKG8pO1xuXHRcdGlmIChvLmNvbnRhY3RzKSB7XG5cdFx0XHRvID0gY2hlY2tSZXNwb25zZShvLCAnY29udGFjdHMnKTtcblx0XHRcdHBhZ2luZyhvKTtcblx0XHRcdG8uZGF0YSA9IG8uY29udGFjdDtcblx0XHRcdGRlbGV0ZSBvLmNvbnRhY3Q7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG8uZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IG8uZGF0YVtpXTtcblx0XHRcdFx0aXRlbS5pZCA9IGl0ZW0ubnNpZDtcblx0XHRcdFx0aXRlbS5uYW1lID0gaXRlbS5yZWFsbmFtZSB8fCBpdGVtLnVzZXJuYW1lO1xuXHRcdFx0XHRpdGVtLnRodW1ibmFpbCA9IGdldEJ1ZGR5SWNvbihpdGVtLCAnbScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFnaW5nKHJlcykge1xuXHRcdGlmIChyZXMucGFnZSAmJiByZXMucGFnZXMgJiYgcmVzLnBhZ2UgIT09IHJlcy5wYWdlcykge1xuXHRcdFx0cmVzLnBhZ2luZyA9IHtcblx0XHRcdFx0bmV4dDogJz9wYWdlPScgKyAoKytyZXMucGFnZSlcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cbn0pKGhlbGxvKTtcblxuKGZ1bmN0aW9uKGhlbGxvKSB7XG5cblx0aGVsbG8uaW5pdCh7XG5cblx0XHRmb3Vyc3F1YXJlOiB7XG5cblx0XHRcdG5hbWU6ICdGb3Vyc3F1YXJlJyxcblxuXHRcdFx0b2F1dGg6IHtcblx0XHRcdFx0Ly8gU2VlOiBodHRwczovL2RldmVsb3Blci5mb3Vyc3F1YXJlLmNvbS9vdmVydmlldy9hdXRoXG5cdFx0XHRcdHZlcnNpb246IDIsXG5cdFx0XHRcdGF1dGg6ICdodHRwczovL2ZvdXJzcXVhcmUuY29tL29hdXRoMi9hdXRoZW50aWNhdGUnLFxuXHRcdFx0XHRncmFudDogJ2h0dHBzOi8vZm91cnNxdWFyZS5jb20vb2F1dGgyL2FjY2Vzc190b2tlbidcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlZnJlc2ggdGhlIGFjY2Vzc190b2tlbiBvbmNlIGV4cGlyZWRcblx0XHRcdHJlZnJlc2g6IHRydWUsXG5cblx0XHRcdGJhc2U6ICdodHRwczovL2FwaS5mb3Vyc3F1YXJlLmNvbS92Mi8nLFxuXG5cdFx0XHRnZXQ6IHtcblx0XHRcdFx0bWU6ICd1c2Vycy9zZWxmJyxcblx0XHRcdFx0J21lL2ZyaWVuZHMnOiAndXNlcnMvc2VsZi9mcmllbmRzJyxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6ICd1c2Vycy9zZWxmL2ZyaWVuZHMnLFxuXHRcdFx0XHQnbWUvZm9sbG93aW5nJzogJ3VzZXJzL3NlbGYvZnJpZW5kcydcblx0XHRcdH0sXG5cblx0XHRcdHdyYXA6IHtcblx0XHRcdFx0bWU6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdFx0XHRmb3JtYXRFcnJvcihvKTtcblx0XHRcdFx0XHRpZiAobyAmJiBvLnJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0XHRvID0gby5yZXNwb25zZS51c2VyO1xuXHRcdFx0XHRcdFx0Zm9ybWF0VXNlcihvKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQnZGVmYXVsdCc6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdFx0XHRmb3JtYXRFcnJvcihvKTtcblxuXHRcdFx0XHRcdC8vIEZvcm1hdCBmcmllbmRzXG5cdFx0XHRcdFx0aWYgKG8gJiYgJ3Jlc3BvbnNlJyBpbiBvICYmICdmcmllbmRzJyBpbiBvLnJlc3BvbnNlICYmICdpdGVtcycgaW4gby5yZXNwb25zZS5mcmllbmRzKSB7XG5cdFx0XHRcdFx0XHRvLmRhdGEgPSBvLnJlc3BvbnNlLmZyaWVuZHMuaXRlbXM7XG5cdFx0XHRcdFx0XHRvLmRhdGEuZm9yRWFjaChmb3JtYXRVc2VyKTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBvLnJlc3BvbnNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHR4aHI6IGZvcm1hdFJlcXVlc3QsXG5cdFx0XHRqc29ucDogZm9ybWF0UmVxdWVzdFxuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gZm9ybWF0RXJyb3Iobykge1xuXHRcdGlmIChvLm1ldGEgJiYgKG8ubWV0YS5jb2RlID09PSA0MDAgfHwgby5tZXRhLmNvZGUgPT09IDQwMSkpIHtcblx0XHRcdG8uZXJyb3IgPSB7XG5cdFx0XHRcdGNvZGU6ICdhY2Nlc3NfZGVuaWVkJyxcblx0XHRcdFx0bWVzc2FnZTogby5tZXRhLmVycm9yRGV0YWlsXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdFVzZXIobykge1xuXHRcdGlmIChvICYmIG8uaWQpIHtcblx0XHRcdG8udGh1bWJuYWlsID0gby5waG90by5wcmVmaXggKyAnMTAweDEwMCcgKyBvLnBob3RvLnN1ZmZpeDtcblx0XHRcdG8ubmFtZSA9IG8uZmlyc3ROYW1lICsgJyAnICsgby5sYXN0TmFtZTtcblx0XHRcdG8uZmlyc3RfbmFtZSA9IG8uZmlyc3ROYW1lO1xuXHRcdFx0by5sYXN0X25hbWUgPSBvLmxhc3ROYW1lO1xuXHRcdFx0aWYgKG8uY29udGFjdCkge1xuXHRcdFx0XHRpZiAoby5jb250YWN0LmVtYWlsKSB7XG5cdFx0XHRcdFx0by5lbWFpbCA9IG8uY29udGFjdC5lbWFpbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdFJlcXVlc3QocCwgcXMpIHtcblx0XHR2YXIgdG9rZW4gPSBxcy5hY2Nlc3NfdG9rZW47XG5cdFx0ZGVsZXRlIHFzLmFjY2Vzc190b2tlbjtcblx0XHRxcy5vYXV0aF90b2tlbiA9IHRva2VuO1xuXHRcdHFzLnYgPSAyMDEyMTEyNTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG59KShoZWxsbyk7XG5cbihmdW5jdGlvbihoZWxsbykge1xuXG5cdGhlbGxvLmluaXQoe1xuXG5cdFx0Z2l0aHViOiB7XG5cblx0XHRcdG5hbWU6ICdHaXRIdWInLFxuXG5cdFx0XHRvYXV0aDoge1xuXHRcdFx0XHR2ZXJzaW9uOiAyLFxuXHRcdFx0XHRhdXRoOiAnaHR0cHM6Ly9naXRodWIuY29tL2xvZ2luL29hdXRoL2F1dGhvcml6ZScsXG5cdFx0XHRcdGdyYW50OiAnaHR0cHM6Ly9naXRodWIuY29tL2xvZ2luL29hdXRoL2FjY2Vzc190b2tlbicsXG5cdFx0XHRcdHJlc3BvbnNlX3R5cGU6ICdjb2RlJ1xuXHRcdFx0fSxcblxuXHRcdFx0c2NvcGU6IHtcblx0XHRcdFx0ZW1haWw6ICd1c2VyOmVtYWlsJ1xuXHRcdFx0fSxcblxuXHRcdFx0YmFzZTogJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vJyxcblxuXHRcdFx0Z2V0OiB7XG5cdFx0XHRcdG1lOiAndXNlcicsXG5cdFx0XHRcdCdtZS9mcmllbmRzJzogJ3VzZXIvZm9sbG93aW5nP3Blcl9wYWdlPUB7bGltaXR8MTAwfScsXG5cdFx0XHRcdCdtZS9mb2xsb3dpbmcnOiAndXNlci9mb2xsb3dpbmc/cGVyX3BhZ2U9QHtsaW1pdHwxMDB9Jyxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6ICd1c2VyL2ZvbGxvd2Vycz9wZXJfcGFnZT1Ae2xpbWl0fDEwMH0nLFxuXHRcdFx0XHQnbWUvbGlrZSc6ICd1c2VyL3N0YXJyZWQ/cGVyX3BhZ2U9QHtsaW1pdHwxMDB9J1xuXHRcdFx0fSxcblxuXHRcdFx0d3JhcDoge1xuXHRcdFx0XHRtZTogZnVuY3Rpb24obywgaGVhZGVycykge1xuXG5cdFx0XHRcdFx0Zm9ybWF0RXJyb3IobywgaGVhZGVycyk7XG5cdFx0XHRcdFx0Zm9ybWF0VXNlcihvKTtcblxuXHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdCdkZWZhdWx0JzogZnVuY3Rpb24obywgaGVhZGVycywgcmVxKSB7XG5cblx0XHRcdFx0XHRmb3JtYXRFcnJvcihvLCBoZWFkZXJzKTtcblxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG5cdFx0XHRcdFx0XHRvID0ge2RhdGE6b307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG8uZGF0YSkge1xuXHRcdFx0XHRcdFx0cGFnaW5nKG8sIGhlYWRlcnMsIHJlcSk7XG5cdFx0XHRcdFx0XHRvLmRhdGEuZm9yRWFjaChmb3JtYXRVc2VyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0eGhyOiBmdW5jdGlvbihwKSB7XG5cblx0XHRcdFx0aWYgKHAubWV0aG9kICE9PSAnZ2V0JyAmJiBwLmRhdGEpIHtcblxuXHRcdFx0XHRcdC8vIFNlcmlhbGl6ZSBwYXlsb2FkIGFzIEpTT05cblx0XHRcdFx0XHRwLmhlYWRlcnMgPSBwLmhlYWRlcnMgfHwge307XG5cdFx0XHRcdFx0cC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcblx0XHRcdFx0XHRpZiAodHlwZW9mIChwLmRhdGEpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0cC5kYXRhID0gSlNPTi5zdHJpbmdpZnkocC5kYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGZvcm1hdEVycm9yKG8sIGhlYWRlcnMpIHtcblx0XHR2YXIgY29kZSA9IGhlYWRlcnMgPyBoZWFkZXJzLnN0YXR1c0NvZGUgOiAobyAmJiAnbWV0YScgaW4gbyAmJiAnc3RhdHVzJyBpbiBvLm1ldGEgJiYgby5tZXRhLnN0YXR1cyk7XG5cdFx0aWYgKChjb2RlID09PSA0MDEgfHwgY29kZSA9PT0gNDAzKSkge1xuXHRcdFx0by5lcnJvciA9IHtcblx0XHRcdFx0Y29kZTogJ2FjY2Vzc19kZW5pZWQnLFxuXHRcdFx0XHRtZXNzYWdlOiBvLm1lc3NhZ2UgfHwgKG8uZGF0YSA/IG8uZGF0YS5tZXNzYWdlIDogJ0NvdWxkIG5vdCBnZXQgcmVzcG9uc2UnKVxuXHRcdFx0fTtcblx0XHRcdGRlbGV0ZSBvLm1lc3NhZ2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0VXNlcihvKSB7XG5cdFx0aWYgKG8uaWQpIHtcblx0XHRcdG8udGh1bWJuYWlsID0gby5waWN0dXJlID0gby5hdmF0YXJfdXJsO1xuXHRcdFx0by5uYW1lID0gby5sb2dpbjtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwYWdpbmcocmVzLCBoZWFkZXJzLCByZXEpIHtcblx0XHRpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEubGVuZ3RoICYmIGhlYWRlcnMgJiYgaGVhZGVycy5MaW5rKSB7XG5cdFx0XHR2YXIgbmV4dCA9IGhlYWRlcnMuTGluay5tYXRjaCgvPCguKj8pPjtcXHMqcmVsPVxcXCJuZXh0XFxcIi8pO1xuXHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0cmVzLnBhZ2luZyA9IHtcblx0XHRcdFx0XHRuZXh0OiBuZXh0WzFdXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn0pKGhlbGxvKTtcblxuKGZ1bmN0aW9uKGhlbGxvKSB7XG5cblx0dmFyIGNvbnRhY3RzVXJsID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20vbTgvZmVlZHMvY29udGFjdHMvZGVmYXVsdC9mdWxsP3Y9My4wJmFsdD1qc29uJm1heC1yZXN1bHRzPUB7bGltaXR8MTAwMH0mc3RhcnQtaW5kZXg9QHtzdGFydHwxfSc7XG5cblx0aGVsbG8uaW5pdCh7XG5cblx0XHRnb29nbGU6IHtcblxuXHRcdFx0bmFtZTogJ0dvb2dsZSBQbHVzJyxcblxuXHRcdFx0Ly8gU2VlOiBodHRwOi8vY29kZS5nb29nbGUuY29tL2FwaXMvYWNjb3VudHMvZG9jcy9PQXV0aDJVc2VyQWdlbnQuaHRtbFxuXHRcdFx0b2F1dGg6IHtcblx0XHRcdFx0dmVyc2lvbjogMixcblx0XHRcdFx0YXV0aDogJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi9hdXRoJyxcblx0XHRcdFx0Z3JhbnQ6ICdodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20vby9vYXV0aDIvdG9rZW4nXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBBdXRob3JpemF0aW9uIHNjb3Blc1xuXHRcdFx0c2NvcGU6IHtcblx0XHRcdFx0YmFzaWM6ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL3BsdXMubWUgcHJvZmlsZScsXG5cdFx0XHRcdGVtYWlsOiAnZW1haWwnLFxuXHRcdFx0XHRiaXJ0aGRheTogJycsXG5cdFx0XHRcdGV2ZW50czogJycsXG5cdFx0XHRcdHBob3RvczogJ2h0dHBzOi8vcGljYXNhd2ViLmdvb2dsZS5jb20vZGF0YS8nLFxuXHRcdFx0XHR2aWRlb3M6ICdodHRwOi8vZ2RhdGEueW91dHViZS5jb20nLFxuXHRcdFx0XHRmcmllbmRzOiAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tOC9mZWVkcywgaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9wbHVzLmxvZ2luJyxcblx0XHRcdFx0ZmlsZXM6ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLnJlYWRvbmx5Jyxcblx0XHRcdFx0cHVibGlzaDogJycsXG5cdFx0XHRcdHB1Ymxpc2hfZmlsZXM6ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlJyxcblx0XHRcdFx0c2hhcmU6ICcnLFxuXHRcdFx0XHRjcmVhdGVfZXZlbnQ6ICcnLFxuXHRcdFx0XHRvZmZsaW5lX2FjY2VzczogJydcblx0XHRcdH0sXG5cblx0XHRcdHNjb3BlX2RlbGltOiAnICcsXG5cblx0XHRcdGxvZ2luOiBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmIChwLnFzLmRpc3BsYXkgPT09ICdub25lJykge1xuXHRcdFx0XHRcdC8vIEdvb2dsZSBkb2Vzbid0IGxpa2UgZGlzcGxheT1ub25lXG5cdFx0XHRcdFx0cC5xcy5kaXNwbGF5ID0gJyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocC5xcy5yZXNwb25zZV90eXBlID09PSAnY29kZScpIHtcblxuXHRcdFx0XHRcdC8vIExldCdzIHNldCB0aGlzIHRvIGFuIG9mZmxpbmUgYWNjZXNzIHRvIHJldHVybiBhIHJlZnJlc2hfdG9rZW5cblx0XHRcdFx0XHRwLnFzLmFjY2Vzc190eXBlID0gJ29mZmxpbmUnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVhdXRoZW50aWNhdGVcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vaWRlbnRpdHkvcHJvdG9jb2xzL1xuXHRcdFx0XHRpZiAocC5vcHRpb25zLmZvcmNlKSB7XG5cdFx0XHRcdFx0cC5xcy5hcHByb3ZhbF9wcm9tcHQgPSAnZm9yY2UnO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBBUEkgYmFzZSBVUklcblx0XHRcdGJhc2U6ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS8nLFxuXG5cdFx0XHQvLyBNYXAgR0VUIHJlcXVlc3RzXG5cdFx0XHRnZXQ6IHtcblx0XHRcdFx0bWU6ICdwbHVzL3YxL3Blb3BsZS9tZScsXG5cblx0XHRcdFx0Ly8gRGVwcmVjYXRlZCBTZXB0IDEsIDIwMTRcblx0XHRcdFx0Ly8nbWUnOiAnb2F1dGgyL3YxL3VzZXJpbmZvP2FsdD1qc29uJyxcblxuXHRcdFx0XHQvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tLysvYXBpL2xhdGVzdC9wZW9wbGUvbGlzdFxuXHRcdFx0XHQnbWUvZnJpZW5kcyc6ICdwbHVzL3YxL3Blb3BsZS9tZS9wZW9wbGUvdmlzaWJsZT9tYXhSZXN1bHRzPUB7bGltaXR8MTAwfScsXG5cdFx0XHRcdCdtZS9mb2xsb3dpbmcnOiBjb250YWN0c1VybCxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6IGNvbnRhY3RzVXJsLFxuXHRcdFx0XHQnbWUvY29udGFjdHMnOiBjb250YWN0c1VybCxcblx0XHRcdFx0J21lL3NoYXJlJzogJ3BsdXMvdjEvcGVvcGxlL21lL2FjdGl2aXRpZXMvcHVibGljP21heFJlc3VsdHM9QHtsaW1pdHwxMDB9Jyxcblx0XHRcdFx0J21lL2ZlZWQnOiAncGx1cy92MS9wZW9wbGUvbWUvYWN0aXZpdGllcy9wdWJsaWM/bWF4UmVzdWx0cz1Ae2xpbWl0fDEwMH0nLFxuXHRcdFx0XHQnbWUvYWxidW1zJzogJ2h0dHBzOi8vcGljYXNhd2ViLmdvb2dsZS5jb20vZGF0YS9mZWVkL2FwaS91c2VyL2RlZmF1bHQ/YWx0PWpzb24mbWF4LXJlc3VsdHM9QHtsaW1pdHwxMDB9JnN0YXJ0LWluZGV4PUB7c3RhcnR8MX0nLFxuXHRcdFx0XHQnbWUvYWxidW0nOiBmdW5jdGlvbihwLCBjYWxsYmFjaykge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBwLnF1ZXJ5LmlkO1xuXHRcdFx0XHRcdGRlbGV0ZSBwLnF1ZXJ5LmlkO1xuXHRcdFx0XHRcdGNhbGxiYWNrKGtleS5yZXBsYWNlKCcvZW50cnkvJywgJy9mZWVkLycpKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQnbWUvcGhvdG9zJzogJ2h0dHBzOi8vcGljYXNhd2ViLmdvb2dsZS5jb20vZGF0YS9mZWVkL2FwaS91c2VyL2RlZmF1bHQ/YWx0PWpzb24ma2luZD1waG90byZtYXgtcmVzdWx0cz1Ae2xpbWl0fDEwMH0mc3RhcnQtaW5kZXg9QHtzdGFydHwxfScsXG5cblx0XHRcdFx0Ly8gU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9kcml2ZS92Mi9yZWZlcmVuY2UvZmlsZXMvbGlzdFxuXHRcdFx0XHQnbWUvZmlsZSc6ICdkcml2ZS92Mi9maWxlcy9Ae2lkfScsXG5cdFx0XHRcdCdtZS9maWxlcyc6ICdkcml2ZS92Mi9maWxlcz9xPSUyMkB7cGFyZW50fHJvb3R9JTIyK2luK3BhcmVudHMrYW5kK3RyYXNoZWQ9ZmFsc2UmbWF4UmVzdWx0cz1Ae2xpbWl0fDEwMH0nLFxuXG5cdFx0XHRcdC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vZHJpdmUvdjIvcmVmZXJlbmNlL2ZpbGVzL2xpc3Rcblx0XHRcdFx0J21lL2ZvbGRlcnMnOiAnZHJpdmUvdjIvZmlsZXM/cT0lMjJAe2lkfHJvb3R9JTIyK2luK3BhcmVudHMrYW5kK21pbWVUeXBlKz0rJTIyYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLmZvbGRlciUyMithbmQrdHJhc2hlZD1mYWxzZSZtYXhSZXN1bHRzPUB7bGltaXR8MTAwfScsXG5cblx0XHRcdFx0Ly8gU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9kcml2ZS92Mi9yZWZlcmVuY2UvZmlsZXMvbGlzdFxuXHRcdFx0XHQnbWUvZm9sZGVyJzogJ2RyaXZlL3YyL2ZpbGVzP3E9JTIyQHtpZHxyb290fSUyMitpbitwYXJlbnRzK2FuZCt0cmFzaGVkPWZhbHNlJm1heFJlc3VsdHM9QHtsaW1pdHwxMDB9J1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gTWFwIFBPU1QgcmVxdWVzdHNcblx0XHRcdHBvc3Q6IHtcblxuXHRcdFx0XHQvLyBHb29nbGUgRHJpdmVcblx0XHRcdFx0J21lL2ZpbGVzJzogdXBsb2FkRHJpdmUsXG5cdFx0XHRcdCdtZS9mb2xkZXJzJzogZnVuY3Rpb24ocCwgY2FsbGJhY2spIHtcblx0XHRcdFx0XHRwLmRhdGEgPSB7XG5cdFx0XHRcdFx0XHR0aXRsZTogcC5kYXRhLm5hbWUsXG5cdFx0XHRcdFx0XHRwYXJlbnRzOiBbe2lkOiBwLmRhdGEucGFyZW50IHx8ICdyb290J31dLFxuXHRcdFx0XHRcdFx0bWltZVR5cGU6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZm9sZGVyJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Y2FsbGJhY2soJ2RyaXZlL3YyL2ZpbGVzJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIE1hcCBQVVQgcmVxdWVzdHNcblx0XHRcdHB1dDoge1xuXHRcdFx0XHQnbWUvZmlsZXMnOiB1cGxvYWREcml2ZVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gTWFwIERFTEVURSByZXF1ZXN0c1xuXHRcdFx0ZGVsOiB7XG5cdFx0XHRcdCdtZS9maWxlcyc6ICdkcml2ZS92Mi9maWxlcy9Ae2lkfScsXG5cdFx0XHRcdCdtZS9mb2xkZXInOiAnZHJpdmUvdjIvZmlsZXMvQHtpZH0nXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBNYXAgUEFUQ0ggcmVxdWVzdHNcblx0XHRcdHBhdGNoOiB7XG5cdFx0XHRcdCdtZS9maWxlJzogJ2RyaXZlL3YyL2ZpbGVzL0B7aWR9J1xuXHRcdFx0fSxcblxuXHRcdFx0d3JhcDoge1xuXHRcdFx0XHRtZTogZnVuY3Rpb24obykge1xuXHRcdFx0XHRcdGlmIChvLmlkKSB7XG5cdFx0XHRcdFx0XHRvLmxhc3RfbmFtZSA9IG8uZmFtaWx5X25hbWUgfHwgKG8ubmFtZSA/IG8ubmFtZS5mYW1pbHlOYW1lIDogbnVsbCk7XG5cdFx0XHRcdFx0XHRvLmZpcnN0X25hbWUgPSBvLmdpdmVuX25hbWUgfHwgKG8ubmFtZSA/IG8ubmFtZS5naXZlbk5hbWUgOiBudWxsKTtcblxuXHRcdFx0XHRcdFx0aWYgKG8uZW1haWxzICYmIG8uZW1haWxzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRvLmVtYWlsID0gby5lbWFpbHNbMF0udmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvcm1hdFBlcnNvbihvKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQnbWUvZnJpZW5kcyc6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdFx0XHRpZiAoby5pdGVtcykge1xuXHRcdFx0XHRcdFx0cGFnaW5nKG8pO1xuXHRcdFx0XHRcdFx0by5kYXRhID0gby5pdGVtcztcblx0XHRcdFx0XHRcdG8uZGF0YS5mb3JFYWNoKGZvcm1hdFBlcnNvbik7XG5cdFx0XHRcdFx0XHRkZWxldGUgby5pdGVtcztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQnbWUvY29udGFjdHMnOiBmb3JtYXRGcmllbmRzLFxuXHRcdFx0XHQnbWUvZm9sbG93ZXJzJzogZm9ybWF0RnJpZW5kcyxcblx0XHRcdFx0J21lL2ZvbGxvd2luZyc6IGZvcm1hdEZyaWVuZHMsXG5cdFx0XHRcdCdtZS9zaGFyZSc6IGZvcm1hdEZlZWQsXG5cdFx0XHRcdCdtZS9mZWVkJzogZm9ybWF0RmVlZCxcblx0XHRcdFx0J21lL2FsYnVtcyc6IGdFbnRyeSxcblx0XHRcdFx0J21lL3Bob3Rvcyc6IGZvcm1hdFBob3Rvcyxcblx0XHRcdFx0J2RlZmF1bHQnOiBnRW50cnlcblx0XHRcdH0sXG5cblx0XHRcdHhocjogZnVuY3Rpb24ocCkge1xuXG5cdFx0XHRcdGlmIChwLm1ldGhvZCA9PT0gJ3Bvc3QnIHx8IHAubWV0aG9kID09PSAncHV0Jykge1xuXHRcdFx0XHRcdHRvSlNPTihwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChwLm1ldGhvZCA9PT0gJ3BhdGNoJykge1xuXHRcdFx0XHRcdGhlbGxvLnV0aWxzLmV4dGVuZChwLnF1ZXJ5LCBwLmRhdGEpO1xuXHRcdFx0XHRcdHAuZGF0YSA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERvbid0IGV2ZW4gdHJ5IHN1Ym1pdHRpbmcgdmlhIGZvcm0uXG5cdFx0XHQvLyBUaGlzIG1lYW5zIG5vIFBPU1Qgb3BlcmF0aW9ucyBpbiA8PUlFOVxuXHRcdFx0Zm9ybTogZmFsc2Vcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIHRvSW50KHMpIHtcblx0XHRyZXR1cm4gcGFyc2VJbnQocywgMTApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0RmVlZChvKSB7XG5cdFx0cGFnaW5nKG8pO1xuXHRcdG8uZGF0YSA9IG8uaXRlbXM7XG5cdFx0ZGVsZXRlIG8uaXRlbXM7XG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHQvLyBGb3JtYXQ6IGVuc3VyZSBlYWNoIHJlY29yZCBjb250YWlucyBhIG5hbWUsIGlkIGV0Yy5cblx0ZnVuY3Rpb24gZm9ybWF0SXRlbShvKSB7XG5cdFx0aWYgKG8uZXJyb3IpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIW8ubmFtZSkge1xuXHRcdFx0by5uYW1lID0gby50aXRsZSB8fCBvLm1lc3NhZ2U7XG5cdFx0fVxuXG5cdFx0aWYgKCFvLnBpY3R1cmUpIHtcblx0XHRcdG8ucGljdHVyZSA9IG8udGh1bWJuYWlsTGluaztcblx0XHR9XG5cblx0XHRpZiAoIW8udGh1bWJuYWlsKSB7XG5cdFx0XHRvLnRodW1ibmFpbCA9IG8udGh1bWJuYWlsTGluaztcblx0XHR9XG5cblx0XHRpZiAoby5taW1lVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtYXBwcy5mb2xkZXInKSB7XG5cdFx0XHRvLnR5cGUgPSAnZm9sZGVyJztcblx0XHRcdG8uZmlsZXMgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZHJpdmUvdjIvZmlsZXM/cT0lMjInICsgby5pZCArICclMjIraW4rcGFyZW50cyc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRJbWFnZShpbWFnZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzb3VyY2U6IGltYWdlLnVybCxcblx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcblx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdFBob3RvcyhvKSB7XG5cdFx0by5kYXRhID0gby5mZWVkLmVudHJ5Lm1hcChmb3JtYXRFbnRyeSk7XG5cdFx0ZGVsZXRlIG8uZmVlZDtcblx0fVxuXG5cdC8vIEdvb2dsZSBoYXMgYSBob3JyaWJsZSBKU09OIEFQSVxuXHRmdW5jdGlvbiBnRW50cnkobykge1xuXHRcdHBhZ2luZyhvKTtcblxuXHRcdGlmICgnZmVlZCcgaW4gbyAmJiAnZW50cnknIGluIG8uZmVlZCkge1xuXHRcdFx0by5kYXRhID0gby5mZWVkLmVudHJ5Lm1hcChmb3JtYXRFbnRyeSk7XG5cdFx0XHRkZWxldGUgby5mZWVkO1xuXHRcdH1cblxuXHRcdC8vIE9sZCBzdHlsZTogUGljYXNhLCBldGMuXG5cdFx0ZWxzZSBpZiAoJ2VudHJ5JyBpbiBvKSB7XG5cdFx0XHRyZXR1cm4gZm9ybWF0RW50cnkoby5lbnRyeSk7XG5cdFx0fVxuXG5cdFx0Ly8gTmV3IHN0eWxlOiBHb29nbGUgRHJpdmUgJiBQbHVzXG5cdFx0ZWxzZSBpZiAoJ2l0ZW1zJyBpbiBvKSB7XG5cdFx0XHRvLmRhdGEgPSBvLml0ZW1zLm1hcChmb3JtYXRJdGVtKTtcblx0XHRcdGRlbGV0ZSBvLml0ZW1zO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZvcm1hdEl0ZW0obyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRQZXJzb24obykge1xuXHRcdG8ubmFtZSA9IG8uZGlzcGxheU5hbWUgfHwgby5uYW1lO1xuXHRcdG8ucGljdHVyZSA9IG8ucGljdHVyZSB8fCAoby5pbWFnZSA/IG8uaW1hZ2UudXJsIDogbnVsbCk7XG5cdFx0by50aHVtYm5haWwgPSBvLnBpY3R1cmU7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRGcmllbmRzKG8sIGhlYWRlcnMsIHJlcSkge1xuXHRcdHBhZ2luZyhvKTtcblx0XHR2YXIgciA9IFtdO1xuXHRcdGlmICgnZmVlZCcgaW4gbyAmJiAnZW50cnknIGluIG8uZmVlZCkge1xuXHRcdFx0dmFyIHRva2VuID0gcmVxLnF1ZXJ5LmFjY2Vzc190b2tlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgby5mZWVkLmVudHJ5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBhID0gby5mZWVkLmVudHJ5W2ldO1xuXG5cdFx0XHRcdGEuaWRcdD0gYS5pZC4kdDtcblx0XHRcdFx0YS5uYW1lXHQ9IGEudGl0bGUuJHQ7XG5cdFx0XHRcdGRlbGV0ZSBhLnRpdGxlO1xuXHRcdFx0XHRpZiAoYS5nZCRlbWFpbCkge1xuXHRcdFx0XHRcdGEuZW1haWxcdD0gKGEuZ2QkZW1haWwgJiYgYS5nZCRlbWFpbC5sZW5ndGggPiAwKSA/IGEuZ2QkZW1haWxbMF0uYWRkcmVzcyA6IG51bGw7XG5cdFx0XHRcdFx0YS5lbWFpbHMgPSBhLmdkJGVtYWlsO1xuXHRcdFx0XHRcdGRlbGV0ZSBhLmdkJGVtYWlsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGEudXBkYXRlZCkge1xuXHRcdFx0XHRcdGEudXBkYXRlZCA9IGEudXBkYXRlZC4kdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhLmxpbmspIHtcblxuXHRcdFx0XHRcdHZhciBwaWMgPSAoYS5saW5rLmxlbmd0aCA+IDApID8gYS5saW5rWzBdLmhyZWYgOiBudWxsO1xuXHRcdFx0XHRcdGlmIChwaWMgJiYgYS5saW5rWzBdLmdkJGV0YWcpIHtcblx0XHRcdFx0XHRcdHBpYyArPSAocGljLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nKSArICdhY2Nlc3NfdG9rZW49JyArIHRva2VuO1xuXHRcdFx0XHRcdFx0YS5waWN0dXJlID0gcGljO1xuXHRcdFx0XHRcdFx0YS50aHVtYm5haWwgPSBwaWM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGVsZXRlIGEubGluaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhLmNhdGVnb3J5KSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGEuY2F0ZWdvcnk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0by5kYXRhID0gby5mZWVkLmVudHJ5O1xuXHRcdFx0ZGVsZXRlIG8uZmVlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdEVudHJ5KGEpIHtcblxuXHRcdHZhciBncm91cCA9IGEubWVkaWEkZ3JvdXA7XG5cdFx0dmFyIHBob3RvID0gZ3JvdXAubWVkaWEkY29udGVudC5sZW5ndGggPyBncm91cC5tZWRpYSRjb250ZW50WzBdIDoge307XG5cdFx0dmFyIG1lZGlhQ29udGVudCA9IGdyb3VwLm1lZGlhJGNvbnRlbnQgfHwgW107XG5cdFx0dmFyIG1lZGlhVGh1bWJuYWlsID0gZ3JvdXAubWVkaWEkdGh1bWJuYWlsIHx8IFtdO1xuXG5cdFx0dmFyIHBpY3R1cmVzID0gbWVkaWFDb250ZW50XG5cdFx0XHQuY29uY2F0KG1lZGlhVGh1bWJuYWlsKVxuXHRcdFx0Lm1hcChmb3JtYXRJbWFnZSlcblx0XHRcdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEud2lkdGggLSBiLndpZHRoO1xuXHRcdFx0fSk7XG5cblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIF9hO1xuXHRcdHZhciBwID0ge1xuXHRcdFx0aWQ6IGEuaWQuJHQsXG5cdFx0XHRuYW1lOiBhLnRpdGxlLiR0LFxuXHRcdFx0ZGVzY3JpcHRpb246IGEuc3VtbWFyeS4kdCxcblx0XHRcdHVwZGF0ZWRfdGltZTogYS51cGRhdGVkLiR0LFxuXHRcdFx0Y3JlYXRlZF90aW1lOiBhLnB1Ymxpc2hlZC4kdCxcblx0XHRcdHBpY3R1cmU6IHBob3RvID8gcGhvdG8udXJsIDogbnVsbCxcblx0XHRcdHBpY3R1cmVzOiBwaWN0dXJlcyxcblx0XHRcdGltYWdlczogW10sXG5cdFx0XHR0aHVtYm5haWw6IHBob3RvID8gcGhvdG8udXJsIDogbnVsbCxcblx0XHRcdHdpZHRoOiBwaG90by53aWR0aCxcblx0XHRcdGhlaWdodDogcGhvdG8uaGVpZ2h0XG5cdFx0fTtcblxuXHRcdC8vIEdldCBmZWVkL2NoaWxkcmVuXG5cdFx0aWYgKCdsaW5rJyBpbiBhKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5saW5rLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkID0gYS5saW5rW2ldO1xuXHRcdFx0XHRpZiAoZC5yZWwubWF0Y2goL1xcI2ZlZWQkLykpIHtcblx0XHRcdFx0XHRwLnVwbG9hZF9sb2NhdGlvbiA9IHAuZmlsZXMgPSBwLnBob3RvcyA9IGQuaHJlZjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEdldCBpbWFnZXMgb2YgZGlmZmVyZW50IHNjYWxlc1xuXHRcdGlmICgnY2F0ZWdvcnknIGluIGEgJiYgYS5jYXRlZ29yeS5sZW5ndGgpIHtcblx0XHRcdF9hID0gYS5jYXRlZ29yeTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBfYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoX2FbaV0uc2NoZW1lICYmIF9hW2ldLnNjaGVtZS5tYXRjaCgvXFwja2luZCQvKSkge1xuXHRcdFx0XHRcdHAudHlwZSA9IF9hW2ldLnRlcm0ucmVwbGFjZSgvXi4qP1xcIy8sICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEdldCBpbWFnZXMgb2YgZGlmZmVyZW50IHNjYWxlc1xuXHRcdGlmICgnbWVkaWEkdGh1bWJuYWlsJyBpbiBncm91cCAmJiBncm91cC5tZWRpYSR0aHVtYm5haWwubGVuZ3RoKSB7XG5cdFx0XHRfYSA9IGdyb3VwLm1lZGlhJHRodW1ibmFpbDtcblx0XHRcdHAudGh1bWJuYWlsID0gX2FbMF0udXJsO1xuXHRcdFx0cC5pbWFnZXMgPSBfYS5tYXAoZm9ybWF0SW1hZ2UpO1xuXHRcdH1cblxuXHRcdF9hID0gZ3JvdXAubWVkaWEkY29udGVudDtcblxuXHRcdGlmIChfYSAmJiBfYS5sZW5ndGgpIHtcblx0XHRcdHAuaW1hZ2VzLnB1c2goZm9ybWF0SW1hZ2UoX2FbMF0pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhZ2luZyhyZXMpIHtcblxuXHRcdC8vIENvbnRhY3RzIFYyXG5cdFx0aWYgKCdmZWVkJyBpbiByZXMgJiYgcmVzLmZlZWQub3BlblNlYXJjaCRpdGVtc1BlclBhZ2UpIHtcblx0XHRcdHZhciBsaW1pdCA9IHRvSW50KHJlcy5mZWVkLm9wZW5TZWFyY2gkaXRlbXNQZXJQYWdlLiR0KTtcblx0XHRcdHZhciBzdGFydCA9IHRvSW50KHJlcy5mZWVkLm9wZW5TZWFyY2gkc3RhcnRJbmRleC4kdCk7XG5cdFx0XHR2YXIgdG90YWwgPSB0b0ludChyZXMuZmVlZC5vcGVuU2VhcmNoJHRvdGFsUmVzdWx0cy4kdCk7XG5cblx0XHRcdGlmICgoc3RhcnQgKyBsaW1pdCkgPCB0b3RhbCkge1xuXHRcdFx0XHRyZXMucGFnaW5nID0ge1xuXHRcdFx0XHRcdG5leHQ6ICc/c3RhcnQ9JyArIChzdGFydCArIGxpbWl0KVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICgnbmV4dFBhZ2VUb2tlbicgaW4gcmVzKSB7XG5cdFx0XHRyZXMucGFnaW5nID0ge1xuXHRcdFx0XHRuZXh0OiAnP3BhZ2VUb2tlbj0nICsgcmVzLm5leHRQYWdlVG9rZW5cblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29uc3RydWN0IGEgbXVsdGlwYXJ0IG1lc3NhZ2Vcblx0ZnVuY3Rpb24gTXVsdGlwYXJ0KCkge1xuXG5cdFx0Ly8gSW50ZXJuYWwgYm9keVxuXHRcdHZhciBib2R5ID0gW107XG5cdFx0dmFyIGJvdW5kYXJ5ID0gKE1hdGgucmFuZG9tKCkgKiAxZTEwKS50b1N0cmluZygzMik7XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsaW5lQnJlYWsgPSAnXFxyXFxuJztcblx0XHR2YXIgZGVsaW0gPSBsaW5lQnJlYWsgKyAnLS0nICsgYm91bmRhcnk7XG5cdFx0dmFyIHJlYWR5ID0gZnVuY3Rpb24oKSB7fTtcblxuXHRcdHZhciBkYXRhVXJpID0gL15kYXRhXFw6KFteOyxdKyhcXDtjaGFyc2V0PVteOyxdKyk/KShcXDtiYXNlNjQpPywvaTtcblxuXHRcdC8vIEFkZCBmaWxlXG5cdFx0ZnVuY3Rpb24gYWRkRmlsZShpdGVtKSB7XG5cdFx0XHR2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0ZnIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRhZGRDb250ZW50KGJ0b2EoZS50YXJnZXQucmVzdWx0KSwgaXRlbS50eXBlICsgbGluZUJyZWFrICsgJ0NvbnRlbnQtVHJhbnNmZXItRW5jb2Rpbmc6IGJhc2U2NCcpO1xuXHRcdFx0fTtcblxuXHRcdFx0ZnIucmVhZEFzQmluYXJ5U3RyaW5nKGl0ZW0pO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBjb250ZW50XG5cdFx0ZnVuY3Rpb24gYWRkQ29udGVudChjb250ZW50LCB0eXBlKSB7XG5cdFx0XHRib2R5LnB1c2gobGluZUJyZWFrICsgJ0NvbnRlbnQtVHlwZTogJyArIHR5cGUgKyBsaW5lQnJlYWsgKyBsaW5lQnJlYWsgKyBjb250ZW50KTtcblx0XHRcdGNvdW50ZXItLTtcblx0XHRcdHJlYWR5KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIG5ldyB0aGluZ3MgdG8gdGhlIG9iamVjdFxuXHRcdHRoaXMuYXBwZW5kID0gZnVuY3Rpb24oY29udGVudCwgdHlwZSkge1xuXG5cdFx0XHQvLyBEb2VzIHRoZSBjb250ZW50IGhhdmUgYW4gYXJyYXlcblx0XHRcdGlmICh0eXBlb2YgKGNvbnRlbnQpID09PSAnc3RyaW5nJyB8fCAhKCdsZW5ndGgnIGluIE9iamVjdChjb250ZW50KSkpIHtcblx0XHRcdFx0Ly8gQ29udmVydGkgdG8gbXVsdGlwbGVzXG5cdFx0XHRcdGNvbnRlbnQgPSBbY29udGVudF07XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHRcdGNvdW50ZXIrKztcblxuXHRcdFx0XHR2YXIgaXRlbSA9IGNvbnRlbnRbaV07XG5cblx0XHRcdFx0Ly8gSXMgdGhpcyBhIGZpbGU/XG5cdFx0XHRcdC8vIEZpbGVzIGNhbiBiZSBlaXRoZXIgQmxvYnMgb3IgRmlsZSB0eXBlc1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KHR5cGVvZiAoRmlsZSkgIT09ICd1bmRlZmluZWQnICYmIGl0ZW0gaW5zdGFuY2VvZiBGaWxlKSB8fFxuXHRcdFx0XHRcdCh0eXBlb2YgKEJsb2IpICE9PSAndW5kZWZpbmVkJyAmJiBpdGVtIGluc3RhbmNlb2YgQmxvYilcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gUmVhZCB0aGUgZmlsZSBpblxuXHRcdFx0XHRcdGFkZEZpbGUoaXRlbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEYXRhLVVSST9cblx0XHRcdFx0Ly8gRGF0YTpbPG1pbWUgdHlwZT5dWztjaGFyc2V0PTxjaGFyc2V0Pl1bO2Jhc2U2NF0sPGVuY29kZWQgZGF0YT5cblx0XHRcdFx0Ly8gL15kYXRhXFw6KFteOyxdKyhcXDtjaGFyc2V0PVteOyxdKyk/KShcXDtiYXNlNjQpPywvaVxuXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgKGl0ZW0pID09PSAnc3RyaW5nJyAmJiBpdGVtLm1hdGNoKGRhdGFVcmkpKSB7XG5cdFx0XHRcdFx0dmFyIG0gPSBpdGVtLm1hdGNoKGRhdGFVcmkpO1xuXHRcdFx0XHRcdGFkZENvbnRlbnQoaXRlbS5yZXBsYWNlKGRhdGFVcmksICcnKSwgbVsxXSArIGxpbmVCcmVhayArICdDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiBiYXNlNjQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlZ3VsYXIgc3RyaW5nXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGFkZENvbnRlbnQoaXRlbSwgdHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5vbnJlYWR5ID0gZnVuY3Rpb24oZm4pIHtcblx0XHRcdHJlYWR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChjb3VudGVyID09PSAwKSB7XG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciByZWFkeVxuXHRcdFx0XHRcdGJvZHkudW5zaGlmdCgnJyk7XG5cdFx0XHRcdFx0Ym9keS5wdXNoKCctLScpO1xuXHRcdFx0XHRcdGZuKGJvZHkuam9pbihkZWxpbSksIGJvdW5kYXJ5KTtcblx0XHRcdFx0XHRib2R5ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHJlYWR5KCk7XG5cdFx0fTtcblx0fVxuXG5cdC8vIFVwbG9hZCB0byBEcml2ZVxuXHQvLyBJZiB0aGlzIGlzIFBVVCB0aGVuIG9ubHkgYXVnbWVudCB0aGUgZmlsZSB1cGxvYWRlZFxuXHQvLyBQVVQgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vZHJpdmUvdjIvcmVmZXJlbmNlL2ZpbGVzL3VwZGF0ZVxuXHQvLyBQT1NUIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2RyaXZlL21hbmFnZS11cGxvYWRzXG5cdGZ1bmN0aW9uIHVwbG9hZERyaXZlKHAsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0Ly8gVGVzdCBmb3IgRE9NIGVsZW1lbnRcblx0XHRpZiAocC5kYXRhICYmXG5cdFx0XHQodHlwZW9mIChIVE1MSW5wdXRFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiYgcC5kYXRhIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudClcblx0XHQpIHtcblx0XHRcdHAuZGF0YSA9IHtmaWxlOiBwLmRhdGF9O1xuXHRcdH1cblxuXHRcdGlmICghcC5kYXRhLm5hbWUgJiYgT2JqZWN0KE9iamVjdChwLmRhdGEuZmlsZSkuZmlsZXMpLmxlbmd0aCAmJiBwLm1ldGhvZCA9PT0gJ3Bvc3QnKSB7XG5cdFx0XHRwLmRhdGEubmFtZSA9IHAuZGF0YS5maWxlLmZpbGVzWzBdLm5hbWU7XG5cdFx0fVxuXG5cdFx0aWYgKHAubWV0aG9kID09PSAncG9zdCcpIHtcblx0XHRcdHAuZGF0YSA9IHtcblx0XHRcdFx0dGl0bGU6IHAuZGF0YS5uYW1lLFxuXHRcdFx0XHRwYXJlbnRzOiBbe2lkOiBwLmRhdGEucGFyZW50IHx8ICdyb290J31dLFxuXHRcdFx0XHRmaWxlOiBwLmRhdGEuZmlsZVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cblx0XHRcdC8vIE1ha2UgYSByZWZlcmVuY2Vcblx0XHRcdGRhdGEgPSBwLmRhdGE7XG5cdFx0XHRwLmRhdGEgPSB7fTtcblxuXHRcdFx0Ly8gQWRkIHRoZSBwYXJ0cyB0byBjaGFuZ2UgYXMgcmVxdWlyZWRcblx0XHRcdGlmIChkYXRhLnBhcmVudCkge1xuXHRcdFx0XHRwLmRhdGEucGFyZW50cyA9IFt7aWQ6IHAuZGF0YS5wYXJlbnQgfHwgJ3Jvb3QnfV07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLmZpbGUpIHtcblx0XHRcdFx0cC5kYXRhLmZpbGUgPSBkYXRhLmZpbGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLm5hbWUpIHtcblx0XHRcdFx0cC5kYXRhLnRpdGxlID0gZGF0YS5uYW1lO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEV4dHJhY3QgdGhlIGZpbGUsIGlmIGl0IGV4aXN0cyBmcm9tIHRoZSBkYXRhIG9iamVjdFxuXHRcdC8vIElmIHRoZSBGaWxlIGlzIGFuIElOUFVUIGVsZW1lbnQgbGV0cyBqdXN0IGNvbmNlcm4gb3Vyc2VsdmVzIHdpdGggdGhlIE5vZGVMaXN0XG5cdFx0dmFyIGZpbGU7XG5cdFx0aWYgKCdmaWxlJyBpbiBwLmRhdGEpIHtcblx0XHRcdGZpbGUgPSBwLmRhdGEuZmlsZTtcblx0XHRcdGRlbGV0ZSBwLmRhdGEuZmlsZTtcblxuXHRcdFx0aWYgKHR5cGVvZiAoZmlsZSkgPT09ICdvYmplY3QnICYmICdmaWxlcycgaW4gZmlsZSkge1xuXHRcdFx0XHQvLyBBc3NpZ24gdGhlIE5vZGVMaXN0XG5cdFx0XHRcdGZpbGUgPSBmaWxlLmZpbGVzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWZpbGUgfHwgIWZpbGUubGVuZ3RoKSB7XG5cdFx0XHRcdGNhbGxiYWNrKHtcblx0XHRcdFx0XHRlcnJvcjoge1xuXHRcdFx0XHRcdFx0Y29kZTogJ3JlcXVlc3RfaW52YWxpZCcsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiAnVGhlcmUgd2VyZSBubyBmaWxlcyBhdHRhY2hlZCB3aXRoIHRoaXMgcmVxdWVzdCB0byB1cGxvYWQnXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0eXBlIHAuZGF0YS5taW1lVHlwZSA9IE9iamVjdChmaWxlWzBdKS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuXG5cdFx0Ly8gQ29uc3RydWN0IGEgbXVsdGlwYXJ0IG1lc3NhZ2Vcblx0XHR2YXIgcGFydHMgPSBuZXcgTXVsdGlwYXJ0KCk7XG5cdFx0cGFydHMuYXBwZW5kKEpTT04uc3RyaW5naWZ5KHAuZGF0YSksICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cblx0XHQvLyBSZWFkIHRoZSBmaWxlIGludG8gYSAgYmFzZTY0IHN0cmluZy4uLiB5ZXAgYSBoYXNzbGUsIGkga25vd1xuXHRcdC8vIEZvcm1EYXRhIGRvZXNuJ3QgbGV0IHVzIGFzc2lnbiBvdXIgb3duIE11bHRpcGFydCBoZWFkZXJzIGFuZCBIVFRQIENvbnRlbnQtVHlwZVxuXHRcdC8vIEFsYXMgR29vZ2xlQXBpIG5lZWQgdGhlc2UgaW4gYSBwYXJ0aWN1bGFyIGZvcm1hdFxuXHRcdGlmIChmaWxlKSB7XG5cdFx0XHRwYXJ0cy5hcHBlbmQoZmlsZSk7XG5cdFx0fVxuXG5cdFx0cGFydHMub25yZWFkeShmdW5jdGlvbihib2R5LCBib3VuZGFyeSkge1xuXG5cdFx0XHRwLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ211bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT1cIicgKyBib3VuZGFyeSArICdcIic7XG5cdFx0XHRwLmRhdGEgPSBib2R5O1xuXG5cdFx0XHRjYWxsYmFjaygndXBsb2FkL2RyaXZlL3YyL2ZpbGVzJyArIChkYXRhLmlkID8gJy8nICsgZGF0YS5pZCA6ICcnKSArICc/dXBsb2FkVHlwZT1tdWx0aXBhcnQnKTtcblx0XHR9KTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdG9KU09OKHApIHtcblx0XHRpZiAodHlwZW9mIChwLmRhdGEpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Ly8gQ29udmVydCB0aGUgUE9TVCBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3Rcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHAuZGF0YSA9IEpTT04uc3RyaW5naWZ5KHAuZGF0YSk7XG5cdFx0XHRcdHAuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge31cblx0XHR9XG5cdH1cblxufSkoaGVsbG8pO1xuXG4oZnVuY3Rpb24oaGVsbG8pIHtcblxuXHRoZWxsby5pbml0KHtcblxuXHRcdGluc3RhZ3JhbToge1xuXG5cdFx0XHRuYW1lOiAnSW5zdGFncmFtJyxcblxuXHRcdFx0b2F1dGg6IHtcblx0XHRcdFx0Ly8gU2VlOiBodHRwOi8vaW5zdGFncmFtLmNvbS9kZXZlbG9wZXIvYXV0aGVudGljYXRpb24vXG5cdFx0XHRcdHZlcnNpb246IDIsXG5cdFx0XHRcdGF1dGg6ICdodHRwczovL2luc3RhZ3JhbS5jb20vb2F1dGgvYXV0aG9yaXplLycsXG5cdFx0XHRcdGdyYW50OiAnaHR0cHM6Ly9hcGkuaW5zdGFncmFtLmNvbS9vYXV0aC9hY2Nlc3NfdG9rZW4nXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZWZyZXNoIHRoZSBhY2Nlc3NfdG9rZW4gb25jZSBleHBpcmVkXG5cdFx0XHRyZWZyZXNoOiB0cnVlLFxuXG5cdFx0XHRzY29wZToge1xuXHRcdFx0XHRiYXNpYzogJ2Jhc2ljJyxcblx0XHRcdFx0cGhvdG9zOiAnJyxcblx0XHRcdFx0ZnJpZW5kczogJ3JlbGF0aW9uc2hpcHMnLFxuXHRcdFx0XHRwdWJsaXNoOiAnbGlrZXMgY29tbWVudHMnLFxuXHRcdFx0XHRlbWFpbDogJycsXG5cdFx0XHRcdHNoYXJlOiAnJyxcblx0XHRcdFx0cHVibGlzaF9maWxlczogJycsXG5cdFx0XHRcdGZpbGVzOiAnJyxcblx0XHRcdFx0dmlkZW9zOiAnJyxcblx0XHRcdFx0b2ZmbGluZV9hY2Nlc3M6ICcnXG5cdFx0XHR9LFxuXG5cdFx0XHRzY29wZV9kZWxpbTogJyAnLFxuXG5cdFx0XHRsb2dpbjogZnVuY3Rpb24ocCkge1xuXHRcdFx0XHQvLyBJbnN0YWdyYW0gdGhyb3dzIGVycm9ycyBsaWtlICdKYXZhU2NyaXB0IEFQSSBpcyB1bnN1cHBvcnRlZCcgaWYgdGhlIGRpc3BsYXkgaXMgJ3BvcHVwJy5cblx0XHRcdFx0Ly8gTWFrZSB0aGUgZGlzcGxheSBhbnl0aGluZyBidXQgJ3BvcHVwJ1xuXHRcdFx0XHRwLnFzLmRpc3BsYXkgPSAnJztcblx0XHRcdH0sXG5cblx0XHRcdGJhc2U6ICdodHRwczovL2FwaS5pbnN0YWdyYW0uY29tL3YxLycsXG5cblx0XHRcdGdldDoge1xuXHRcdFx0XHRtZTogJ3VzZXJzL3NlbGYnLFxuXHRcdFx0XHQnbWUvZmVlZCc6ICd1c2Vycy9zZWxmL2ZlZWQ/Y291bnQ9QHtsaW1pdHwxMDB9Jyxcblx0XHRcdFx0J21lL3Bob3Rvcyc6ICd1c2Vycy9zZWxmL21lZGlhL3JlY2VudD9taW5faWQ9MCZjb3VudD1Ae2xpbWl0fDEwMH0nLFxuXHRcdFx0XHQnbWUvZnJpZW5kcyc6ICd1c2Vycy9zZWxmL2ZvbGxvd3M/Y291bnQ9QHtsaW1pdHwxMDB9Jyxcblx0XHRcdFx0J21lL2ZvbGxvd2luZyc6ICd1c2Vycy9zZWxmL2ZvbGxvd3M/Y291bnQ9QHtsaW1pdHwxMDB9Jyxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6ICd1c2Vycy9zZWxmL2ZvbGxvd2VkLWJ5P2NvdW50PUB7bGltaXR8MTAwfScsXG5cdFx0XHRcdCdmcmllbmQvcGhvdG9zJzogJ3VzZXJzL0B7aWR9L21lZGlhL3JlY2VudD9taW5faWQ9MCZjb3VudD1Ae2xpbWl0fDEwMH0nXG5cdFx0XHR9LFxuXG5cdFx0XHRwb3N0OiB7XG5cdFx0XHRcdCdtZS9saWtlJzogZnVuY3Rpb24ocCwgY2FsbGJhY2spIHtcblx0XHRcdFx0XHR2YXIgaWQgPSBwLmRhdGEuaWQ7XG5cdFx0XHRcdFx0cC5kYXRhID0ge307XG5cdFx0XHRcdFx0Y2FsbGJhY2soJ21lZGlhLycgKyBpZCArICcvbGlrZXMnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0ZGVsOiB7XG5cdFx0XHRcdCdtZS9saWtlJzogJ21lZGlhL0B7aWR9L2xpa2VzJ1xuXHRcdFx0fSxcblxuXHRcdFx0d3JhcDoge1xuXHRcdFx0XHRtZTogZnVuY3Rpb24obykge1xuXG5cdFx0XHRcdFx0Zm9ybWF0RXJyb3Iobyk7XG5cblx0XHRcdFx0XHRpZiAoJ2RhdGEnIGluIG8pIHtcblx0XHRcdFx0XHRcdG8uaWQgPSBvLmRhdGEuaWQ7XG5cdFx0XHRcdFx0XHRvLnRodW1ibmFpbCA9IG8uZGF0YS5wcm9maWxlX3BpY3R1cmU7XG5cdFx0XHRcdFx0XHRvLm5hbWUgPSBvLmRhdGEuZnVsbF9uYW1lIHx8IG8uZGF0YS51c2VybmFtZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQnbWUvZnJpZW5kcyc6IGZvcm1hdEZyaWVuZHMsXG5cdFx0XHRcdCdtZS9mb2xsb3dpbmcnOiBmb3JtYXRGcmllbmRzLFxuXHRcdFx0XHQnbWUvZm9sbG93ZXJzJzogZm9ybWF0RnJpZW5kcyxcblx0XHRcdFx0J21lL3Bob3Rvcyc6IGZ1bmN0aW9uKG8pIHtcblxuXHRcdFx0XHRcdGZvcm1hdEVycm9yKG8pO1xuXHRcdFx0XHRcdHBhZ2luZyhvKTtcblxuXHRcdFx0XHRcdGlmICgnZGF0YScgaW4gbykge1xuXHRcdFx0XHRcdFx0by5kYXRhID0gby5kYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBkLnR5cGUgPT09ICdpbWFnZSc7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0by5kYXRhLmZvckVhY2goZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdFx0XHRkLm5hbWUgPSBkLmNhcHRpb24gPyBkLmNhcHRpb24udGV4dCA6IG51bGw7XG5cdFx0XHRcdFx0XHRcdGQudGh1bWJuYWlsID0gZC5pbWFnZXMudGh1bWJuYWlsLnVybDtcblx0XHRcdFx0XHRcdFx0ZC5waWN0dXJlID0gZC5pbWFnZXMuc3RhbmRhcmRfcmVzb2x1dGlvbi51cmw7XG5cdFx0XHRcdFx0XHRcdGQucGljdHVyZXMgPSBPYmplY3Qua2V5cyhkLmltYWdlcylcblx0XHRcdFx0XHRcdFx0XHQubWFwKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGltYWdlID0gZC5pbWFnZXNba2V5XTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmb3JtYXRJbWFnZShpbWFnZSk7XG5cdFx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0XHQuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gYS53aWR0aCAtIGIud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQnZGVmYXVsdCc6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdFx0XHRvID0gZm9ybWF0RXJyb3Iobyk7XG5cdFx0XHRcdFx0cGFnaW5nKG8pO1xuXHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBJbnN0YWdyYW0gZG9lcyBub3QgcmV0dXJuIGFueSBDT1JTIEhlYWRlcnNcblx0XHRcdC8vIFNvIGJlc2lkZXMgSlNPTlAgd2UncmUgc3R1Y2sgd2l0aCBwcm94eVxuXHRcdFx0eGhyOiBmdW5jdGlvbihwLCBxcykge1xuXG5cdFx0XHRcdHZhciBtZXRob2QgPSBwLm1ldGhvZDtcblx0XHRcdFx0dmFyIHByb3h5ID0gbWV0aG9kICE9PSAnZ2V0JztcblxuXHRcdFx0XHRpZiAocHJveHkpIHtcblxuXHRcdFx0XHRcdGlmICgobWV0aG9kID09PSAncG9zdCcgfHwgbWV0aG9kID09PSAncHV0JykgJiYgcC5xdWVyeS5hY2Nlc3NfdG9rZW4pIHtcblx0XHRcdFx0XHRcdHAuZGF0YS5hY2Nlc3NfdG9rZW4gPSBwLnF1ZXJ5LmFjY2Vzc190b2tlbjtcblx0XHRcdFx0XHRcdGRlbGV0ZSBwLnF1ZXJ5LmFjY2Vzc190b2tlbjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBObyBhY2Nlc3MgY29udHJvbCBoZWFkZXJzXG5cdFx0XHRcdFx0Ly8gVXNlIHRoZSBwcm94eSBpbnN0ZWFkXG5cdFx0XHRcdFx0cC5wcm94eSA9IHByb3h5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHByb3h5O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gTm8gZm9ybVxuXHRcdFx0Zm9ybTogZmFsc2Vcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGZvcm1hdEltYWdlKGltYWdlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNvdXJjZTogaW1hZ2UudXJsLFxuXHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHRcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0RXJyb3Iobykge1xuXHRcdGlmICh0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGVycm9yOiB7XG5cdFx0XHRcdFx0Y29kZTogJ2ludmFsaWRfcmVxdWVzdCcsXG5cdFx0XHRcdFx0bWVzc2FnZTogb1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmIChvICYmICdtZXRhJyBpbiBvICYmICdlcnJvcl90eXBlJyBpbiBvLm1ldGEpIHtcblx0XHRcdG8uZXJyb3IgPSB7XG5cdFx0XHRcdGNvZGU6IG8ubWV0YS5lcnJvcl90eXBlLFxuXHRcdFx0XHRtZXNzYWdlOiBvLm1ldGEuZXJyb3JfbWVzc2FnZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdEZyaWVuZHMobykge1xuXHRcdHBhZ2luZyhvKTtcblx0XHRpZiAobyAmJiAnZGF0YScgaW4gbykge1xuXHRcdFx0by5kYXRhLmZvckVhY2goZm9ybWF0RnJpZW5kKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdEZyaWVuZChvKSB7XG5cdFx0aWYgKG8uaWQpIHtcblx0XHRcdG8udGh1bWJuYWlsID0gby5wcm9maWxlX3BpY3R1cmU7XG5cdFx0XHRvLm5hbWUgPSBvLmZ1bGxfbmFtZSB8fCBvLnVzZXJuYW1lO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNlZTogaHR0cDovL2luc3RhZ3JhbS5jb20vZGV2ZWxvcGVyL2VuZHBvaW50cy9cblx0ZnVuY3Rpb24gcGFnaW5nKHJlcykge1xuXHRcdGlmICgncGFnaW5hdGlvbicgaW4gcmVzKSB7XG5cdFx0XHRyZXMucGFnaW5nID0ge1xuXHRcdFx0XHRuZXh0OiByZXMucGFnaW5hdGlvbi5uZXh0X3VybFxuXHRcdFx0fTtcblx0XHRcdGRlbGV0ZSByZXMucGFnaW5hdGlvbjtcblx0XHR9XG5cdH1cblxufSkoaGVsbG8pO1xuXG4oZnVuY3Rpb24oaGVsbG8pIHtcblxuXHRoZWxsby5pbml0KHtcblxuXHRcdGpvaW5tZToge1xuXG5cdFx0XHRuYW1lOiAnam9pbi5tZScsXG5cblx0XHRcdG9hdXRoOiB7XG5cdFx0XHRcdHZlcnNpb246IDIsXG5cdFx0XHRcdGF1dGg6ICdodHRwczovL3NlY3VyZS5qb2luLm1lL2FwaS9wdWJsaWMvdjEvYXV0aC9vYXV0aDInLFxuXHRcdFx0XHRncmFudDogJ2h0dHBzOi8vc2VjdXJlLmpvaW4ubWUvYXBpL3B1YmxpYy92MS9hdXRoL29hdXRoMidcblx0XHRcdH0sXG5cblx0XHRcdHJlZnJlc2g6IGZhbHNlLFxuXG5cdFx0XHRzY29wZToge1xuXHRcdFx0XHRiYXNpYzogJ3VzZXJfaW5mbycsXG5cdFx0XHRcdHVzZXI6ICd1c2VyX2luZm8nLFxuXHRcdFx0XHRzY2hlZHVsZXI6ICdzY2hlZHVsZXInLFxuXHRcdFx0XHRzdGFydDogJ3N0YXJ0X21lZXRpbmcnLFxuXHRcdFx0XHRlbWFpbDogJycsXG5cdFx0XHRcdGZyaWVuZHM6ICcnLFxuXHRcdFx0XHRzaGFyZTogJycsXG5cdFx0XHRcdHB1Ymxpc2g6ICcnLFxuXHRcdFx0XHRwaG90b3M6ICcnLFxuXHRcdFx0XHRwdWJsaXNoX2ZpbGVzOiAnJyxcblx0XHRcdFx0ZmlsZXM6ICcnLFxuXHRcdFx0XHR2aWRlb3M6ICcnLFxuXHRcdFx0XHRvZmZsaW5lX2FjY2VzczogJydcblx0XHRcdH0sXG5cblx0XHRcdHNjb3BlX2RlbGltOiAnICcsXG5cblx0XHRcdGxvZ2luOiBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHAub3B0aW9ucy5wb3B1cC53aWR0aCA9IDQwMDtcblx0XHRcdFx0cC5vcHRpb25zLnBvcHVwLmhlaWdodCA9IDcwMDtcblx0XHRcdH0sXG5cblx0XHRcdGJhc2U6ICdodHRwczovL2FwaS5qb2luLm1lL3YxLycsXG5cblx0XHRcdGdldDoge1xuXHRcdFx0XHRtZTogJ3VzZXInLFxuXHRcdFx0XHRtZWV0aW5nczogJ21lZXRpbmdzJyxcblx0XHRcdFx0J21lZXRpbmdzL2luZm8nOiAnbWVldGluZ3MvQHtpZH0nXG5cdFx0XHR9LFxuXG5cdFx0XHRwb3N0OiB7XG5cdFx0XHRcdCdtZWV0aW5ncy9zdGFydC9hZGhvYyc6IGZ1bmN0aW9uKHAsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soJ21lZXRpbmdzL3N0YXJ0Jyk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0J21lZXRpbmdzL3N0YXJ0L3NjaGVkdWxlZCc6IGZ1bmN0aW9uKHAsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0dmFyIG1lZXRpbmdJZCA9IHAuZGF0YS5tZWV0aW5nSWQ7XG5cdFx0XHRcdFx0cC5kYXRhID0ge307XG5cdFx0XHRcdFx0Y2FsbGJhY2soJ21lZXRpbmdzLycgKyBtZWV0aW5nSWQgKyAnL3N0YXJ0Jyk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0J21lZXRpbmdzL3NjaGVkdWxlJzogZnVuY3Rpb24ocCwgY2FsbGJhY2spIHtcblx0XHRcdFx0XHRjYWxsYmFjaygnbWVldGluZ3MnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0cGF0Y2g6IHtcblx0XHRcdFx0J21lZXRpbmdzL3VwZGF0ZSc6IGZ1bmN0aW9uKHAsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soJ21lZXRpbmdzLycgKyBwLmRhdGEubWVldGluZ0lkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0ZGVsOiB7XG5cdFx0XHRcdCdtZWV0aW5ncy9kZWxldGUnOiAnbWVldGluZ3MvQHtpZH0nXG5cdFx0XHR9LFxuXG5cdFx0XHR3cmFwOiB7XG5cdFx0XHRcdG1lOiBmdW5jdGlvbihvLCBoZWFkZXJzKSB7XG5cdFx0XHRcdFx0Zm9ybWF0RXJyb3IobywgaGVhZGVycyk7XG5cblx0XHRcdFx0XHRpZiAoIW8uZW1haWwpIHtcblx0XHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG8ubmFtZSA9IG8uZnVsbE5hbWU7XG5cdFx0XHRcdFx0by5maXJzdF9uYW1lID0gby5uYW1lLnNwbGl0KCcgJylbMF07XG5cdFx0XHRcdFx0by5sYXN0X25hbWUgPSBvLm5hbWUuc3BsaXQoJyAnKVsxXTtcblx0XHRcdFx0XHRvLmlkID0gby5lbWFpbDtcblxuXHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdCdkZWZhdWx0JzogZnVuY3Rpb24obywgaGVhZGVycykge1xuXHRcdFx0XHRcdGZvcm1hdEVycm9yKG8sIGhlYWRlcnMpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHhocjogZm9ybWF0UmVxdWVzdFxuXG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBmb3JtYXRFcnJvcihvLCBoZWFkZXJzKSB7XG5cdFx0dmFyIGVycm9yQ29kZTtcblx0XHR2YXIgbWVzc2FnZTtcblx0XHR2YXIgZGV0YWlscztcblxuXHRcdGlmIChvICYmICgnTWVzc2FnZScgaW4gbykpIHtcblx0XHRcdG1lc3NhZ2UgPSBvLk1lc3NhZ2U7XG5cdFx0XHRkZWxldGUgby5NZXNzYWdlO1xuXG5cdFx0XHRpZiAoJ0Vycm9yQ29kZScgaW4gbykge1xuXHRcdFx0XHRlcnJvckNvZGUgPSBvLkVycm9yQ29kZTtcblx0XHRcdFx0ZGVsZXRlIG8uRXJyb3JDb2RlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGVycm9yQ29kZSA9IGdldEVycm9yQ29kZShoZWFkZXJzKTtcblx0XHRcdH1cblxuXHRcdFx0by5lcnJvciA9IHtcblx0XHRcdFx0Y29kZTogZXJyb3JDb2RlLFxuXHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0XHRkZXRhaWxzOiBvXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0UmVxdWVzdChwLCBxcykge1xuXHRcdC8vIE1vdmUgdGhlIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSByZXF1ZXN0IGJvZHkgdG8gdGhlIHJlcXVlc3QgaGVhZGVyXG5cdFx0dmFyIHRva2VuID0gcXMuYWNjZXNzX3Rva2VuO1xuXHRcdGRlbGV0ZSBxcy5hY2Nlc3NfdG9rZW47XG5cdFx0cC5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmVhcmVyICcgKyB0b2tlbjtcblxuXHRcdC8vIEZvcm1hdCBub24tZ2V0IHJlcXVlc3RzIHRvIGluZGljYXRlIGpzb24gYm9keVxuXHRcdGlmIChwLm1ldGhvZCAhPT0gJ2dldCcgJiYgcC5kYXRhKSB7XG5cdFx0XHRwLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuXHRcdFx0aWYgKHR5cGVvZiAocC5kYXRhKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0cC5kYXRhID0gSlNPTi5zdHJpbmdpZnkocC5kYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocC5tZXRob2QgPT09ICdwdXQnKSB7XG5cdFx0XHRwLm1ldGhvZCA9ICdwYXRjaCc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRFcnJvckNvZGUoaGVhZGVycykge1xuXHRcdHN3aXRjaCAoaGVhZGVycy5zdGF0dXNDb2RlKSB7XG5cdFx0XHRjYXNlIDQwMDpcblx0XHRcdFx0cmV0dXJuICdpbnZhbGlkX3JlcXVlc3QnO1xuXHRcdFx0Y2FzZSA0MDM6XG5cdFx0XHRcdHJldHVybiAnc3RhbGVfdG9rZW4nO1xuXHRcdFx0Y2FzZSA0MDE6XG5cdFx0XHRcdHJldHVybiAnaW52YWxpZF90b2tlbic7XG5cdFx0XHRjYXNlIDUwMDpcblx0XHRcdFx0cmV0dXJuICdzZXJ2ZXJfZXJyb3InO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuICdzZXJ2ZXJfZXJyb3InO1xuXHRcdH1cblx0fVxuXG59KGhlbGxvKSk7XG5cbihmdW5jdGlvbihoZWxsbykge1xuXG5cdGhlbGxvLmluaXQoe1xuXG5cdFx0bGlua2VkaW46IHtcblxuXHRcdFx0b2F1dGg6IHtcblx0XHRcdFx0dmVyc2lvbjogMixcblx0XHRcdFx0cmVzcG9uc2VfdHlwZTogJ2NvZGUnLFxuXHRcdFx0XHRhdXRoOiAnaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL3Vhcy9vYXV0aDIvYXV0aG9yaXphdGlvbicsXG5cdFx0XHRcdGdyYW50OiAnaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL3Vhcy9vYXV0aDIvYWNjZXNzVG9rZW4nXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZWZyZXNoIHRoZSBhY2Nlc3NfdG9rZW4gb25jZSBleHBpcmVkXG5cdFx0XHRyZWZyZXNoOiB0cnVlLFxuXG5cdFx0XHRzY29wZToge1xuXHRcdFx0XHRiYXNpYzogJ3JfYmFzaWNwcm9maWxlJyxcblx0XHRcdFx0ZW1haWw6ICdyX2VtYWlsYWRkcmVzcycsXG5cdFx0XHRcdGZpbGVzOiAnJyxcblx0XHRcdFx0ZnJpZW5kczogJycsXG5cdFx0XHRcdHBob3RvczogJycsXG5cdFx0XHRcdHB1Ymxpc2g6ICd3X3NoYXJlJyxcblx0XHRcdFx0cHVibGlzaF9maWxlczogJ3dfc2hhcmUnLFxuXHRcdFx0XHRzaGFyZTogJycsXG5cdFx0XHRcdHZpZGVvczogJycsXG5cdFx0XHRcdG9mZmxpbmVfYWNjZXNzOiAnJ1xuXHRcdFx0fSxcblx0XHRcdHNjb3BlX2RlbGltOiAnICcsXG5cblx0XHRcdGJhc2U6ICdodHRwczovL2FwaS5saW5rZWRpbi5jb20vdjEvJyxcblxuXHRcdFx0Z2V0OiB7XG5cdFx0XHRcdG1lOiAncGVvcGxlL346KHBpY3R1cmUtdXJsLGZpcnN0LW5hbWUsbGFzdC1uYW1lLGlkLGZvcm1hdHRlZC1uYW1lLGVtYWlsLWFkZHJlc3MpJyxcblxuXHRcdFx0XHQvLyBTZWU6IGh0dHA6Ly9kZXZlbG9wZXIubGlua2VkaW4uY29tL2RvY3VtZW50cy9nZXQtbmV0d29yay11cGRhdGVzLWFuZC1zdGF0aXN0aWNzLWFwaVxuXHRcdFx0XHQnbWUvc2hhcmUnOiAncGVvcGxlL34vbmV0d29yay91cGRhdGVzP2NvdW50PUB7bGltaXR8MjUwfSdcblx0XHRcdH0sXG5cblx0XHRcdHBvc3Q6IHtcblxuXHRcdFx0XHQvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLmxpbmtlZGluLmNvbS9kb2N1bWVudHMvYXBpLXJlcXVlc3RzLWpzb25cblx0XHRcdFx0J21lL3NoYXJlJzogZnVuY3Rpb24ocCwgY2FsbGJhY2spIHtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRcdHZpc2liaWxpdHk6IHtcblx0XHRcdFx0XHRcdFx0Y29kZTogJ2FueW9uZSdcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKHAuZGF0YS5pZCkge1xuXG5cdFx0XHRcdFx0XHRkYXRhLmF0dHJpYnV0aW9uID0ge1xuXHRcdFx0XHRcdFx0XHRzaGFyZToge1xuXHRcdFx0XHRcdFx0XHRcdGlkOiBwLmRhdGEuaWRcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGRhdGEuY29tbWVudCA9IHAuZGF0YS5tZXNzYWdlO1xuXHRcdFx0XHRcdFx0aWYgKHAuZGF0YS5waWN0dXJlICYmIHAuZGF0YS5saW5rKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGEuY29udGVudCA9IHtcblx0XHRcdFx0XHRcdFx0XHQnc3VibWl0dGVkLXVybCc6IHAuZGF0YS5saW5rLFxuXHRcdFx0XHRcdFx0XHRcdCdzdWJtaXR0ZWQtaW1hZ2UtdXJsJzogcC5kYXRhLnBpY3R1cmVcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwLmRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcblxuXHRcdFx0XHRcdGNhbGxiYWNrKCdwZW9wbGUvfi9zaGFyZXM/Zm9ybWF0PWpzb24nKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQnbWUvbGlrZSc6IGxpa2Vcblx0XHRcdH0sXG5cblx0XHRcdGRlbDp7XG5cdFx0XHRcdCdtZS9saWtlJzogbGlrZVxuXHRcdFx0fSxcblxuXHRcdFx0d3JhcDoge1xuXHRcdFx0XHRtZTogZnVuY3Rpb24obykge1xuXHRcdFx0XHRcdGZvcm1hdEVycm9yKG8pO1xuXHRcdFx0XHRcdGZvcm1hdFVzZXIobyk7XG5cdFx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0J21lL2ZyaWVuZHMnOiBmb3JtYXRGcmllbmRzLFxuXHRcdFx0XHQnbWUvZm9sbG93aW5nJzogZm9ybWF0RnJpZW5kcyxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6IGZvcm1hdEZyaWVuZHMsXG5cdFx0XHRcdCdtZS9zaGFyZSc6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdFx0XHRmb3JtYXRFcnJvcihvKTtcblx0XHRcdFx0XHRwYWdpbmcobyk7XG5cdFx0XHRcdFx0aWYgKG8udmFsdWVzKSB7XG5cdFx0XHRcdFx0XHRvLmRhdGEgPSBvLnZhbHVlcy5tYXAoZm9ybWF0VXNlcik7XG5cdFx0XHRcdFx0XHRvLmRhdGEuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0ubWVzc2FnZSA9IGl0ZW0uaGVhZGxpbmU7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0ZGVsZXRlIG8udmFsdWVzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdCdkZWZhdWx0JzogZnVuY3Rpb24obywgaGVhZGVycykge1xuXHRcdFx0XHRcdGZvcm1hdEVycm9yKG8pO1xuXHRcdFx0XHRcdGVtcHR5KG8sIGhlYWRlcnMpO1xuXHRcdFx0XHRcdHBhZ2luZyhvKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0anNvbnA6IGZ1bmN0aW9uKHAsIHFzKSB7XG5cdFx0XHRcdGZvcm1hdFF1ZXJ5KHFzKTtcblx0XHRcdFx0aWYgKHAubWV0aG9kID09PSAnZ2V0Jykge1xuXHRcdFx0XHRcdHFzLmZvcm1hdCA9ICdqc29ucCc7XG5cdFx0XHRcdFx0cXNbJ2Vycm9yLWNhbGxiYWNrJ10gPSBwLmNhbGxiYWNrSUQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHhocjogZnVuY3Rpb24ocCwgcXMpIHtcblx0XHRcdFx0aWYgKHAubWV0aG9kICE9PSAnZ2V0Jykge1xuXHRcdFx0XHRcdGZvcm1hdFF1ZXJ5KHFzKTtcblx0XHRcdFx0XHRwLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuXG5cdFx0XHRcdFx0Ly8gTm90ZTogeC1saS1mb3JtYXQgZW5zdXJlcyBlcnJvciByZXNwb25zZXMgYXJlIG5vdCByZXR1cm5lZCBpbiBYTUxcblx0XHRcdFx0XHRwLmhlYWRlcnNbJ3gtbGktZm9ybWF0J10gPSAnanNvbic7XG5cdFx0XHRcdFx0cC5wcm94eSA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBmb3JtYXRFcnJvcihvKSB7XG5cdFx0aWYgKG8gJiYgJ2Vycm9yQ29kZScgaW4gbykge1xuXHRcdFx0by5lcnJvciA9IHtcblx0XHRcdFx0Y29kZTogby5zdGF0dXMsXG5cdFx0XHRcdG1lc3NhZ2U6IG8ubWVzc2FnZVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRVc2VyKG8pIHtcblx0XHRpZiAoby5lcnJvcikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG8uZmlyc3RfbmFtZSA9IG8uZmlyc3ROYW1lO1xuXHRcdG8ubGFzdF9uYW1lID0gby5sYXN0TmFtZTtcblx0XHRvLm5hbWUgPSBvLmZvcm1hdHRlZE5hbWUgfHwgKG8uZmlyc3RfbmFtZSArICcgJyArIG8ubGFzdF9uYW1lKTtcblx0XHRvLnRodW1ibmFpbCA9IG8ucGljdHVyZVVybDtcblx0XHRvLmVtYWlsID0gby5lbWFpbEFkZHJlc3M7XG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRGcmllbmRzKG8pIHtcblx0XHRmb3JtYXRFcnJvcihvKTtcblx0XHRwYWdpbmcobyk7XG5cdFx0aWYgKG8udmFsdWVzKSB7XG5cdFx0XHRvLmRhdGEgPSBvLnZhbHVlcy5tYXAoZm9ybWF0VXNlcik7XG5cdFx0XHRkZWxldGUgby52YWx1ZXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHRmdW5jdGlvbiBwYWdpbmcocmVzKSB7XG5cdFx0aWYgKCdfY291bnQnIGluIHJlcyAmJiAnX3N0YXJ0JyBpbiByZXMgJiYgKHJlcy5fY291bnQgKyByZXMuX3N0YXJ0KSA8IHJlcy5fdG90YWwpIHtcblx0XHRcdHJlcy5wYWdpbmcgPSB7XG5cdFx0XHRcdG5leHQ6ICc/c3RhcnQ9JyArIChyZXMuX3N0YXJ0ICsgcmVzLl9jb3VudCkgKyAnJmNvdW50PScgKyByZXMuX2NvdW50XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGVtcHR5KG8sIGhlYWRlcnMpIHtcblx0XHRpZiAoSlNPTi5zdHJpbmdpZnkobykgPT09ICd7fScgJiYgaGVhZGVycy5zdGF0dXNDb2RlID09PSAyMDApIHtcblx0XHRcdG8uc3VjY2VzcyA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0UXVlcnkocXMpIHtcblx0XHQvLyBMaW5rZWRJbiBzaWducyByZXF1ZXN0cyB3aXRoIHRoZSBwYXJhbWV0ZXIgJ29hdXRoMl9hY2Nlc3NfdG9rZW4nXG5cdFx0Ly8gLi4uIHllYWggYW5vdGhlciBvbmUgd2hvIHRoaW5rcyB0aGV5IHNob3VsZCBiZSBkaWZmZXJlbnQhXG5cdFx0aWYgKHFzLmFjY2Vzc190b2tlbikge1xuXHRcdFx0cXMub2F1dGgyX2FjY2Vzc190b2tlbiA9IHFzLmFjY2Vzc190b2tlbjtcblx0XHRcdGRlbGV0ZSBxcy5hY2Nlc3NfdG9rZW47XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbGlrZShwLCBjYWxsYmFjaykge1xuXHRcdHAuaGVhZGVyc1sneC1saS1mb3JtYXQnXSA9ICdqc29uJztcblx0XHR2YXIgaWQgPSBwLmRhdGEuaWQ7XG5cdFx0cC5kYXRhID0gKHAubWV0aG9kICE9PSAnZGVsZXRlJykudG9TdHJpbmcoKTtcblx0XHRwLm1ldGhvZCA9ICdwdXQnO1xuXHRcdGNhbGxiYWNrKCdwZW9wbGUvfi9uZXR3b3JrL3VwZGF0ZXMva2V5PScgKyBpZCArICcvaXMtbGlrZWQnKTtcblx0fVxuXG59KShoZWxsbyk7XG5cbi8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXJzLnNvdW5kY2xvdWQuY29tL2RvY3MvYXBpL3JlZmVyZW5jZVxuKGZ1bmN0aW9uKGhlbGxvKSB7XG5cblx0aGVsbG8uaW5pdCh7XG5cblx0XHRzb3VuZGNsb3VkOiB7XG5cdFx0XHRuYW1lOiAnU291bmRDbG91ZCcsXG5cblx0XHRcdG9hdXRoOiB7XG5cdFx0XHRcdHZlcnNpb246IDIsXG5cdFx0XHRcdGF1dGg6ICdodHRwczovL3NvdW5kY2xvdWQuY29tL2Nvbm5lY3QnLFxuXHRcdFx0XHRncmFudDogJ2h0dHBzOi8vc291bmRjbG91ZC5jb20vb2F1dGgyL3Rva2VuJ1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVxdWVzdCBwYXRoIHRyYW5zbGF0ZWRcblx0XHRcdGJhc2U6ICdodHRwczovL2FwaS5zb3VuZGNsb3VkLmNvbS8nLFxuXHRcdFx0Z2V0OiB7XG5cdFx0XHRcdG1lOiAnbWUuanNvbicsXG5cblx0XHRcdFx0Ly8gSHR0cDovL2RldmVsb3BlcnMuc291bmRjbG91ZC5jb20vZG9jcy9hcGkvcmVmZXJlbmNlI21lXG5cdFx0XHRcdCdtZS9mcmllbmRzJzogJ21lL2ZvbGxvd2luZ3MuanNvbicsXG5cdFx0XHRcdCdtZS9mb2xsb3dlcnMnOiAnbWUvZm9sbG93ZXJzLmpzb24nLFxuXHRcdFx0XHQnbWUvZm9sbG93aW5nJzogJ21lL2ZvbGxvd2luZ3MuanNvbicsXG5cblx0XHRcdFx0Ly8gU2VlOiBodHRwOi8vZGV2ZWxvcGVycy5zb3VuZGNsb3VkLmNvbS9kb2NzL2FwaS9yZWZlcmVuY2UjYWN0aXZpdGllc1xuXHRcdFx0XHQnZGVmYXVsdCc6IGZ1bmN0aW9uKHAsIGNhbGxiYWNrKSB7XG5cblx0XHRcdFx0XHQvLyBJbmNsdWRlICcuanNvbiBhdCB0aGUgZW5kIG9mIGVhY2ggcmVxdWVzdCdcblx0XHRcdFx0XHRjYWxsYmFjayhwLnBhdGggKyAnLmpzb24nKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGFuZGxlcnNcblx0XHRcdHdyYXA6IHtcblx0XHRcdFx0bWU6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdFx0XHRmb3JtYXRVc2VyKG8pO1xuXHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdCdkZWZhdWx0JzogZnVuY3Rpb24obykge1xuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG5cdFx0XHRcdFx0XHRvID0ge1xuXHRcdFx0XHRcdFx0XHRkYXRhOiBvLm1hcChmb3JtYXRVc2VyKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwYWdpbmcobyk7XG5cdFx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHhocjogZm9ybWF0UmVxdWVzdCxcblx0XHRcdGpzb25wOiBmb3JtYXRSZXF1ZXN0XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBmb3JtYXRSZXF1ZXN0KHAsIHFzKSB7XG5cdFx0Ly8gQWx0ZXIgdGhlIHF1ZXJ5c3RyaW5nXG5cdFx0dmFyIHRva2VuID0gcXMuYWNjZXNzX3Rva2VuO1xuXHRcdGRlbGV0ZSBxcy5hY2Nlc3NfdG9rZW47XG5cdFx0cXMub2F1dGhfdG9rZW4gPSB0b2tlbjtcblx0XHRxc1snX3N0YXR1c19jb2RlX21hcFszMDJdJ10gPSAyMDA7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRVc2VyKG8pIHtcblx0XHRpZiAoby5pZCkge1xuXHRcdFx0by5waWN0dXJlID0gby5hdmF0YXJfdXJsO1xuXHRcdFx0by50aHVtYm5haWwgPSBvLmF2YXRhcl91cmw7XG5cdFx0XHRvLm5hbWUgPSBvLnVzZXJuYW1lIHx8IG8uZnVsbF9uYW1lO1xuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0Ly8gU2VlOiBodHRwOi8vZGV2ZWxvcGVycy5zb3VuZGNsb3VkLmNvbS9kb2NzL2FwaS9yZWZlcmVuY2UjYWN0aXZpdGllc1xuXHRmdW5jdGlvbiBwYWdpbmcocmVzKSB7XG5cdFx0aWYgKCduZXh0X2hyZWYnIGluIHJlcykge1xuXHRcdFx0cmVzLnBhZ2luZyA9IHtcblx0XHRcdFx0bmV4dDogcmVzLm5leHRfaHJlZlxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxufSkoaGVsbG8pO1xuXG4oZnVuY3Rpb24oaGVsbG8pIHtcblxuXHR2YXIgYmFzZSA9ICdodHRwczovL2FwaS50d2l0dGVyLmNvbS8nO1xuXG5cdGhlbGxvLmluaXQoe1xuXG5cdFx0dHdpdHRlcjoge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhhdCB5b3UgZGVmaW5lIGFuIG9hdXRoX3Byb3h5XG5cdFx0XHRvYXV0aDoge1xuXHRcdFx0XHR2ZXJzaW9uOiAnMS4wYScsXG5cdFx0XHRcdGF1dGg6IGJhc2UgKyAnb2F1dGgvYXV0aGVudGljYXRlJyxcblx0XHRcdFx0cmVxdWVzdDogYmFzZSArICdvYXV0aC9yZXF1ZXN0X3Rva2VuJyxcblx0XHRcdFx0dG9rZW46IGJhc2UgKyAnb2F1dGgvYWNjZXNzX3Rva2VuJ1xuXHRcdFx0fSxcblxuXHRcdFx0bG9naW46IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0Ly8gUmVhdXRoZW50aWNhdGVcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kZXYudHdpdHRlci5jb20vb2F1dGgvcmVmZXJlbmNlL2dldC9vYXV0aC9hdXRoZW50aWNhdGVcblx0XHRcdFx0dmFyIHByZWZpeCA9ICc/Zm9yY2VfbG9naW49dHJ1ZSc7XG5cdFx0XHRcdHRoaXMub2F1dGguYXV0aCA9IHRoaXMub2F1dGguYXV0aC5yZXBsYWNlKHByZWZpeCwgJycpICsgKHAub3B0aW9ucy5mb3JjZSA/IHByZWZpeCA6ICcnKTtcblx0XHRcdH0sXG5cblx0XHRcdGJhc2U6IGJhc2UgKyAnMS4xLycsXG5cblx0XHRcdGdldDoge1xuXHRcdFx0XHRtZTogJ2FjY291bnQvdmVyaWZ5X2NyZWRlbnRpYWxzLmpzb24nLFxuXHRcdFx0XHQnbWUvZnJpZW5kcyc6ICdmcmllbmRzL2xpc3QuanNvbj9jb3VudD1Ae2xpbWl0fDIwMH0nLFxuXHRcdFx0XHQnbWUvZm9sbG93aW5nJzogJ2ZyaWVuZHMvbGlzdC5qc29uP2NvdW50PUB7bGltaXR8MjAwfScsXG5cdFx0XHRcdCdtZS9mb2xsb3dlcnMnOiAnZm9sbG93ZXJzL2xpc3QuanNvbj9jb3VudD1Ae2xpbWl0fDIwMH0nLFxuXG5cdFx0XHRcdC8vIEh0dHBzOi8vZGV2LnR3aXR0ZXIuY29tL2RvY3MvYXBpLzEuMS9nZXQvc3RhdHVzZXMvdXNlcl90aW1lbGluZVxuXHRcdFx0XHQnbWUvc2hhcmUnOiAnc3RhdHVzZXMvdXNlcl90aW1lbGluZS5qc29uP2NvdW50PUB7bGltaXR8MjAwfScsXG5cblx0XHRcdFx0Ly8gSHR0cHM6Ly9kZXYudHdpdHRlci5jb20vcmVzdC9yZWZlcmVuY2UvZ2V0L2Zhdm9yaXRlcy9saXN0XG5cdFx0XHRcdCdtZS9saWtlJzogJ2Zhdm9yaXRlcy9saXN0Lmpzb24/Y291bnQ9QHtsaW1pdHwyMDB9J1xuXHRcdFx0fSxcblxuXHRcdFx0cG9zdDoge1xuXHRcdFx0XHQnbWUvc2hhcmUnOiBmdW5jdGlvbihwLCBjYWxsYmFjaykge1xuXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBwLmRhdGE7XG5cdFx0XHRcdFx0cC5kYXRhID0gbnVsbDtcblxuXHRcdFx0XHRcdHZhciBzdGF0dXMgPSBbXTtcblxuXHRcdFx0XHRcdC8vIENoYW5nZSBtZXNzYWdlIHRvIHN0YXR1c1xuXHRcdFx0XHRcdGlmIChkYXRhLm1lc3NhZ2UpIHtcblx0XHRcdFx0XHRcdHN0YXR1cy5wdXNoKGRhdGEubWVzc2FnZSk7XG5cdFx0XHRcdFx0XHRkZWxldGUgZGF0YS5tZXNzYWdlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElmIGxpbmsgaXMgZ2l2ZW5cblx0XHRcdFx0XHRpZiAoZGF0YS5saW5rKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMucHVzaChkYXRhLmxpbmspO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGRhdGEubGluaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZGF0YS5waWN0dXJlKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMucHVzaChkYXRhLnBpY3R1cmUpO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGRhdGEucGljdHVyZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDb21wb3VuZCBhbGwgdGhlIGNvbXBvbmVudHNcblx0XHRcdFx0XHRpZiAoc3RhdHVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0ZGF0YS5zdGF0dXMgPSBzdGF0dXMuam9pbignICcpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFR3ZWV0IG1lZGlhXG5cdFx0XHRcdFx0aWYgKGRhdGEuZmlsZSkge1xuXHRcdFx0XHRcdFx0ZGF0YVsnbWVkaWFbXSddID0gZGF0YS5maWxlO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGRhdGEuZmlsZTtcblx0XHRcdFx0XHRcdHAuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygnc3RhdHVzZXMvdXBkYXRlX3dpdGhfbWVkaWEuanNvbicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJldHdlZXQ/XG5cdFx0XHRcdFx0ZWxzZSBpZiAoJ2lkJyBpbiBkYXRhKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygnc3RhdHVzZXMvcmV0d2VldC8nICsgZGF0YS5pZCArICcuanNvbicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFR3ZWV0XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBBc3NpZ24gdGhlIHBvc3QgYm9keSB0byB0aGUgcXVlcnkgcGFyYW1ldGVyc1xuXHRcdFx0XHRcdFx0aGVsbG8udXRpbHMuZXh0ZW5kKHAucXVlcnksIGRhdGEpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soJ3N0YXR1c2VzL3VwZGF0ZS5qc29uP2luY2x1ZGVfZW50aXRpZXM9MScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTZWU6IGh0dHBzOi8vZGV2LnR3aXR0ZXIuY29tL3Jlc3QvcmVmZXJlbmNlL3Bvc3QvZmF2b3JpdGVzL2NyZWF0ZVxuXHRcdFx0XHQnbWUvbGlrZSc6IGZ1bmN0aW9uKHAsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0dmFyIGlkID0gcC5kYXRhLmlkO1xuXHRcdFx0XHRcdHAuZGF0YSA9IG51bGw7XG5cdFx0XHRcdFx0Y2FsbGJhY2soJ2Zhdm9yaXRlcy9jcmVhdGUuanNvbj9pZD0nICsgaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRkZWw6IHtcblxuXHRcdFx0XHQvLyBTZWU6IGh0dHBzOi8vZGV2LnR3aXR0ZXIuY29tL3Jlc3QvcmVmZXJlbmNlL3Bvc3QvZmF2b3JpdGVzL2Rlc3Ryb3lcblx0XHRcdFx0J21lL2xpa2UnOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRwLm1ldGhvZCA9ICdwb3N0Jztcblx0XHRcdFx0XHR2YXIgaWQgPSBwLmRhdGEuaWQ7XG5cdFx0XHRcdFx0cC5kYXRhID0gbnVsbDtcblx0XHRcdFx0XHRjYWxsYmFjaygnZmF2b3JpdGVzL2Rlc3Ryb3kuanNvbj9pZD0nICsgaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHR3cmFwOiB7XG5cdFx0XHRcdG1lOiBmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHRmb3JtYXRFcnJvcihyZXMpO1xuXHRcdFx0XHRcdGZvcm1hdFVzZXIocmVzKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdCdtZS9mcmllbmRzJzogZm9ybWF0RnJpZW5kcyxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6IGZvcm1hdEZyaWVuZHMsXG5cdFx0XHRcdCdtZS9mb2xsb3dpbmcnOiBmb3JtYXRGcmllbmRzLFxuXG5cdFx0XHRcdCdtZS9zaGFyZSc6IGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRcdGZvcm1hdEVycm9yKHJlcyk7XG5cdFx0XHRcdFx0cGFnaW5nKHJlcyk7XG5cdFx0XHRcdFx0aWYgKCFyZXMuZXJyb3IgJiYgJ2xlbmd0aCcgaW4gcmVzKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge2RhdGE6IHJlc307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQnZGVmYXVsdCc6IGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRcdHJlcyA9IGFycmF5VG9EYXRhUmVzcG9uc2UocmVzKTtcblx0XHRcdFx0XHRwYWdpbmcocmVzKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0eGhyOiBmdW5jdGlvbihwKSB7XG5cblx0XHRcdFx0Ly8gUmVseSBvbiB0aGUgcHJveHkgZm9yIG5vbi1HRVQgcmVxdWVzdHMuXG5cdFx0XHRcdHJldHVybiAocC5tZXRob2QgIT09ICdnZXQnKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGZvcm1hdFVzZXIobykge1xuXHRcdGlmIChvLmlkKSB7XG5cdFx0XHRpZiAoby5uYW1lKSB7XG5cdFx0XHRcdHZhciBtID0gby5uYW1lLnNwbGl0KCcgJyk7XG5cdFx0XHRcdG8uZmlyc3RfbmFtZSA9IG0uc2hpZnQoKTtcblx0XHRcdFx0by5sYXN0X25hbWUgPSBtLmpvaW4oJyAnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlOiBodHRwczovL2Rldi50d2l0dGVyLmNvbS9vdmVydmlldy9nZW5lcmFsL3VzZXItcHJvZmlsZS1pbWFnZXMtYW5kLWJhbm5lcnNcblx0XHRcdG8udGh1bWJuYWlsID0gby5wcm9maWxlX2ltYWdlX3VybF9odHRwcyB8fCBvLnByb2ZpbGVfaW1hZ2VfdXJsO1xuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0RnJpZW5kcyhvKSB7XG5cdFx0Zm9ybWF0RXJyb3Iobyk7XG5cdFx0cGFnaW5nKG8pO1xuXHRcdGlmIChvLnVzZXJzKSB7XG5cdFx0XHRvLmRhdGEgPSBvLnVzZXJzLm1hcChmb3JtYXRVc2VyKTtcblx0XHRcdGRlbGV0ZSBvLnVzZXJzO1xuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0RXJyb3Iobykge1xuXHRcdGlmIChvLmVycm9ycykge1xuXHRcdFx0dmFyIGUgPSBvLmVycm9yc1swXTtcblx0XHRcdG8uZXJyb3IgPSB7XG5cdFx0XHRcdGNvZGU6ICdyZXF1ZXN0X2ZhaWxlZCcsXG5cdFx0XHRcdG1lc3NhZ2U6IGUubWVzc2FnZVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHQvLyBUYWtlIGEgY3Vyc29yIGFuZCBhZGQgaXQgdG8gdGhlIHBhdGhcblx0ZnVuY3Rpb24gcGFnaW5nKHJlcykge1xuXHRcdC8vIERvZXMgdGhlIHJlc3BvbnNlIGluY2x1ZGUgYSAnbmV4dF9jdXJzb3Jfc3RyaW5nJ1xuXHRcdGlmICgnbmV4dF9jdXJzb3Jfc3RyJyBpbiByZXMpIHtcblx0XHRcdC8vIFNlZTogaHR0cHM6Ly9kZXYudHdpdHRlci5jb20vZG9jcy9taXNjL2N1cnNvcmluZ1xuXHRcdFx0cmVzLnBhZ2luZyA9IHtcblx0XHRcdFx0bmV4dDogJz9jdXJzb3I9JyArIHJlcy5uZXh0X2N1cnNvcl9zdHJcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYXJyYXlUb0RhdGFSZXNwb25zZShyZXMpIHtcblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShyZXMpID8ge2RhdGE6IHJlc30gOiByZXM7XG5cdH1cblxuXHQvKipcblx0Ly8gVGhlIGRvY3VtZW50YXRpb24gc2F5cyB0byBkZWZpbmUgdXNlciBpbiB0aGUgcmVxdWVzdFxuXHQvLyBBbHRob3VnaCBpdHMgbm90IGFjdHVhbGx5IHJlcXVpcmVkLlxuXG5cdHZhciB1c2VyX2lkO1xuXG5cdGZ1bmN0aW9uIHdpdGhVc2VySWQoY2FsbGJhY2spe1xuXHRcdGlmKHVzZXJfaWQpe1xuXHRcdFx0Y2FsbGJhY2sodXNlcl9pZCk7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0XHRoZWxsby5hcGkoJ3R3aXR0ZXI6L21lJywgZnVuY3Rpb24obyl7XG5cdFx0XHRcdHVzZXJfaWQgPSBvLmlkO1xuXHRcdFx0XHRjYWxsYmFjayhvLmlkKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNpZ24odXJsKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24ocCwgY2FsbGJhY2spe1xuXHRcdFx0d2l0aFVzZXJJZChmdW5jdGlvbih1c2VyX2lkKXtcblx0XHRcdFx0Y2FsbGJhY2sodXJsKyc/dXNlcl9pZD0nK3VzZXJfaWQpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fVxuXHQqL1xuXG59KShoZWxsbyk7XG5cbi8vIFZrb250YWt0ZSAodmsuY29tKVxuKGZ1bmN0aW9uKGhlbGxvKSB7XG5cblx0aGVsbG8uaW5pdCh7XG5cblx0XHR2azoge1xuXHRcdFx0bmFtZTogJ1ZrJyxcblxuXHRcdFx0Ly8gU2VlIGh0dHBzOi8vdmsuY29tL2Rldi9vYXV0aF9kaWFsb2dcblx0XHRcdG9hdXRoOiB7XG5cdFx0XHRcdHZlcnNpb246IDIsXG5cdFx0XHRcdGF1dGg6ICdodHRwczovL29hdXRoLnZrLmNvbS9hdXRob3JpemUnLFxuXHRcdFx0XHRncmFudDogJ2h0dHBzOi8vb2F1dGgudmsuY29tL2FjY2Vzc190b2tlbidcblx0XHRcdH0sXG5cblx0XHRcdC8vIEF1dGhvcml6YXRpb24gc2NvcGVzXG5cdFx0XHQvLyBTZWUgaHR0cHM6Ly92ay5jb20vZGV2L3Blcm1pc3Npb25zXG5cdFx0XHRzY29wZToge1xuXHRcdFx0XHRlbWFpbDogJ2VtYWlsJyxcblx0XHRcdFx0ZnJpZW5kczogJ2ZyaWVuZHMnLFxuXHRcdFx0XHRwaG90b3M6ICdwaG90b3MnLFxuXHRcdFx0XHR2aWRlb3M6ICd2aWRlbycsXG5cdFx0XHRcdHNoYXJlOiAnc2hhcmUnLFxuXHRcdFx0XHRvZmZsaW5lX2FjY2VzczogJ29mZmxpbmUnXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZWZyZXNoIHRoZSBhY2Nlc3NfdG9rZW5cblx0XHRcdHJlZnJlc2g6IHRydWUsXG5cblx0XHRcdGxvZ2luOiBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHAucXMuZGlzcGxheSA9IHdpbmRvdy5uYXZpZ2F0b3IgJiZcblx0XHRcdFx0XHR3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCAmJlxuXHRcdFx0XHRcdC9pcGFkfHBob25lfHBob25lfGFuZHJvaWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkgPyAnbW9iaWxlJyA6ICdwb3B1cCc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBBUEkgQmFzZSBVUkxcblx0XHRcdGJhc2U6ICdodHRwczovL2FwaS52ay5jb20vbWV0aG9kLycsXG5cblx0XHRcdC8vIE1hcCBHRVQgcmVxdWVzdHNcblx0XHRcdGdldDoge1xuXHRcdFx0XHRtZTogZnVuY3Rpb24ocCwgY2FsbGJhY2spIHtcblx0XHRcdFx0XHRwLnF1ZXJ5LmZpZWxkcyA9ICdpZCxmaXJzdF9uYW1lLGxhc3RfbmFtZSxwaG90b19tYXgnO1xuXHRcdFx0XHRcdGNhbGxiYWNrKCd1c2Vycy5nZXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0d3JhcDoge1xuXHRcdFx0XHRtZTogZnVuY3Rpb24ocmVzLCBoZWFkZXJzLCByZXEpIHtcblx0XHRcdFx0XHRmb3JtYXRFcnJvcihyZXMpO1xuXHRcdFx0XHRcdHJldHVybiBmb3JtYXRVc2VyKHJlcywgcmVxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gTm8gWEhSXG5cdFx0XHR4aHI6IGZhbHNlLFxuXG5cdFx0XHQvLyBBbGwgcmVxdWVzdHMgc2hvdWxkIGJlIEpTT05QIGFzIG9mIG1pc3NpbmcgQ09SUyBoZWFkZXJzIGluIGh0dHBzOi8vYXBpLnZrLmNvbS9tZXRob2QvKlxuXHRcdFx0anNvbnA6IHRydWUsXG5cblx0XHRcdC8vIE5vIGZvcm1cblx0XHRcdGZvcm06IGZhbHNlXG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBmb3JtYXRVc2VyKG8sIHJlcSkge1xuXG5cdFx0aWYgKG8gIT09IG51bGwgJiYgJ3Jlc3BvbnNlJyBpbiBvICYmIG8ucmVzcG9uc2UgIT09IG51bGwgJiYgby5yZXNwb25zZS5sZW5ndGgpIHtcblx0XHRcdG8gPSBvLnJlc3BvbnNlWzBdO1xuXHRcdFx0by5pZCA9IG8udWlkO1xuXHRcdFx0by50aHVtYm5haWwgPSBvLnBpY3R1cmUgPSBvLnBob3RvX21heDtcblx0XHRcdG8ubmFtZSA9IG8uZmlyc3RfbmFtZSArICcgJyArIG8ubGFzdF9uYW1lO1xuXG5cdFx0XHRpZiAocmVxLmF1dGhSZXNwb25zZSAmJiByZXEuYXV0aFJlc3BvbnNlLmVtYWlsICE9PSBudWxsKVxuXHRcdFx0XHRvLmVtYWlsID0gcmVxLmF1dGhSZXNwb25zZS5lbWFpbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdEVycm9yKG8pIHtcblxuXHRcdGlmIChvLmVycm9yKSB7XG5cdFx0XHR2YXIgZSA9IG8uZXJyb3I7XG5cdFx0XHRvLmVycm9yID0ge1xuXHRcdFx0XHRjb2RlOiBlLmVycm9yX2NvZGUsXG5cdFx0XHRcdG1lc3NhZ2U6IGUuZXJyb3JfbXNnXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG59KShoZWxsbyk7XG5cbihmdW5jdGlvbihoZWxsbykge1xuXG5cdGhlbGxvLmluaXQoe1xuXHRcdHdpbmRvd3M6IHtcblx0XHRcdG5hbWU6ICdXaW5kb3dzIGxpdmUnLFxuXG5cdFx0XHQvLyBSRUY6IGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDI0MzY0MS5hc3B4XG5cdFx0XHRvYXV0aDoge1xuXHRcdFx0XHR2ZXJzaW9uOiAyLFxuXHRcdFx0XHRhdXRoOiAnaHR0cHM6Ly9sb2dpbi5saXZlLmNvbS9vYXV0aDIwX2F1dGhvcml6ZS5zcmYnLFxuXHRcdFx0XHRncmFudDogJ2h0dHBzOi8vbG9naW4ubGl2ZS5jb20vb2F1dGgyMF90b2tlbi5zcmYnXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZWZyZXNoIHRoZSBhY2Nlc3NfdG9rZW4gb25jZSBleHBpcmVkXG5cdFx0XHRyZWZyZXNoOiB0cnVlLFxuXG5cdFx0XHRsb2dvdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJ2h0dHA6Ly9sb2dpbi5saXZlLmNvbS9vYXV0aDIwX2xvZ291dC5zcmY/dHM9JyArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBBdXRob3JpemF0aW9uIHNjb3Blc1xuXHRcdFx0c2NvcGU6IHtcblx0XHRcdFx0YmFzaWM6ICd3bC5zaWduaW4sd2wuYmFzaWMnLFxuXHRcdFx0XHRlbWFpbDogJ3dsLmVtYWlscycsXG5cdFx0XHRcdGJpcnRoZGF5OiAnd2wuYmlydGhkYXknLFxuXHRcdFx0XHRldmVudHM6ICd3bC5jYWxlbmRhcnMnLFxuXHRcdFx0XHRwaG90b3M6ICd3bC5waG90b3MnLFxuXHRcdFx0XHR2aWRlb3M6ICd3bC5waG90b3MnLFxuXHRcdFx0XHRmcmllbmRzOiAnd2wuY29udGFjdHNfZW1haWxzJyxcblx0XHRcdFx0ZmlsZXM6ICd3bC5za3lkcml2ZScsXG5cdFx0XHRcdHB1Ymxpc2g6ICd3bC5zaGFyZScsXG5cdFx0XHRcdHB1Ymxpc2hfZmlsZXM6ICd3bC5za3lkcml2ZV91cGRhdGUnLFxuXHRcdFx0XHRzaGFyZTogJ3dsLnNoYXJlJyxcblx0XHRcdFx0Y3JlYXRlX2V2ZW50OiAnd2wuY2FsZW5kYXJzX3VwZGF0ZSx3bC5ldmVudHNfY3JlYXRlJyxcblx0XHRcdFx0b2ZmbGluZV9hY2Nlc3M6ICd3bC5vZmZsaW5lX2FjY2Vzcydcblx0XHRcdH0sXG5cblx0XHRcdC8vIEFQSSBiYXNlIFVSTFxuXHRcdFx0YmFzZTogJ2h0dHBzOi8vYXBpcy5saXZlLm5ldC92NS4wLycsXG5cblx0XHRcdC8vIE1hcCBHRVQgcmVxdWVzdHNcblx0XHRcdGdldDoge1xuXG5cdFx0XHRcdC8vIEZyaWVuZHNcblx0XHRcdFx0bWU6ICdtZScsXG5cdFx0XHRcdCdtZS9mcmllbmRzJzogJ21lL2ZyaWVuZHMnLFxuXHRcdFx0XHQnbWUvZm9sbG93aW5nJzogJ21lL2NvbnRhY3RzJyxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6ICdtZS9mcmllbmRzJyxcblx0XHRcdFx0J21lL2NvbnRhY3RzJzogJ21lL2NvbnRhY3RzJyxcblxuXHRcdFx0XHQnbWUvYWxidW1zJzogJ21lL2FsYnVtcycsXG5cblx0XHRcdFx0Ly8gSW5jbHVkZSB0aGUgZGF0YVtpZF0gaW4gdGhlIHBhdGhcblx0XHRcdFx0J21lL2FsYnVtJzogJ0B7aWR9L2ZpbGVzJyxcblx0XHRcdFx0J21lL3Bob3RvJzogJ0B7aWR9JyxcblxuXHRcdFx0XHQvLyBGaWxlc1xuXHRcdFx0XHQnbWUvZmlsZXMnOiAnQHtwYXJlbnR8bWUvc2t5ZHJpdmV9L2ZpbGVzJyxcblx0XHRcdFx0J21lL2ZvbGRlcnMnOiAnQHtpZHxtZS9za3lkcml2ZX0vZmlsZXMnLFxuXHRcdFx0XHQnbWUvZm9sZGVyJzogJ0B7aWR8bWUvc2t5ZHJpdmV9L2ZpbGVzJ1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gTWFwIFBPU1QgcmVxdWVzdHNcblx0XHRcdHBvc3Q6IHtcblx0XHRcdFx0J21lL2FsYnVtcyc6ICdtZS9hbGJ1bXMnLFxuXHRcdFx0XHQnbWUvYWxidW0nOiAnQHtpZH0vZmlsZXMvJyxcblxuXHRcdFx0XHQnbWUvZm9sZGVycyc6ICdAe2lkfG1lL3NreWRyaXZlL30nLFxuXHRcdFx0XHQnbWUvZmlsZXMnOiAnQHtwYXJlbnR8bWUvc2t5ZHJpdmV9L2ZpbGVzJ1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gTWFwIERFTEVURSByZXF1ZXN0c1xuXHRcdFx0ZGVsOiB7XG5cdFx0XHRcdC8vIEluY2x1ZGUgdGhlIGRhdGFbaWRdIGluIHRoZSBwYXRoXG5cdFx0XHRcdCdtZS9hbGJ1bSc6ICdAe2lkfScsXG5cdFx0XHRcdCdtZS9waG90byc6ICdAe2lkfScsXG5cdFx0XHRcdCdtZS9mb2xkZXInOiAnQHtpZH0nLFxuXHRcdFx0XHQnbWUvZmlsZXMnOiAnQHtpZH0nXG5cdFx0XHR9LFxuXG5cdFx0XHR3cmFwOiB7XG5cdFx0XHRcdG1lOiBmb3JtYXRVc2VyLFxuXG5cdFx0XHRcdCdtZS9mcmllbmRzJzogZm9ybWF0RnJpZW5kcyxcblx0XHRcdFx0J21lL2NvbnRhY3RzJzogZm9ybWF0RnJpZW5kcyxcblx0XHRcdFx0J21lL2ZvbGxvd2Vycyc6IGZvcm1hdEZyaWVuZHMsXG5cdFx0XHRcdCdtZS9mb2xsb3dpbmcnOiBmb3JtYXRGcmllbmRzLFxuXHRcdFx0XHQnbWUvYWxidW1zJzogZm9ybWF0QWxidW1zLFxuXHRcdFx0XHQnbWUvcGhvdG9zJzogZm9ybWF0RGVmYXVsdCxcblx0XHRcdFx0J2RlZmF1bHQnOiBmb3JtYXREZWZhdWx0XG5cdFx0XHR9LFxuXG5cdFx0XHR4aHI6IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKHAubWV0aG9kICE9PSAnZ2V0JyAmJiBwLm1ldGhvZCAhPT0gJ2RlbGV0ZScgJiYgIWhlbGxvLnV0aWxzLmhhc0JpbmFyeShwLmRhdGEpKSB7XG5cblx0XHRcdFx0XHQvLyBEb2VzIHRoaXMgaGF2ZSBhIGRhdGEtdXJpIHRvIHVwbG9hZCBhcyBhIGZpbGU/XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiAocC5kYXRhLmZpbGUpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0cC5kYXRhLmZpbGUgPSBoZWxsby51dGlscy50b0Jsb2IocC5kYXRhLmZpbGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHAuZGF0YSA9IEpTT04uc3RyaW5naWZ5KHAuZGF0YSk7XG5cdFx0XHRcdFx0XHRwLmhlYWRlcnMgPSB7XG5cdFx0XHRcdFx0XHRcdCdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHRqc29ucDogZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAocC5tZXRob2QgIT09ICdnZXQnICYmICFoZWxsby51dGlscy5oYXNCaW5hcnkocC5kYXRhKSkge1xuXHRcdFx0XHRcdHAuZGF0YS5tZXRob2QgPSBwLm1ldGhvZDtcblx0XHRcdFx0XHRwLm1ldGhvZCA9ICdnZXQnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBmb3JtYXREZWZhdWx0KG8pIHtcblx0XHRpZiAoJ2RhdGEnIGluIG8pIHtcblx0XHRcdG8uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0aWYgKGQucGljdHVyZSkge1xuXHRcdFx0XHRcdGQudGh1bWJuYWlsID0gZC5waWN0dXJlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGQuaW1hZ2VzKSB7XG5cdFx0XHRcdFx0ZC5waWN0dXJlcyA9IGQuaW1hZ2VzXG5cdFx0XHRcdFx0XHQubWFwKGZvcm1hdEltYWdlKVxuXHRcdFx0XHRcdFx0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYS53aWR0aCAtIGIud2lkdGg7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRJbWFnZShpbWFnZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodCxcblx0XHRcdHNvdXJjZTogaW1hZ2Uuc291cmNlXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdEFsYnVtcyhvKSB7XG5cdFx0aWYgKCdkYXRhJyBpbiBvKSB7XG5cdFx0XHRvLmRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGQucGhvdG9zID0gZC5maWxlcyA9ICdodHRwczovL2FwaXMubGl2ZS5uZXQvdjUuMC8nICsgZC5pZCArICcvcGhvdG9zJztcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0VXNlcihvLCBoZWFkZXJzLCByZXEpIHtcblx0XHRpZiAoby5pZCkge1xuXHRcdFx0dmFyIHRva2VuID0gcmVxLnF1ZXJ5LmFjY2Vzc190b2tlbjtcblx0XHRcdGlmIChvLmVtYWlscykge1xuXHRcdFx0XHRvLmVtYWlsID0gby5lbWFpbHMucHJlZmVycmVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIG5vdCBhbiBub24tbmV0d29yayBmcmllbmRcblx0XHRcdGlmIChvLmlzX2ZyaWVuZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Ly8gVXNlIHRoZSBpZCBvZiB0aGUgdXNlcl9pZCBpZiBhdmFpbGFibGVcblx0XHRcdFx0dmFyIGlkID0gKG8udXNlcl9pZCB8fCBvLmlkKTtcblx0XHRcdFx0by50aHVtYm5haWwgPSBvLnBpY3R1cmUgPSAnaHR0cHM6Ly9hcGlzLmxpdmUubmV0L3Y1LjAvJyArIGlkICsgJy9waWN0dXJlP2FjY2Vzc190b2tlbj0nICsgdG9rZW47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRGcmllbmRzKG8sIGhlYWRlcnMsIHJlcSkge1xuXHRcdGlmICgnZGF0YScgaW4gbykge1xuXHRcdFx0by5kYXRhLmZvckVhY2goZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRmb3JtYXRVc2VyKGQsIGhlYWRlcnMsIHJlcSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbztcblx0fVxuXG59KShoZWxsbyk7XG5cbihmdW5jdGlvbihoZWxsbykge1xuXG5cdGhlbGxvLmluaXQoe1xuXG5cdFx0eWFob286IHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoYXQgeW91IGRlZmluZSBhbiBvYXV0aF9wcm94eVxuXHRcdFx0b2F1dGg6IHtcblx0XHRcdFx0dmVyc2lvbjogJzEuMGEnLFxuXHRcdFx0XHRhdXRoOiAnaHR0cHM6Ly9hcGkubG9naW4ueWFob28uY29tL29hdXRoL3YyL3JlcXVlc3RfYXV0aCcsXG5cdFx0XHRcdHJlcXVlc3Q6ICdodHRwczovL2FwaS5sb2dpbi55YWhvby5jb20vb2F1dGgvdjIvZ2V0X3JlcXVlc3RfdG9rZW4nLFxuXHRcdFx0XHR0b2tlbjogJ2h0dHBzOi8vYXBpLmxvZ2luLnlhaG9vLmNvbS9vYXV0aC92Mi9nZXRfdG9rZW4nXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBMb2dpbiBoYW5kbGVyXG5cdFx0XHRsb2dpbjogZnVuY3Rpb24ocCkge1xuXHRcdFx0XHQvLyBDaGFuZ2UgdGhlIGRlZmF1bHQgcG9wdXAgd2luZG93IHRvIGJlIGF0IGxlYXN0IDU2MFxuXHRcdFx0XHQvLyBZYWhvbyBkb2VzIGR5bmFtaWNhbGx5IGNoYW5nZSBpdCBvbiB0aGUgZmx5IGZvciB0aGUgc2lnbmluIHNjcmVlbiAob25seSwgd2hhdCBpZiB5b3VyIGFscmVhZHkgc2lnbmVkIGluKVxuXHRcdFx0XHRwLm9wdGlvbnMucG9wdXAud2lkdGggPSA1NjA7XG5cblx0XHRcdFx0Ly8gWWFob28gdGhyb3dzIGFuIHBhcmFtZXRlciBlcnJvciBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBzdGF0ZS5zY29wZSBjb250YWlucyBhIGNvbW1hLCBzbyBsZXRzIHJlbW92ZSBzY29wZVxuXHRcdFx0XHR0cnkge2RlbGV0ZSBwLnFzLnN0YXRlLnNjb3BlO31cblx0XHRcdFx0Y2F0Y2ggKGUpIHt9XG5cdFx0XHR9LFxuXG5cdFx0XHRiYXNlOiAnaHR0cHM6Ly9zb2NpYWwueWFob29hcGlzLmNvbS92MS8nLFxuXG5cdFx0XHRnZXQ6IHtcblx0XHRcdFx0bWU6IHlxbCgnc2VsZWN0ICogZnJvbSBzb2NpYWwucHJvZmlsZSgwKSB3aGVyZSBndWlkPW1lJyksXG5cdFx0XHRcdCdtZS9mcmllbmRzJzogeXFsKCdzZWxlY3QgKiBmcm9tIHNvY2lhbC5jb250YWN0cygwKSB3aGVyZSBndWlkPW1lJyksXG5cdFx0XHRcdCdtZS9mb2xsb3dpbmcnOiB5cWwoJ3NlbGVjdCAqIGZyb20gc29jaWFsLmNvbnRhY3RzKDApIHdoZXJlIGd1aWQ9bWUnKVxuXHRcdFx0fSxcblx0XHRcdHdyYXA6IHtcblx0XHRcdFx0bWU6IGZvcm1hdFVzZXIsXG5cblx0XHRcdFx0Ly8gQ2FuJ3QgZ2V0IElEc1xuXHRcdFx0XHQvLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8gbG9vcCB0aHJvdWdoIHRoZSBzb2NpYWwucmVsYXRpb25zaGlwIHRhYmxlIHdpdGggaGFzIHVuaXF1ZSBJRHMgb2YgdXNlcnMuXG5cdFx0XHRcdCdtZS9mcmllbmRzJzogZm9ybWF0RnJpZW5kcyxcblx0XHRcdFx0J21lL2ZvbGxvd2luZyc6IGZvcm1hdEZyaWVuZHMsXG5cdFx0XHRcdCdkZWZhdWx0JzogcGFnaW5nXG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvKlxuXHRcdC8vIEF1dG8tcmVmcmVzaCBmaXg6IGJ1ZyBpbiBZYWhvbyBjYW4ndCBnZXQgdGhpcyB0byB3b3JrIHdpdGggbm9kZS1vYXV0aC1zaGltXG5cdFx0bG9naW4gOiBmdW5jdGlvbihvKXtcblx0XHRcdC8vIElzIHRoZSB1c2VyIGFscmVhZHkgbG9nZ2VkIGluXG5cdFx0XHR2YXIgYXV0aCA9IGhlbGxvKCd5YWhvbycpLmdldEF1dGhSZXNwb25zZSgpO1xuXG5cdFx0XHQvLyBJcyB0aGlzIGEgcmVmcmVzaCB0b2tlbj9cblx0XHRcdGlmKG8ub3B0aW9ucy5kaXNwbGF5PT09J25vbmUnJiZhdXRoJiZhdXRoLmFjY2Vzc190b2tlbiYmYXV0aC5yZWZyZXNoX3Rva2VuKXtcblx0XHRcdFx0Ly8gQWRkIHRoZSBvbGQgdG9rZW4gYW5kIHRoZSByZWZyZXNoIHRva2VuLCBpbmNsdWRpbmcgcGF0aCB0byB0aGUgcXVlcnlcblx0XHRcdFx0Ly8gU2VlIGh0dHA6Ly9kZXZlbG9wZXIueWFob28uY29tL29hdXRoL2d1aWRlL29hdXRoLXJlZnJlc2hhY2Nlc3N0b2tlbi5odG1sXG5cdFx0XHRcdG8ucXMuYWNjZXNzX3Rva2VuID0gYXV0aC5hY2Nlc3NfdG9rZW47XG5cdFx0XHRcdG8ucXMucmVmcmVzaF90b2tlbiA9IGF1dGgucmVmcmVzaF90b2tlbjtcblx0XHRcdFx0by5xcy50b2tlbl91cmwgPSAnaHR0cHM6Ly9hcGkubG9naW4ueWFob28uY29tL29hdXRoL3YyL2dldF90b2tlbic7XG5cdFx0XHR9XG5cdFx0fSxcblx0Ki9cblxuXHRmdW5jdGlvbiBmb3JtYXRFcnJvcihvKSB7XG5cdFx0aWYgKG8gJiYgJ21ldGEnIGluIG8gJiYgJ2Vycm9yX3R5cGUnIGluIG8ubWV0YSkge1xuXHRcdFx0by5lcnJvciA9IHtcblx0XHRcdFx0Y29kZTogby5tZXRhLmVycm9yX3R5cGUsXG5cdFx0XHRcdG1lc3NhZ2U6IG8ubWV0YS5lcnJvcl9tZXNzYWdlXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdFVzZXIobykge1xuXG5cdFx0Zm9ybWF0RXJyb3Iobyk7XG5cdFx0aWYgKG8ucXVlcnkgJiYgby5xdWVyeS5yZXN1bHRzICYmIG8ucXVlcnkucmVzdWx0cy5wcm9maWxlKSB7XG5cdFx0XHRvID0gby5xdWVyeS5yZXN1bHRzLnByb2ZpbGU7XG5cdFx0XHRvLmlkID0gby5ndWlkO1xuXHRcdFx0by5sYXN0X25hbWUgPSBvLmZhbWlseU5hbWU7XG5cdFx0XHRvLmZpcnN0X25hbWUgPSBvLmdpdmVuTmFtZSB8fCBvLm5pY2tuYW1lO1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XHRcdGlmIChvLmZpcnN0X25hbWUpIHtcblx0XHRcdFx0YS5wdXNoKG8uZmlyc3RfbmFtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvLmxhc3RfbmFtZSkge1xuXHRcdFx0XHRhLnB1c2goby5sYXN0X25hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRvLm5hbWUgPSBhLmpvaW4oJyAnKTtcblx0XHRcdG8uZW1haWwgPSAoby5lbWFpbHMgJiYgby5lbWFpbHNbMF0pID8gby5lbWFpbHNbMF0uaGFuZGxlIDogbnVsbDtcblx0XHRcdG8udGh1bWJuYWlsID0gby5pbWFnZSA/IG8uaW1hZ2UuaW1hZ2VVcmwgOiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0RnJpZW5kcyhvLCBoZWFkZXJzLCByZXF1ZXN0KSB7XG5cdFx0Zm9ybWF0RXJyb3Iobyk7XG5cdFx0cGFnaW5nKG8sIGhlYWRlcnMsIHJlcXVlc3QpO1xuXHRcdHZhciBjb250YWN0O1xuXHRcdHZhciBmaWVsZDtcblx0XHRpZiAoby5xdWVyeSAmJiBvLnF1ZXJ5LnJlc3VsdHMgJiYgby5xdWVyeS5yZXN1bHRzLmNvbnRhY3QpIHtcblx0XHRcdG8uZGF0YSA9IG8ucXVlcnkucmVzdWx0cy5jb250YWN0O1xuXHRcdFx0ZGVsZXRlIG8ucXVlcnk7XG5cblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShvLmRhdGEpKSB7XG5cdFx0XHRcdG8uZGF0YSA9IFtvLmRhdGFdO1xuXHRcdFx0fVxuXG5cdFx0XHRvLmRhdGEuZm9yRWFjaChmb3JtYXRGcmllbmQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0RnJpZW5kKGNvbnRhY3QpIHtcblx0XHRjb250YWN0LmlkID0gbnVsbDtcblxuXHRcdC8vICMzNjI6IFJlcG9ydHMgb2YgcmVzcG9uc2VzIHJldHVybmluZyBhIHNpbmdsZSBpdGVtLCByYXRoZXIgdGhhbiBhbiBBcnJheSBvZiBpdGVtcy5cblx0XHQvLyBGb3JtYXQgdGhlIGNvbnRhY3QuZmllbGRzIHRvIGJlIGFuIGFycmF5LlxuXHRcdGlmIChjb250YWN0LmZpZWxkcyAmJiAhKGNvbnRhY3QuZmllbGRzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRjb250YWN0LmZpZWxkcyA9IFtjb250YWN0LmZpZWxkc107XG5cdFx0fVxuXG5cdFx0KGNvbnRhY3QuZmllbGRzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG5cdFx0XHRpZiAoZmllbGQudHlwZSA9PT0gJ2VtYWlsJykge1xuXHRcdFx0XHRjb250YWN0LmVtYWlsID0gZmllbGQudmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmaWVsZC50eXBlID09PSAnbmFtZScpIHtcblx0XHRcdFx0Y29udGFjdC5maXJzdF9uYW1lID0gZmllbGQudmFsdWUuZ2l2ZW5OYW1lO1xuXHRcdFx0XHRjb250YWN0Lmxhc3RfbmFtZSA9IGZpZWxkLnZhbHVlLmZhbWlseU5hbWU7XG5cdFx0XHRcdGNvbnRhY3QubmFtZSA9IGZpZWxkLnZhbHVlLmdpdmVuTmFtZSArICcgJyArIGZpZWxkLnZhbHVlLmZhbWlseU5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmaWVsZC50eXBlID09PSAneWFob29pZCcpIHtcblx0XHRcdFx0Y29udGFjdC5pZCA9IGZpZWxkLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFnaW5nKHJlcywgaGVhZGVycywgcmVxdWVzdCkge1xuXG5cdFx0Ly8gU2VlOiBodHRwOi8vZGV2ZWxvcGVyLnlhaG9vLmNvbS95cWwvZ3VpZGUvcGFnaW5nLmh0bWwjbG9jYWxfbGltaXRzXG5cdFx0aWYgKHJlcy5xdWVyeSAmJiByZXMucXVlcnkuY291bnQgJiYgcmVxdWVzdC5vcHRpb25zKSB7XG5cdFx0XHRyZXMucGFnaW5nID0ge1xuXHRcdFx0XHRuZXh0OiAnP3N0YXJ0PScgKyAocmVzLnF1ZXJ5LmNvdW50ICsgKCtyZXF1ZXN0Lm9wdGlvbnMuc3RhcnQgfHwgMSkpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHRmdW5jdGlvbiB5cWwocSkge1xuXHRcdHJldHVybiAnaHR0cHM6Ly9xdWVyeS55YWhvb2FwaXMuY29tL3YxL3lxbD9xPScgKyAocSArICcgbGltaXQgQHtsaW1pdHwxMDB9IG9mZnNldCBAe3N0YXJ0fDB9JykucmVwbGFjZSgvXFxzL2csICclMjAnKSArICcmZm9ybWF0PWpzb24nO1xuXHR9XG5cbn0pKGhlbGxvKTtcblxuLy8gUmVnaXN0ZXIgYXMgYW5vbnltb3VzIEFNRCBtb2R1bGVcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBoZWxsbztcblx0fSk7XG59XG5cbi8vIENvbW1vbkpTIG1vZHVsZSBmb3IgYnJvd3NlcmlmeVxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gaGVsbG87XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9oZWxsb2pzL2Rpc3QvaGVsbG8uYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gNDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4gKiogbW9kdWxlIGlkID0gNDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3RpbWVycy1icm93c2VyaWZ5L34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtQcm9wVHlwZXN9IGZyb20gJ1N1YnNjaGVtYSc7XG5pbXBvcnQgZ2l0aHViLCB7aXNBdXRofSBmcm9tICcuL2dpdGh1Yic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2luIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGJ1dHRvbkNsYXNzOiBcImJ0biBidG4tcHJpbWFyeVwiLFxuICAgICAgICBsb2dpblRleHQ6ICdHaXRodWIgTG9naW4nLFxuICAgICAgICBsb2dvdXRUZXh0OiAnR2l0aHViIExvZ291dCcsXG4gICAgICAgIGltZ0NsYXNzOiBcInRodW1ibmFpbFwiLFxuICAgICAgICB2YWx1ZTogXCIuXCIsXG4gICAgICAgIG9uQ2hhbmdlOiBcIi5cIlxuICAgIH07XG5cbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICBvbkNoYW5nZTogUHJvcFR5cGVzLnZhbHVlRXZlbnQsXG4gICAgICAgIHZhbHVlOiBQcm9wVHlwZXMudmFsdWUsXG4gICAgICAgIHN0eWxlOiBQcm9wVHlwZXMuc3R5bGVcbiAgICB9O1xuXG4gICAgaGFuZGxlQ2hhbmdlKG1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2hhbmRsZUNoYW5nZScsIG1lKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UobWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgcHJvZmlsZSA9ICgpPT4ge1xuICAgICAgICByZXR1cm4gZ2l0aHViKCkuYXBpKHtwYXRoOiAnbWUnLCBmb3JtYXRSZXNwb25zZTogZmFsc2V9KS50aGVuKHRoaXMuaGFuZGxlR2l0aHViTG9naW5TdWNjZXNzKTtcbiAgICB9O1xuXG4gICAgaGFuZGxlQ2xpY2sgPSAoZSk9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2lucHJvZ3Jlc3M6IHRydWV9KTtcbiAgICAgICAgZ2l0aHViKCkubG9naW4oe3Njb3BlOiAncmVhZDpvcmcsIGZyaWVuZHMsIHBob3RvcywgcHVibGlzaCd9KS50aGVuKHRoaXMucHJvZmlsZSwgdGhpcy5oYW5kbGVHaXRodWJMb2dpbkZhaWx1cmUpXG4gICAgfTtcbiAgICBoYW5kbGVHaXRodWJMb2dpblN1Y2Nlc3MgPSAobWUpPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnc3VjY2Vzcy0+bWUnLCBtZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2lucHJvZ3Jlc3M6IGZhbHNlLCBlcnJvcjogZmFsc2V9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UobWUpO1xuICAgIH07XG4gICAgaGFuZGxlR2l0aHViTG9naW5GYWlsdXJlID0gKGVycm9yKT0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2ZhaWwtPm1lJywgZXJyb3IpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtpbnByb2dyZXNzOiBmYWxzZSwgZXJyb3J9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UobnVsbCk7XG4gICAgfTtcblxuICAgIHN0YXRlID0ge1xuICAgICAgICBpbnByb2dyZXNzOiBmYWxzZVxuICAgIH07XG5cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuXG4gICAgICAgIGlmICghdGhpcy5wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgbWUgPSBpc0F1dGgoKTtcbiAgICAgICAgICAgIGlmIChtZSAmJiBtZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2Vycm9yOiBtZS5lcnJvciwgaW5wcm9ncmVzczogZmFsc2V9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9maWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGhhbmRsZUxvZ291dCA9IChlKT0+IHtcbiAgICAgICAgZ2l0aHViKCkubG9nb3V0KCk7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2Vycm9yOiBmYWxzZSwgaW5wcm9ncmVzczogZmFsc2V9KTtcbiAgICB9O1xuXG4gICAgcmVuZGVyTWUoKSB7XG4gICAgICAgIGNvbnN0IHt2YWx1ZTp7YXZhdGFyX3VybD0nJywgbG9naW4sIG5hbWV9LGxhYmVsQ2xhc3MsIG5hbWVDbGFzcywgbG9naW5DbGFzcywgaW1nQ2xhc3N9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIDxidXR0b24gb25DbGljaz17dGhpcy5oYW5kbGVMb2dvdXR9IGNsYXNzTmFtZT17YGNsZWFyZml4ICR7bG9naW5DbGFzc31gfT5cbiAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPXtpbWdDbGFzc30gc3JjPXthdmF0YXJfdXJsfS8+XG4gICAgICAgICAgICA8c3Ryb25nIGNsYXNzTmFtZT17bGFiZWxDbGFzc30+PGkgY2xhc3NOYW1lPVwiZmEgZmEtZ2l0aHViXCIvPiB7bG9naW59PC9zdHJvbmc+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e25hbWVDbGFzc30+e25hbWV9PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICB9XG5cbiAgICByZW5kZXJMb2dpbigpIHtcbiAgICAgICAgcmV0dXJuIDxidXR0b24gY2xhc3NOYW1lPXt0aGlzLnByb3BzLmJ1dHRvbkNsYXNzfSBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT48aVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmEgZmEtZ2l0aHViXCIvPiB7dGhpcy5wcm9wcy5sb2dpblRleHR9PC9idXR0b24+O1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW5wcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIDxzcGFuIGNsYXNzTmFtZT17dGhpcy5wcm9wcy5pbnByb2dyZXNzQ2xhc3N9PjxpXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmEgZmEtZ2l0aHViXCIvPiBMb2dnaW5nIEludG8gR2l0aHViLi4uPC9zcGFuPlxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuaGFzRXJyb3JDbGFzc30+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXt0aGlzLnByb3BzLmVycm9yTWVzc2FnZUNsYXNzfT57dGhpcy5zdGF0ZS5lcnJvcn08L3NwYW4+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyTG9naW4oKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnZhbHVlID8gdGhpcy5yZW5kZXJNZSgpIDogdGhpcy5yZW5kZXJMb2dpbigpO1xuXG4gICAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcHVibGljL0xvZ2luLmpzeFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IGhlbGxvanMgZnJvbSAnaGVsbG9qcyc7XG5cbmNvbnN0IHtsb2NhdGlvbjp7aG9zdG5hbWV9fSA9IHdpbmRvdztcblxuY29uc3QgcmVkaXJlY3RfdXJsID0gKHtcbiAgICAnbG9jYWxob3N0LnN1YnNjaGVtYS5jb20nOiAnL3JlZGlyZWN0LmhtbCcsXG4gICAgJ3N1YnNjaGVtYS5naXRodWIuaW8nOiAnL3N1YnNjaGVtYS1naXRodWIvcmVkaXJlY3QuaHRtbCdcbn0pW2hvc3RuYW1lXTtcblxuY29uc3QgaGVsbG8gPSAoe1xuICAgICdsb2NhbGhvc3Quc3Vic2NoZW1hLmNvbSc6IHtnaXRodWI6ICc2MjdhNDMxZjUxZTNiNjAwNzdhNSd9LFxuICAgICdzdWJzY2hlbWEuZ2l0aHViLmlvJzoge2dpdGh1YjogJzU2ZGEyNTViNjIzMjc5MGYwZmZlJ31cbn0pW2hvc3RuYW1lXTtcblxuZXhwb3J0IGNvbnN0IHNldHRpbmdzID0ge1xuICAgIGhlbGxvLFxuICAgIG5ldHdvcms6IHtcbiAgICAgICAgb2F1dGhfcHJveHk6ICdodHRwczovL2F1dGgtc2VydmVyLmhlcm9rdWFwcC5jb20vcHJveHknLFxuICAgICAgICByZWRpcmVjdF91cmxcbiAgICB9XG59O1xuXG5sZXQgX2doO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnaXRodWIoX3NldHRpbmdzID0gc2V0dGluZ3MpIHtcbiAgICBpZiAoX2doKSB7XG4gICAgICAgIHJldHVybiBfZ2g7XG4gICAgfVxuICAgIGhlbGxvanMuaW5pdChfc2V0dGluZ3MuaGVsbG8pO1xuICAgIHdpbmRvdy5naXRodWIgPSBfZ2ggPSBoZWxsb2pzKCdnaXRodWInLCBfc2V0dGluZ3MubmV0d29yayk7XG5cbiAgICByZXR1cm4gX2doO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoKF9zZXR0aW5ncyA9IHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGdpdGh1Yihfc2V0dGluZ3MpLmdldEF1dGhSZXNwb25zZSgnZ2l0aHViJylcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3B1YmxpYy9naXRodWIuanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9tb2R1bGVzJmltcG9ydExvYWRlcnM9MSZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX19baGFzaDpiYXNlNjQ6NV0hLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9Mb2dpbi5sZXNzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9tb2R1bGVzJmltcG9ydExvYWRlcnM9MSZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX19baGFzaDpiYXNlNjQ6NV0hLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9Mb2dpbi5sZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMmaW1wb3J0TG9hZGVycz0xJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fX1toYXNoOmJhc2U2NDo1XSEuLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL0xvZ2luLmxlc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvTG9naW4ubGVzc1xuICoqIG1vZHVsZSBpZCA9IDQxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuTG9naW5fX2ltZ19fXzJjNWdMIHtcXG4gIGhlaWdodDogNDBweDtcXG4gIHdpZHRoOiA0MHB4O1xcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLkxvZ2luX19sb2dpbl9fXzN0Q2ViIHtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgbWFyZ2luOiA1cHg7XFxuICBib3JkZXI6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG59XFxuLkxvZ2luX19sYWJlbF9fX3pJSGhBIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG4uTG9naW5fX25hbWVfX18xZlBBMSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwiaW1nXCI6IFwiTG9naW5fX2ltZ19fXzJjNWdMXCIsXG5cdFwibG9naW5cIjogXCJMb2dpbl9fbG9naW5fX18zdENlYlwiLFxuXHRcImxhYmVsXCI6IFwiTG9naW5fX2xhYmVsX19feklIaEFcIixcblx0XCJuYW1lXCI6IFwiTG9naW5fX25hbWVfX18xZlBBMVwiXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXI/bW9kdWxlcyZpbXBvcnRMb2FkZXJzPTEmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19fW2hhc2g6YmFzZTY0OjVdIS4vfi9sZXNzLWxvYWRlciEuL3B1YmxpYy9Mb2dpbi5sZXNzXG4gKiogbW9kdWxlIGlkID0gNDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0MThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxyXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xyXG5cclxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xyXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XHJcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xyXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XHJcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xyXG5cdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYoc291cmNlTWFwKSB7XHJcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XHJcblxyXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xyXG5cclxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKVxyXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0MTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IGdoLCB7aXNBdXRofSBmcm9tICcuL2dpdGh1Yic7XG5cbi8qYXZhdGFyX3VybDogXCJodHRwczovL2F2YXRhcnMuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3UvMjIxODczNT92PTNcIlxuIGRlc2NyaXB0aW9uOiBudWxsXG4gZXZlbnRzX3VybDogXCJodHRwczovL2FwaS5naXRodWIuY29tL29yZ3MvYm9iYW1vL2V2ZW50c1wiXG4gaG9va3NfdXJsOiBcImh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vb3Jncy9ib2JhbW8vaG9va3NcIlxuIGlkOiAyMjE4NzM1XG4gaXNzdWVzX3VybDogXCJodHRwczovL2FwaS5naXRodWIuY29tL29yZ3MvYm9iYW1vL2lzc3Vlc1wiXG4gbG9naW46IFwiYm9iYW1vXCJcbiBtZW1iZXJzX3VybDogXCJodHRwczovL2FwaS5naXRodWIuY29tL29yZ3MvYm9iYW1vL21lbWJlcnN7L21lbWJlcn1cIlxuIG5hbWU6IFwiYm9iYW1vXCJcbiBwaWN0dXJlOiBcImh0dHBzOi8vYXZhdGFycy5naXRodWJ1c2VyY29udGVudC5jb20vdS8yMjE4NzM1P3Y9M1wiXG4gcHVibGljX21lbWJlcnNfdXJsOiBcImh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vb3Jncy9ib2JhbW8vcHVibGljX21lbWJlcnN7L21lbWJlcn1cIlxuIHJlcG9zX3VybDogXCJodHRwczovL2FwaS5naXRodWIuY29tL29yZ3MvYm9iYW1vL3JlcG9zXCJcbiB0aHVtYm5haWw6IFwiaHR0cHM6Ly9hdmF0YXJzLmdpdGh1YnVzZXJjb250ZW50LmNvbS91LzIyMTg3MzU/dj0zXCJcbiB1cmw6IFwiaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9vcmdzL2JvYmFtb1wiKi9cblxubGV0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cblxuZnVuY3Rpb24gZmlsdGVyKG9yZ3MsIHZhbHVlLCBjYikge1xuICAgIGxldCByZXN1bHQgPSBvcmdzO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAodmFsdWUsICdpJyk7XG4gICAgICAgIHJlc3VsdCA9IG9yZ3MuZmlsdGVyKHYgPT4gcmUudGVzdCh2Lm5hbWUgfHwgdi5mdWxsX25hbWUpKTtcbiAgICB9XG4gICAgY2IobnVsbCwgcmVzdWx0KTtcblxufVxuXG5jb25zdCBhcGkgPSB7XG4gICAgZmV0Y2godXJsLCB2YWx1ZSwgY29tcG9uZW50LCBjYikge1xuICAgICAgICBjb25zdCBkYXRhID0gbWFwLmdldChjb21wb25lbnQpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGdoKCkuYXBpKHVybCkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQoY29tcG9uZW50LCByZXNwLmRhdGEpO1xuICAgICAgICAgICAgICAgIGZpbHRlcihyZXNwLmRhdGEsIHZhbHVlLCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlcihkYXRhLCB2YWx1ZSwgY2IpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipWYWx1ZSByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgb2JqZWN0LCBub3QgbmVjZXNzYXJpbHkgd2hhdHMgaW4gdGhlIGlucHV0IGJveCoqL1xuICAgIHZhbHVlKG9iail7XG4gICAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IG51bGwgOiBvYmoubmFtZSB8fCBvYmouZnVsbF9uYW1lIHx8IG9iajtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZvcm1hdCByZXR1cm5zIHRoZSBmb3JtYXQuXG4gICAgICogQHBhcmFtIHZcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBmb3JtYXQodil7XG4gICAgICAgIHJldHVybiB2ID09IG51bGwgPyBudWxsIDogdi5uYW1lIHx8IHYuZnVsbF9uYW1lIHx8IHY7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgYXBpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcHVibGljL0dpdGh1YlByb2Nlc3Nvci5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=